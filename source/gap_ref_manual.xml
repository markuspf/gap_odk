<?xml version="1.0" encoding="UTF-8"?>

<!-- %W  main.xml        GAP 4 Reference Manual        ... -->
<!-- %Y  Copyright 1997, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->


<!DOCTYPE Book SYSTEM "gapdoc.dtd"
   [ <!ENTITY ATLAS "<Package>Atlas</Package>">
     <!ENTITY mdash "<Alt Only='HTML'>&#8212;</Alt><Alt Not='HTML'>---</Alt>">
     <!-- Do not edit the following four lines. They will be updated 
     automatically by the distribution wrapper scripts. -->
<!ENTITY VERSIONNUMBER "4.dev">
<!ENTITY RELEASEDAY "today">
<!ENTITY RELEASEYEAR "this year">
<!ENTITY GAPDIRNAME "gap4dev">

     <!ENTITY H "<Alt Only='HTML'>\(\mathcal{H}\)</Alt><Alt
      Only='Text'><E>H</E></Alt><Alt Only='LaTeX'><M>\mathcal{H}</M></Alt>">
     <!ENTITY R "<Alt Only='HTML'>\(\mathcal{R}\)</Alt><Alt
      Only='Text'><E>R</E></Alt><Alt Only='LaTeX'><M>\mathcal{R}</M></Alt>">
     <!ENTITY L "<Alt Only='HTML'>\(\mathcal{L}\)</Alt><Alt
      Only='Text'><E>L</E></Alt><Alt Only='LaTeX'><M>\mathcal{L}</M></Alt>">
     <!ENTITY D "<Alt Only='HTML'>\(\mathcal{D}\)</Alt><Alt
      Only='Text'><E>D</E></Alt><Alt Only='LaTeX'><M>\mathcal{D}</M></Alt>">
   ]>

<!-- the 2.8em parameter causes that in the toc lines for sections more 
     space is reserved for the section numbers (otherwise the header text
     overwrite some of the wide numbers); similar for subsections      -->
<?LaTeX ExtraPreamble="
\makeatletter 
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.8em}}
\renewcommand*\l@subsection{\@dottedtocline{2}{3.8em}{4.0em}}
\def\@pnumwidth{2.1em}
\makeatother
"?>

<Book Name="ref">
<TitlePage>
  <Title>GAP - Reference Manual</Title>
  <Version>Release &VERSIONNUMBER;, &RELEASEDAY;</Version>
  <Author>The GAP Group
    <Email>support@gap-system.org</Email>
    <Homepage>http://www.gap-system.org</Homepage>
  </Author>

  <Copyright>
    Copyright &copyright; (1987-&RELEASEYEAR;) 
    for the core part of the &GAP; system by the &GAP; Group.
    <P/>
    Most parts of this distribution, including the core part of the &GAP; 
    system are distributed under the terms of the GNU General Public License, 
    see <URL>http://www.gnu.org/licenses/gpl.html</URL> or the file 
    <F>GPL</F> in the <F>etc</F> directory of the &GAP; 
    installation.
    <P/>
    More detailed information about copyright and licenses of parts of this
    distribution can be found in Section 
    <Ref Sect="Copyright and License"/> of this manual.
    <P/>
    &GAP; is developed over a long time and has many authors and contributors.
    More detailed information can be found in Section
    <Ref Sect="Authors and Maintainers"/> of this manual.
  </Copyright>
</TitlePage>

<TableOfContents/>

<Body>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  preface.tex               GAP documentation         Joachim Neubueser -->
<!-- %% -->
<!-- %H  @(#)<M>Id: preface.tex,v 4.44 2006/06/27 21:37:08 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright (C) 1997, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<!-- %%  This file contains the preface of the GAP reference manual. -->
<!-- %% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Chapter Label="Preface">
<Heading>Preface</Heading>
<Index Key="About GAP manual">About &GAP; manual</Index>

Welcome to &GAP;. 
This is one of three manuals documenting the core part of &GAP;, 
the other being the <E>&GAP; Tutorial</E>
<Alt Only="HTML">(see <Ref BookName="tut" Label="Preface"/>)</Alt>.
and the document called <E><Q>&GAP; - Changes from Earlier Versions</Q></E>
<Alt Only="HTML">(see <Ref BookName="Changes" Label="Preface"/>)</Alt>.
<P/>
This preface serves not only to introduce <Q>The &GAP; Reference Manual</Q>, 
but also as an introduction to the whole system.
<P/>
&GAP; stands  for  <E>Groups, Algorithms  and Programming</E>.  The  name was
chosen to reflect  the aim of  the  system, which  is introduced in  this
reference manual.  Since  that  choice,  the  system has become   somewhat
broader,    and  you will  also   find information   about algorithms and
programming  for other   algebraic structures,   such as semigroups   and
algebras.
<P/>
This manual, the <E>&GAP; reference manual</E> contains the official definitions
of &GAP; functions. It should contain all the information needed to 
use &GAP;, and is not intended to be read cover-to-cover.
<P/>
To get started a new user may first look at parts of the <E>&GAP; Tutorial</E> 
<Alt Only="HTML">(see <Ref BookName="tut" Label="Preface"/>)</Alt>. 
<P/>
A lot of the functionality of the system and a number of
contributed extensions are provided as <Q>&GAP; packages</Q>
which are developed independently of the core part of &GAP; and can be loaded
into a &GAP; session. Each package comes with a its own manual which is 
also available through the &GAP; help system.
<P/>
This manual is divided into chapters, sections and subsections.
Chapter&nbsp;<Ref Chap="The Help System"/> describes the <E>help system</E>,
which provides access to all the  manuals from a running &GAP; session.
Chapter&nbsp;<Ref Chap="Running GAP"/> gives technical advice for 
<E>running</E> &GAP;. Chapter&nbsp;<Ref Chap="The Programming Language"/> 
introduces the &GAP; language, and the next chapters deal with the 
<E>environment</E> provided by &GAP; for the user. These are followed by 
the main bulk of chapters which are devoted to the various mathematical 
structures that &GAP; can handle.
<P/>
Subsequent sections of this preface explain the structure of the
system and
provide copyright and licensing information.
<P/>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The GAP System">
<Heading>The &GAP; System</Heading>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  overview.xml              GAP documentation         Joachim Neubueser -->
<!-- %% -->
<!-- %H  @(#)<M>Id: preface.tex,v 4.44 2006/06/27 21:37:08 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright (C) 1997, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<!-- %%  This file contains a part of the preface to the tutorial and reference manual -->
<!-- %% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

&GAP; is a <E>free</E>, <E>open</E> and <E>extensible</E> software package for
computation in discrete abstract algebra. The terms <Q>free</Q> and <Q>open</Q> 
describe the conditions under which the system is distributed -- in brief, it 
is <E>free of charge</E> (except possibly for the immediate costs of delivering 
it to you), you are <E>free to pass it on</E> within certain limits, and 
all of the workings of the system are <E>open for you to examine and change</E>.
Details of these conditions can be found in Section 
<Ref Chap="Copyright and License" BookName="ref"/>.
<P/>
The system is <Q>extensible</Q> in that you can write your own  programs  in
the &GAP; language, and use them in just the same way  as  the  programs
which form part of the system  (the  <Q>library</Q>).  Indeed,  we  actively
support the contribution, refereeing and distribution  of  extensions  to
the system, in the form of <Q>&GAP; packages</Q>.  Further details of  this
can be found in chapter <Ref Chap="Using GAP Packages" BookName="ref"/>, and
on our website.
<P/>
Development of &GAP; began at Lehrstuhl D für Mathematik,
RWTH-Aachen, under the leadership of Joachim Neubüser
in 1985. Version 2.4 was released in 1988 and version 3.1 in 1992.
In 1997 coordination of 
&GAP; development, now very much an international effort, was
transferred to St Andrews.  A complete internal redesign and almost
complete rewrite of the system was completed over the following years and
version 4.1 was released in July 1999.
A sign of the further internationalization of the project was the 
&GAP;&nbsp;4.4 release in 2004, which has been coordinated from 
Colorado State University, Fort Collins.
<P/>
More information on the motivation and development of &GAP; to date,
can be found on our Web pages in a section entitled <Q>Release history
and Prefaces</Q>.
<P/>
For those readers who have used an earlier version of &GAP;, an
overview of the changes from &GAP;&nbsp;4.4 and a brief 
summary of changes from earlier versions is given in a separate
manual <Ref Chap="Changes between GAP 4.4 and GAP 4.5" BookName="changes"/>.
<P/>
The system that you are getting now consists of a <Q>core system</Q> and
a number of packages. The core system consists of four main parts.
<Enum>
<Item>
    A  <E>kernel</E>, written in C, which provides the user with
    <List>
    <Item>
      automatic dynamic storage management, which the user needn't bother
      about in his programming;
    </Item>
    <Item>
      a   set of  time-critical basic   functions, e.g.   <Q>arithmetic</Q>,
      operations for integers, finite fields,  permutations and words, as
      well as natural operations for lists and records;
    </Item>
    <Item>
      an interpreter   for  the &GAP; language,    an untyped
      imperative programming language with functions as first class objects
      and some extra built-in data types such as permutations and finite
      field elements.  The language supports a form of object-oriented
      programming, similar to that supported by languages like C++ and
      Java but with some important differences.
    </Item>
    <Item>
      a small set of system functions allowing the &GAP; programmer to handle
      files and execute external programs in a uniform way, regardless of 
      the particular operating system in use. 
    </Item>
    <Item>
      a  set  of programming tools  for   testing, debugging, and timing
      algorithms.
    </Item>
    <Item>
      a <Q>read-eval-view</Q> style user interface.
    </Item>
    </List>
</Item>
<Item>
A much larger <E>library of &GAP; functions</E> that
  implement algebraic and other algorithms.  Since this is written
  entirely in the &GAP; language, the &GAP; language is both the
  main implementation language and the user language of the system.
  Therefore the user can as easily as the original programmers
  investigate and vary algorithms of the library and add new ones to
  it, first for own use and eventually for the benefit of all &GAP;
  users.
</Item>
<Item>
A <E>library of group theoretical data</E> which contains
  various libraries of groups, including the library of small groups
  (containing all groups of order at most 2000, except those of order
  1024) and others. Large libraries of ordinary and Brauer character
  tables and Tables of Marks are included as packages.
</Item>
<Item>
    The <E>documentation</E>.  This is available as on-line help, as
    printable files in PDF format and as HTML for viewing
    with a Web browser.
</Item>
</Enum>
<P/>
Also included with the core system are some test files and a few
small utilities which we hope you will find useful.
<P/>

&GAP; <E>packages</E> are self-contained extensions to the core system.  A
package contains &GAP; code and its own documentation and may also
contain data files or external programs to which the &GAP; code
provides an interface.  These packages may be loaded into &GAP; using
the <Ref Func="LoadPackage" BookName="ref"/> command, and both the package 
and its documentation are then available just as if they were parts of the
core system. Some packages may be loaded automatically, when &GAP; is
started, if they are present. Some packages, because they depend on
external programs, may only be available on the operating systems
where those programs are available (usually UNIX). You should note
that, while the packages included with this release are the most
recent versions ready for release at this time, new packages and new
versions may be released at any time and can be easily installed in
your copy of &GAP;.
<P/>
With &GAP; there are two packages (the library of ordinary and
Brauer character tables, and the library of tables of marks) which
contain functionality developed from parts of the &GAP; core
system. These have been moved into packages for ease of maintenance
and to allow new versions to be released independently of new releases
of the core system. The library of small groups should also be
regarded as a package, although it does not currently use the standard
package mechanism. Other packages contain functionality which has
never been part of the core system, and may extend it substantially,
implementing specific algorithms to enhance its capabilities, providing
data libraries, interfaces to other computer algebra systems and
data sources such as the electronic version of the Atlas of Finite Group 
Representations; therefore, installation and usage of packages is recommended.
<P/>
Further details about &GAP; packages can be found in chapter 
<Ref Chap="Using GAP Packages" BookName="ref"/>, and on the &GAP;
website here: <URL>http://www.gap-system.org/Packages/packages.html</URL>. 

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Authors and Maintainers">
<Heading>Authors and Maintainers</Heading>
&GAP; is the work of very many people, many of whom still maintain
parts of the system. A complete list of authors, and an approximation
to the current list of maintainers can be found on the &GAP;
World Wide Web site at
 <URL>http://www.gap-system.org/Contacts/People/authors.html</URL> and 
 <URL>http://www.gap-system.org/Contacts/People/modules.html</URL>.


All &GAP; packages have their
own authors and maintainers. It should however be noted that some
packages provide interfaces between &GAP; and an external program, a
copy of which is included for convenience, and that, in these cases,
we do not claim that the package authors or maintainers wrote, or
maintain, this external program. Similarly, the system and some packages
include large data libraries that may have been computed by many
people. We try to make clear in each case what credit is attributable
to whom.
<P/>
We have, for some time, operated a refereeing system for contributed
packages, both to ensure the quality of the software we distribute,
and to provide recognition for the authors. We now consider this to be
a refereeing system for modules, and we would note, in particular
that, although it does not use the standard package interface, the
library of small groups has been refereed and accepted on exactly the
same basis as the accepted  packages.
<P/>
We also include with this distribution a
number of packages which have not (yet) gone through our refereeing
process. Some may be accepted in the future, in other cases the
authors have chosen not to submit them.  More information can be found
on our World Wide Web site 
(see Section <Ref Sect="Further Information about GAP"/>).
<P/>

</Section>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Acknowledgements">
		 <Heading>Acknowledgements</Heading>

Very many people have worked on, and contributed to, &GAP; over the
years since its inception. On our Web site you will find the prefaces
to the previous releases, each of which acknowledges people who have
made special contributions to that release. Even so, it is appropriate
to mention here Joachim Neubüser whose vision of a free,
open and extensible system for computational algebra inspired &GAP;
in the first place, and Martin Schönert, who was the
technical architect of &GAP; 3 and &GAP; 4.
<P/>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Copyright and License">
<Heading>Copyright and License</Heading>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  copyrigh.xml              GAP documentation                      LDFM -->
<!-- %W                                                                 & SMCS -->
<!-- %% -->
<!-- %H  @(#)<M>Id: copyrigh.msk,v 1.6 2004/02/13 17:38:52 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,   RWTH Aachen, Germany -->
<!-- %Y  Copyright (C) 2002, The GAP Group -->
<!-- %% -->


Copyright &copyright; (1987-&RELEASEYEAR;) by the &GAP; Group, 
<P/>
incorporating the Copyright &copyright; 1999, 2000  by
        School of Mathematical and Computational Sciences,
        University of St&nbsp;Andrews,
        North Haugh, St&nbsp;Andrews, Fife KY16 9SS, Scotland
<P/>
being the Copyright &copyright; 1992 by
        Lehrstuhl D für Mathematik, RWTH,
        52056 Aachen, Germany,
transferred to St&nbsp;Andrews on July 21st, 1997.
<P/>
except for files in the distribution, which have an explicit different
copyright statement. In particular, the copyright of packages distributed
with &GAP; is usually with the package authors or their institutions.
<P/>
&GAP; is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version. For details, see 
the file <F>GPL</F> in the <F>etc</F> directory of the &GAP; distribution or see
<URL>http://www.gnu.org/licenses/gpl.html</URL>.
<P/>
If you obtain &GAP; please send us a short notice to that effect, e.g.,
an e-mail message to the address <Email>support@gap-system.org</Email>. 
This helps us to keep track of the number of &GAP; users.
<P/>
If you publish a mathematical result that was partly obtained using
&GAP;, please cite &GAP;, just as you would cite another paper that you
used (see below for sample citation). Also we would appreciate if you
could inform us about such a paper, which we will add to the &GAP;
<URL Text="bibliography">http://www.gap-system.org/Doc/Bib/bib.html</URL>.
<P/>
Specifically, please refer to
<P/>
<Listing>
[GAP] The GAP Group, GAP - Groups, Algorithms, and Programming,
      Version &VERSIONNUMBER;; &RELEASEYEAR; (http://www.gap-system.org)
</Listing>
<P/>
You are permitted to modify and redistribute &GAP;, but you are not
allowed to restrict further redistribution. That is to say proprietary
modifications will not be allowed. We want all versions of &GAP; to
remain free.
<P/>
If you  modify any part of &GAP; and redistribute it,  you must supply a
<F>README</F> document. This should specify what modifications you made in
which files. We do not want to take credit or be blamed for your
modifications.
<P/>
Of course we are interested in all of your modifications. In particular
we would like to see bug-fixes, improvements and new functions. So again
we would appreciate it if you would inform us about all modifications you
make.
<P/>
In addition to the general copyright for &GAP; set forth above,
the following terms apply to the versions of &GAP; for Windows.
<P/>
The executable of &GAP; for Windows that we distribute was compiled with
the <C>gcc</C> compiler supplied with <Package>Cygwin</Package> installation
(<URL>http://cygwin.com/</URL>).
<P/>
The GNU C compiler is
<P/>
<E>Copyright &copyright; 2010 Free Software Foundation, Inc.</E>
<P/>
under the terms of the GNU General Public License (GPL).
<P/>
The <Package>Cygwin</Package> API library is also covered by the GNU GPL. 
The executable we provide is linked against this library (and in the process 
includes GPL'd <Package>Cygwin</Package> glue code). This means that the 
executable falls under the GPL too, which it does anyhow.
<P/>
The <F>cyggcc_s-1.dll</F>, <F>cygncurses-10.dll</F>, <F>cygncursesw-10.dll</F>,
<F>cygpanel-10.dll</F>, <F>cygpopt-0.dll</F>, <F>cygreadline7.dll</F>,
<F>cygstart.exe</F>, <F>cygwin1.dll</F>, <F>libW11.dll</F>, <F>mintty.exe</F>, 
<F>rxvt.exe</F> and <F>regtool.exe</F> are taken unmodified from the 
<Package>Cygwin</Package> distribution. They are copyright by RedHat Software
and released under the GPL. For more information on <Package>Cygwin</Package>,
see <URL>http://www.cygwin.com</URL>. 
<P/>
Please contact <Email>support@gap-system.org</Email> if you need further information.




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Further Information about GAP">
<Heading>Further Information about &GAP;</Heading>
<Index Subkey="for GAP">web sites</Index>
<Index>email addresses</Index>
<Index Subkey="email address">support</Index>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  moreinfo.xml              GAP documentation         Joachim Neubueser -->
<!-- %% -->
<!-- %H  @(#)<M>Id: preface.tex,v 4.44 2006/06/27 21:37:08 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright (C) 1997, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<!-- %%  This file contains a part of the preface to the tutorial and reference manual -->
<!-- %% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

Information about &GAP; is best obtained from the &GAP; website
<P/>
	<URL>http://www.gap-system.org</URL>
<P/>
There you will find, amongst other things
<List>
<Item>
directions to the sites from which you can download the
current &GAP; distribution, all accepted and deposited &GAP; packages,
and a selection of other contributions.
</Item>
<Item>
the &GAP; manual and an archive of the <C>gap-forum</C> mailing
list, formatted for reading with a Web browser, and indexed for
searching.
</Item>
<Item>
information about &GAP; developers, and about the email
addresses available for comment, discussion and support.
</Item>
</List>
<P/>
<P/>
We would particularly ask you to note the following things:
<List>
<Item>
The &GAP; Forum &ndash; an email discussion forum for comments,
discussions or questions about &GAP;. You must subscribe to the list
before you can post to it, see the website for details.
In particular we will announce new releases in this mailing list.
</Item>
<Item>
The email address <Email>support@gap-system.org</Email> to which you
are asked to send any questions or bug reports which do not seem likely
to be of interest to the whole &GAP; Forum. Please give a 
(short, if possible) self-contained excerpt of a &GAP;
session containing both input and output that illustrates your problem 
(including comments of why you think it is a bug) and state the type of
the machine, operating system, (compiler used, if UNIX/Linux) and the 
version of &GAP; you are using (the first line after the &GAP;&nbsp;4 
banner starting <C>GAP, Version 4...</C>).
</Item>
<Item>
We also ask you to send a brief message to 
<Email>support@gap-system.org</Email> when you install &GAP;.
</Item>
<Item>
The correct form of citation of &GAP;, which we ask you use
whenever you publish scientific results obtained using &GAP;.
</Item>
</List>
<P/>
It finally remains for us to wish you all pleasure and success in using
&GAP;, and to invite your constructive comment and criticism.
<P/>
<P/>
<P/>
The GAP Group,
<P/>
&RELEASEDAY;

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


</Section>

</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  help.tex               GAP documentation                    Frank Lbeck -->
<!-- %% -->
<!-- %A  @(#)<M>Id: help.tex,v 4.21 2005/05/09 07:00:37 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1990-2001, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<!-- %%  Original version by Martin Schönert. -->
<!-- %% -->
<Chapter Label="The Help System">
<Heading>The Help System</Heading>

This chapter describes the &GAP; help system. The help system lets you read
the documentation interactively.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Invoking the Help">
<Heading>Invoking the Help</Heading>

The  basic command  to  read  &GAP;'s documentation  from  within a  &GAP;
session is as follows.
<P/>
<Index>getting help</Index>
<C>?[<A>book</A>:][?]<A>topic</A></C>
<P/>
For an explanation and some examples
see&nbsp;<Ref Sect="Help" BookName="tut"/>.
<P/>
Note that the first question mark must appear in the <E>first position</E>
after the <C>gap> </C> prompt.
The search strings <A>book</A> and <A>topic</A> are normalized in a certain
way (see the end of this section for details) before the search starts.
This makes the search case insensitive and there can be arbitrary white space
after the first question mark.
<P/>
When there are several manual sections  that match the query a numbered list
of topics is displayed.
These matches can be accessed with <C>?<A>number</A></C>.
<P/>
There  are  some  further  specially   handled  commands  which  start  with
a  question  mark.
They are explained in
Section&nbsp;<Ref Sect="Browsing through the Sections"/>.
<P/>
By default &GAP; shows the help  sections as text in the terminal (window),
page by  page if the shown  text does not fit  on the screen. But  there are
several other choices to read (other formats of) the documents: via a 
viewer for <C>pdf</C> files or via a web browser.
This is explained below in Section&nbsp;<Ref Sect="Changing the Help Viewer"/>.
<P/>
<E>Details of the string normalization process</E>
<P/>
Here is a precise description how the search strings <A>book</A> and 
<A>topic</A> are
normalized before a search starts:
backslashes and double or single quotes are removed,
parentheses and braces are substituted by blanks,
non-ASCII characters are considered as ISO-latin1 characters
and the accented letters are substituted by their non-accented counterpart.
Finally white space is normalized.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Browsing through the Sections">
<Heading>Browsing through the Sections</Heading>

Help books for &GAP; are organized in chapters, sections, and subsections.
There are a few special commands starting with a question mark (in the first
position after the <C>gap> </C> prompt) which allow browsing a book section
or chapter wise.
<P/>

<Index>browsing forward</Index>
<C>?></C>
<P/>
<Index>browsing backwards</Index>
<C>?&lt;</C>
<P/>
The two help commands <C>?&lt;</C> and <C>?></C> allow one to browse through
a whole help book.
<C>?&lt;</C> displays the section or subsection preceding the 
previously shown (sub)section,
and <C>?></C> takes you to the section or subsection following the 
previously shown one.
<P/>
<Index>browsing forward one chapter</Index>
<C>?>></C>
<P/>
<Index>browsing backwards one chapter</Index>
<C>?&lt;&lt;</C>
<P/>
<C>?&lt;&lt;</C> takes you back to the beginning of the current chapter.
If you are already at the start of a chapter <C>?&lt;&lt;</C> takes you to 
the beginning of the previous chapter.
<C>?>></C> takes you to the beginning of the next chapter.
<P/>
<Index>browsing the previous section browsed</Index>
<C>?-</C>
<P/>
<Index>browsing the next section browsed</Index>
<C>?+</C>
<P/>
&GAP; remembers the last few sections that you have read.
<C>?-</C> takes you to the one that you have read before the current one,
and displays it again.
Further applications of <C>?-</C> take you further back in this history.
<C>?+</C> reverses this process, i.e., it takes you back to the section that
you have read after the current one.
It is important to note that <C>?-</C>  and <C>?+</C> do not alter the
history like the other help commands.
<P/>
<Index>list of available books</Index>
<C>?books</C>
<P/>
This command shows a list of the books which are currently known to the help
system. For each book there is a short name which is used with the
<A>book</A> part of the basic help query
and there is a long name which hopefully tells you what this book is about.
<P/>
A short name which ends in <C>(not loaded)</C> refers to a &GAP; package
whose documentation is loaded but which needs a call of
<Ref Func="LoadPackage"/> before you can use the described functions.
<P/>
<Index>table of sections for help books</Index>
<C>?[<A>book</A>:]sections</C>
<P/>
<Index>table of chapters for help books</Index>
<C>?[<A>book</A>:][chapters]</C>
<P/>
These commands  show tables of  contents for all available,  respectively the
matching books. For some books these commands show the same, namely the
whole table of contents.
<P/>
<Index>redisplay a help section</Index>
<C>?</C>
<P/>
<Index>redisplay with next help viewer</Index>
<C>?&amp;</C>
<P/>
These commands redisplay the last shown help section.
In the form <C>?&amp;</C> the next preferred help viewer is used for the
display (provided one has chosen several viewers),
see&nbsp;<Ref Func="SetHelpViewer"/> below.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changing the Help Viewer">
<Heading>Changing the Help Viewer</Heading>

<Index>document formats (text, dvi, ps, pdf, HTML)</Index>

Books of the &GAP; help system or package manuals can be available in 
several  formats. Currently the following formats occur (not  
all of them may be available for all books):
<P/>
<List>
<Mark>text</Mark>
<Item>
  This is used for display in the terminal window in which &GAP; is
  running. Complicated mathematical expressions may not be easy to read in
  this format. 
</Item>
<Mark>pdf</Mark>
<Item>
  Adobe's <C>pdf</C> format. Can be used for printing and onscreen reading
  on most current systems (with freely available software).
  Some manual books contain hyperlinks in this format.
</Item>
<Mark>HTML</Mark>
<Item>
  The format of web pages.  Can be used with any web browser.  There may be
  hyperlink information available which allows a convenient browsing through
  the book via cross-references. This format has the problem that
  complicated formulae may be not be easy to read since there is no syntax for
  formulae in  HTML. (Some older manual books  use special  symbol fonts 
  for  formulae and need a particular configuration of the web browser 
  for correct display. Some manuals may use technology for quite
  sophisticated formula display.)
</Item>
</List>
<P/>
Depending on your operating system and available additional software you can
use several of  these formats with &GAP;'s help system.  This is configured
with the following command.


<ManSection>
<Func Name="SetHelpViewer" Arg='viewer1, viewer2, ...'/>

<Description>
This command  takes an arbitrary number  of arguments which must  be strings
describing a viewer. The recognized viewers are explained below. A call with
no arguments shows the current setting.
<P/>
The first  given arguments  are those  with higher priority.  So, if  a help
section is available in the format needed by <A>viewer1</A>,
this viewer is used.
If not, availability of the format for <A>viewer2</A> is checked and so on.
Recall that the command <C>?&amp;</C> displays the last seen section again
but with the next possible viewer in your list,
see&nbsp;<Ref Sect="Browsing through the Sections"/>.
<P/>
The viewer <C>"screen"</C> (see below) is always silently appended since we
assume that each help book is available in text format.
<P/>
If you want to change the default setting you can use a call of 
<C>SetUserPreference( "HelpViewers", [ ... ] );</C>  (the list in 
the second argument containing the viewers you want) 
in your <F>gap.ini</F> file (see&nbsp;<Ref Sect="sect:gap.ini"/>).
<P/>
<List>
<Mark><C>"screen"</C></Mark>
<Item>
  This is the default setting. The help is shown in text format using the
  <Ref Func="Pager"/> command.
  Hint:
  Text versions of manuals are formatted assuming that your terminal 
  displays at least 80 characters per line, if this is not the case 
  some sections may look very bad. 
  We suggest to use a terminal in <C>UTF-8</C> encoding with a fixed
  width font (this is the default on most modern Linux/Windows/Mac systems
  anyway). Terminals in <C>ISO-8859-X</C> encoding will also work reasonably
  well (so far, since we do not yet use many special characters which
  such terminals could not display). 
</Item>
<Mark><C>"firefox"</C>, <C>"chrome"</C>, <C>"mozilla"</C>, <C>"netscape"</C>, <C>"konqueror"</C></Mark>
<Item>
  If a book is available in HTML format this is shown using the
  corresponding web browser.
  How well this works, for example by using a running instance of this
  browser, depends on your particular start script of this browser.
  (Note, that for some old books the browser must be configured
  to use symbol fonts.)
</Item>
<Mark><C>"browser"</C></Mark>
<Item>
  (for MS Windows) If a book is available in HTML format, it will be 
  opened using the Windows default application (typically, a web browser).
</Item>
<Mark><C>"links2"</C>, <C>"w3m"</C>, <C>"lynx"</C></Mark>
<Item>
  If a book is available in HTML format this is shown using the text based
  <C>"links2"</C> (in graphics mode), <C>w3m</C> or <C>lynx</C> web browser, 
  respectively, inside the terminal running &GAP;.
  (Formulae in some older books which use symbol fonts may be unreadable.)
</Item>
<Mark><C>"mac default browser"</C>, <C>"browser"</C>, <C>"safari"</C>, <C>"firefox"</C></Mark>
<Item>
  (for Mac OS X) If a book is available in HTML format this is shown
  in a web browser. The options <C>"safari"</C> and <C>"firefox"</C> use 
  the corresponding browsers. The other two options use the program default browser
  (which can be set in Safari's preferences, in the "General" tab).
</Item>
<Mark><C>"xpdf"</C></Mark>
<Item>
  (on X-windows systems) If a book is available in pdf format it is shown
  with the onscreen viewer program <C>xpdf</C>
  (which must be installed on your system).
  This is a nice program, once it is running it is reused by &GAP; for the
  next displays of help sections.
</Item>
<Mark><C>"acroread"</C></Mark>
<Item>
  If a book is available in pdf format it is shown with the onscreen viewer
  program <C>acroread</C> (which must be available on your system).
  This program does not allow remote commands or startup with a given page.
  Therefore the page numbers you have to visit are just printed on the
  screen.
  When you are looking at several sections of the same book, this viewer
  assumes that the <C>acroread</C> window still exists.
  When you go to another book a new acroread window is launched.
</Item>
<Mark><C>"pdf viewer"</C>, <C>"skim"</C>, <C>"preview"</C>, <C>"adobe reader"</C></Mark>
<Item>
  (for Mac OS X) If a book is available in pdf format this is shown
  in a pdf viewer. The options <C>"skim"</C>, <C>"preview"</C> and <C>"adobe reader"</C> use 
  the corresponding viewers. The other two options use the pdf viewer which you have 
  chosen to open pdf files from the Finder.
  Note that only <C>"Skim"</C> seems to be capable to open a pdf file 
  on a given page. For the other help viewers, the page numbers where the information can be found will just be 
  printed on the screen.
  None of the help viewers seems to be capable of 
  opening a pdf at a given named destination (i. e., jump to precisely the place where the information can be found).
  The pdf viewer <C>"Skim"</C> is open source software, it can be downloaded from <F>http://skim-app.sourceforge.net/</F>.
</Item>
<Mark><C>"less"</C> or <C>"more"</C></Mark>
<Item>
  This is the same as <C>"screen"</C> but additionally the user preferences
  <C>"Pager"</C> and <C>""PagerOptions"</C> are set,
  see the section&nbsp;<Ref Sect="The Pager Command"/> for more details.
</Item>
</List>
<P/>
Please, send ideas for further viewer commands to
<Email>support@gap-system.org</Email>.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Pager Command">
<Heading>The Pager Command</Heading>

&GAP; contains a builtin pager which  shows a text string which does not fit
on  the screen  page  by page.  Its functionality  is  very rudimentary  and
self-explaining. This  is because (at  least under UNIX) there  are powerful
external standard programs which do this job.

<ManSection>
<Func Name="Pager" Arg='lines'/>

<Description>
This function can be used to display a text on screen using a pager,
i.e., the text is shown page by page. 
<P/>
There is a default builtin pager in &GAP; which has very limited
capabilities but should work on any system.
<P/>
At least on a UNIX system one should use an external pager program like
<C>less</C> or <C>more</C>.
&GAP; assumes that this program has a command line option <C>+nr</C>
which starts the display of the text with line number <C>nr</C>.
<P/>
Which pager is used can be controlled by setting the user preference
<C>"Pager"</C>.
The default value is <C>"builtin"</C>
which means that the internal pager is used.
<P/>
On UNIX systems you probably want to set the user preference
<C>"Pager"</C> to the value <C>"less"</C> or <C>"more"</C>,
you can do this for example in your <F>gap.ini</F>
file (see <Ref Sect="sect:gap.ini"/>).
In that case you can also tell &GAP; a list of standard options for the
external pager, via the user preference <C>"PagerOptions"</C>.
<P/>
<Log><![CDATA[
  SetUserPreference( "Pager", "less" );
  SetUserPreference( "PagerOptions", ["-f","-r","-a","-i","-M","-j2"] );
]]></Log>
<P/>
The argument <A>lines</A> can have one of the following forms:
<P/>
<Enum> 
<Item> 
 a string (i.e., lines are separated by newline characters)
</Item>
<Item>
 a list of strings (without  newline characters) 
which are interpreted as lines of the text to be shown
</Item>
<Item>
 a record with component <C>lines</C> as in 1. or 2. and
optional further components
</Item> 
</Enum>
<P/>
In case&nbsp;3. currently the following additional components are used:
<P/>
<List>
<Mark><C>formatted</C></Mark>
<Item>
  can be <K>false</K> or <K>true</K>.
  If set to <K>true</K> the builtin pager tries to show the text exactly
  as it is given (avoiding &GAP;'s automatic line breaking),
</Item>
<Mark><C>start</C></Mark>
<Item>
  must be a positive integer.
  This is interpreted as the number of the first line shown by the pager
  (one may see the beginning of the text via back scrolling).
</Item>
<Mark><C>exitAtEnd</C></Mark>
<Item>
  can be <K>false</K> or <K>true</K>.
  If set to <K>true</K> (the default), the builtin pager is terminated
  as soon as the end of the list is shown;
  otherwise entering the <B>q</B> key is necessary in order to return
  from the pager.
</Item>
</List>
<P/>
The <Ref Func="Pager"/> command is used by &GAP;'s help system for
displaying help sections in text format.
But, of course, it may be used for other purposes as well.
<P/>
<Log><![CDATA[
gap> s6 := SymmetricGroup(6);;
gap> words := ["This", "is", "a", "very", "stupid", "example"];;
gap> l := List(s6, p-> Permuted(words, p));;
gap> Pager(List(l, a-> JoinStringsWithSeparator(a," ")));;
]]></Log>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  run.msk                 GAP documentation                Frank Celler -->
<!-- %W                                                     & Martin Schönert -->
<!-- %W                                                     & Alexander Hulpke -->
<!-- %W                                                    & Burkhard Höfling -->
<!-- %% -->
<!-- %H  @(#)<M>Id: run.msk,v 1.43 2006/09/27 21:40:31 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<!-- %%  This file contains the  description of the installation procedure and -->
<!-- %%  command line options for various operating systems. -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Running GAP">
<Heading>Running GAP</Heading>

<Index>options</Index>
This chapter informs about command line options for &GAP; 
(see&nbsp;<Ref Sect="Command Line Options"/>),
some files in user specific &GAP; root  directory
(see&nbsp;<Ref Sect="sect:gap.ini"/>) 
and saving and loading a &GAP; workspace
(see&nbsp;<Ref Sect="Saving and Loading a Workspace"/>).


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Command Line Options">
<Heading>Command Line Options</Heading>

<Index Subkey="under UNIX">features</Index>
<Index Subkey="features">UNIX</Index>
<Index Subkey="under UNIX">options</Index>
<Index Subkey="options">UNIX</Index>
<Index Key="GAPInfo.CommandLineOptions">
<C>GAPInfo.CommandLineOptions</C></Index>

When you start &GAP; from a command line or from a script you may 
specify a number of  options on
the command-line to change  the default behaviour  of &GAP;.  All  these
options  start with a  hyphen <C>-</C>, followed by a  single letter.
Options must not be grouped, e.g., <C>gap -gq</C> is invalid,
use <C>gap -g -q</C> instead.
Some options require an argument, this must follow the option
and  must be separated by whitespace, e.g.,  <C>gap -m 256m</C>,
it is not correct to say <C>gap -m256m</C> instead.
Certain Boolean options (<C>-b</C>, <C>-q</C>, <C>-e</C>, <C>-r</C>,
<C>-A</C>, <C>-D</C>, <C>-M</C>, <C>-T</C>, <C>-X</C>, <C>-Y</C>)
toggle the current value so that <C>gap -b -b</C> is equivalent to <C>gap</C>
and to <C>gap -b -q -b -q</C> etc.
<P/>
&GAP; for UNIX will distinguish between upper and lower case options.
<P/>
As described in the &GAP; installation instructions (see the 
<F>INSTALL</F> file in the &GAP; root directory, or at
<URL>http://www.gap-system.org/Download/INSTALL</URL>),
usually you will not execute &GAP; directly. Instead  you  will
call a (shell) script, with the name <C>gap</C>, which in turn executes  &GAP;.
This  script sets some options which are necessary  to  make  &GAP;
work on your system. This means that the default settings mentioned below
may not be what you experience when you execute &GAP; on your system.
<P/>
During a &GAP; session, one can find the current values of command line options 
in the record <C>GAPInfo.CommandLineOptions</C> (see <Ref Var="GAPInfo"/>),
whose component names are the command line options
(without the leading <C>-</C>).
<P/>
<List>

<Mark><Index Key="-A"><C>-A</C></Index>
<C>-A</C></Mark>
<Item>
By default, some needed and suggested &GAP; packages
(see <Ref Chap="GAP Packages"/>) are loaded,
if present, into the &GAP; session when it  starts.
This option disables (actually toggles) the loading of suggested packages,
which can be useful for debugging or testing.
The needed packages (and their needed packages, and so on)
are loaded in any case.
</Item>
<Mark><Index Key="-a"><C>-a</C></Index>
<C>-a </C><A>memory</A></Mark>
<Item>
GASMAN, the storage manager of &GAP; uses <C>sbrk</C> to get blocks of memory
from (certain) operating systems and it is required that subsequent calls
to <C>sbrk</C> produce adjacent blocks of memory in this case  because  &GAP;
only wants to deal with one large block of  memory.  If  the  C  function
<C>malloc</C> is called for whatever reason, it is likely that 
<C>sbrk</C> will  no
longer produce adjacent blocks, therefore &GAP; does  not  use  <C>malloc</C>
itself.
<P/>
However some operating systems insist on calling  <C>malloc</C>  to  create  a
buffer when a file is opened, or for some other reason. In order to catch
these cases &GAP; preallocates a block of memory with <C>malloc</C> which  is
immediately freed. The amount preallocated can  be  controlled  with  the
<C>-a</C> option. (Most users do not need this option.)
<P/>
The option argument <A>memory</A> is specified as with the <C>-m</C> option.
</Item>
<Mark><Index Key="-B"><C>-B</C></Index>
<C>-B </C><A>architecture</A></Mark>
<Item>
Executable binary files that form part of &GAP; or of  a &GAP;  package
are kept in a subdirectory of the <F>bin</F> directory within  the  &GAP; or
package root directory. The subdirectory  name  is  determined  from  the
operating system, processor and compiler details when &GAP;  (resp.  the
package) is installed. Under rare circumstances, it may be  necessary  to
override this name, and this can be done using the <C>-B</C> option.
</Item>
<Mark><Index Key="-b"><C>-b</C></Index>
<C>-b</C></Mark>
<Item>
tells &GAP; to suppress the banner. That means that  &GAP;  immediately
prints the prompt. This is useful when, after a while, you get  tired  of
the banner. This option can be repeated to enable the banner; each <C>-b</C>
toggles the state of banner display.
</Item>
<Mark><Index Key="-D"><C>-D</C></Index>
<C>-D</C></Mark>
<Item>
The <C>-D</C> option tells &GAP; to print short messages when it  is  reading
files or loading modules. This option may be repeated to
toggle this behavior on and off. The message,
<P/>
<Log><![CDATA[
#I  READ_GAP_ROOT: loading 'lib/kernel.g' as GAP file
]]></Log>
<P/>
tells   you  that   &GAP;  has  started    to  read the   library   file
<F>lib/kernel.g</F>. 
<P/>
<Log><![CDATA[
#I  READ_GAP_ROOT: loading 'lib/kernel.g' statically
]]></Log>
<P/>
tells you that &GAP; has used the compiled version of the  library  file
<F>lib/kernel.g</F>. This compiled module was statically linked to the  &GAP;
kernel at the time the kernel was created. 
<P/>
<Log><![CDATA[
#I  READ_GAP_ROOT: loading 'lib/kernel.g' dynamically
]]></Log>
<P/>
tells you that &GAP; has loaded the compiled version of the library file
<F>lib/kernel.g</F>. This compiled module was dynamically loaded to the &GAP;
kernel at runtime from a corresponding <C>.so</C> file.
<P/>
Obviously, this is a debugging option and most users will not need it.
</Item>
<Mark><Index Key="-E"><C>-E</C></Index>
<C>-E</C></Mark>
<Item>
If your &GAP; installation uses the <C>readline</C> library for command line 
editing (see <Ref Sect="sec:readline"/>), this may be disabled by using 
<C>-E</C> option. This option may be repeated to toggle this behavior on and 
off. If your &GAP; installation does not use the <C>readline</C> library 
(you can check by <C>IsBound(GAPInfo.UseReadline);</C> if this is the case),
this option will have no effect at all.
</Item>
<Mark><Index Key="-e"><C>-e</C></Index>
<C>-e</C></Mark>
<Item>
tells &GAP; not to quit when receiving a <B>Ctrl-D</B>
on an empty input line (see&nbsp;<Ref Subsect="quit"/>).
This option should not be used when the input is a file or pipe.
This option may be repeated to toggle this behavior on and off.
</Item>
<Mark><Index Key="-f"><C>-f</C></Index>
<C>-f</C></Mark>
<Item>
tells &GAP; to enable the line editing and history 
(see <Ref Sect="Line Editing"/>).
<P/>
In general  line editing will  be enabled if the input  is connected to a
terminal.  There are rare circumstances, for  example when using a remote
session with a corrupted telnet implementation, when this detection fails.
Try using <C>-f</C> in this case to enable line editing. This option does not
toggle; you must use <C>-n</C> to disable line editing.
</Item>
<Mark><Index Key="-g"><C>-g</C></Index>
<C>-g</C></Mark>
<Item>
tells &GAP; to print a message every  time  a  full  garbage
collection is performed.
<P/>
<Log><![CDATA[
#G  FULL 44580/2479kb live   57304/4392kb dead   734/4096kb free
]]></Log>
<P/>
For example, this tells you  that  there  are  44580  live  objects  that
survived a full  garbage  collection,  that  57304  unused  objects  were
reclaimed by it, and that 734 kilobytes from a  total  allocated  memory  of
4096 kilobytes are available afterwards.
</Item>
<Mark><Index Key="-g -g"><C>-g -g</C></Index>
<C>-g -g</C></Mark>
<Item>
If you give the option <C>-g</C> twice, &GAP; prints  a  information  message
every time a  partial  or  full  garbage  collection  is  performed.  The
message,
<P/>
<Log><![CDATA[
#G  PART 9405/961kb+live   7525/1324kb+dead   2541/4096kb free
]]></Log>
<P/>
for example, tells you that 9405 objects  survived  the  partial  garbage
collection and 7525 objects were reclaimed, and that 2541 kilobytes  from  a
total allocated memory of 4096 kilobytes are available afterwards.
</Item>
<Mark><Index Key="-h"><C>-h</C></Index>
<C>-h</C></Mark>
<Item>
tells &GAP; to print a summary of all available options (<C>-h</C> is mnemonic
for <Q>help</Q>). &GAP; exits after printing the summary, all other options
are ignored.
</Item>
<Mark><Index Key="-i"><C>-i</C></Index>
<C>-i </C><A>filename</A></Mark>
<Item>
changes  the  name  of  the  init  file  from  the  default  <F>init.g</F>  to
<A>filename</A>. (Usually not needed.)
</Item>
<Mark><Index Key="-K"><C>-K</C></Index> 
<C>-K </C><A>memory</A></Mark>
<Item>
is like the <C>-o</C> option.
But while the latter actually allocates more memory if the system allows it
and then prints a warning inside a break loop the <C>-K</C> 
options tells &GAP; not even to try to allocate more memory. Instead &GAP;
just exits with an appropriate message. The default is that this feature is
switched off. You have to set it explicitly when you want to enable it.
</Item>
<Mark><Index Key="-L"><C>-L</C></Index>
<C>-L </C><A>filename</A></Mark>
<Item>
The option <C>-L</C> tells &GAP; to load a saved workspace. See
section&nbsp;<Ref Sect="Saving and Loading a Workspace"/>.
</Item>
<Mark><Index Key="-l"><C>-l</C></Index>
<C>-l </C><A>path_list</A></Mark>
<Item>
can be used to set or modify &GAP;'s list of root directories
(see <Ref Sect="GAP Root Directories"/>).
The default if no <C>-l </C> option is given is the current directory
<F>./</F>. This option can be used several times. Depending on the 
<C>-r</C> option a further user specific path is prepended to the
list of root directories (the path in <C>GAPInfo.UserGapRoot</C>).
<P/>
<A>path_list</A> should be a list of directories separated by  semicolons.
No whitespace is permitted before or after a semicolon.
If <A>path_list</A> does not start  or  end  with  a semicolon,
then <A>path_list</A> replaces the existing list of root directories.
If <A>path_list</A> starts with a semicolon, then <A>path_list</A>  is
appended to the existing list of root directories.  If  <A>path_list</A>  ends
with a semicolon and does not start with one, then the new list of root
directories is the concatenation of <A>path_list</A> and the existing list  of
root directories. After &GAP; has completed its  startup  procedure  and
displays the prompt, the list of root directories can be  seen  in  the
variable <C>GAPInfo.RootPaths</C>,
see <Ref Var="GAPInfo"/>.
<P/>
Usually this option is used inside a startup script to specify
where &GAP; is installed on the system.
The <C>-l</C> option can also be used by individual users to tell &GAP;
about privately installed modifications of the library,
additional &GAP; packages and so on.
Section <Ref Sect="GAP Root Directories"/>  explains  how  several
root paths can be used to do this.
<P/>
&GAP; will attempt to read the file <A>root_dir</A><F>/lib/init.g</F> during
startup where <A>root_dir</A> is one of the directories in its  list  of  root
directories.
If &GAP; cannot find its <F>init.g</F> file it will print the following
warning.
<P/>
<Log><![CDATA[
gap: hmm, I cannot find 'lib/init.g' maybe use option '-l <gaproot>'?
]]></Log>
<P/>
It is not possible  to use &GAP; without the  library files, so you must
not  ignore this warning.  You  should leave &GAP;   and start it again,
specifying the correct root path using the <C>-l</C> option.
</Item>
<Mark><Index Key="-M"><C>-M</C></Index>
<C>-M</C></Mark>
<Item>
tells &GAP; not to check for, nor to use, compiled versions  of  library
files. This option may be repeated to toggle this behavior on and off.
</Item>
<Mark><Index Key="-m"><C>-m</C></Index>
<C>-m </C><A>memory</A></Mark>
<Item>
tells &GAP; to allocate <A>memory</A> bytes at startup time.
If the last character of <A>memory</A> is <C>k</C> or <C>K</C>
it is taken as kilobytes,
if the last character is <C>m</C> or <C>M</C> <A>memory</A>
is taken as megabytes
and if it is <C>g</C> or <C>G</C> it is taken as gigabytes.
<P/>
This amount of memory should be large enough so that computations  do  not
require too many garbage  collections.  On  the  other  hand,  if  &GAP;
allocates more memory than is physically available, it will spend
most of the time paging.
</Item>
<Mark><Index Key="-n"><C>-n</C></Index>
<C>-n</C></Mark>
<Item>
tells &GAP; to disable the line editing and history
(see <Ref Sect="Line Editing"/>).
<P/>
You may want to do this if the command line  editing is incompatible with
another program that is used to run &GAP;.  For example if &GAP; is run
from inside a GNU Emacs shell window, <C>-n</C> should be used since otherwise
every input line will be echoed twice, once by Emacs and once by &GAP;.
This option does not toggle; you must use <C>-f</C> to enable line editing.
</Item>
<Mark><Index Key="-O"><C>-O</C></Index>
<C>-O</C></Mark>
<Item>
disables loading obsolete variables (see 
Chapter <Ref Label="Replaced and Removed Command Names"/>). This 
option is used mainly for testing purposes, for example in order to make 
sure that a &GAP; package or one's own &GAP; code does not rely on the 
obsolete variables.
</Item>
<Mark><Index Key="-o"><C>-o</C></Index>
<C>-o </C><A>memory</A></Mark>
<Item>
tells &GAP; to allocate at most <A>memory</A> bytes without asking.
The option argument <A>memory</A> is specified as with the <C>-m</C> 
option.
<P/>
If more than this amount is required during the &GAP; session, 
&GAP; prints an error message and enters a break loop. In that case you can
enter <C>return;</C> which implicitly doubles the amount given with this 
option. 
</Item>
<Mark><Index Key="-q"><C>-q</C></Index>
<C>-q</C></Mark>
<Item>
tells &GAP; to be quiet. This means that  &GAP;  displays  neither  the
banner nor the prompt <C>gap></C>. This is useful if you want to run &GAP; as
a filter with input and output redirection and want to avoid  the  banner
and the prompts appearing in the output file. This option may be repeated
to disable quiet mode; each <C>-q</C> toggles quiet mode.
</Item>
<Mark><Index Key="-R"><C>-R</C></Index>
<C>-R</C></Mark>
<Item>
The option <C>-R</C> tells &GAP; not to load a saved workspace previously 
specified via the <C>-L</C> option. This option does not toggle.
</Item>
<Mark><Index Key="-r"><C>-r</C></Index>
<C>-r</C></Mark>
<Item>
The option <C>-r</C> tells &GAP; to ignore any user specific configuration 
files. In particular, the user specific root directory 
<C>GAPInfo.UserGapRoot</C> is not added to the &GAP; root directories and
so <F>gap.ini</F> and <F>gaprc</F> files  that may be contained in that
directory are not read, see <Ref Sect="sect:gap.ini"/>.
Multiple <C>-r</C> options toggle this behaviour.
</Item>
<Mark><Index Key="-s"><C>-s</C></Index>
<C>-s </C><A>memory</A></Mark>
<Item>
With this option &GAP; does not use <C>sbrk</C> to get memory from the 
operating system. Instead it uses <C>mmap</C>, <C>malloc</C> or some other
command for the amount given 
with this option to allocate 
space for the <C>GASMAN</C> memory manager. 
Usually &GAP; does not really use all of this memory, the options 
<C>-m</C>, <C>-o</C>, <C>-K</C> still work
as documented. This feature assumes that the operating system only assigns 
physical memory to the &GAP; process when it is accessed, so that specifying a
large amount of memory with <C>-s</C> should not cause any performance problem.
The advantage of using this option is that &GAP; can work together with kernel
modules which allocate a lot of memory with <C>malloc</C>.
<P/>
The option argument <A>memory</A> is specified as with the <C>-m</C> 
option.
</Item>
<Mark><Index Key="-T"><C>-T</C></Index>
<C>-T</C></Mark>
<Item>
suppresses the usual break loop behaviour of  &GAP;.  With  this  option
&GAP; behaves as if the user <K>quit</K> immediately from every  break  loop.
This is intended for automated testing of &GAP;. This option may be 
repeated to toggle this behavior on and off.
</Item>
<Mark><Index Key="-X"><C>-X</C></Index>
<C>-X</C></Mark>
<Item>
tells &GAP; to do a consistency  check  of  the  library  file  and  the
corresponding compiled module when loading the compiled module. This
option may be repeated to toggle this behavior on and off.
</Item>
<Mark><Index Key="-x"><C>-x</C></Index>
<C>-x </C><A>length</A></Mark>
<Item>
With this option  you can tell  &GAP;  how long lines  are.  &GAP; uses
this value to decide when to split long lines. After starting &GAP;  you
may use <Ref Func="SizeScreen"/> to alter the line length.
<P/>
The default value is 80, unless another value can be  obtained  from  the
Operating System, which is the right value if you have a  standard 
terminal application. If you have a  larger  monitor,  or  use  a  
smaller  font,  or
redirect the output to a printer, you may want to increase this value.
</Item>
<Mark><Index Key="-y"><C>-y</C></Index>
<C>-y </C><A>length</A></Mark>
<Item>
With this option you can tell &GAP; how  many  lines  your  screen  has.
&GAP; uses this value to decide after how many lines of on-line help  it
should  wait.  After   starting   &GAP;   you   may   use
<Ref Func="SizeScreen"/> to alter the number of lines.
<P/>
The default value is 24, unless another value can be  obtained  from  the
Operating System, which is the right value if you have a  standard  
terminal application. 
If you have a  larger  monitor,  or  use  a  smaller  font,  or
redirect the output to a printer, you may want to increase this value.
</Item>
<Mark><Index Subkey="command line, filenames">options</Index>
<A>filename</A> ...</Mark>
<Item>
Further arguments are taken as filenames of files that are read by &GAP;
during startup, after the system  and private init   files are read,  but
before the first prompt is  printed.
The files are read in the order in which they appear on the command line.
&GAP; only accepts up to 14 filenames on the command line.
If a file cannot be opened &GAP; will print an error message and will abort.
</Item>
</List>
<P/>
<Index Subkey="command line, internal">options</Index>
<Index Key="-C"><C>-C</C></Index><Index Key="-U"><C>-U</C></Index>
<Index Key="-P"><C>-P</C></Index><Index Key="-W"><C>-W</C></Index>
<Index Key="-z"><C>-z</C></Index><Index Key="-p"><C>-p</C></Index>
Additional options, <C>-C</C>, <C>-U</C>, <C>-P</C>, <C>-W</C>, <C>-p</C>
and <C>-z</C> are  used  
internally by the <Package>gac</Package> script (see <Ref Label="Kernel modules"/>)
and/or on specific operating systems.


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:gap.ini">
<Heading>The gap.ini and gaprc files</Heading>

When you start &GAP;,
it looks for files with the names <F>gap.ini</F> and <F>gaprc</F>
in its root directories (see <Ref Sect="GAP Root Directories"/>),
and reads the first <F>gap.ini</F> and the first <F>gaprc</F> file it finds.
These files are used for certain initializations, as follows.
<P/>
The file <F>gap.ini</F> is read early in the startup process.
Therefore, the parameters set in this file can influence the startup process,
such as which packages are automatically loaded
(see <Ref Func="LoadPackage"/>)
and whether library files containing obsolete variables are read
(see Chapter <Ref Chap="Replaced and Removed Command Names"/>).
On the other hand, only calls to a restricted set of &GAP; functions are
allowed in a <F>gap.ini</F> file. Usually, it should only contain calls
of <Ref Func="SetUserPreference"/>. This file can be generated (or updated
when new releases introduce further user preferences) with the command
<Ref Func="WriteGapIniFile"/>.
This file is read whenever &GAP; is started, with or without a workspace.
<P/>
The file <F>gaprc</F> is read after the startup process,
before the first input file given on the command line
(see <Ref Sect="Command Line Options"/>).
So the contents of this file cannot influence the startup process,
but all &GAP; library functions can be called in this file.
When &GAP; is started with a workspace then the file is read only if no
<F>gaprc</F> file had been read before the workspace was created.
(With this setup, it is on the one hand possible that administrators provide
a &GAP; workspace for several users such that the user's <F>gaprc</F> file
is read when &GAP; is started with the workspace,
and on the other hand one can start &GAP;, read one's <F>gaprc</F> file,
save a workspace, and then start from this workspace <E>without</E>
reading one's <F>gaprc</F> file again.)
<P/>
Note that by default, the user specific &GAP; root directory 
<C>GAPInfo.UserGapRoot</C> 
is the first &GAP; root directory. 
So you can put your <F>gap.ini</F> and <F>gaprc</F> files into this directory.
<P/>
This mechanism substitutes the much less flexible reading of a users
<F>.gaprc</F> file in versions of &GAP; up to 4.4. 
For compatibility this <F>.gaprc</F> file is still read if the directory
<C>GAPInfo.UserGapRoot</C> does not exist, see <Ref Sect="obsolete-gaprc"/>
how to migrate your old setup.

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:gap.ini file">
<Heading>The gap.ini file</Heading>

<Index Key="gap.ini"><F>gap.ini</F></Index>

The file <F>gap.ini</F> is read after the declaration part
of the &GAP; library is read,
before the declaration parts of the packages needed and suggested by &GAP;
are read,
and before the implementation parts of &GAP; and of the packages are read.
<P/>
The file <F>gap.ini</F> is expected to consist of calls to the function
<Ref Func="SetUserPreference"/>,
see Section&nbsp;<Ref Func="SetUserPreference"/>.
<P/>

Since the file <F>gap.ini</F> is read before the implementation part of
&GAP; is read, not all &GAP; functions may be called in the file.
Assignments of numbers, lists, and records are admissible as well as calls
to basic functions such as
<Ref Func="Concatenation" Label="for several lists"/> and
<Ref Func="JoinStringsWithSeparator"/>.
<P/>
Note that the file <F>gap.ini</F> is read also when &GAP; is started
with a workspace.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:gaprc file">
<Heading>The gaprc file</Heading>

If a file <F>gaprc</F> is found it is read after &GAP;'s <F>init.g</F>,
but before any of the files mentioned on the command line are read.
You can use this file for your private customizations.
(Many users may be happy with using just  user preferences in the
<F>gap.ini</F> file (see above) for private customization.)
For example, if you have a file containing functions or data that you
always need, you could read this from <F>gaprc</F>.
Or if you find some of the names in the library too long,
you could define abbreviations for those names in <F>gaprc</F>.
The following sample <F>gaprc</F> file does both.
<P/>
<Log><![CDATA[
Read( "/usr/you/dat/mygroups.grp" );
Ac := Action;
AcHom := ActionHomomorphism;
RepAc := RepresentativeAction;
]]></Log>
<P/>
Note that only one <F>gaprc</F> file is read when &GAP; is started.
When a workspace is created in a &GAP; session after a <F>gaprc</F> file
has been read then no more <F>gaprc</F> file will be read when &GAP;
is started with this workspace.
<P/>
Also note that the file must be called <F>gaprc</F>.
If you use a Windows text editor,
in particular if your default is not to show file suffixes,
you might accidentally create a file <F>gaprc.txt</F> or <F>gaprc.doc</F>
which GAP will not recognize.

</Subsection>

<ManSection>
<Heading>Configuring User preferences</Heading>
<Func Name="SetUserPreference" Arg="[package, ]name, value"/>
<Func Name="UserPreference" Arg="[package, ]name"/>
<Func Name="ShowUserPreferences" Arg="package1, package2, ..."/>
<Func Name="WriteGapIniFile" Arg="[dir][,][ignorecurrent]"/>

<Description>

Some aspects of the behaviour of &GAP; can be customized by the user via
<Emph>user preferences</Emph>.  Examples include  the way  help sections
are displayed or the use of colors in the terminal. <P/>

User preferences are  specified via a pair of strings,  the first is the
(case insensitive) name of a package (or <C>"GAP"</C> for the core &GAP;
library) and the second is some arbitrary case sensitive string. <P/>

User   preferences  can   be  set   to  some   <A>value</A>  with   <Ref
Func="SetUserPreference"/>. The  current value of a  user preference can
be found with <Ref Func="UserPreference"/>. In both cases, if no package
name is  given the default  <C>"GAP"</C> is  used. If a  user preference
is  not  known or  not  set  then <Ref  Func="UserPreference"/>  returns
<K>fail</K>. <P/>

The function <Ref Func="ShowUserPreferences"/> with no argument shows in
a  pager  an  overview  of  all known  user  preferences  together  with
some  explanation  and  the  current  value.  If  one  or  more  strings
<A>package1</A>, ... are given then  only the user preferences for these
packages are shown. <P/>

The easiest way to  make use of user preferences is  probably to use the
function <Ref  Func="WriteGapIniFile"/>, usually without  argument. This
function creates a file <F>gap.ini</F>  in your user specific &GAP; root
directory (<C>GAPInfo.UserGapRoot</C>).  If such  a file  already exists
the function  will make a  backup of it  first. This newly  created file
contains  descriptions of  all  known user  preferences  and also  calls
of  <Ref Func="SetUserPreference"/>  for  those  user preferences  which
currently do not  have their default value. You can  then edit that file
to customize (further)  the user preferences for  future &GAP; sessions.
<P/>

Should a  later version  of &GAP;  or some  packages introduce  new user
preferences then you can  call <Ref Func="WriteGapIniFile"/> again since
it  will set  the previously  known  user preferences  to their  current
values. <P/>

Optionally,  a  different  directory for  the  resulting  <F>gap.ini</F>
file    can   be    specified   as    argument   <A>dir</A>    to   <Ref
Func="WriteGapIniFile"/>. Another optional argument is the boolean value
<K>true</K>, if this  is given, the settings of all  user preferences in
the current session are ignored. <P/>

Note that  your <F>gap.ini</F> file is  read by &GAP; very  early during
its startup process. A consequence  is that the <A>value</A> argument in
a call of <Ref Func="SetUserPreference"/>  must be some very basic &GAP;
object, usually a boolean, a number, a  string or a list of those. A few
user  preferences support  more complicated  settings. For  example, the
user  preference <C>"UseColorPrompt"</C>  admits a  record as  its value
whose components are available  only after the <Package>GAPDoc</Package>
package has been loaded, see&nbsp;<Ref Func="ColorPrompt"/>. If you want
to specify such a complicated value, then move the corresponding call of
<Ref Func="SetUserPreference"/> from your  <F>gap.ini</F> file into your
<F>gaprc</F>  file (also  in the  directory <C>GAPInfo.UserGapRoot</C>).
This file is read much later. <P/>

<Example>
gap> SetUserPreference( "Pager", "less" );
gap> SetUserPreference("PagerOptions",
>                      [ "-f", "-r", "-a", "-i", "-M", "-j2" ] );
gap> UserPreference("Pager");
"less"
</Example>

The first two lines of this example will cause &GAP; to use the programm
<C>less</C> as  a pager.  This is highly  recommended if  <C>less</C> is
available on  your system. The  last line displays the  current setting.
<P/>

</Description> 
</ManSection>

<ManSection>
<Func Name="DeclareUserPreference" Arg="record"/>

<Description>

This  function can  be used  (also in  packages) to  introduce new  user
preferences. It declares  a user preference, determines  a default value
and contains documentation  of the user preference.  After declaration a
user preference will be shown with <Ref Func="ShowUserPreferences"/> and
<Ref Func="WriteGapIniFile"/>. <P/>

When  this  declaration  is  evaluated  it  is  checked,  if  this  user
preference is  already set in the  current session. If not  the value of
the user  preference is set to  its default. (Do not  use <K>fail</K> as
default  value  since this  indicated  that  a  user preference  is  not
set.)<P/>

The argument <A>record</A> of <Ref Func="DeclareUserPreference"/> must be
a record with the following components.
<P/>
<List>
<Mark><C>name</C></Mark>
<Item>
  a string or a list of strings, the latter meaning several preferences
  which belong together,
</Item>
<Mark><C>description</C></Mark>
<Item>
  a list of strings describing the preference(s), one string for each
  paragraph;
  if several preferences are declared together then the description
  refers to all of them,
</Item>
<Mark><C>default</C></Mark>
<Item>
  the default value that is used,
  or a function without arguments that computes this default value;
  if several preferences are declared together then the value of this
  component must be the list of default values for the individual
  preferences.
</Item>
</List>
<P/>
The following components of <A>record</A> are optional.
<P/>
<List>
<Mark><C>check</C></Mark>
<Item>
  a function that takes a value as its argument and returns either
  <K>true</K> or <K>false</K>, depending on whether the given value
  is admissible for this preference;
  if several preferences are declared together then the number of
  arguments of the function must equal the length of the <C>name</C>
  list,
</Item>
<Mark><C>values</C></Mark>
<Item>
  the list of admissible values, or a function without arguments
  that returns this list,
</Item>
<Mark><C>multi</C></Mark>
<Item>
  <K>true</K> or <K>false</K>, depending on whether one may choose
  several values from the given list or just one;
  needed (and useful only) if the <C>values</C> component is present,
</Item>
<Mark><C>package</C></Mark>
<Item>
  the name of the &GAP; package to which the preference is assigned;
  if the declaration happens inside a file that belongs to this package
  then the value of this component is computed,
  using <C>GAPInfo.PackageCurrent</C>;
  otherwise, the default value for <C>package</C> is <C>"GAP"</C>,
</Item>
<Mark><C>omitFromGapIniFile</C></Mark>
<Item>
  if the value is <K>true</K> then this user preference is ignored by
  <Ref Func="WriteGapIniFile"/>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> UserPreference( "MyFavouritePrime" );
fail
gap> DeclareUserPreference( rec(
>        name:= "MyFavouritePrime",
>        description:= [ "is not used, serves as an example" ],
>        default:= 2,
>        omitFromGapIniFile:= true ) );
gap> UserPreference( "MyFavouritePrime" );
2
gap> SetUserPreference( "MyFavouritePrime", 17 );
gap> UserPreference( "MyFavouritePrime" );
17
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Saving and Loading a Workspace">
<Heading>Saving and Loading a Workspace</Heading>

&GAP; workspace files are binary files that contain the data of a &GAP;
session.
One can produce a workspace file with <Ref Func="SaveWorkspace"/>,
and load it into a new &GAP; session using the <C>-L</C> command line option,
see Section <Ref Sect="Command Line Options"/>.
<P/>
One purpose of workspace files is of course the possibility
to save a <Q>snapshot</Q> image of the current &GAP; workspace in a file.
<P/>
The recommended way to start &GAP; is to load an existing workspace file,
because this reduces the startup time of &GAP; drastically.
So if you have installed &GAP; yourself then you should think about creating
a workspace file immediately after you have started &GAP;,
and then using this workspace file later on, whenever you start &GAP;.
If your &GAP; installation is shared between several users,
the system administrator should think about providing such a workspace file.

<ManSection>
<Func Name="SaveWorkspace" Arg='filename'/>

<Description>
<Index>save</Index>
will save a <Q>snapshot</Q> image of the current &GAP; workspace in the file
<A>filename</A>. This image then can be loaded by another copy of &GAP; which
then will behave as at the point when <Ref Func="SaveWorkspace"/> was called. 
<P/>
<Log><![CDATA[
gap> a:=1;
gap> SaveWorkspace("savefile");
true
gap> quit;
]]></Log>
<P/>
<Ref Func="SaveWorkspace"/> can only be used at the main <C>gap></C> prompt.
It cannot be included in the body of a loop or function,
or called from a break loop.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Testing for the System Architecture">
<Heading>Testing for the System Architecture</Heading>

<ManSection>
<Func Name="ARCH_IS_UNIX" Arg=''/>

<Description>
tests whether &GAP; is running on a UNIX system (including Mac OS X).
</Description>
</ManSection>

<ManSection>
<Func Name="ARCH_IS_MAC_OS_X" Arg=''/>

<Description>
tests whether &GAP; is running on Mac OS X. Note that on Mac OS X, also
<Ref Func="ARCH_IS_UNIX"/> will be <C>true</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="ARCH_IS_WINDOWS" Arg=''/>

<Description>
tests whether &GAP; is running on a Windows system.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="GAPInfo_sect">
<Heading>Global Values that Control the &GAP; Session</Heading>

<ManSection>
<Var Name="GAPInfo"/>

<Description>
Several global values control the &GAP; session,
such as the command line, the architecture,
or the information about available and loaded packages.
Many of these values are accessible as components of the global record
<Ref Var="GAPInfo"/>.
Typically, these components are set and read in low level &GAP; functions,
so changing the values of existing components of <Ref Var="GAPInfo"/>
<Q>by hand</Q> is not recommended.
<P/>
Important components are documented via index entries,
try the input <C>??GAPInfo</C> for getting an overview of these components.
</Description>
</ManSection>

<!-- further components:
GAPInfo.Architecture (has an index entry)
GAPInfo.AtExitFuncs
GAPInfo.BytesPerVariable
GAPInfo.CommandLineEditFunctions
GAPInfo.CommandLineOptions (has an index entry)
GAPInfo.CommandLineOptionData
GAPInfo.Date
GAPInfo.DeletePrompts
GAPInfo.DirectoriesLibrary
GAPInfo.DirectoriesPrograms
GAPInfo.DirectoriesSystemPrograms
GAPInfo.DirectoriesTemporary
GAPInfo.DirectoryCurrent
GAPInfo.HasReadGAPRC
GAPInfo.History
GAPInfo.InitFiles
GAPInfo.KernelVersion
GAPInfo.MaxNrArgsMethod
GAPInfo.PackageInfoCurrent
GAPInfo.PackageLoadingMessages
GAPInfo.PackagesInfo
GAPInfo.PackagesLoaded
GAPInfo.RootPaths (has an index entry)
GAPInfo.SystemCommandLine
GAPInfo.TestData
GAPInfo.UseReadline
GAPInfo.UserHome
GAPInfo.UserPreferences
GAPInfo.Version (has an index entry)
GAPInfo.gaprc
-->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coloring the Prompt and Input">
<Heading>Coloring the Prompt and Input</Heading>

&GAP; provides hooks for functions which are called when the prompt is 
to be printed and when an input line is finished. 
<P/>
An example of using this feature is the following function. 

<ManSection>
<Func Name="ColorPrompt" Arg='bool[, optrec]'/>

<Description>
With  <C>ColorPrompt(true);</C> &GAP;  changes its  user interface:
The prompts and the user input are displayed in different colors.
Switch off the colored prompts with <C>ColorPrompt(false);</C>.
<P/>
Note that  this will only work  if your terminal emulation  in which
you run &GAP; understands the so called ANSI color escape sequences
&ndash;almost all  terminal emulations  on current  UNIX/Linux
(<C>xterm</C>, <C>rxvt</C>, <C>konsole</C>, ...) systems do so.
<P/>
The colors shown depend on  the terminal configuration and cannot be
forced  from  an application.  If  your  terminal follows  the  ANSI
conventions you see  the standard prompt in bold blue  and the break
loop prompt in bold red, as well as your input in red.
<P/>
If it works for you and you like it, put a call of 
<C>SetUserPreference("UseColorPrompt", true);</C>
in your <F>gap.ini</F> file.
If you want a more complicated setting as explained below then
put your <C>SetUserPreference("UseColorPrompt", rec( ... ) );</C>
call into your <F>gaprc</F> file.
<P/>
The optional second argument <A>optrec</A> allows one to further
customize the behaviour.
It must be a record from which the following components are recognized:
<P/>
<List>
<Mark><C>MarkupStdPrompt</C></Mark>
<Item>
  a string or no argument function returning a string
  containing the escape sequence used for the main prompt <C>gap> </C>.
</Item>
<Mark><C>MarkupContPrompt</C></Mark>
<Item>
  a string or no argument function returning a string
  containing the escape sequence used for the continuation prompt
  <C>> </C>.
</Item>
<Mark><C>MarkupBrkPrompt</C></Mark>
<Item>
  a string or no argument function returning a string
  containing the escape sequence used for the break prompt
  <C>brk...> </C>.
</Item>
<Mark><C>MarkupInput</C></Mark>
<Item>
  a string or no argument function returning a string
  containing the escape sequence used for user input.
</Item>
<Mark><C>TextPrompt</C></Mark>
<Item>
  a no argument function returning the string with the text 
  of the prompt, but without any escape sequences.
  The current standard prompt is returned by <C>CPROMPT()</C>.
  But note that changing the standard prompts makes the automatic removal
  of prompts from input lines impossible
  (see&nbsp;<Ref Sect="Special Rules for Input Lines"/>).
</Item>
<Mark><C>PrePrompt</C></Mark>
<Item>
  a function called before printing a prompt.
</Item>
</List>
<P/>
Here is an example.
<P/>
<Listing><![CDATA[
LoadPackage("GAPDoc");
timeSHOWMIN := 100;
ColorPrompt(true, rec(
   # usually cyan bold, see ?TextAttr
   MarkupStdPrompt := Concatenation(TextAttr.bold, TextAttr.6),
   MarkupContPrompt := Concatenation(TextAttr.bold, TextAttr.6),
   PrePrompt := function()
     # show the 'time' automatically if at least timeSHOWMIN
     if CPROMPT() = "gap> " and time >= timeSHOWMIN then
       Print("Time of last command: ", time, " ms\n");
     fi;
   end)    );
]]></Listing>
</Description>
</ManSection>


</Section>


</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  language.msk           GAP documentation                Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: language.msk,v 1.41 2006/09/27 21:40:31 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1990-1992, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<!-- %%  This file describes the &GAP; programming language. -->
<!-- %% -->
<Chapter Label="The Programming Language">
<Heading>The Programming Language</Heading>

This chapter describes the &GAP; programming language.  It should allow
you in principle to predict the result of each and every input. In order
to know what we are talking about, we first have to look more closely at
the process of interpretation and the various representations of data
involved.

<!-- %%  The &GAP; language and its interpreter in the kernel were designed by  -->
<!-- %%  Martin Sch{\"o}nert. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Language Overview">
<Heading>Language Overview</Heading>

First we have the input to &GAP;, given as a string of characters. How
those characters enter &GAP; is operating system dependent, e.g., they
might be entered at a terminal, pasted with a mouse into a window, or
read from a file. The mechanism does not matter. This representation of
expressions by characters is called the <E>external representation</E> of the
expression. Every expression has at least one external representation
that can be entered to get exactly this expression.
<P/>
The input, i.e., the external representation, is transformed in a process
called <E>reading</E> to an internal representation.  At this point the input
is analyzed and inputs  that are not legal external representations,
according to the rules given below, are rejected as errors. Those rules
are usually called the <E>syntax</E> of a programming language.
<P/>
The internal representation created by reading is called either an
<E>expression</E> or a <E>statement</E>.
Later we will distinguish between those two terms.
However for now we will use them interchangeably.
The exact form of the internal representation does not matter.
It could be a string of characters equal to the external representation,
in which case the reading would only need to check for errors.
It could be a series of machine instructions for the processor on which
&GAP; is running, in which case the reading would more appropriately
be called compilation.
It is in fact a tree-like structure.
<P/>
After the input has been read it is again transformed in a process called
<E>evaluation</E> or <E>execution</E>.
Later we will distinguish between those two terms too,
but for the moment we will use them interchangeably. The name
hints at the nature of this process, it replaces an expression with the
value of the expression. This works recursively, i.e., to evaluate an
expression first the subexpressions are evaluated and then the value of
the expression is computed from those values according to rules given below.
Those rules are usually called the <E>semantics</E> of a programming language.
<P/>
The result of the evaluation is, not surprisingly, called a <E>value</E>.
<!-- % The -->
<!-- % set of values  is of course a  much smaller set than the  set of -->
<!-- % expressions; for every value there may be several expressions that will -->
<!-- % evaluate to  this value. -->
Again the form in which such a  value is
represented internally does not  matter. It is  in fact a tree-like
structure again.
<P/>
The last process is called <E>printing</E>. It takes the value produced by
the evaluation and creates an external representation, i.e., a string of
characters again. What you do with this external representation is up to
you. You can look at it, paste it with the mouse into another window, or
write it to a file.
<P/>
Lets look at an example to make this more clear. Suppose you type in the
following string of 8 characters
<P/>
<Listing><![CDATA[
1 + 2 * 3;
]]></Listing>
<P/>
&GAP; takes  this external representation  and creates  a tree-like
internal representation, which we can picture as follows
<P/>
<Listing><![CDATA[
  +
 / \
1   *
   / \
  2   3
]]></Listing>
<P/>
This expression is then evaluated. To do this &GAP; first evaluates the
right subexpression <C>2*3</C>.  Again, to do this &GAP; first evaluates its
subexpressions 2 and 3. However they are so simple that they are their
own value, we say that they are self-evaluating. After this has been
done, the rule for <C>*</C> tells us that the value is the product of the
values of the two subexpressions, which in this case is clearly 6.
Combining this with the value of the left operand of the <C>+</C>, which is
self-evaluating, too, gives us the value of the whole expression 7. This
is then printed, i.e., converted into the external representation
consisting of the single character <C>7</C>.
<P/>
In this fashion we can predict the result of every input when we know the
syntactic rules that govern the process of reading and the semantic rules
that tell us for every expression how its value is computed in terms of
the values of the subexpressions.
The syntactic rules are given in sections <Ref Sect="Lexical Structure"/>,
<Ref Sect="Symbols"/>, <Ref Sect="Whitespaces"/>, <Ref Sect="Keywords"/>,
<!-- <Ref Sect="Identifiers"/>, and <Ref Sect="The Syntax in BNF"/>, -->
and <Ref Sect="Identifiers"/>,
the semantic rules are given in sections <Ref Sect="Expressions"/>,
<Ref Sect="Variables"/>, <Ref Sect="Function Calls"/>,
<Ref Sect="Comparisons"/>, <Ref Sect="Arithmetic Operators"/>,
<Ref Sect="Statements"/>, <Ref Sect="Assignments"/>,
<Ref Sect="Procedure Calls"/>, <Ref Sect="If"/>, <Ref Sect="While"/>,
<Ref Sect="Repeat"/>, <Ref Sect="For"/>, <Ref Sect="Function"/>,
and the chapters describing the individual data types.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Lexical Structure">
<Heading>Lexical Structure</Heading>

Most input of &GAP; consists of sequences of the following characters.
<P/>
Digits, uppercase and lowercase letters, <B>Space</B>, <B>Tab</B>,
<B>Newline</B>, <B>Return</B> and the special characters
<P/>
<Listing><![CDATA[
"    `    (    )    *    +    ,    -    #
.    /    :    ;    <    =    >    ~    
[    \    ]    ^    _    {    }    ! 
]]></Listing>
<P/>
It is possible to use other characters in identifiers by escaping
them with backslashes, but we do not recommend to use this feature.
Inside strings
(see section&nbsp;<Ref Sect="Symbols"/> and
chapter&nbsp;<Ref Chap="Strings and Characters"/>)
and comments (see&nbsp;<Ref Sect="Whitespaces"/>) the full character set
supported by the computer is allowed.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Symbols">
<Heading>Symbols</Heading>

The process of reading, i.e., of assembling the input into expressions,
has a subprocess, called <E>scanning</E>, that assembles the characters into
symbols.  A <E>symbol</E> is a sequence of characters that form a lexical
unit. The set of symbols consists of keywords, identifiers, strings,
integers, and operator and delimiter symbols.
<P/>
A <E>keyword</E> is a reserved word (see <Ref Sect="Keywords"/>).
An <E>identifier</E> is a sequence of letters, digits and underscores
(or other characters escaped by backslashes) that contains at least one
non-digit and is not a keyword (see <Ref Sect="Identifiers"/>).
An integer is a sequence of digits (see <Ref Chap="Integers"/>),
possibly prepended by <C>-</C> and <C>+</C> sign characters.
A <E>string</E> is a sequence of arbitrary characters enclosed in
double quotes (see <Ref Chap="Strings and Characters"/>).
<P/>
Operator and delimiter symbols are
<P/>
<Listing><![CDATA[
+    -    *    /    ^    ~   !.
=    <>   <    <=   >    >=  ![
:=   .    ..   ->   ,    ;   !{
[    ]    {    }    (    )    :
]]></Listing>
<P/>
Note also that during the process of scanning all whitespace is removed
(see <Ref Sect="Whitespaces"/>).

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Whitespaces">
<Heading>Whitespaces</Heading>

<Index>space</Index>
<Index>blank</Index><Index>tabulator</Index><Index>newline</Index>
<Index>comments</Index>
The characters <B>Space</B>, <B>Tab</B>, <B>Newline</B>, and <B>Return</B>
are called <E>whitespace characters</E>.
Whitespace is used as necessary to separate lexical symbols,
such as integers, identifiers, or keywords. For example
<C>Thorondor</C> is a single identifier,
while <C>Th or ondor</C> is the keyword <K>or</K> between the two identifiers
<C>Th</C> and <C>ondor</C>.
Whitespace may occur between any two symbols, but not within a symbol.
Two or more adjacent whitespace characters are equivalent to a single
whitespace.
Apart from the role as separator of symbols,
whitespace characters are otherwise insignificant.
Whitespace characters may also occur inside a string,
where they are significant.
Whitespace characters should also be used freely for improved readability.
<P/>
A <E>comment</E> starts with the  character <C>#</C>,
which is sometimes called sharp or hatch,
and continues to the end of the line on which the comment character appears.
The whole comment, including <C>#</C> and the <B>Newline</B> character
is treated as a single whitespace.
Inside a string, the comment character <C>#</C> loses its role and is just
an ordinary character.
<P/>
For example, the following statement
<P/>
<Listing><![CDATA[
if i<0 then a:=-i;else a:=i;fi;
]]></Listing>
<P/>
is equivalent to
<P/>
<Listing><![CDATA[
if i < 0 then   # if i is negative
  a := -i;      #   take its additive inverse
else            # otherwise
  a := i;       #   take itself
fi;
]]></Listing>
<P/>
(which by the way shows that it is possible to write superfluous
comments). However the first statement is <E>not</E> equivalent to
<P/>
<Listing><![CDATA[
ifi<0thena:=-i;elsea:=i;fi;
]]></Listing>
<P/>
since the keyword <K>if</K> must be separated from the identifier <C>i</C>
by a whitespace, and similarly <K>then</K> and <C>a</C>,
and <K>else</K> and <C>a</C> must be separated.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Keywords">
<Heading>Keywords</Heading>

<Index Key="GAPInfo.Keywords"><C>GAPInfo.Keywords</C></Index>

<E>Keywords</E> are reserved words that are used to denote special operations
or are part of statements. They must not be used as identifiers. The list of
keywords is contained in the <C>GAPInfo.Keywords</C> component of the
<C>GAPInfo</C> record (see <Ref Sect="GAPInfo"/>). We will show how to print
it in a nice table, demonstrating at the same time some list manipulation
techniques:
<P/>
<Example><![CDATA[
gap> keys:=SortedList( GAPInfo.Keywords );; l:=Length( keys );;
gap> arr:= List( [ 0 .. Int( l/4 )-1 ], i-> keys{ 4*i + [ 1 .. 4 ] } );;
gap> if l mod 4 <> 0 then Add( arr, keys{[ 4*Int(l/4) + 1 .. l ]} ); fi;
gap> Length( keys ); PrintArray( arr );
35
[ [         Assert,           Info,        IsBound,           QUIT ],
  [  TryNextMethod,         Unbind,            and,         atomic ],
  [          break,       continue,             do,           elif ],
  [           else,            end,          false,             fi ],
  [            for,       function,             if,             in ],
  [          local,            mod,            not,             od ],
  [             or,           quit,       readonly,      readwrite ],
  [            rec,         repeat,         return,           then ],
  [           true,          until,          while ] ]
]]></Example>
<P/>
Note that (almost) all keywords are written in lowercase and that they
are case sensitive.
For example <K>else</K> is a keyword; <C>Else</C>, <C>eLsE</C>, <C>ELSE</C>
and so forth are ordinary identifiers.
Keywords must not contain whitespace, for example <C>el if</C> is not the
same as <K>elif</K>.
<P/>
<E>Note</E>: 
Several tokens from the list of keywords above may appear to be normal 
identifiers representing functions or literals of various kinds but are 
actually implemented as keywords for technical reasons. The only 
consequence of this is that those identifiers cannot be re-assigned, and 
do not actually have function objects bound to them, which could be 
assigned to other variables or passed to functions. These keywords are
<K>true</K>, <K>false</K>, <Ref Func="Assert"/>, 
<Ref Func="IsBound" Label="for a global variable"/>,
<Ref Func="Unbind" Label="unbind a variable"/>, 
<Ref Func="Info"/> and <Ref Func="TryNextMethod"/>.
<P/>
Keywords <C>atomic</C>, <C>readonly</C>, <C>readwrite</C> are not used
at the moment. They are reserved for the future version of GAP to prevent
their accidental use as identifiers.
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Identifiers">
<Heading>Identifiers</Heading>

An <E>identifier</E> is used to refer to a variable
(see <Ref Sect="Variables"/>).
An identifier usually consists of letters, digits, underscores <C>_</C>,
and <Q>at</Q>-characters <C>@</C>,
and must contain at least one non-digit.
An identifier is terminated by the first character not in this class.
Note that the <Q>at</Q>-character <C>@</C> is used to implement
namespaces, see Section <Ref Sect="Namespaces"/> for details.
<P/>
Examples of valid identifiers are
<P/>
<Listing><![CDATA[
a           foo         aLongIdentifier
hello       Hello       HELLO
x100        100x       _100
some_people_prefer_underscores_to_separate_words
WePreferMixedCaseToSeparateWords
abc@def
]]></Listing>
<P/>
Note that case is significant, so the three identifiers in the second
line are distinguished.
<P/>
The backslash <C>\</C> can be used to include other characters in identifiers;
a backslash followed by a character is equivalent  to the character,
except that this escape sequence is considered to be an ordinary letter.
For example
<Listing><![CDATA[
G\(2\,5\)
]]></Listing>
is an identifier, not a call to a function <C>G</C>.
<P/>
An identifier that starts with a backslash is never a keyword, so for
example <C>\*</C> and <C>\mod</C> are identifiers.
<P/>
The length of identifiers is not limited,
however only the first <M>1023</M> characters are significant.
The escape sequence <C>\</C><B>newline</B> is ignored,
making it possible to split long identifiers over multiple lines.

<ManSection>
<Func Name="IsValidIdentifier" Arg='str'/>

<Description>
returns <K>true</K>  if  the  string  <A>str</A>  would  form  a  valid  identifier
consisting of letters,  digits  and  underscores;  otherwise  it  returns
<K>false</K>. It does not check whether <A>str</A> contains characters escaped by a
backslash <C>\</C>.
</Description>
</ManSection>


Note that the <Q>at</Q>-character is used to implement namespaces
for global variables in packages. See <Ref Sect="Namespaces"/> for
details.
<Index>namespace</Index>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Expressions">
<Heading>Expressions</Heading>

<Index>evaluation</Index>
An <E>expression</E> is a construct that evaluates to a value.
Syntactic constructs that are executed to produce a side effect and return
no value are called <E>statements</E> (see <Ref Sect="Statements"/>).
Expressions appear as right hand sides of assignments
(see <Ref Sect="Assignments"/>), as actual arguments in function calls
(see <Ref Sect="Function Calls"/>), and in statements.
<P/>
Note that an expression is not the same as a value.
For example <C>1 + 11</C> is an expression, whose value is the integer 12.
The external representation of this integer is the character sequence
<C>12</C>, i.e., this sequence is output if the integer is printed.
This sequence is another expression whose value is the integer <M>12</M>.
The process of finding the value of an expression is done by the interpreter
and is called the <E>evaluation</E> of the expression.
<P/>
Variables, function calls, and integer, permutation, string, function, list,
and record literals
(see <Ref Sect="Variables"/>, <Ref Sect="Function Calls"/>,
<Ref Chap="Integers"/>, <Ref Chap="Permutations"/>,
<Ref Chap="Strings and Characters"/>, <Ref Sect="Function"/>,
<Ref Chap="Lists"/>, <Ref Chap="Records"/>),
are the simplest cases of expressions.
<P/>
Expressions, for example the simple expressions mentioned above, can be
combined with the operators to form more complex expressions. Of course
those expressions can then be combined further with the operators to form
even more complex expressions. The <E>operators</E> fall into three classes.
<Index>operators</Index>
The <E>comparisons</E> are <C>=</C>, <C>&lt;></C>, <C>&lt;</C>, <C>&lt;=</C>,
<C>></C>, <C>>=</C>, and <K>in</K> (see <Ref Sect="Comparisons"/> and
<Ref Sect="Membership Test for Collections"/>).
The <E>arithmetic operators</E> are <C>+</C>, <C>-</C>, <C>*</C>, <C>/</C>,
<K>mod</K>, and <C>^</C> (see&nbsp;<Ref Sect="Arithmetic Operators"/>).
The <E>logical operators</E> are <K>not</K>, <K>and</K>, and <K>or</K>
(see&nbsp;<Ref Sect="Operations for Booleans"/>).
<P/>
The following example shows a very simple expression with value 4 and a
more complex expression.
<P/>
<Example><![CDATA[
gap> 2 * 2;
4
gap> 2 * 2 + 9 = Fibonacci(7) and Fibonacci(13) in Primes;
true
]]></Example>
<P/>
For the precedence of operators, see&nbsp;<Ref Sect="Comparisons"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Variables">
<Heading>Variables</Heading>

<Index>scope</Index><Index>bound</Index>
A <E>variable</E> is a location in a &GAP; program that points to a value.
We say the variable is <E>bound</E> to this value.
If a variable is evaluated it evaluates to this value.
<P/>
Initially an ordinary variable is not bound to any value.
The variable can be bound to a value by <E>assigning</E> this value to the
variable (see <Ref Sect="Assignments"/>).
Because of this we sometimes say that a variable that is not bound to any
value has no assigned value.
Assignment is in fact the only way by which a variable, which is not an
argument of a function, can be bound to a value.
After a variable has been bound to a  value an assignment can also be used
to bind the variable to another value.
<P/>
A special class of variables is the class of <E>arguments</E> of functions.
They behave similarly to other variables,
except they are bound to the value of the
actual arguments upon a function call (see <Ref Sect="Function Calls"/>).
<P/>
Each variable has a name that is also called its <E>identifier</E>. This is
because in a given scope an identifier identifies a unique variable (see
<Ref Sect="Identifiers"/>).
A <E>scope</E> is a lexical part of a program text. There is
the <E>global scope</E> that encloses the entire program text, and there are
local scopes that range from the <K>function</K> keyword, denoting the
beginning of a function definition, to the corresponding <K>end</K> keyword.
A <E>local scope</E> introduces new variables, whose identifiers are given in
the formal argument list and the <K>local</K> declaration of the function (see
<Ref Sect="Function"/>). Usage of an identifier in a program text refers to the
variable in the innermost scope that has this identifier as its name.
Because this mapping from identifiers to variables is done when the
program is read, not when it is executed, &GAP; is said to have <E>lexical
scoping</E>.  The following example shows how one identifier refers to
different variables at different points in the program text.
<P/>
<Listing><![CDATA[
g := 0;      # global variable g
x := function ( a, b, c )
  local  y;
  g := c;     # c refers to argument c of function x
  y := function ( y )
    local d, e, f;
    d := y;   # y refers to argument y of function y
    e := b;   # b refers to argument b of function x
    f := g;   # g refers to global variable g
    return d + e + f;
  end;
  return y( a ); # y refers to local y of function x
end;
]]></Listing>
<P/>
It is important to note that the concept of a variable in &GAP; is quite
different from the concept of a variable in most compiled programming languages.
<P/>
In those languages a variable denotes a block of memory. The
value of the variable is stored in this block. So in those languages two
variables can have the same value, but they can never have identical
values, because they denote different blocks of memory.  Note that
some languages have the concept of a reference argument. It seems as if such an
argument and the variable used in the actual function call have the same
value, since changing the argument's value also changes the value of the
variable used in the actual function call.  But this is not so; the
reference argument is actually a pointer to the variable used in the
actual function call, and it is the compiler that inserts enough magic to
make the pointer invisible.  In order for this to work the compiler
needs enough information to compute the amount of memory needed for each
variable in a program, which is readily available in the declarations.
<P/>
In &GAP; on the other hand each variable just points to a value,
and different variables can share the same value.


<ManSection>
<Func Name="IsBound" Arg='ident' Label="for a global variable"/>

<Description>
<Ref Func="IsBound" Label="for a global variable"/> returns <K>true</K>
if the variable <A>ident</A> points to a value,
and <K>false</K> otherwise.
<P/>
For records and lists <Ref Func="IsBound" Label="for a global variable"/>
can be used to check whether components or entries, respectively,
are bound
(see Chapters&nbsp;<Ref Chap="Records"/> and <Ref Chap="Lists"/>).
</Description>
</ManSection>


<ManSection>
<Func Name="Unbind" Arg='ident' Label="unbind a variable"/>

<Description>
deletes the identifier <A>ident</A>.
If there is no other variable pointing to the same value as <A>ident</A> was,
this value will be removed by the next garbage collection.
Therefore <Ref Func="Unbind" Label="unbind a variable"/> can be used to get
rid of unwanted large objects.
<P/>
For records and lists <Ref Func="Unbind" Label="unbind a variable"/>
can be used to delete components or entries, respectively
(see Chapters&nbsp;<Ref Chap="Records"/> and <Ref Chap="Lists"/>).
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="More About Global Variables">
<Heading>More About Global Variables</Heading>

The vast majority of variables in &GAP; are defined at the outer
level (the global scope). They are used to access functions and
other objects created either in the &GAP; library or packages or in the user's
code. 
<P/>
Note that for packages there is a mechanism to implement package local
namespaces on top of this global namespace. See Section <Ref
Sect="Namespaces"/> for details.
<Index>namespace</Index>
<P/>
Certain special facilities are provided for manipulating global
variables which are not available for other types of variable (such as 
local variables or function arguments).
<P/>
First, such variables may be marked <E>read-only</E>. In which case
attempts to change them will fail. Most of the global variables
defined in the &GAP; library are so marked.
<P/>
Second, a group of functions are supplied for accessing and altering the
values assigned to global variables. Use of these functions differs
from the use of assignment,
<Ref Func="Unbind" Label="unbind a variable"/> and
<Ref Func="IsBound" Label="for a global variable"/>
statements, in two ways.
First, these functions always affect global variables, even if 
local variables of the same names exist.
Second, the variable names are passed as strings,
rather than being written directly into the statements. 
<P/>
Note that the functions <Ref Func="NamesGVars"/>,
<Ref Func="NamesSystemGVars"/>, <Ref Func="NamesUserGVars"/>,
and <Ref Func="TemporaryGlobalVarName"/>
deal with the <E>global namespace</E>.


<ManSection>
<Func Name="IsReadOnlyGlobal" Arg='name'/>

<Description>
returns <K>true</K> if the global variable named by the string <A>name</A> is 
read-only and <K>false</K> otherwise (the default). 
</Description>
</ManSection>


<ManSection>
<Func Name="MakeReadOnlyGlobal" Arg='name'/>

<Description>
marks the global variable named by the string <A>name</A> as read-only. 
<P/>
A warning is given if <A>name</A> has no value bound to it or if it is
already read-only.
</Description>
</ManSection>


<ManSection>
<Func Name="MakeReadWriteGlobal" Arg='name'/>

<Description>
marks the global variable named by the string <A>name</A> as read-write.
<P/>
A warning is given if <A>name</A> is already read-write.
<P/>
<Log><![CDATA[
gap> xx := 17;
17
gap> IsReadOnlyGlobal("xx");
false
gap> xx := 15;
15
gap> MakeReadOnlyGlobal("xx");
gap> xx := 16;
Variable: 'xx' is read only
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' after making it writable to continue
brk> quit;
gap> IsReadOnlyGlobal("xx");
true
gap> MakeReadWriteGlobal("xx");
gap> xx := 16;
16
gap> IsReadOnlyGlobal("xx");
false
]]></Log>
</Description>
</ManSection>


<ManSection>
<Func Name="ValueGlobal" Arg='name'/>

<Description>
returns the value currently bound to the global variable named by the 
string <A>name</A>. An error is raised if no value is currently bound.
</Description>
</ManSection>


<ManSection>
<Func Name="IsBoundGlobal" Arg='name'/>

<Description>
returns <K>true</K> if a value currently bound
to the global variable named by the string <A>name</A> and <K>false</K> otherwise.
</Description>
</ManSection>


<ManSection>
<Func Name="UnbindGlobal" Arg='name'/>

<Description>
removes any value currently bound
to the global variable named by the string <A>name</A>. Nothing is returned.
<P/>
A warning is given if <A>name</A> was not bound. The global variable named
by <A>name</A> must be writable, otherwise an error is raised.
</Description>
</ManSection>


<ManSection>
<Func Name="BindGlobal" Arg='name, val'/>

<Description>
sets the global variable named by the string <A>name</A> to the value
<A>val</A>, provided it is writable, and makes it read-only.
If <A>name</A> already had a value, a warning message is printed.
<P/>
This is intended to be the normal way to create and set <Q>official</Q>
global variables (such as operations and filters).
<P/>
Caution should be exercised in using these functions, especially
<Ref Func="BindGlobal"/> and <Ref Func="UnbindGlobal"/>
as unexpected changes
in global variables can be very confusing for the user.
<P/>
<Example><![CDATA[
gap> xx := 16;
16
gap> IsReadOnlyGlobal("xx");
false
gap> ValueGlobal("xx");
16
gap> IsBoundGlobal("xx");
true
gap> BindGlobal("xx",17);
#W BIND_GLOBAL: variable `xx' already has a value
gap> xx;
17
gap> IsReadOnlyGlobal("xx");
true
gap> MakeReadWriteGlobal("xx");
gap> Unbind(xx);
]]></Example>
</Description>
</ManSection>



<ManSection>
<Func Name="NamesGVars" Arg=''/>

<Description>
This function returns an immutable
(see&nbsp;<Ref Sect="Mutability and Copyability"/>)
sorted (see&nbsp;<Ref Sect="Sorted Lists and Sets"/>) list of all the global
variable names known to the system.  This includes names of variables
which were bound but have now been unbound and some other names which
have never been bound but have become known to the system by various
routes.
</Description>
</ManSection>


<ManSection>
<Func Name="NamesSystemGVars" Arg=''/>

<Description>
This function returns an immutable sorted list of all the global
variable names created by the &GAP; library when &GAP; was started.
</Description>
</ManSection>


<ManSection>
<Func Name="NamesUserGVars" Arg=''/>

<Description>
This function returns an immutable sorted list of the global variable
names created since the library was read, to which a value is
currently bound.
</Description>
</ManSection>


<ManSection>
<Func Name="TemporaryGlobalVarName" Arg='[prefix]'/>

<Description>
returns a string  that can be used
as the  name  of a global  variable  that is not bound   at the time when
<Ref Func="TemporaryGlobalVarName"/> is called.
The optional argument <A>prefix</A> can
specify a string with which the name of the global variable starts.
</Description>
</ManSection>

<!-- here name spaces -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Namespaces">
<Heading>Namespaces for &GAP; packages</Heading>

As mentioned in Section <Ref Sect="More About Global Variables"/>
above all global variables share a common namespace. This can
relatively easily lead to name clashes, in particular when many
&GAP; packages are loaded at the same time. To give package code
a way to have a package local namespace without breaking backward
compatibility of the &GAP; language, the following simple rule has
been devised:
<P/>
If in package code a global variable that ends with an
<Q>at</Q>-character <C>@</C> is accessed in any way, the name of the
package is appended before accessing it. Here, <Q>package code</Q>
refers to everything which is read with <Ref Func="ReadPackage"/>.
As the name of the package the entry <C>PackageName</C> in its 
<F>PackageInfo.g</F> file is taken. As for all identifiers,
this name is case sensitive.
<P/>
For example, if the following is done in the code of a package with name
<C>xYz</C>:

<Log><![CDATA[
gap> a@ := 12;
]]>
</Log>

Then actually the global variable <C>a@xYz</C> is assigned. Further
accesses to <C>a@</C> within the package code will all be redirected
to <C>a@xYz</C>. This includes all the functions described in Section
<Ref Sect="More About Global Variables"/> and indeed all the functions
described Section <Ref Sect="Global Variables in the Library"/> like
for example <Ref Func="DeclareCategory"/>. Note that from code in the
same package it is still possible to access the same global variable
via <C>a@xYz</C> explicitly.
<P/>
All other code outside the package as well as interactive user input
that wants to refer to that variable <C>a@xYz</C> must do so explicitly
by using <C>a@xYz</C>.
<P/>
Since in earlier releases of &GAP; the <Q>at</Q>-character <C>@</C>
was not a legal character (without using backslashes), this small
extension of the language does not break any old code.

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Function Calls">
<Heading>Function Calls</Heading>

<Subsection Label="Function Call With Arguments">
<Heading>Function Call With Arguments</Heading>

<C><A>function-var</A>( [<A>arg-expr</A>[, <A>arg-expr</A>, ...]] )</C>
<P/>
The function call has the effect of calling the function <A>function-var</A>.
The precise semantics are as follows.
<P/>
First &GAP; evaluates the <A>function-var</A>.
Usually <A>function-var</A> is a variable,
and &GAP; does nothing more than taking the value of this variable.
It is allowed though that <A>function-var</A> is a more complex expression,
such as a reference to an element of a list
(see Chapter&nbsp;<Ref Chap="Lists"/>)
<C><A>list-var</A>[<A>int-expr</A>]</C>,
or to a component of a record (see Chapter&nbsp;<Ref Chap="Records"/>)
<C><A>record-var</A>.<A>ident</A></C>.
In any case &GAP; tests whether the value is a function.
If it is not, &GAP; signals an error.
<P/>
<Index Subkey="with a variable number of arguments, calling">functions</Index>
<Index Key="arg" Subkey="special function argument, calling with"><C>arg</C></Index>
Next &GAP; checks that the number of actual arguments <A>arg-expr</A>s agrees
with the number of <E>formal arguments</E> as given in the function definition.
If they do not agree &GAP; signals an error.
An exception is the case when the function has a variable length argument list,
which is denoted by adding <C>...</C> after the final argument.
In this case there must be at least as many
actual arguments as there are formal arguments <E>before the
final argument</E> and can be any larger number
(see&nbsp;<Ref Sect="Function"/> for examples).
<P/>
Now &GAP; allocates for each formal argument and for each <E>formal local</E>
(that is, the identifiers in the <K>local</K> declaration) a new variable.
Remember that a variable is a location in a &GAP; program
that points to a value. Thus for  each formal argument and for each
formal local such a location is allocated.
<P/>
Next the arguments <A>arg-expr</A>s are evaluated, and the values are assigned
to the newly created variables corresponding to the formal arguments. Of
course the first value is assigned to the new variable corresponding to
the first formal argument, the second  value  is assigned to the new
variable corresponding  to  the second  formal argument, and  so on.
However, &GAP; does not make any guarantee about the order in which the
arguments are evaluated. They might be evaluated left to right, right to
left, or in any other order, but each argument is evaluated once. An
exception again occurs if the last formal argument has
the name <C>arg</C>. In this case the values of all the actual
arguments not assigned to the other formal parameters are
stored in  a list and this  list is assigned to the  new variable
corresponding to the formal argument <C>arg</C>.
<P/>
The new variables corresponding to the formal locals are initially not
bound to any  value.  So trying  to evaluate those  variables before
something has been assigned to them will signal an error.
<P/>
Now the body of the function, which is a statement, is executed. If the
identifier of one of the formal arguments or formal locals appears in the
body of the function it refers to the new variable that was allocated for
this formal argument or formal local, and evaluates to the value of this
variable.
<P/>
If during the execution of the body of the function a <K>return</K> statement
with an expression (see <Ref Sect="Return (With or without Value)"/>)
is executed, execution of the body is
terminated and the value of the function call is the value of the
expression of the <K>return</K>. If during the execution of the body a
<K>return</K> statement without an expression is executed, execution of the
body is terminated and the function call does not produce a value, in
which case we call this call a procedure call (see <Ref Sect="Procedure Calls"/>).
If the execution of the body completes without execution of a <K>return</K>
statement, the function call again produces no value, and again we talk
about a procedure call.
<P/>
<Example><![CDATA[
gap> Fibonacci( 11 );
89
]]></Example>
<P/>
The above example shows a call to the function <Ref Func="Fibonacci"/> with
actual argument <C>11</C>, the following one shows a call to the operation
<Ref Func="RightCosets"/> where the second actual argument is another
function call.
<P/>
<Log><![CDATA[
gap> RightCosets( G, Intersection( U, V ) );;
]]></Log>

</Subsection>


<Subsection Label="Function Call With Options">
<Heading>Function Call With Options</Heading>

<C><A>function-var</A>( <A>arg-expr</A>[, <A>arg-expr</A>, ...][ : [ <A>option-expr</A> [,<A>option-expr</A>, ....]]])</C>
<P/>
As well as passing arguments to a function, providing the mathematical 
input to its calculation, it is sometimes useful to supply <Q>hints</Q>
suggesting to &GAP; how the desired result may be computed more
quickly, or specifying a level of tolerance for random errors in a
Monte Carlo algorithm.
<P/>
Such hints may be supplied to a function-call <E>and to all subsidiary
functions called from that call</E> using the options mechanism. Options
are separated from the actual arguments by a colon <C>:</C> and have much
the same syntax as the components of a record expression. The one
exception to this is that a component name may appear without a value,
in which case the value <K>true</K> is silently inserted.
<P/>
The following example shows a call to <Ref Func="Size"/> passing the options
<C>hard</C> (with the value <K>true</K>)
and <C>tcselection</C> (with the string <C>"external"</C> as value).
<P/>
<Log><![CDATA[
gap> Size( fpgrp : hard, tcselection := "external" );
]]></Log>
<P/>
Options supplied with function calls in this way are passed down using 
the global options stack described in chapter <Ref Chap="Options Stack"/>,
so that the call above is exactly equivalent to
<P/>
<Log><![CDATA[
gap> PushOptions( rec( hard := true, tcselection := "external") );
gap> Size( fpgrp );
gap> PopOptions( );
]]></Log>
<P/>
<E>Note</E> that any option may be passed with any function, whether or not 
it has any actual meaning for that function, or any function called by 
it. The system provides no safeguard against misspelled option names.

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons">
<Heading>Comparisons</Heading>

<Index>equality test</Index>
<C><A>left-expr</A> = <A>right-expr</A></C>
<P/>
<Index>inequality test</Index>
<C><A>left-expr</A> &lt;> <A>right-expr</A></C>
<P/>
The operator <C>=</C> tests for equality of its two operands and evaluates to
<K>true</K> if they are equal and to <K>false</K> otherwise.
Likewise <C>&lt;></C> tests for inequality of its two operands.
For each type of objects the definition of equality is given in the
respective chapter.
Objects in different families (see&nbsp;<Ref Sect="Families"/>) are never equal,
i.e., <C>=</C> evaluates in this case to <K>false</K>, and <C>&lt;></C> evaluates to <K>true</K>.
<P/>
<Index>smaller test</Index>
<C><A>left-expr</A> &lt; <A>right-expr</A></C>
<P/>
<Index>larger test</Index>
<C><A>left-expr</A> >  <A>right-expr</A></C>
<P/>
<Index>smaller or equal</Index>
<C><A>left-expr</A> &lt;= <A>right-expr</A></C>
<P/>
<Index>larger or equal</Index>
<C><A>left-expr</A> >= <A>right-expr</A></C>
<P/>
<C>&lt;</C> denotes less than, <C>&lt;=</C> less than or equal, <C>></C> greater than, and
<C>>=</C> greater than or equal of its two operands.
For each kind of objects the definition of the ordering is given in the
respective chapter.
<P/>
Note that <C>&lt;</C> implements a <E>total ordering</E> of objects (which
can be used for example to sort a list of elements). Therefore in general
<C>&lt;</C> will not be compatible with any inclusion relation (which can be
tested using <Ref Func="IsSubset"/>). (For
example, it is possible to compare permutation groups with <C>&lt;</C> in a
total ordering of all permutation groups, but this ordering is not
compatible with the relation of being a subgroup.)
<P/>
Only for the following kinds of objects, an ordering via <C>&lt;</C> of objects
in <E>different</E> families (see&nbsp;<Ref Sect="Families"/>) is supported.
Rationals (see&nbsp;<Ref Func="IsRat"/>) are smallest,
next are cyclotomics (see&nbsp;<Ref Func="IsCyclotomic"/>),
followed by finite field elements (see&nbsp;<Ref Func="IsFFE"/>);
finite field elements in different characteristics are compared
via their characteristics,
next are permutations (see&nbsp;<Ref Func="IsPerm"/>),
followed by the boolean values <K>true</K>, <K>false</K>, and <K>fail</K>
(see&nbsp;<Ref Func="IsBool"/>),
characters (such as <C>{</C>}a{'}', see&nbsp;<Ref Func="IsChar"/>),
and lists (see&nbsp;<Ref Func="IsList"/>) are largest;
note that two lists can be compared with <C>&lt;</C> if and only if their
elements are again objects that can be compared with <C>&lt;</C>.
<P/>
For other objects, &GAP; does <E>not</E> provide an ordering via <C>&lt;</C>.
The reason for this is that a total ordering of all &GAP; objects
would be hard to maintain when new kinds of objects are introduced,
and such a total ordering is hardly used in its full generality.
<P/>
However, for objects in the filters listed above, the ordering via <C>&lt;</C>
has turned out to be useful.
For example, one can form <E>sorted lists</E> containing integers and nested
lists of integers, and then search in them using <C>PositionSorted</C>
(see&nbsp;<Ref Sect="Finding Positions in Lists"/>).
<P/>
Of course it would in principle be possible to define an ordering
via <C>&lt;</C> also for certain other objects,
by installing appropriate methods for the operation <C>\&lt;</C>.
But this may lead to problems at least as soon as one loads &GAP; code
in which the same is done, under the assumption that one is completely
free to define an ordering via <C>&lt;</C> for other objects than the ones
for which the <Q>official</Q> &GAP; provides already an ordering via <C>&lt;</C>.

<P/>
Comparison operators, including the operator <K>in</K>
(see&nbsp;<Ref Sect="Membership Test for Lists"/>),
are not associative,
Hence it is not allowed to write <C><A>a</A> = <A>b</A> &lt;> <A>c</A> = <A>d</A></C>,
you must use <C>(<A>a</A> = <A>b</A>) &lt;> (<A>c</A> = <A>d</A>)</C> instead.
The comparison operators have  higher precedence than the logical operators
<Index Subkey="precedence">operators</Index>
(see&nbsp;<Ref Sect="Operations for Booleans"/>), but lower precedence than the arithmetic
operators (see&nbsp;<Ref Sect="Arithmetic Operators"/>).
Thus, for instance, <C><A>a</A> * <A>b</A> = <A>c</A> and <A>d</A></C> is interpreted as
<C>((<A>a</A> * <A>b</A>) = <A>c</A>) and <A>d</A>)</C>.
<P/>
The following example shows a comparison where the left operand is an
expression.
<P/>
<Example><![CDATA[
gap> 2 * 2 + 9 = Fibonacci(7);
true
]]></Example>
<P/>
For the underlying operations of the operators introduced above,
see&nbsp;<Ref Sect="Comparison Operations for Elements"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Operators">
<Heading>Arithmetic Operators</Heading>

<Index>precedence</Index>
<Index>associativity</Index>
<Index Subkey="arithmetic">operators</Index>
<Index Key="+"><C>+</C></Index>
<Index Key="-"><C>-</C></Index>
<Index Key="*"><C>*</C></Index>
<Index Key="/"><C>/</C></Index>
<Index Key="^"><C>^</C></Index>
<Index Key="mod" Subkey="arithmetic operators"><K>mod</K></Index>
<Index>modulo</Index>
<Index Subkey="arithmetic operators">modulo</Index>
<Index>positive number</Index>
<C>+ <A>right-expr</A></C>
<P/>
<Index>negative number</Index>
<C>- <A>right-expr</A></C>
<P/>
<Index>addition</Index>
<C><A>left-expr</A> + <A>right-expr</A></C>
<P/>
<Index>subtraction</Index>
<C><A>left-expr</A> - <A>right-expr</A></C>
<P/>
<Index>multiplication</Index>
<C><A>left-expr</A> * <A>right-expr</A></C>
<P/>
<Index>division</Index>
<C><A>left-expr</A> / <A>right-expr</A></C>
<P/>
<Index Key="mod"><K>mod</K></Index>
<C><A>left-expr</A> mod <A>right-expr</A></C>
<P/>
<Index>power</Index>
<C><A>left-expr</A> ^ <A>right-expr</A></C>
<P/>
The arithmetic operators are <C>+</C>, <C>-</C>, <C>*</C>, <C>/</C>,
<K>mod</K>, and <C>^</C>.
The meanings (semantics) of those operators generally depend on the types
of the operands involved,
and they are defined in the various chapters describing the types.
However basically the meanings are as follows.
<P/>
<C><A>a</A> + <A>b</A></C> denotes the addition of additive elements <A>a</A> and <A>b</A>.
<P/>
<C><A>a</A> - <A>b</A></C> denotes the addition of <A>a</A> and the additive inverse of <A>b</A>.
<P/>
<C><A>a</A> * <A>b</A></C> denotes the multiplication of multiplicative elements <A>a</A> and
<A>b</A>.
<P/>
<C><A>a</A> / <A>b</A></C> denotes the multiplication of <A>a</A> with the multiplicative
inverse of <A>b</A>.
<P/>
<Index Subkey="rationals">mod</Index>
<C><A>a</A> mod <A>b</A></C>, for integer or rational left operand <A>a</A> and for non-zero
integer right operand <A>b</A>, is defined as follows.
If <A>a</A> and <A>b</A> are both integers, <C><A>a</A> mod <A>b</A></C> is the integer <A>r</A> in the
integer range <C>0 .. |<A>b</A>| - 1</C> satisfying <C><A>a</A> = <A>r</A> + <A>b</A><A>q</A></C>,
for some integer <A>q</A> (where the operations occurring have their usual meaning
over the integers, of course).
<P/>
<Index>modular remainder</Index><Index>modular inverse</Index>
<Index>coprime</Index><Index>relatively prime</Index>
If <A>a</A> is a rational number and <A>b</A> is a non-zero integer,
and <C><A>a</A> = <A>m</A> / <A>n</A></C> where <A>m</A> and <A>n</A> are
coprime integers  with  <A>n</A>  positive,  then
<C><A>a</A> mod <A>b</A></C> is the integer <A>r</A> in the integer range
<C>0 .. |<A>b</A>| - 1</C>
such that <A>m</A> is congruent to <C><A>r</A><A>n</A></C> modulo <A>b</A>,
and <A>r</A> is called the
<Q>modular remainder</Q> of <A>a</A> modulo <A>b</A>.
Also,  <C>1  /  <A>n</A>  mod  <A>b</A></C>  is
called the <Q>modular inverse</Q> of <A>n</A> modulo <A>b</A>.
(A pair of integers is said to be <E>coprime</E> (or <E>relatively prime</E>)
if their greatest common divisor is 1.)
<P/>
With the above definition, <C>4 / 6 mod 32</C> equals <C>2 / 3 mod 32</C>
and hence exists (and is equal to 22),
despite the fact that 6 has no inverse modulo 32.
<P/>
<E>Note:</E>
For rational <A>a</A>, <C><A>a</A> mod <A>b</A></C> could have been defined
to be the non-negative rational <A>c</A> less than <C>|<A>b</A>|</C>
such that <C><A>a</A> - <A>c</A></C> is a multiple of <A>b</A>.
However this definition is seldom useful and <E>not</E> the
one chosen for &GAP;.
<P/>
<C>+</C> and <C>-</C> can also be used as unary operations.
The unary <C>+</C> is ignored. The unary <C>-</C> returns the additive inverse of
its operand; over the integers it is equivalent to multiplication by <C>-1</C>.
<P/>
<C>^</C> denotes powering of a multiplicative element if the right operand  is
an integer, and is also used to denote the action of a group element on a
point of a set if the right operand is a group element.
<P/>
<Index Subkey="precedence">arithmetic operators</Index>
The <E>precedence</E> of those operators is as follows.
The powering operator <C>^</C> has the highest precedence,
followed by the unary operators <C>+</C> and <C>-</C>,
which are followed by the multiplicative operators <C>*</C>, <C>/</C>, and
<K>mod</K>,
and the additive binary operators <C>+</C> and <C>-</C> have the lowest
precedence.
That means that the expression <C>-2 ^ -2 * 3 + 1</C> is
interpreted as <C>(-(2 ^ (-2)) * 3) + 1</C>. If in doubt use parentheses
to clarify your intention.
<P/>
<Index Subkey="associativity">operators</Index>
The <E>associativity</E> of the arithmetic operators is as follows.
<C>^</C> is not associative, i.e., it is invalid to write <C>2^3^4</C>,
use parentheses to clarify whether you mean <C>(2^3)^4</C> or <C>2^(3^4)</C>.
The unary operators <C>+</C> and <C>-</C> are right associative,
because they are written to the left of their operands.
<C>*</C>, <C>/</C>, <K>mod</K>, <C>+</C>, and <C>-</C> are all left
associative,
i.e., <C>1-2-3</C> is interpreted as <C>(1-2)-3</C> not as <C>1-(2-3)</C>.
Again, if in doubt use parentheses to clarify your intentions.
<P/>
The arithmetic operators have higher precedence than the comparison
operators (see&nbsp;<Ref Sect="Comparisons"/>
and&nbsp;<Ref Sect="Membership Test for Collections"/>)
and the logical operators (see <Ref Sect="Operations for Booleans"/>).
Thus, for example,
<C><A>a</A> * <A>b</A> = <A>c</A> and <A>d</A></C> is interpreted,
<C>((<A>a</A> * <A>b</A>) = <A>c</A>) and <A>d</A></C>.
<P/>
<Example><![CDATA[
gap> 2 * 2 + 9;  # a very simple arithmetic expression
13
]]></Example>
<P/>
For other arithmetic operations, and for the underlying operations of
the operators introduced above,
see&nbsp;<Ref Sect="Arithmetic Operations for Elements"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Statements">
<Heading>Statements</Heading>

<Index>execution</Index>
Assignments (see <Ref Sect="Assignments"/>),
Procedure calls (see <Ref Sect="Procedure Calls"/>),
<K>if</K> statements (see <Ref Sect="If"/>),
<K>while</K> (see <Ref Sect="While"/>),
<K>repeat</K> (see <Ref Sect="Repeat"/>) and
<K>for</K> loops (see <Ref Sect="For"/>),
and the <K>return</K> statement
(see <Ref Sect="Return (With or without Value)"/>)
are called <E>statements</E>.
They can be entered interactively or be part of a function definition.
Every statement must be terminated by a semicolon.
<P/>
Statements, unlike expressions, have no value. They are executed only to
produce an effect. For example an assignment has the effect of assigning
a  value to a variable, a <K>for</K> loop  has the effect of executing a
statement sequence for all elements in a list and so on.
We will talk about <E>evaluation</E> of expressions
but about <E>execution</E> of statements to emphasize this difference.
<P/>
Using expressions as statements is treated as syntax error.
<P/>
<Log><![CDATA[
gap> i := 7;;
gap> if i <> 0 then k = 16/i; fi;
Syntax error: := expected
if i <> 0 then k = 16/i; fi;
                 ^
gap> 
]]></Log>
<P/>
As you can see from the example this warning does in particular address
those users who are used to languages where <C>=</C> instead of <C>:=</C>
denotes assignment.
<P/>
Empty statements are permitted and have no effect.
<P/>
A sequence of one or more statements is a <E>statement sequence</E>, and may
occur everywhere instead of a single statement.
Each construct is terminated by a keyword.
The simplest statement sequence is a single semicolon, which can be
used as an empty statement sequence. In fact an empty statement
sequence as in <C>for i in [ 1 .. 2 ] do od</C> is also permitted and is
silently translated into the sequence containing just a semicolon.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Assignments">
<Heading>Assignments</Heading>

<Index Subkey="variable">assignment</Index>
<C><A>var</A> := <A>expr</A>;</C>
<P/>
The <E>assignment</E> has the effect of assigning the value of the expressions
<A>expr</A> to the variable <A>var</A>.
<P/>
The variable <A>var</A> may be an ordinary variable
(see <Ref Sect="Variables"/>),
a list element selection <C><A>list-var</A>[<A>int-expr</A>]</C>
(see <Ref Sect="List Assignment"/>) or a record component selection
<C><A>record-var</A>.<A>ident</A></C> (see <Ref Sect="Record Assignment"/>).
Since a list element or a record component may itself be a
list or a record the left hand side of an assignment may be arbitrarily
complex.
<P/>
Note that variables do not have a type. Thus any value may be assigned
to any variable.  For example a variable with an integer value may be
assigned a permutation or a list or anything else.
<P/>
<Example><![CDATA[
gap> data:= rec( numbers:= [ 1, 2, 3 ] );
rec( numbers := [ 1, 2, 3 ] )
gap> data.string:= "string";; data;
rec( numbers := [ 1, 2, 3 ], string := "string" )
gap> data.numbers[2]:= 4;; data;
rec( numbers := [ 1, 4, 3 ], string := "string" )
]]></Example>
<P/>
If the expression <A>expr</A> is a function call then this function must
return a value.  If the function does not return a value an error is
signalled and you enter a break loop (see <Ref Sect="Break Loops"/>).
As usual you can leave the break  loop  with <C>quit;</C>.
If you enter <C>return <A>return-expr</A>;</C> the value of the expression
<A>return-expr</A> is assigned to the variable,
and execution continues after the assignment.
<P/>
<Log><![CDATA[
gap> f1:= function( x ) Print( "value: ", x, "\n" ); end;;
gap> f2:= function( x ) return f1( x ); end;;
gap> f2( 4 );
value: 4
Function Calls: <func> must return a value at
return f1( x );
 called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can supply one by 'return <value>;' to continue
brk> return "hello";
"hello"
]]></Log>
<P/>
In the above example, the function <C>f2</C> calls <C>f1</C> with argument
<C>4</C>,
and since <C>f1</C> does not return a value (but only prints a line
<Q><C>value: ...</C></Q>),
the <K>return</K> statement of <C>f2</C> cannot be executed.
The error message says that it is possible to return an appropriate value,
and the returned string <C>"hello"</C> is used by <C>f2</C> instead of the
missing return value of <C>f1</C>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Procedure Calls">
<Heading>Procedure Calls</Heading>

<Index>procedure call</Index>
<Index>procedure call with arguments</Index>
<C><A>procedure-var</A>( [<A>arg-expr</A> [,<A>arg-expr</A>, ...]] );</C>
<P/>
The <E>procedure call</E> has  the  effect  of calling  the procedure
<A>procedure-var</A>.  A procedure call is done exactly like a function call
(see <Ref Sect="Function Calls"/>).
The distinction between functions and procedures is only for the sake of the
discussion, &GAP; does not distinguish between them.
So we state the following conventions.
<P/>
A <E>function</E> does return a value but does not produce a side effect. As
a convention the name of a function is a noun, denoting what the function
returns, e.g., <C>"Length"</C>, <C>"Concatenation"</C> and <C>"Order"</C>.
<P/>
A <E>procedure</E> is a function that does not return a value but produces
some  effect. Procedures are called  only for  this effect. As  a
convention the name of a procedure is a verb, denoting what the procedure
does, e.g., <C>"Print"</C>, <C>"Append"</C> and <C>"Sort"</C>.
<P/>
<Log><![CDATA[
gap> Read( "myfile.g" );   # a call to the procedure Read
gap> l := [ 1, 2 ];;
gap> Append( l, [3,4,5] );  # a call to the procedure Append
]]></Log>
<P/>
There are a few exceptions of &GAP; functions that do both return
a value and produce some effect.
An example is <Ref Func="Sortex"/> which sorts a list
and returns the corresponding permutation of the entries.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="If">
<Heading>If</Heading>

<Index Key="fi"><K>fi</K></Index>
<Index Key="then"><K>then</K></Index>
<Index Key="else"><K>else</K></Index>
<Index Key="elif"><K>elif</K></Index>
<C>if <A>bool-expr1</A> then <A>statements1</A> { elif <A>bool-expr2</A> then <A>statements2</A> }[ else <A>statements3</A> ] fi;</C>
<Index Key="if statement"><K>if</K> statement</Index>
<P/>
The <K>if</K> statement allows one to execute statements depending on the
value of some boolean expression. The execution is done as follows.
<P/>
First the expression <A>bool-expr1</A> following the <K>if</K> is evaluated.
If it evaluates to <K>true</K> the statement sequence <A>statements1</A>
after the first <K>then</K> is executed,
and the execution of the <K>if</K> statement is complete.
<P/>
Otherwise the expressions <A>bool-expr2</A> following the <K>elif</K> are
evaluated in turn.
There may be any number of <K>elif</K> parts, possibly none at all.
As soon as an expression evaluates to <K>true</K> the corresponding statement
sequence <A>statements2</A> is executed and execution of the <K>if</K>
statement is complete.
<P/>
If the <K>if</K> expression and all, if any, <K>elif</K> expressions evaluate
to <K>false</K> and there is an <K>else</K> part, which is optional,
its statement sequence <A>statements3</A> is executed and the execution of
the <K>if</K> statement is complete.
If there is no <K>else</K> part the <K>if</K> statement is complete without
executing any statement sequence.
<P/>
Since the <K>if</K> statement is terminated by the <K>fi</K> keyword
there is no question where an <K>else</K> part belongs,
i.e., &GAP; has no <Q>dangling else</Q>.
In
<P/>
<Listing><![CDATA[
if expr1 then if expr2 then stats1 else stats2 fi; fi;
]]></Listing>
<P/>
the <K>else</K> part belongs to the second  <K>if</K> statement, whereas in
<P/>
<Listing><![CDATA[
if expr1 then if expr2 then stats1 fi; else stats2 fi;
]]></Listing>
<P/>
the <K>else</K> part belongs to the first <K>if</K> statement.
<P/>
Since an <K>if</K> statement is not an expression it is not possible to write
<P/>
<Listing><![CDATA[
abs := if x > 0 then x; else -x; fi;
]]></Listing>
<P/>
which would, even if legal syntax, be  meaningless, since the <K>if</K>
statement does not produce a value that could be assigned to <C>abs</C>.
<P/>
If one of the expressions <A>bool-expr1</A>, <A>bool-expr2</A> is evaluated
and its value is neither <K>true</K> nor <K>false</K> an error is signalled
and a break loop (see <Ref Sect="Break Loops"/>) is entered.
As usual you can leave  the break loop with <C>quit;</C>.
If you enter <C>return true;</C>,
execution of the <K>if</K> statement continues as if the expression whose
evaluation  failed had evaluated to <K>true</K>.
Likewise, if you enter <C>return false;</C>,
execution of the <K>if</K> statement continues as if the expression
whose evaluation failed had evaluated to <K>false</K>.
<P/>
<Example><![CDATA[
gap> i := 10;;
gap> if 0 < i then
>    s := 1;
>  elif i < 0 then
>    s := -1;
>  else
>    s := 0;
>  fi;
gap> s;  # the sign of i
1
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="While">
<Heading>While</Heading>

<Index Subkey="while">loop</Index>
<Index Key="while loop"><K>while</K> loop</Index>
<C>while <A>bool-expr</A> do <A>statements</A> od;</C>
<P/>
The <K>while</K> loop executes the statement sequence <A>statements</A> while
the condition <A>bool-expr</A> evaluates to <K>true</K>.
<P/>
First <A>bool-expr</A> is evaluated.
If it evaluates to <K>false</K> execution of the <K>while</K> loop terminates
and the statement immediately following the <K>while</K> loop is executed
next.
Otherwise if it evaluates to <K>true</K> the
<A>statements</A> are executed and the whole process begins again.
<P/>
The difference between the <K>while</K> loop
and the <K>repeat</K> <K>until</K> loop (see <Ref Sect="Repeat"/>)
is that the <A>statements</A> in the <K>repeat</K> <K>until</K> loop are
executed at least once, while the <A>statements</A> in the <K>while</K> loop
are not executed at all if <A>bool-expr</A> is <K>false</K> at the first
iteration.
<P/>
If <A>bool-expr</A> does not evaluate to <K>true</K> or <K>false</K> an error
is signalled and a break loop (see <Ref Sect="Break Loops"/>) is entered.
As usual you can leave the break loop with <C>quit;</C>.
If you enter <C>return false;</C>,
execution continues with the next statement immediately following the
<K>while</K> loop.
If you enter <C>return true;</C>, execution continues at <A>statements</A>,
after which the next evaluation of <A>bool-expr</A> may cause another error.
<P/>
The following example shows a <K>while</K> loop that sums up the squares
<M>1^2, 2^2, \ldots</M> until the sum exceeds <M>200</M>.
<P/>
<Example><![CDATA[
gap> i := 0;; s := 0;;
gap> while s <= 200 do
>    i := i + 1; s := s + i^2;
>  od;
gap> s;
204
]]></Example>
<P/>
A <K>while</K> loop may be left prematurely using <K>break</K>,
see <Ref Sect="Break"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Repeat">
<Heading>Repeat</Heading>

<Index Subkey="repeat">loop</Index>
<Index Key="until"><K>until</K></Index>
<Index Key="repeat loop"><K>repeat</K> loop</Index>
<C>repeat <A>statements</A> until <A>bool-expr</A>;</C>
<P/>
The <K>repeat</K> loop executes the statement sequence <A>statements</A>
until the condition <A>bool-expr</A> evaluates to <K>true</K>.
<P/>
First <A>statements</A> are executed.
Then <A>bool-expr</A> is evaluated.
If it evaluates to <K>true</K> the <K>repeat</K> loop terminates
and the statement immediately following the <K>repeat</K> loop is executed
next.
Otherwise if it evaluates to <K>false</K> the whole process begins again
with the execution of the <A>statements</A>.
<P/>
The difference between the <K>while</K> loop (see <Ref Sect="While"/>)
and the <K>repeat</K> <K>until</K> loop is that the <A>statements</A>
in the <K>repeat</K> <K>until</K> loop are executed at least once,
while the <A>statements</A> in the <K>while</K> loop are not executed at all
if <A>bool-expr</A> is <K>false</K> at the first iteration.
<P/>
If <A>bool-expr</A> does not evaluate to <K>true</K> or <K>false</K>
an error is signalled and a break loop (see <Ref Sect="Break Loops"/>)
is entered.
As usual you can leave the break loop with <C>quit;</C>.
If you enter <C>return true;</C>,
execution continues with the next statement immediately following the
<K>repeat</K> loop.
If you enter <C>return false;</C>, execution continues at <A>statements</A>,
after which the next evaluation of <A>bool-expr</A> may cause another error.
<P/>
The <K>repeat</K> loop in the following example has the same purpose as the
<K>while</K> loop in the preceding example, namely to sum up the squares
<M>1^2, 2^2, \ldots</M> until the sum exceeds <M>200</M>.
<P/>
<Example><![CDATA[
gap> i := 0;; s := 0;;
gap> repeat
>    i := i + 1; s := s + i^2;
>  until s > 200;
gap> s;
204
]]></Example>
<P/>
A <K>repeat</K> loop may be left prematurely using <K>break</K>,
see <Ref Sect="Break"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="For">
<Heading>For</Heading>

<Index Subkey="for">loop</Index>
<Index Key="do"><K>do</K></Index>
<Index Key="od"><K>od</K></Index>
<C>for <A>simple-var</A> in <A>list-expr</A> do <A>statements</A> od;</C>
<Index Key="for loop"><K>for</K> loop</Index>
<P/>
The <K>for</K> loop executes the statement sequence <A>statements</A> for
every element of the list <A>list-expr</A>.
<P/>
The statement sequence <A>statements</A> is first executed with
<A>simple-var</A> bound to the first element of the list <A>list-expr</A>,
then with <A>simple-var</A> bound to the second element of <A>list-expr</A>
and so on.
<A>simple-var</A> must be a simple variable, it must not be a list element
selection <C><A>list-var</A>[<A>int-expr</A>]</C>
or a record component selection <C><A>record-var</A>.<A>ident</A></C>.
<P/>
The execution of the <K>for</K> loop over a list is exactly equivalent to
the following <K>while</K> loop.
<P/>
<Listing><![CDATA[
loop_list := list;
loop_index := 1;
while loop_index <= Length(loop_list) do
  variable := loop_list[loop_index];
  statements
  loop_index := loop_index + 1;
od;
]]></Listing>
<P/>
with the  exception  that <Q>loop_list</Q> and <Q>loop_index</Q> are different
variables for each <K>for</K> loop,
i.e., these variables of different <K>for</K> loops do not interfere with
each other.
<P/>
The list <A>list-expr</A> is very often a range (see&nbsp;<Ref Sect="Ranges"/>).
<P/>
<P/>
<Index>loop over range</Index>
<C>for <A>variable</A> in [<A>from</A>..<A>to</A>] do <A>statements</A> od;</C>
<P/>
corresponds to the more common
<P/>
<C>for <A>variable</A> from <A>from</A> to <A>to</A> do <A>statements</A> od;</C>
<P/>
in other programming languages.
<P/>
<Example><![CDATA[
gap> s := 0;;
gap> for i in [1..100] do
>    s := s + i;
> od;
gap> s;
5050
]]></Example>
<P/>
Note in the following example how the modification of the <E>list</E> in the
loop body causes the loop body also to be executed for the new values.
<P/>
<Example><![CDATA[
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    if i mod 2 = 0 then Add( l, 3 * i / 2 ); fi;
> od; Print( "\n" );
1 2 3 4 5 6 3 6 9 9 
gap> l;
[ 1, 2, 3, 4, 5, 6, 3, 6, 9, 9 ]
]]></Example>
<P/>
Note in the following example that the modification of the <E>variable</E>
that holds the list has no influence on the loop.
<P/>
<Example><![CDATA[
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    l := [];
> od; Print( "\n" );
1 2 3 4 5 6 
gap> l;
[  ]
]]></Example>
<P/>
<Index>loop over iterator</Index>
<C>for <A>variable</A> in <A>iterator</A> do <A>statements</A> od;</C>
<P/>
It is also possible to have a <K>for</K>-loop run over an iterator
(see&nbsp;<Ref Sect="Iterators"/>). In this case
the <K>for</K>-loop is equivalent to
<P/>
<Listing><![CDATA[
while not IsDoneIterator(iterator) do
  variable := NextIterator(iterator)
  statements
od;
]]></Listing>
<P/>
<Index>loop over object</Index>
<C>for <A>variable</A> in <A>object</A> do <A>statements</A> od;</C>
<P/>
Finally, if an object <A>object</A> which is not a list or an iterator appears in a
<K>for</K>-loop, then &GAP; will attempt to evaluate the function call
<C>Iterator(<A>object</A>)</C>. If this is successful then the loop is taken to
run over the iterator returned.
<P/>
<Example><![CDATA[
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> count := 0;; sumord := 0;;
gap> for x in g do
> count := count + 1; sumord := sumord + Order(x); od;
gap> count;
120
gap> sumord;
471
]]></Example>
<P/>
The effect of
<P/>
<C>for <A>variable</A> in <A>domain</A> do</C>
<P/>
should thus normally be the same as 
<P/>
<C>for <A>variable</A> in AsList(<A>domain</A>) do</C>
<P/>
but may use much less storage, as the iterator may be more compact than
a list of all the elements.
<P/>
See <Ref Sect="Iterators"/> for details about iterators.
<P/>
A <K>for</K> loop may be left prematurely using <K>break</K>,
see <Ref Sect="Break"/>. This
combines especially well with a loop over an iterator, as a way of
searching through a domain for an element with some useful property.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Break">
<Heading>Break</Heading>

<Index Subkey="leaving">loops</Index>
<C>break;</C>
<Index Key="break statement"><K>break</K> statement</Index>
<P/>
The statement <C>break;</C> causes an immediate exit from the innermost
loop enclosing it.
<P/>
<Example><![CDATA[
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> for x in g do
> if Order(x) = 3 then
> break;
> fi; od;
gap> x;
(1,5,2)(3,4,6)
]]></Example>
<P/>
It is an error to use this statement other than inside a loop.
<P/>
<Log><![CDATA[
gap> break;
Error, A break statement can only appear inside a loop
not in any function
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Continue">
<Heading>Continue</Heading>

<Index Subkey="restarting">loops</Index>
<C>continue;</C>
<Index Key="continue statement"><K>continue</K> statement</Index>
<P/>
The statement <C>continue;</C> causes the rest of the current iteration of
the innermost loop enclosing it to be skipped.
<P/>
<Example><![CDATA[
gap> g := Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> for x in g do
> if Order(x) = 3 then
> continue;
> fi; Print(x,"\n"); od;
()
(2,3)
(1,3)
(1,2)
]]></Example>
<P/>
It is an error to use this statement other than inside a loop.
<P/>
<Log><![CDATA[
gap> continue;
Error, A continue statement can only appear inside a loop
not in any function
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Function">
<Heading>Function</Heading>

<Index Subkey="definition of">functions</Index>
<Index Key="end"><K>end</K></Index>
<Index Key="local"><K>local</K></Index>
<Index>recursion</Index>
<Index Subkey="recursive">functions</Index>
<Index>environment</Index><Index>body</Index>
<C>function( [ <A>arg-ident</A> {, <A>arg-ident</A>} ] )</C>
<P/>
<C>&nbsp;&nbsp;[local  <A>loc-ident</A> {, <A>loc-ident</A>} ; ]</C>
<P/>
<C>&nbsp;&nbsp;<A>statements</A></C>
<P/>
<C>end</C>
<P/>
A function is in fact a literal and not a statement. Such a function
literal can be assigned to a variable or to a list element or a record
component.
Later this function can be called as described in <Ref Sect="Function Calls"/>.
<P/>
The following is an example of a function definition.  It is a function
to compute values of the Fibonacci sequence (see <Ref Func="Fibonacci"/>).
<P/>
<Example><![CDATA[
gap> fib := function ( n )
>     local f1, f2, f3, i;
>     f1 := 1; f2 := 1;
>     for i in [3..n] do
>       f3 := f1 + f2;
>       f1 := f2;
>       f2 := f3;
>     od;
>     return f2;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
]]></Example>
<P/>
Because for each of the formal arguments <A>arg-ident</A> and for each of the
formal locals <A>loc-ident</A> a new variable is allocated when the function
is called (see <Ref Sect="Function Calls"/>),
it is possible that a function calls itself.
This is usually called <E>recursion</E>.
The following is a recursive function that computes values of the Fibonacci
sequence.
<P/>
<Example><![CDATA[
gap> fib := function ( n )
>     if n < 3 then
>       return 1;
>     else
>       return fib(n-1) + fib(n-2);
>     fi;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
]]></Example>
<P/>
Note that the recursive version needs <C>2 * fib(<A>n</A>)-1</C> steps
to compute <C>fib(<A>n</A>)</C>,
while the iterative version of <C>fib</C> needs only <C><A>n</A>-2</C> steps.
Both are not optimal however, the library function <Ref Func="Fibonacci"/>
only needs about <C>Log(<A>n</A>)</C> steps.
<P/>
<Index Subkey="with a variable number of arguments">functions</Index>
<Index Key="arg" Subkey="special function argument"><C>arg</C></Index>
As noted in Section&nbsp;<Ref Sect="Function Calls"/>,
the case where a function's last argument is followed by <C>...</C> is special.
It provides a way of defining  a  function  with  a  variable  number  of
arguments. The values of the actual arguments are computed and the
first ones are assigned to the new variables corresponding to the
formal arguments before the last argument, if any. The values of all the
remaining actual arguments are stored  in  a  list
and this list is assigned to the new variable corresponding to the final formal
argument. There are  two  typical  scenarios  for  wanting  such  a
possibility:  having  optional  arguments  and  having  any   number   of
arguments.
<P/>
The  following  example  shows  one  way  that  the  function
<Ref Func="Position"/> might be encoded  and  demonstrates  the
<Q>optional argument</Q> scenario.
<P/>
<Example><![CDATA[
gap> position := function ( list, obj, arg... )    
>     local pos;
>     if 0 = Length(arg) then
>       pos := 0;
>     else
>       pos := arg[1];
>     fi;
>     repeat
>       pos := pos + 1;
>       if pos > Length(list) then
>         return fail;
>       fi;
>     until list[pos] = obj;
>     return pos;
>    end;
function( list, obj, arg... ) ... end
gap> position([1, 4, 2], 4);
2
gap> position([1, 4, 2], 3);
fail
gap> position([1, 4, 2], 4, 2);
fail
]]></Example>
<P/>
The following  example  demonstrates  the  <Q>any  number  of  arguments</Q>
scenario.
<P/>
<Example><![CDATA[
gap> sum := function ( l... )
>     local total, x;
>     total := 0;
>     for x in l do
>       total := total + x;
>     od;
>     return total;
>    end;
function( l... ) ... end
gap> sum(1, 2, 3);
6
gap> sum(1, 2, 3, 4);
10
gap> sum();
0
]]></Example>
<P/>
The user should compare the above with the  &GAP; function <Ref Func="Sum"/>
which, for example, may take a list argument and optionally
an initial element (which zero should the sum of an empty list return?).
<P/>
GAP will also special case a function with a single argument with the name
<C>arg</C> as function with a variable length list of arguments, as if the
user had written <C>arg...</C>.
<P/>
Note that if a function <A>f</A> is defined as above
then <C>NumberArgumentsFunction(<A>f</A>)</C> returns
minus the number of formal arguments (including the final argument)
(see&nbsp;<Ref Func="NumberArgumentsFunction"/>).
<P/>
Using the <C>...</C> notation on a function <A>f</A> with only a single
named argument tells &GAP; that when it encounters <A>f</A> that it should
form a list out of the arguments of <A>f</A>.
What if one wishes to do the <Q>opposite</Q>:
tell &GAP; that a list should be <Q>unwrapped</Q> and passed as several
arguments to a function.
The function <Ref Func="CallFuncList"/> is provided for this purpose.
<P/>
Also see Chapter&nbsp;<Ref Chap="Functions"/>.
<P/>
<Index Subkey="definition by arrow notation">functions</Index>
<Index>arrow notation for functions</Index>
<C><A>arg-ident</A> -> <A>expr</A></C>
<P/>
This is a shorthand for
<P/>
<C>function ( <A>arg-ident</A> ) return <A>expr</A>; end.</C>
<P/>
<A>arg-ident</A> must be a single identifier, i.e., it is not possible to
write functions of several arguments this way. Also <C>arg</C> is not treated
specially, so it is also impossible to write functions that take a
variable number of arguments this way.
<P/>
The following is an example of a typical use of such a function
<P/>
<Example><![CDATA[
gap> Sum( List( [1..100], x -> x^2 ) );
338350
]]></Example>
<P/>
When the definition of a function <A>fun1</A> is evaluated inside another
function <A>fun2</A>,
&GAP; binds all the identifiers inside the function <A>fun1</A> that
are identifiers of an argument or a local of <A>fun2</A> to the corresponding
variable.
This set of bindings is called the environment of the function <A>fun1</A>.
When <A>fun1</A> is called, its body is executed in this environment.
The following implementation of a simple stack uses this.
Values can be pushed onto the stack and then later be popped off again.
The interesting thing here is that the functions <C>push</C> and <C>pop</C>
in the record returned by <C>Stack</C> access the local variable <C>stack</C>
of <C>Stack</C>.
When <C>Stack</C> is called, a new variable for the identifier <C>stack</C>
is created.
When the function definitions of <C>push</C> and <C>pop</C> are then
evaluated (as part of the <K>return</K> statement) each reference to
<C>stack</C> is bound to this new variable.
Note also that the two stacks <C>A</C> and <C>B</C> do not interfere,
because each call of <C>Stack</C> creates a new variable for <C>stack</C>.
<P/>
<Example><![CDATA[
gap> Stack := function ()
>     local  stack;
>     stack := [];
>     return rec(
>       push := function ( value )
>         Add( stack, value );
>       end,
>       pop := function ()
>         local  value;
>         value := stack[Length(stack)];
>         Unbind( stack[Length(stack)] );
>         return value;
>       end
>     );
>  end;;
gap> A := Stack();;
gap> B := Stack();;
gap> A.push( 1 ); A.push( 2 ); A.push( 3 );
gap> B.push( 4 ); B.push( 5 ); B.push( 6 );
gap> A.pop(); A.pop(); A.pop();
3
2
1
gap> B.pop(); B.pop(); B.pop();
6
5
4
]]></Example>
<P/>
This feature should be used rarely, since its implementation in &GAP; is
not very efficient.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Return (With or without Value)">
<Heading>Return (With or without Value)</Heading>

<Index Key="return" Subkey="no value"><K>return</K></Index>
<C>return;</C>
<P/>
In this form <K>return</K> terminates the call of the innermost function that
is currently executing, and control returns to the calling function. An
error is signalled if no function is currently executing. No value is
returned by the function.
<P/>
<C>return <A>expr</A>;</C>
<Index Key="return" Subkey="with value"><K>return</K></Index>
<P/>
In this form <K>return</K> terminates the call of the innermost function that
is currently executing, and returns the value of the expression <A>expr</A>.
Control returns to the calling function. An error is signalled if no
function is currently executing.
<P/>
Both statements can also be used in break loops
(see <Ref Sect="Break Loops"/>).
<C>return;</C> has the effect that the computation continues where it was
interrupted by an error or the user hitting <B>Ctrl-C</B>.
<C>return <A>expr</A>;</C> can be used to continue execution after an error.
What happens with the value <A>expr</A> depends on the particular error.
<P/>
For examples of <K>return</K> statements, see the functions <C>fib</C> and
<C>Stack</C> in Section&nbsp;<Ref Sect="Function"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!--
<Section Label="The Syntax in BNF">
<Heading>The Syntax in BNF</Heading>

<Index>BNF</Index>
This section contains the definition of the &GAP; syntax in
Backus-Naur form. A few recent additions to the syntax may be missing
from this definition. Also, the actual rules for identifier names
implemented by the system, are somewhat more permissive than those
given below (see section <Ref Sect="Identifiers"/>).
<P/>
A  BNF is a set of rules, whose left side  is the name of  a  syntactical
construct.  Those  names  are written using <A>this font</A>.
The right side of each rule contains a possible form for that
syntactic  construct.   Each  right  side  may  contain  names  of  other
syntactic  constructs,  again  enclosed in angle brackets and written  in
<A>italics</A>,  or character  sequences that  must  occur literally; they are
written in <C>this font</C>.
<P/>
Furthermore  each right hand side  can contain  the  following metasymbols.
If the right  hand  side contains forms separated
by a pipe symbol  (<M>|</M>)  this means  that one  of the possible forms can
occur.  If a part of a form  is enclosed  in square brackets  (<C>[]</C>)  this
means that this part is optional, i.e.  might be present or  missing.  If
part  of the form is enclosed  in curly braces  (<C>{}</C>)  this means that
the part may occur arbitrarily often, or possibly be missing.
<P/>
<Table Align="lll">
<Row>
  <Item><A>Ident</A></Item>
  <Item>:=</Item>
  <Item><C>a</C><M>|\ldots|</M><C>z</C><M>|</M>
        <C>A</C><M>|\ldots|</M><C>Z</C><M>|</M>
        <C>_</C>
        <C>{a</C><M>|\ldots|</M><C>z</C><M>|</M>
                <C>A</C><M>|\ldots|</M><C>Z</C><M>|</M>
                <C>0</C><M>|\ldots|</M><C>9</C><M>|</M>
                <C>_}</C></Item>
</Row>
<Row>
  <Item><A>Var</A></Item>
  <Item>:=</Item>
  <Item><A>Ident</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>.</C> <A>Ident</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>. (</C> <A>Expr</A> <C>)</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>[</C> <A>Expr</A> <C>]</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>{</C> <A>Expr</A> <C>}</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>(</C> [ <A>Expr</A> <C>{,</C> <A>Expr</A> <C>} ] )</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>!.</C> <A>Ident</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>!. (</C> <A>Expr</A> <C>)</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>![</C> <A>Expr</A> <C>]</C></Item>
</Row>
<Row>
  <Item><A>List</A></Item>
  <Item>:=</Item>
  <Item><C>[</C> [ <A>Expr</A> ] <C>{,</C> [ <A>Expr</A> ] <C>} ]</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>[</C> <A>Expr</A> [<C>,</C> <A>Expr</A> ] <C>..</C> <A>Expr</A> <C>]</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>List</A> <C>{</C> <A>List</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Record</A></Item>
  <Item>:=</Item>
  <Item><C>rec(</C> [ <A>Ident</A> <C>:=</C> <A>Expr</A>
                         <C>{,</C> <A>Ident</A> <C>:=</C> <A>Expr</A> <C>} ] )</C></Item>
</Row>
<Row>
  <Item><A>Permutation</A></Item>
  <Item>:=</Item>
  <Item><C>(</C> <A>Expr</A> <C>{,</C> <A>Expr</A> <C>} )</C>
                    <C>{ (</C> <A>Expr</A> <C>{,</C> <A>Expr</A> <C>} ) }</C></Item>
</Row>
<Row>
  <Item><A>Function</A></Item>
  <Item>:=</Item>
  <Item><C>function (</C> [ <A>Ident</A> <C>{,</C> <A>Ident</A> <C>} ] )</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>[ <K>local</K> <A>Ident</A> <C>{,</C> <A>Ident</A> <C>} ;</C> ]</Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item><A>Statements</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item><K>end</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Ident</A> <C>-></C> <A>Expr</A></Item>
</Row>
<Row>
  <Item><A>Char</A></Item>
  <Item>:=</Item>
  <Item><C>'<A>any character</A>'</C></Item>
</Row>
<Row>
  <Item><A>String</A></Item>
  <Item>:=</Item>
  <Item><C>" {</C> <A>any character</A> <C>} "</C></Item>
</Row>
<Row>
  <Item><A>Int</A></Item>
  <Item>:=</Item>
  <Item><C>0</C><M>|</M><C>1</C><M>|</M>...<M>|</M><C>9</C>
        <C>{0</C><M>|</M><C>1</C><M>|</M>...<M>|</M><C>9}</C></Item>
</Row>
<Row>
  <Item><A>Atom</A></Item>
  <Item>:=</Item>
  <Item><A>Int</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>(</C> <A>Expr</A> <C>)</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Permutation</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Char</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>String</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Function</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>List</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Record</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>{</C> <K>not</K> <C>}</C> <K>true</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>{</C> <K>not</K> <C>}</C> <K>false</K></Item>
</Row>
<Row>
  <Item><A>Factor</A></Item>
  <Item>:=</Item>
  <Item><C>{+</C><M>|</M><C>-}</C> <A>Atom</A>
                [ <C>^ {+</C><M>|</M><C>-}</C> <A>Atom</A> ]</Item>
</Row>
<Row>
  <Item><A>Term</A></Item>
  <Item>:=</Item>
  <Item><A>Factor</A> <C>{ *</C><M>|</M><C>/</C><M>|</M><K>mod</K> <A>Factor</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Arith</A></Item>
  <Item>:=</Item>
  <Item><A>Term</A> <C>{ +</C><M>|</M><C>-</C> <A>Term</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Rel</A></Item>
  <Item>:=</Item>
  <Item><C>{</C> <K>not</K> <C>}</C> <A>Arith</A>
                [ <C>=</C><M>|</M><C>&lt;></C><M>|</M><C>&lt;</C><M>|</M><C>></C><M>|</M><C>&lt;=</C><M>|</M><C>>=</C><M>|</M><K>in</K> <A>Arith</A> ]</Item>
</Row>
<Row>
  <Item><A>And</A></Item>
  <Item>:=</Item>
  <Item><A>Rel</A> <C>{</C> <K>and</K> <A>Rel</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Logical</A></Item>
  <Item>:=</Item>
  <Item><A>And</A> <C>{</C> <K>or</K> <A>And</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Expr</A></Item>
  <Item>:=</Item>
  <Item><A>Logical</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A></Item>
</Row>
<Row>
  <Item><A>Statement</A></Item>
  <Item>:=</Item>
  <Item><A>Expr</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>:=</C> <A>Expr</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>if</K> <A>Expr</A> <K>then</K> <A>Statements</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item><C>{</C> <K>elif</K> <A>Expr</A> <K>then</K> <A>Statements</A> <C>}</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>[ <K>else</K> <A>Statements</A> ] <K>fi</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>for</K> <A>Var</A> <K>in</K> <A>Expr</A> <K>do</K> <A>Statements</A> <K>od</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>while</K> <A>Expr</A> <K>do</K> <A>Statements</A> <K>od</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>repeat</K> <A>Statements</A> <K>until</K> <A>Expr</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>return</K> [ <A>Expr</A> ]</Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>break</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>quit</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>QUIT</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item></Item>
</Row>
<Row>
  <Item><A>Statements</A></Item>
  <Item>:=</Item>
  <Item><C>{</C> <A>Statement</A> <C>; }</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>;</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item></Item>
</Row>
</Table>

</Section>
-->
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  function.msk           GAP documentation                Alexander Hulpke -->
<!-- %% -->
<!-- %H  @(#)<M>Id: function.msk,v 1.8 2005/04/27 13:48:10 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1999 -->
<!-- %% -->
<!-- %%  This file describes functions for functions. -->
<!-- %% -->
<Chapter Label="Functions">
<Heading>Functions</Heading>

<Index Subkey="as in programming language">functions</Index>
The section&nbsp;<Ref Sect="Function"/> describes how to define a function.
In this chapter we describe functions that give information about functions,
and various utility functions used either when defining functions or calling
functions.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Information about a function">
<Heading>Information about a function</Heading>

<ManSection>
<Func Name="NameFunction" Arg='func'/>

<Description>
returns the name of a function. For operations, this is the name used in
their declaration. For functions, this is the variable name they were
first assigned to. (For some internal functions, this might be a name
<E>different</E> from the name that is documented.)
If no such name exists, the string <C>"unknown"</C> is returned.
<P/>
<Example><![CDATA[
gap> NameFunction(SylowSubgroup);
"SylowSubgroup"
gap> Blubberflutsch:=x->x;;
gap> NameFunction(Blubberflutsch);
"Blubberflutsch"
gap> a:=Blubberflutsch;;
gap> NameFunction(a);
"Blubberflutsch"
gap> NameFunction(x->x);
"unknown"
gap> NameFunction(NameFunction);
"NameFunction"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NumberArgumentsFunction" Arg='func'/>

<Description>
returns the number of arguments the function <A>func</A> accepts.
-1 is returned for all operations.
For functions that use <C>...</C> or <C>arg</C> to take a variable number of
arguments, the number returned is -1 times the total number of parameters.
For attributes, 1 is returned.
<P/>
<Example><![CDATA[
gap> NumberArgumentsFunction(function(a,b,c,d,e,f,g,h,i,j,k)return 1;end);
11
gap> NumberArgumentsFunction(Size);
1
gap> NumberArgumentsFunction(IsCollsCollsElms);
3
gap> NumberArgumentsFunction(Sum);
-1
gap> NumberArgumentsFunction(function(a, x...) return 1; end);
-2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NamesLocalVariablesFunction" Arg='func'/>

<Description>
returns a mutable list of strings;
the first entries are the names of the arguments of the function
<A>func</A>, in the same order as they were entered in the definition of
<A>func</A>, and the remaining ones are the local variables as given in
the <K>local</K> statement in <A>func</A>.
(The number of arguments can be computed with
<Ref Func="NumberArgumentsFunction"/>.)
<P/>
<Example><![CDATA[
gap> NamesLocalVariablesFunction(function( a, b ) local c; return 1; end);
[ "a", "b", "c" ]
gap> NamesLocalVariablesFunction(function( arg ) local a; return 1; end);
[ "arg", "a" ]
gap> NamesLocalVariablesFunction( Size );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FilenameFunc" Arg='func'/>

<Description>
For a function <A>func</A>, <Ref Func="FilenameFunc"/> returns either
<K>fail</K> or the absolute path of the file from which <A>func</A>
has been read.
The return value <K>fail</K> occurs if <A>func</A> is
a compiled function or an operation.
For functions that have been entered interactively,
the string <C>"*stdin*"</C> is returned,
see Section <Ref Sect="Special Filenames"/>.
<P/>
<Log><![CDATA[
gap> FilenameFunc( LEN_LIST );  # a kernel function
fail
gap> FilenameFunc( Size );      # an operation
fail
gap> FilenameFunc( x -> x^2 );  # an interactively entered function
"*stdin*"
gap> meth:= ApplicableMethod( Size, [ Group( () ) ] );;
gap> FilenameFunc( meth );
"... some path .../grpperm.gi"
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="StartlineFunc" Arg='func'/>
<Func Name="EndlineFunc" Arg='func'/>

<Description>
Let <A>func</A> be a function.
If <Ref Func="FilenameFunc"/> returns <K>fail</K> for <A>func</A> then
also <Ref Func="StartlineFunc"/> returns <K>fail</K>.
If <Ref Func="FilenameFunc"/> returns a filename for <A>func</A> then
<Ref Func="StartlineFunc"/> returns the line number in this file
where the definition of <A>func</A> starts.
<P/>
<Ref Func="EndlineFunc"/> behaves similarly and returns the line number 
in this file where the definition of <A>func</A> ends.
<P/>
<Log><![CDATA[
gap> meth:= ApplicableMethod( Size, [ Group( () ) ] );;
gap> FilenameFunc( meth );
"... some path ... gap4r5/lib/grpperm.gi"
gap> StartlineFunc( meth );
487
gap> EndlineFunc( meth );
487
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="PageSource" Arg='func'/>

<Description>
This shows the file containing the source code of the function or method
<A>func</A> in a pager (see <Ref Func="Pager"/>). The display starts at 
a line shortly before the code of <A>func</A>.<P/>

This function works if <C>FilenameFunc(<A>func</A>)</C> returns the name of
a proper file. In that case this filename and the position of the 
function definition are also printed.
Otherwise the function indicates that the source is not available 
(for example this happens for functions which are implemented in 
the &GAP; C-kernel).<P/>

Usage examples:<Br/>
<C>met := ApplicableMethod(\^, [(1,2),2743527]); PageSource(met);</C><Br/>
<C>PageSource(Combinations);</C><Br/>
<C>ct:=CharacterTable(Group((1,2,3))); </C><Br/>
<C>met := ApplicableMethod(Size,[ct]); PageSource(met); </C>
<P/>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Calling a function with a list argument that is interpreted as
several arguments">
<Heading>Calling a function with a list argument that is interpreted as
several arguments</Heading>

<ManSection>
<Oper Name="CallFuncList" Arg='func, args'/>

<Description>
returns the result, when calling function <A>func</A> with the arguments
given in the list <A>args</A>,
i.e.&nbsp;<A>args</A> is <Q>unwrapped</Q> so that <A>args</A> 
appears as several arguments to <A>func</A>.
<P/>
<Example><![CDATA[
gap> CallFuncList(\+, [6, 7]);
13
gap> #is equivalent to:
gap> \+(6, 7);
13
]]></Example>
<P/>
A more useful application of <Ref Func="CallFuncList"/> is for a function
<C>g</C> that is called in the body of a function <C>f</C> with
(a sublist of) the arguments of <C>f</C>, where <C>f</C> has been defined
with a single formal argument <C>arg</C>
(see&nbsp;<Ref Sect="Function"/>), as in the following code fragment.
<P/>
<Log><![CDATA[
f := function ( arg )
       CallFuncList(g, arg);
       ...
     end;
]]></Log>
<P/>
In the body of <C>f</C> the several arguments passed to <C>f</C> become a
list <C>arg</C>.
If <C>g</C> were called instead via <C>g( arg )</C> then <C>g</C> would
see a single list argument, so that <C>g</C> would, in general, have to
<Q>unwrap</Q> the passed list.
The following (not particularly useful) example demonstrates both
described possibilities for the call to <C>g</C>.
<P/>
<Example><![CDATA[
gap> PrintNumberFromDigits := function ( arg )
>     CallFuncList( Print, arg );
>     Print( "\n" );
>    end;
function( arg... ) ... end
gap> PrintNumberFromDigits( 1, 9, 7, 3, 2 );
19732
gap> PrintDigits := function ( arg )
>     Print( arg );
>     Print( "\n" );
>    end;
function( arg... ) ... end
gap> PrintDigits( 1, 9, 7, 3, 2 );
[ 1, 9, 7, 3, 2 ]
]]></Example>
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Calling a function with a time limit">
<Heading>Calling a function with a time limit</Heading>


<Index>Timeouts</Index>
<ManSection>
<Func Name="CallWithTimeout" Arg='timeout, func, .....'/>
<Func Name="CallWithTimeoutList" Arg='timeout, func, arglist'/>

<Description>
  <C>CallWithTimeout</C> and <C>CallWithTimeoutList</C> support calling a function
with a limit on the CPU time it can consume. <P/>

This functionality may not be available on all systems and you should check 
<Ref Var="GAPInfo.TimeoutsSupported"/> before using this functionality.<P/>

<C>CallWithTimeout</C> is variadic. 
Its third and subsequent arguments, if any, are the arguments passed to <A>func</A>.
<C>CallWithTimeoutList</C> in contrast takes exactly three arguments, of which the third is a list
(possibly empty) or arguments to pass to <A>func</A>. <P/>

If the call completes within the allotted time and returns a value <C>res</C>, the result of 
<C>CallWithTimeout[List]</C> is a length 2 list of the form <C> [ true, res ] </C>. <P/>

If the call completes within the allotted time and returns no value, the result of 
<C>CallWithTimeout[List]</C> is a list of length 1 containing the value <C>true</C>.<P/>

If the call does not complete within the timeout, the result of <C>CallWithTimeout[List]</C>
is a list of length 1 containing the value <C>false</C>  In this case, just as if you had
<C>quit</C> from a break loop, there is some risk that internal data structures in &GAP; may
have been left in an inconsistent state, and you should proceed with caution.<P/>

The timer is suspended during execution of a break loop and abandoned when you quit from a break loop.<P/>

Timeouts may not be nested. That is, during execution of <C>CallWithTimeout(<A>timeout</A>,<A>func</A>,...)</C>,
<A>func</A> (or functions it calls) may not call <C>CallWithTimeout</C> or <C>CallWithTimeoutList</C>. 
This restriction may be lifted on at least some systems in future releases. It is 
permitted to use <C>CallWithTimeout</C> or <C>CallWithTimeoutList</C> from within a break loop, even if a
suspended timeout exists, although there is limit on the depth of such nesting.<P/>

The limit <A>timeout</A> is specified as a record. At present the following components are recognised
<C>nanoseconds</C>, <C>microseconds</C>, <C>milliseconds</C>, <C>seconds</C>, 
<C>minutes</C>, <C>hours</C>, <C>days</C> and <C>weeks</C>. Any of these 
components which is present should be bound to a positive integer, rational or float and the times
represented are totalled to give the actual timeout. As a shorthand, a single positive 
integers may be supplied, and is taken as a number of microseconds.
Further components are permitted and ignored, to allow for future functionality.<P/>

The precision of the timeouts is not guaranteed, and there is a system dependent upper limit on the timeout 
which is typically about 8 years on 32 bit systems and about 30 billion years on 64 bit systems. Timeouts longer
than this will be reduced to this limit. On Windows systems, timing is based on elapsed time, not CPU time
because the necessary POSIX CPU timing API is not supported.<P/>
</Description>
</ManSection>

<ManSection>
<Var Name="GAPInfo.TimeoutsSupported"/>

<Description>
tests whether this installation of &GAP; supports the timeout functionality
of <Ref Func="CallWithTimeout"/> and related functions. 
</Description>
</ManSection>

</Section>




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Functions that do nothing">
<Heading>Functions that do nothing</Heading>

The following functions return fixed results (or just their own argument).
They can be useful in places when the syntax requires a function, but
actually no functionality is required.
So <Ref Func="ReturnTrue"/> is often used as family predicate in
<Ref Func="InstallMethod"/>.

<ManSection>
<Func Name="ReturnTrue" Arg='...'/>

<Description>
This function takes any number of arguments,
and always returns <K>true</K>.
<P/>
<Example><![CDATA[
gap> f:=ReturnTrue;  
function( arg... ) ... end
gap> f();  
true
gap> f(42);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReturnFalse" Arg='...'/>

<Description>
This function takes any number of arguments,
and always returns <K>false</K>.
<P/>
<Example><![CDATA[
gap> f:=ReturnFalse;  
function( arg... ) ... end
gap> f();  
false
gap> f("any_string");
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReturnFail" Arg='...'/>

<Description>
This function takes any number of arguments,
and always returns <K>fail</K>.
<P/>
<Example><![CDATA[
gap> oops:=ReturnFail;  
function( arg... ) ... end
gap> oops();  
fail
gap> oops(-42);  
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReturnNothing" Arg='...'/>

<Description>
This function takes any number of arguments,
and always returns nothing.
<P/>
<Example><![CDATA[
gap> n:=ReturnNothing;
function( object... ) ... end
gap> n();
gap> n(-42);
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReturnFirst" Arg='...'/>

<Description>
This function takes one or more arguments, and always returns
the first argument. <Ref Func="IdFunc"/> behaves similarly, but only
accepts a single argument.
<P/>
<Example><![CDATA[
gap> f:=ReturnFirst;
function( object... ) ... end
gap> f(1);
1
gap> f(2,3,4);
2
gap> f();
Error, RETURN_FIRST requires one or more arguments
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IdFunc" Arg='obj'/>

<Description>
returns <A>obj</A>. <Ref Func="ReturnFirst"/> is similar, but accepts
one or more arguments, returning only the first.
<P/>
<Example><![CDATA[
gap> id:=IdFunc;  
function( object ) ... end
gap> id(42);  
42
gap> f:=id(SymmetricGroup(3));                 
Sym( [ 1 .. 3 ] )
gap> s:=One(AutomorphismGroup(SymmetricGroup(3)));
IdentityMapping( Sym( [ 1 .. 3 ] ) )
gap> f=s;
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Function Types">
<Heading>Function Types</Heading>

Functions are &GAP; objects and thus have categories and a family.

<ManSection>
<Filt Name="IsFunction" Arg='obj' Type='Category'/>

<Description>
is the category of functions.
<P/>
<Example><![CDATA[
gap> IsFunction(x->x^2);
true
gap> IsFunction(Factorial);
true
gap> f:=One(AutomorphismGroup(SymmetricGroup(3)));
IdentityMapping( Sym( [ 1 .. 3 ] ) )
gap> IsFunction(f);         
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsOperation" Arg='obj' Type='Category'/>

<Description>
is the category of operations.
Every operation is a function, but not vice versa.
<P/>
<Example><![CDATA[
gap> MinimalPolynomial;  
<Operation "MinimalPolynomial">
gap> IsOperation(MinimalPolynomial);
true
gap> IsFunction(MinimalPolynomial);         
true
gap> Factorial;
function( n ) ... end
gap> IsOperation(Factorial);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="FunctionsFamily"/>

<Description>
is the family of all functions.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Naming Conventions">
<Heading>Naming Conventions</Heading>

The way functions are named in &GAP; 
might help to memorize or even guess names of library functions.
<P/>

If a variable name consists of several words then the first
letter of each word is capitalized.
<P/>

If the first part of the name of a function is a verb then the function
may modify its argument(s) but does not return anything, for example 
<Ref Oper="Append"/> appends the list given as second argument to the
list given as first argument.
Otherwise the function returns an object without changing the arguments,
for example <Ref Func="Concatenation" Label="for several lists"/> 
returns the concatenation of the lists given as arguments.
<P/>

If the name of a function contains the word <Q><C>Of</C></Q> then the return 
value is thought of as information deduced from the arguments.
Usually such functions are attributes (see&nbsp;<Ref Sect="Attributes"/>).
Examples are <Ref Oper="GeneratorsOfGroup"/>, which returns a list of 
generators for the group entered as argument, or <Ref Func="DiagonalOfMat"/>.
<P/>

For the setter and tester functions of an attribute <C>Attr</C>
the names <C>SetAttr</C> resp.&nbsp;<C>HasAttr</C> are available
(see&nbsp;<Ref Sect="Attributes"/>).
<P/>

If the name of a function contains the word <Q><C>By</C></Q> then the 
return value is thought of as built in a certain way from the parts 
given as arguments. For example, creating a group as a factor group 
of a given group by a normal subgroup can be done by taking the image 
of <Ref Func="NaturalHomomorphismByNormalSubgroup"/>. Other examples of 
<Q><C>By</C></Q> functions are <Ref Func="GroupHomomorphismByImages"/> and
<Ref Oper="LaurentPolynomialByCoefficients"/>.
<P/>

Often such functions construct an algebraic structure given by its generators 
(for example, <Ref Oper="RingByGenerators"/>). In some cases, <Q><C>By</C></Q> 
may be replaced by <Q><C>With</C></Q> (like e.g. <Ref Oper="GroupWithGenerators"/>)
or even both versions of the name may be used. The difference between 
<C>StructByGenerators</C> and <C>StructWithGenerators</C> is that the latter 
guarantees that the <C>GeneratorsOfStruct</C> value of the result is equal to 
the given set of generators (see <Ref Label="Constructing Domains"/>).
<P/>

If the name of a function has the form <Q><C>AsSomething</C></Q> then the return 
value is an object (usually a collection which has the same family of elements),
which may, for example:
<List>
<Item>
know more about its own structure (and so support more operations) than its 
input (e.g. if the elements of the collection form a group, 
then this group can be constructed using <Ref Oper="AsGroup"/>);
</Item>
<Item>
discard its additional structure (e.g. <Ref Oper="AsList"/> applied to a 
group will return a list of its elements); 
</Item>
<Item>
contain all elements of the original object without duplicates
(like e.g. <Ref Oper="AsSet"/> does if its argument is a list of elements
from the same family);
</Item>
<Item>
remain unchanged (like e.g. <Ref Oper="AsSemigroup"/> does if 
its argument is a group). 
</Item>
</List>
If <C>Something</C> and the argument of <C>AsSomething</C> are domains,
some further rules apply as explained in 
<Ref Label="Changing the Structure" BookName="tut"/>.
<P/>

If the name of a function <C>fun1</C> ends with <Q><C>NC</C></Q> then there 
is another function <C>fun2</C> with the same name except that the <C>NC</C> 
is missing. <C>NC</C> stands for <Q>no check</Q>. When <C>fun2</C> is called 
then it checks whether its arguments are valid, and if so then it calls 
<C>fun1</C>. The functions <Ref Func="SubgroupNC"/> and 
<Ref Func="Subgroup"/> are a typical example.
<P/>

The idea is that the possibly time consuming check of the arguments
can be omitted if one is sure that they are unnecessary.
For example, if an algorithm produces generators of the derived subgroup
of a group then it is guaranteed that they lie in the original group;
<Ref Func="Subgroup"/> would check this, and <Ref Func="SubgroupNC"/> 
omits the check.
<P/>

Needless to say, all these rules are not followed slavishly, for example 
there is one operation <Ref Oper="Zero"/> instead of two operations
<C>ZeroOfElement</C> and <C>ZeroOfAdditiveGroup</C>.

</Section>

</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  mloop.msk                  GAP documentation             Martin Schönert -->
<!-- %% -->
<!-- %A @(#)<M>Id: mloop.msk,v 1.34 2006/09/12 14:51:14 jjm Exp </M> -->
<!-- %% -->
<!-- %Y Copyright 1990-1992, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<Chapter Label="Main Loop and Break Loop">
<Heading>Main Loop and Break Loop</Heading>

This chapter is a first of a series of chapters that describe the
interactive environment in which you use &GAP;.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Main Loop">
<Heading>Main Loop</Heading>

<Index>read eval print loop</Index>
<Index Subkey="read eval print">loop</Index>
<Index>prompt</Index>
<Index Subkey="partial">prompt</Index>
<Index>syntax errors</Index>
<Index Subkey="syntax">errors</Index>
<Index Subkey="suppressing">output</Index>
<Index Key="last"><C>last</C></Index>
<Index Key="last2"><C>last2</C></Index>
<Index Key="last3"><C>last3</C></Index>
<Index>previous result</Index>
The normal interaction with &GAP; happens in the so-called
<E>read-eval-print</E> loop.
This means that you type an input, &GAP; first reads it,
evaluates it, and then shows the result.
Note that the term <E>print</E> may be confusing since there is a &GAP;
function called <Ref Func="Print"/> (see&nbsp;<Ref Sect="View and Print"/>)
which is in fact <E>not</E> used in the read-eval-print loop,
but traditions are hard to break.
In the following, whenever we want to express that &GAP; places some
characters on the standard output, we will say that &GAP; <E>shows</E>
something.
<P/>
The exact sequence in the read-eval-print loop is as follows.
<P/>
To signal that it is ready to accept your input,
&GAP; shows the <E>prompt</E> <C>gap></C>.
When you see this, you know that &GAP; is waiting for your input.
<P/>
Note that every statement must be terminated by a semicolon. You must
also enter <B>Return</B> (i.e., strike the <B>Return</B> key)
before &GAP; starts to read and evaluate your input.
(The <B>Return</B> key may actually be marked with the word <B>Enter</B>
and a returning arrow on your terminal.)
Because &GAP; does not do anything until you enter <B>Return</B>, you can
edit your input to fix typos and only when everything is correct enter
<B>Return</B> and have &GAP; take a look at it
(see&nbsp;<Ref Sect="Line Editing"/>). It is
also possible to enter several statements as input on a single line. Of
course each statement must be terminated by a semicolon.
<P/>
It is absolutely acceptable to enter a single statement on several lines.
When you have entered the beginning of a statement, but the statement is
not yet complete, and you enter <B>Return</B>,
&GAP; will show the <E>partial prompt</E> <C>></C>.
When you see this, you know that &GAP; is waiting for the rest
of the statement. This happens also when you forget
the semicolon <C>;</C> that terminates every &GAP; statement.
Note that when <B>Return</B> has been entered and the current statement is not
yet complete, &GAP; will already evaluate those parts of the input that 
are complete, for example function calls that appear as arguments in
another function call which needs several input lines.
So it may happen that one has to wait some time for the partial prompt.
<!-- % And side-effects caused by the first lines are executed although -->
<!-- % a syntax error in a later input line may invalidate the whole statement. -->
<P/>
When you enter <B>Return</B>, &GAP; first checks your input to see if it is
syntactically correct
(see Chapter&nbsp;<Ref Chap="The Programming Language"/> for the
definition of syntactically correct). If it is not, &GAP; prints an
error message of the following form
<P/>
<Log><![CDATA[
gap> 1 * ;
Syntax error: expression expected
1 * ;
    ^
]]></Log>
<P/>
The first line tells you what is wrong about the input, in this case the
<C>*</C> operator takes two expressions as operands, so obviously the right
one is missing.
If the input came from a file (see&nbsp;<Ref Func="Read"/>), this line
will also contain the filename and the line number. The second line is a
copy of the input. And the third line contains a caret pointing to the
place in the previous line where &GAP; realized that something is wrong.
This need not be the exact place where the error is, but it is usually
quite close.
<P/>
Sometimes, you will also see a partial prompt after you have entered an
input that is syntactically incorrect. This is because &GAP; is so
confused by your input, that it thinks that there is still something to
follow.
In this case you should enter <C>;</C><B>Return</B> repeatedly,
ignoring
further error messages, until you see the full prompt again. When you
see the full prompt, you know that &GAP; forgave you and is now ready to
accept your next &ndash;hopefully correct&ndash; input.
<P/>
If your input is syntactically correct, &GAP; evaluates or executes it,
i.e., performs the required computations
(see Chapter&nbsp;<Ref Chap="The Programming Language"/>
for the definition of the evaluation).
<P/>
If you do not see a prompt, you know that &GAP; is still working on your
last input. Of course, you can <E>type ahead</E>, i.e., already start
entering new input, but it will not be accepted by &GAP; until &GAP;
has completed the ongoing computation.
<P/>
When &GAP; is ready it will usually show the result of the computation,
i.e., the value computed. Note that not all statements produce a value,
for example, if you enter a <K>for</K> loop, nothing will be printed,
because the <K>for</K> loop does not produce a value that could be shown.
<P/>
Also sometimes you do not want to see the result. For example if you
have computed a value and now want to assign the result to a variable,
you probably do not want to see the value again. You can terminate
statements by <E>two semicolons</E> to suppress showing the result.
<P/>
If you have entered several statements on a single line &GAP; will first
read, evaluate, and show the first one, then read, evaluate, and show
the second one, and so on. This means that the second statement will not
even be checked for syntactical correctness until &GAP; has completed
the first computation.
<P/>
After the result has been shown &GAP; will display another prompt, and
wait for your next input.
And the whole process starts all over again.
Note that if you have entered several statements on a single line,
a new prompt will only be printed after &GAP; has read, evaluated,
and shown the last statement.
<P/>
In each statement that you enter, the result of the previous statement
that produced a value is available in the variable <C>last</C>.
The next to previous result is available in <C>last2</C>
and the result produced before that is available in <C>last3</C>.
<P/>
<Example><![CDATA[
gap> 1;2;3;
1
2
3
gap> last3 + last2 * last;
7
]]></Example>
<P/>
Also in each statement the time spent by the last statement, whether it
produced a value or not, is available in the variable <Ref Var="time"/>.
This is an integer that holds the number of milliseconds.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Special Rules for Input Lines">
<Heading>Special Rules for Input Lines</Heading>

The input for some &GAP; objects may not fit on one line, in particular 
big integers, long strings or long identifiers. In these cases you can still
type or paste them in long single lines.
<!-- if most people use readline this becomes irrelevant:
but on screen you may only
see the last part (with a <C>$</C> character in front). -->
For nicer display you
can also specify  the input on several lines. This is achieved by ending a
line  by a backslash or by a backslash and a carriage return character, then
continue the input on the beginning of the next line. When reading this 
&GAP; will ignore such continuation backslashes, carriage return characters 
and newline characters. &GAP; also prints long strings and integers this way.
<P/>
<Example><![CDATA[
gap> n := 1234\
> 567890;
1234567890
gap> "This is a very long string that does not fit on a line \
> and is therefore continued on the next line.";
"This is a very long string that does not fit on a line and is therefo\
re continued on the next line."
gap> bla\
> bla := 5;; blabla;
5
]]></Example>
<P/>
There is a special rule about &GAP; prompts in input lines: In line editing 
mode (usual user input and &GAP; started without <C>-n</C>)  in lines starting 
with whitespace following <C>gap> </C>, <C>> </C> or <C>brk> </C> this 
beginning part is removed.
This rule is very convenient because it allows to cut and paste input
from other &GAP; sessions or manual examples easily into your current session.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="View and Print">
<Heading>View and Print</Heading>

&GAP; has three different operations to display or print objects: 
<Ref Oper="Display"/>, <Ref Oper="ViewObj"/> and <Ref Oper="PrintObj"/>, 
and these three have different purposes as follows. The first, <Ref
    Oper="Display"/>, should print the object to the standard output
in a human-readable
relatively complete and verbose form. The second, <Ref
    Oper="ViewObj"/>, should print the object to the standard output
in a short and concise
form, it is used in the main read-eval-print loop to display the
resulting object of a computation. The third, <Ref Oper="PrintObj"/>,
should print the object to the standard output 
in a complete form which is &GAP;-readable if at all
possible, such that reading the output into &GAP; produces an object
which is equal to the original one.

<P/>
All three operations have corresponding operations which do not print
anything to standard output but return the output as a string. These
are <Ref Oper="DisplayString"/>, <Ref Oper="ViewString"/> and
<Ref Oper="PrintString"/> (corresponding to <Ref Oper="PrintObj"/>).
Additionally, there is <Ref Oper="String"/> which is very similar
to <Ref Oper="PrintString"/> but does not insert control characters
for line breaks.

<P/>
For implementation convenience it is allowed that some of these
operations have methods which delegate to some other of these
operations. However, the rules for this are that a method may only
delegate to another operation which appears further down in the
following table:

<P/>
<Table Align="|c|">
    <HorLine/>
    <Row> <Item><Ref Oper="Display"/></Item> </Row>
    <HorLine/>
    <Row> <Item><Ref Oper="ViewObj"/></Item> </Row>
    <HorLine/>
    <Row> <Item><Ref Oper="PrintObj"/></Item> </Row>
    <HorLine/>
    <Row> <Item><Ref Oper="DisplayString"/></Item> </Row>
    <HorLine/>
    <Row> <Item><Ref Oper="ViewString"/></Item> </Row>
    <HorLine/>
    <Row> <Item><Ref Oper="PrintString"/></Item> </Row>
    <HorLine/>
    <Row> <Item><Ref Oper="String"/></Item> </Row>
    <HorLine/>
</Table>

<P/>
This is to avoid circular delegations.

<P/>
Note in particular that none of the methods of the string producing operations 
may delegate to the corresponding printing operations. Note also that
the above mentioned purposes of the different operations suggest that
delegations between different operations will be sub-optimal in most
scenarios.

<Subsection>
    <Heading>Default delegations in the library</Heading>

The library contains the following low ranked default methods:

<List>
<Item>
    A method for 
<Ref Oper="DisplayString"/> which returns the constant value
of the global variable <Ref Var="DEFAULTDISPLAYSTRING"/>.
</Item>

<Item>
A method for 
<Ref Oper="ViewString"/> which returns the constant value
of the global variable <Ref Var="DEFAULTVIEWSTRING"/>.
</Item>

<Item>
A method for <Ref
    Oper="Display"/> which first calls <Ref Oper="DisplayString"/>
and prints the result, if it is a different object than <Ref
    Var="DEFAULTDISPLAYSTRING"/>. Otherwise the method delegates
to <Ref Oper="PrintObj"/>.
</Item>

<Item>
A method for <Ref
    Oper="ViewObj"/> which first calls <Ref Oper="ViewString"/>
and prints the result, if it is a different object than <Ref
    Var="DEFAULTVIEWSTRING"/>. Otherwise the method delegates
to <Ref Oper="PrintObj"/>.
</Item>

<Item>
A method for <Ref Oper="PrintObj"/> which prints the result of <Ref
    Oper="PrintString"/>.
</Item>

<Item>
    A method for <Ref Oper="PrintString"/> which returns the result
    of <Ref Oper="String"/>
</Item>

</List>

</Subsection>

<Subsection>
    <Heading>Recommendations for the implementation</Heading>

This subsection describes what methods for printing and viewing one
should implement for new &GAP; objects.

<P/>
One should at the very least install a <Ref Oper="String"/> method to
allow printing. Using the standard delegations this enables a limited
form of viewing, displaying and printing.

<P/>
If, for larger objects, nicer line breaks are needed, one should install
a separate <Ref Oper="PrintString"/> method which puts in positions for
good line breaks using the control characters <C>\&lt;</C> (ASCII 1) and
<C>\&gt;</C> (ASCII 2).

<P/>
If, for even larger objects, output performance and memory usage
matters, one should install a separate <Ref Oper="PrintObj"/> method.

<P/>
One should usually install a <Ref Oper="ViewString"/> method,
unless the above <Ref Oper="String"/> method is good enough for
<Ref Oper="ViewObj"/> purposes. Performance and memory should never
matter here, so it is usually unnecessary to install a separate <Ref
Oper="ViewObj"/> method.

<P/>
If the type of object calls for it one should install a 
<Ref Oper="DisplayString"/> method. This is the case if a human
readable verbose form is required.

<P/>
If the performance and memory usage for <Ref Oper="Display"/> matters, 
one should install a separate <Ref Oper="Display"/> method.

<P/>
Note that if only a <Ref Oper="String"/> method is installed, then
<Ref Oper="ViewObj"/> works and <Ref Oper="ViewString"/> returns <Ref
Var="DEFAULTVIEWSTRING"/>. Likewise, <Ref Oper="Display"/> works and
<Ref Oper="DisplayString"/> returns <Ref Var="DEFAULTDISPLAYSTRING"/>. If
you want to avoid this then install methods for these operations
as well.
</Subsection>

<ManSection>
<Func Name="View" Arg='obj1, obj2...'/>

<Description>
<Ref Func="View"/> shows the objects <A>obj1</A>, <A>obj2</A>... etc.
<E>in a short form</E> on the standard output by calling the
<Ref Oper="ViewObj"/> operation on each of them.
<Ref Func="View"/> is called in the read-eval-print loop,
thus the output looks exactly like the representation of the
objects shown by the main loop.
Note that no space or newline is printed between the objects.
</Description>
</ManSection>


<ManSection>
<Func Name="Print" Arg='obj1, obj2, ...'/>

<Description>
Also <Ref Func="Print"/> shows the objects <A>obj1</A>, <A>obj2</A>... etc.
on the standard output.
The difference compared to <Ref Func="View"/> is in general that the shown
form is not required to be short,
and that in many cases the form shown by <Ref Func="Print"/> is &GAP;
readable.
<P/>
<!-- % For example for large matrices <Ref Func="Print"/> may print -->
<!-- % the full matrix, while <Ref Func="View"/> may only display the dimensions and the -->
<!-- % characteristic. -->
<Example><![CDATA[
gap> z:= Z(2);
Z(2)^0
gap> v:= [ z, z, z, z, z, z, z ];
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
gap> ConvertToVectorRep(v);; v;
<a GF2 vector of length 7>
gap> Print( v, "\n" );
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
]]></Example>
<P/>
Another difference is that <Ref Func="Print"/> shows strings without the
enclosing quotes, so <Ref Func="Print"/> can be used to produce formatted
text on the standard output
(see also chapter&nbsp;<Ref Chap="Strings and Characters"/>).
Some characters preceded by a backslash, such as <C>\n</C>, are processed
specially (see chapter&nbsp;<Ref Sect="Special Characters"/>).
<Ref Func="PrintTo"/> can be used to print to a file.
<P/>
<Example><![CDATA[
gap> for i in [1..5] do
>      Print( i, " ", i^2, " ", i^3, "\n" );
>    od;
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
gap> g:= SmallGroup(12,5);
<pc group of size 12 with 3 generators>
gap> Print( g, "\n" );
Group( [ f1, f2, f3 ] )
gap> View( g );  Print( "\n" );
<pc group of size 12 with 3 generators>
]]></Example>
</Description>
</ManSection>
<P/>
<ManSection>
<Oper Name="ViewObj" Arg='obj'/>
<Oper Name="PrintObj" Arg='obj'/>

<Description>
The functions <Ref Func="View"/> and <Ref Func="Print"/> actually call
the operations <Ref Oper="ViewObj"/> and&nbsp;<Ref Oper="PrintObj"/>,
respectively, for each argument.
By installing special methods for these operations,
it is possible to achieve special printing behavior for certain objects
(see chapter&nbsp;<Ref Chap="Method Selection"/>).
The only exceptions are strings
(see Chapter&nbsp;<Ref Chap="Strings and Characters"/>),
for which the default <Ref Oper="PrintObj"/> and <Ref Oper="ViewObj"/>
methods as well as the function <Ref Func="View"/> print also the enclosing
doublequotes, whereas <Ref Func="Print"/> strips the doublequotes.
<P/>
The default method for <Ref Oper="ViewObj"/> is to call
<Ref Oper="PrintObj"/>.
So it is sufficient to have a <Ref Oper="PrintObj"/> method for an object
in order to <Ref Func="View"/> it.
If one wants to supply a <Q>short form</Q> for <Ref Func="View"/>,
one can install additionally a method for <Ref Oper="ViewObj"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Display" Arg='obj'/>

<Description>
Displays the object <A>obj</A> in a nice, formatted way which is easy to
read (but might be difficult for machines to understand).
The actual format used for this depends on the type of <A>obj</A>.
Each method should print a newline character as last character.
<Example><![CDATA[
gap> Display( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ] * Z(5) );
 2 4 1
 3 . 2
]]></Example>
<P/>
One can assign a string to an object that <Ref Func="Print"/> will use
instead of the default used by <Ref Func="Print"/>,
via <Ref Func="SetName"/>.
Also, <Ref Attr="Name"/> returns the string previously assigned to
the object for printing, via <Ref Func="SetName"/>.
The following is an example in the context of domains.
<P/>
<Example><![CDATA[
gap> g:= Group( (1,2,3,4) );
Group([ (1,2,3,4) ])
gap> SetName( g, "C4" ); g;
C4
gap> Name( g );
"C4"
]]></Example>
</Description>
</ManSection>


When setting up examples, in particular if for beginning users, it sometimes
can be convenient to hide the structure behind a printing name. For many
objects, such as groups, this can be done using <Ref Func="SetName"/>. If the
objects however is represented internally, for example permutations
representing group elements, this function is not applicable. Instead the
function <Ref Func="SetNameObject"/> can be used to interface with the
display routines on a lower level.

<ManSection>
<Func Name="SetNameObject" Arg='o,s'/>

<Description>
<Ref Func="SetNameObject"/>
sets the string <A>s</A> as display name for object <A>o</A> in an
interactive session. When applying <Ref Func="View"/> to
object <A>o</A>, for example in the system's main loop,
&GAP; will print the string <A>s</A>.
Calling <Ref Func="SetNameObject"/> for the same object <A>o</A> with
<A>s</A> set to <C>fail</C>
deletes the special viewing setup.
since use of this features potentially slows down the whole print
process, this function should be used sparingly.
<Example><![CDATA[
gap> SetNameObject(3,"three"); 
gap> Filtered([1..10],IsPrimeInt);
[ 2, three, 5, 7 ]
gap> SetNameObject(3,fail);   
gap> Filtered([1..10],IsPrimeInt);
[ 2, 3, 5, 7 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Break Loops">
<Heading>Break Loops</Heading>

When an error has occurred or when you interrupt &GAP; (usually by
hitting <B>Ctrl-C</B>) &GAP; enters a break loop,
that is in most respects like the main read eval print loop
(see&nbsp;<Ref Sect="Main Loop"/>). That is, you can
enter statements, &GAP; reads them, evaluates them, and shows the
result if any. However those evaluations happen within the context in
which the error occurred. So you can look at the arguments and local
variables of the functions that were active when the error happened and
even change them. The prompt is changed from <C>gap></C> to <C>brk></C> to
indicate that you are in a break loop.
<P/>
<Log><![CDATA[
gap> 1/0;
Rational operations: <divisor> must not be zero
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can replace <divisor> via 'return <divisor>;' to continue
]]></Log>
<P/>
If errors occur within a break loop &GAP; enters another break loop at a
<E>deeper level</E>. This is indicated by a number appended to <C>brk</C>:
<P/>
<Log><![CDATA[
brk> 1/0;
Rational operations: <divisor> must not be zero
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can replace <divisor> via 'return <divisor>;' to continue
brk_02>
]]></Log>
<P/>
There are two ways to leave a break loop,
see <Ref Subsect="quit"/> and <Ref Subsect="subsect:return"/>.

<Subsection Label="quit">
<Heading>quit from a break loop</Heading>

The first way to leave a break loop is to <E>quit</E> the break loop.
To do this you enter <C>quit;</C> or type the <E>eof</E>
(<E>e</E>nd <E>o</E>f <E>f</E>ile) character,
which is usually <B>Ctrl-D</B> except when using the <C>-e</C> option (see 
Section&nbsp;<Ref Sect="Command Line Options"/>).
Note that &GAP; code between <C>quit;</C> and the end of the input line
is ignored.
<P/>
<Log><![CDATA[
brk_02> quit;
brk>
]]></Log>
<P/>
In this case control returns to the break loop one level above or
to the main loop, respectively.
So iterated break loops must be left iteratively.
Note also that if you type <C>quit;</C> from a <C>gap></C> prompt,
&GAP; will exit (see&nbsp;<Ref Sect="Leaving GAP"/>).
<P/>
<E>Note:</E>
If you leave a break loop with <K>quit</K> without completing a command
it is possible (though not very likely) that data structures
will be corrupted or incomplete data have been stored in objects.
Therefore no guarantee can be given that calculations afterwards
will return correct results! If you have been using options <K>quit</K>ting
a break loop generally leaves the options stack with options you no 
longer want. The function <Ref Func="ResetOptionsStack"/>
removes all options on the options stack, and this is the sole intended
purpose of this function.

</Subsection>


<Subsection Label="subsect:return">
<Heading>return from a break loop</Heading>

<Index Key="return"><K>return</K></Index>
<Index>return from break loop</Index>
The other way to leave a break loop is to <E>return</E> from a break loop.
To do this you type <C>return;</C> or <C>return <A>obj</A>;</C>.
If the break loop was entered because you interrupted &GAP;,
then you can continue by typing <C>return;</C>.
If the break loop was entered due to an error,
you may have to modify the value of a variable before typing <C>return;</C>
(see the example for&nbsp;<Ref Func="IsDenseList"/>) or you may have to
return an object <A>obj</A>
(by typing: <C>return <A>obj</A>;</C>) to continue the computation;
in any case, the message printed on entering the break loop will 
tell you which of these alternatives is possible.
For example, if the break loop was entered because a variable had no
assigned value, the value to be returned is often a value that this 
variable should have to continue the computation.
<P/>
<Log><![CDATA[
brk> return 9;  # we had tried to enter the divisor 9 but typed 0 ...
1/9
gap> 
]]></Log>

</Subsection>


<ManSection>
<Var Name="OnBreak"/>

<Description>
By default, when a break loop is entered, &GAP; prints a trace of the 
innermost 5 commands currently being executed. This behaviour can be
configured by changing the value of the global variable
<Ref Func="OnBreak"/>. When a break loop is entered,
the value of <Ref Func="OnBreak"/> is
checked. If it is a function, then it is called with no arguments. By
default, the value of <Ref Func="OnBreak"/> is <Ref Func="Where"/>.
<P/>
<Example><![CDATA[
gap> OnBreak := function() Print("Hello\n"); end;
function(  ) ... end
]]></Example>
<P/>
<Log><![CDATA[
gap> Error("!\n");
Error, !
Hello
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
]]></Log>
<P/>
In cases where a break loop is entered during a function that was  called
with options (see Chapter&nbsp;<Ref Chap="Options Stack"/>),
a <C>quit;</C> will also cause the
options stack to be reset  and  an  <C>Info</C>-ed  warning  stating  this  is
emitted at <Ref Var="InfoWarning"/> level 1
(see Chapter&nbsp;<Ref Sect="Info Functions"/>).
<!-- %This is actually controlled by -->
<!-- % -->
<!-- %\>OnQuit() F -->
<!-- % -->
<!-- %which, like <Ref Func="OnBreak"/>, is a no-argument function. It is executed -->
<!-- %when a user elects to <C>quit;</C> a non-kernel-induced break loop. -->
<!-- %<C>OnQuit</C> is set read-only to a variant of <C>ResetOptionsStack</C> -->
<!-- %that warns when it does something rather than the other way round. -->
<!-- %It can be redefined after executing <C>MakeReadWriteGlobal( "OnQuit" );</C>. -->
<!-- %Currently, <C>OnQuit</C> is not  advertised, since exception handling  -->
<!-- %may make it obsolete. -->
<P/>
Note that for break loops entered by a call to <Ref Func="Error"/>,
the lines after <Q><C>Entering break read-eval-print loop ...</C></Q>
and before the <C>brk></C> prompt can also be customised,
namely by redefining <Ref Func="OnBreakMessage"/>.
<P/>
<Index Key="ErrorNoTraceBack"><C>ErrorNoTraceBack</C></Index>
Also, note that one can achieve the effect of changing <Ref Func="OnBreak"/>
<E>locally</E>.
As mentioned above, the default value of <Ref Func="OnBreak"/> is
<Ref Func="Where"/>. Thus,
a call to <Ref Func="Error"/> generally gives a trace back up to
five levels of calling functions. Conceivably, we might like to have
a function like <Ref Func="Error"/> that does not trace back without globally
changing <Ref Func="OnBreak"/>.
Such a function we might call <C>ErrorNoTraceBack</C>
and here is how we might define it.
(Note <C>ErrorNoTraceBack</C> is <E>not</E> a &GAP; function.)
<P/>
<Example><![CDATA[
gap> ErrorNoTraceBack := function(arg) # arg is special variable that GAP
>                                      # knows to treat as list of arg's
>      local SavedOnBreak, ENTBOnBreak;
>      SavedOnBreak := OnBreak;        # save current value of OnBreak
> 
>      ENTBOnBreak := function()       # our `local' OnBreak
>      local s;
>        for s in arg do
>          Print(s);
>        od;
>        OnBreak := SavedOnBreak;      # restore OnBreak afterwards
>      end;
> 
>      OnBreak := ENTBOnBreak;
>      Error();
>    end;
function( arg... ) ... end
]]></Example>
<P/>
Here is a somewhat trivial demonstration of the use of
<C>ErrorNoTraceBack</C>.
<P/>
<Log><![CDATA[
gap> ErrorNoTraceBack("Gidday!", " How's", " it", " going?\n");
Error, Gidday! How's it going?
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
]]></Log>
<P/>
Now we call <Ref Func="Error"/> with the same arguments to show the difference.
<P/>
<Log><![CDATA[
gap> Error("Gidday!", " How's", " it", " going?\n");
Error, Gidday! How's it going?
Hello
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
]]></Log>
<P/>
Observe that the value of <Ref Func="OnBreak"/> before the
<C>ErrorNoTraceBack</C> call was restored.
However, we had changed <Ref Func="OnBreak"/> from its default value;
to restore <Ref Func="OnBreak"/> to its default value,
we should do the following.
<P/>
<Example><![CDATA[
gap> OnBreak := Where;;
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="OnBreakMessage"/>

<Description>
<Index>Break loop message</Index>
When a break loop is entered by a call to <Ref Func="Error"/>
the message after the
<Q><C>Entering break read-eval-print loop ...</C></Q> line is produced
by the function <C>OnBreakMessage</C>,
which just like <Ref Func="OnBreak"/>
is a user-configurable global variable
that is a <E>function</E> with <E>no arguments</E>.
<P/>
<Example><![CDATA[
gap> OnBreakMessage(); # By default, OnBreakMessage prints the following
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
]]></Example>
<P/>
Perhaps you are familiar with what's possible in a break loop, and so
don't need to be reminded. In this case, you might wish to do the
following (the first line just makes it easy to restore the default 
value later).
<P/>
<Example><![CDATA[
gap> NormalOnBreakMessage := OnBreakMessage;; # save the default value 
gap> OnBreakMessage := function() end;        # do-nothing function
function(  ) ... end
gap> OnBreakMessage();
gap> OnBreakMessage := NormalOnBreakMessage;; # reset
]]></Example>
<P/>
With <Ref Func="OnBreak"/> still set away from its default value,
calling <Ref Func="Error"/> as we did above, now produces:
<P/>
<Log><![CDATA[
gap> Error("!\n");
Error, !
Hello
Entering break read-eval-print loop ...
brk> quit; # to get back to outer loop
]]></Log>
<P/>
However, suppose you are writing a function which detects an error
condition and <C>OnBreakMessage</C> needs to be changed only <E>locally</E>,
i.e., the instructions on how to recover from the break loop need
to be specific to that function. The same idea used to define 
<C>ErrorNoTraceBack</C> (see <Ref Func="OnBreak"/>) can be adapted to achieve 
this. The function <Ref Func="CosetTableFromGensAndRels"/>
is an example in the &GAP; code where the idea is actually used.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="Where" Arg='nr'/>

<Description>
<Index Subkey="GAP3 name for Where">Backtrace</Index>
<Index>Stack trace</Index>
shows the last <A>nr</A> commands on the execution stack during whose execution
the error occurred. If not given, <A>nr</A> defaults to 5. (Assume, for the
following example, that after the last example <Ref Func="OnBreak"/>
has been set back to its default value.)
<P/>
<Log><![CDATA[
gap> StabChain(SymmetricGroup(100)); # After this we typed ^C  
user interrupt at
bpt := S.orbit[1];
 called from
SiftedPermutation( S, (g * rep) ^ -1 ) called from
StabChainStrong( S.stabilizer, [ sch ], options ); called from
StabChainStrong( S.stabilizer, [ sch ], options ); called from
StabChainStrong( S, GeneratorsOfGroup( G ), options ); called from
StabChainOp( G, rec(
     ) ) called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> Where(2);
 called from
SiftedPermutation( S, (g * rep) ^ -1 ) called from
StabChainStrong( S.stabilizer, [ sch ], options ); called from
...
]]></Log>
<P/>
Note that the variables displayed even in the first line of the
<Ref Func="Where"/> list
(after the <C>called from</C> line) may be already one environment level higher 
and <Ref Func="DownEnv"/> may be necessary to access them.
<P/>
At the moment this backtrace does not work from within compiled code (this
includes the method selection which by default is compiled into the kernel).
If this creates problems for debugging, call &GAP; with the <C>-M</C> option
(see&nbsp;<Ref Sect="Command Line Options"/>)
to avoid loading compiled code.
<P/>
(Function calls to <Ref Func="Info"/> and methods installed for
binary operations are handled in a special way.
In rare circumstances it is possible therefore that they do not show up
in a <Ref Func="Where"/> log but the log refers to the <E>last</E>
proper function call that happened before.)
<P/>
The command line option <C>-T</C> to &GAP; disables the break loop. This
is mainly intended for testing purposes and for special
applications. If this option is given then errors simply cause &GAP;
to return to the main loop.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Variable Access in a Break Loop">
<Heading>Variable Access in a Break Loop</Heading>

In a break loop access to variables of the current break level and higher
levels is possible, but if the same variable name is used for different
objects or if a function calls itself recursively, of course only the
variable at the lowest level can be accessed.

<ManSection>
<Heading>DownEnv and UpEnv</Heading>	
<Func Name="DownEnv" Arg='nr'/>
<Func Name="UpEnv" Arg='nr'/>

<Description>
<Ref Func="DownEnv"/> moves down <A>nr</A> steps in the environment and
allows one to inspect variables on this level;
if <A>nr</A> is negative it steps up in the environment again;
<A>nr</A> defaults to 1 if not given.
<Ref Func="UpEnv"/> acts similarly to <Ref Func="DownEnv"/>
but in the reverse direction
(the mnemonic rule to remember the difference between 
<Ref Func="DownEnv"/> and <Ref Func="UpEnv"/> is the order in which commands
on the execution stack are displayed by <Ref Func="Where"/>).
<P/>
<Log><![CDATA[
gap> OnBreak := function() Where(0); end;; # eliminate back-tracing on
gap>                                       # entry to break loop
gap> test:= function( n )
>    if n > 3 then Error( "!\n" ); fi; test( n+1 ); end;;
gap> test( 1 );
Error, !
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> Where();
 called from
test( n + 1 ); called from
test( n + 1 ); called from
test( n + 1 ); called from
<function>( <arguments> ) called from read-eval-loop
brk> n;
4
brk> DownEnv();
brk> n;
3
brk> Where();
 called from
test( n + 1 ); called from
test( n + 1 ); called from
<function>( <arguments> ) called from read-eval-loop
brk> DownEnv( 2 );
brk> n;
1
brk> Where();
 called from
<function>( <arguments> ) called from read-eval-loop
brk> DownEnv( -2 );
brk> n;
3
brk> quit;
gap> OnBreak := Where;; # restore OnBreak to its default value
]]></Log>
<P/>
Note that the change of the environment caused by <Ref Func="DownEnv"/>
only affects variable access in the break loop.
If you use <K>return</K> to continue a
calculation &GAP; automatically jumps to the right environment level
again.
<P/>
Note also that search for variables looks first in the chain of outer
functions which enclosed the definition of a currently executing
function, before it looks at the chain of calling functions which led
to the current invocation of the function. 
<P/>
<Log><![CDATA[
gap> foo := function()
> local x; x := 1;
> return function() local y; y := x*x; Error("!!\n"); end;
> end;
function(  ) ... end
gap> bar := foo();
function(  ) ... end
gap> fun := function() local x; x := 3; bar(); end;
function(  ) ... end
gap> fun();
Error, !!
 called from
bar(  ); called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> x;
1
brk> DownEnv(1);
brk> x;
3
]]></Log>
<P/>
Here the <C>x</C> of <C>foo</C> which contained the definition of <C>bar</C>
is found before that of <C>fun</C> which caused its execution.
Using <Ref Func="DownEnv"/> we can access the <C>x</C> from <C>fun</C>.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Error">
<Heading>Error and ErrorCount</Heading>

<ManSection>
<Func Name="Error" Arg='messages ...'/>

<Description>
<Ref Func="Error"/> signals an error from within a function.
First the messages <A>messages</A> are printed,
this is done exactly as if <Ref Func="Print"/>
(see&nbsp;<Ref Sect="View and Print"/>)
were called with these arguments.
Then a break loop (see&nbsp;<Ref Sect="Break Loops"/>) is
entered, unless the standard error output is not connected to a terminal.
You can leave this break loop with <C>return;</C> to continue execution with
the statement following the call to <Ref Func="Error"/>. <Ref Func="ErrorNoReturn"/>
operates identically to <Ref Func="Error"/>, except it does not allow using
<C>return;</C> to continue execution.
</Description>
</ManSection>

<ManSection>
<Func Name="ErrorNoReturn" Arg='messages ...'/>

<Description>
<Ref Func="ErrorNoReturn"/> signals an error from within a function.
First the messages <A>messages</A> are printed,
this is done exactly as if <Ref Func="Print"/>
(see&nbsp;<Ref Sect="View and Print"/>)
were called with these arguments.
Then a break loop (see&nbsp;<Ref Sect="Break Loops"/>) is
entered, unless the standard error output is not connected to a terminal.
This break loop can only be exited with <C>quit;</C>. The function differs from
<Ref Func="Error"/> by not allowing execution to continue.
</Description>
</ManSection>

<ManSection>
<Func Name="ErrorCount" Arg=''/>

<Description>
<Ref Func="ErrorCount"/> returns a count of the number of errors
(including user interruptions) which have occurred in the &GAP; session
so far.
This count is reduced modulo <M>2^{28}</M> on <M>32</M> bit systems,
<M>2^{60}</M> on <M>64</M> bit systems.
The count is incremented by each error, even if &GAP; was
started with the <C>-T</C> option to disable the break loop.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Leaving GAP">
<Heading>Leaving GAP</Heading>

<Index Subkey="in emergency">quit</Index>
<Index>exit</Index>
<Index>at exit functions</Index>
<Index>saving on exit</Index>
The normal way to terminate a &GAP; session is to enter either
<C>quit;</C> (note the semicolon) or an end-of-file character (usually
<B>Ctrl-D</B>) at the <C>gap> </C> prompt in the main read eval print loop. 

<ManSection>
<Var Name="QUIT"/>

<Description>
An emergency way to leave &GAP; is to enter 
<Index Key="QUIT" Subkey="emergency quit"><K>QUIT</K></Index>
<K>QUIT</K>
at any <C>gap></C>
or <C>brk></C> or <C>brk_<A>nn</A>></C> prompt. 
</Description>
</ManSection>

<ManSection>
<Func Name="GAP_EXIT_CODE" Arg='ret'/>

<Description>
A <C>GAP_EXIT_CODE</C> sets the return value which will be used when
&GAP; exits. This may be an integer, or a boolean (where
<K>true</K> is interpreted as 0, and
<K>false</K> is interpreted as 1.
<P/>
</Description>
</ManSection>

<ManSection>
<Func Name="QUIT_GAP" Arg='[ret]'/>

<Description>
A <C>QUIT_GAP</C> acts similarly to the keyword <C>quit</C>. It exits
&GAP; cleanly, calling any function installed using <C>InstallAtExit</C>.
The optional argument will be passed to <C>GAP_EXIT_CODE</C>.
<P/>
</Description>
</ManSection>

<ManSection>
<Func Name="FORCE_QUIT_GAP" Arg='[ret]'/>

<Description>
A <C>FORCE_QUIT_GAP</C> is similar to <C>QUIT_GAP</C>, except it ignores any
functions installed with <C>InstallAtExit</C>, or any other functions
normally run at GAP exit, and exits GAP immediately.
The optional argument will be passed to <C>GAP_EXIT_CODE</C>.
<P/>
</Description>
</ManSection>


<ManSection>
<Func Name="InstallAtExit" Arg='func'/>
<Var Name="QUITTING"/>

<Description>
Before actually terminating, &GAP; will call (with no arguments) all
of the functions that have been installed using <C>InstallAtExit</C>. These
typically perform tasks such as cleaning up temporary files created
during the session, and closing open files. If an error occurs during
the execution of one of these functions, that function is simply
abandoned, no break loop is entered. 
<P/>
<!-- Cannot test this as manual example -->
<Log><![CDATA[
gap> InstallAtExit(function() Print("bye\n"); end);
gap> quit;
bye
]]></Log>
<P/>
During execution of these functions, the global variable <C>QUITTING</C>
will be set to <K>true</K> if &GAP; is exiting because the user typed
<K>QUIT</K> and <K>false</K> otherwise.
Since <K>QUIT</K> is considered as an emergency measure,
different action may be appropriate.
</Description>
</ManSection>

<ManSection>
<Var Name="SaveOnExitFile"/>

<Description>
If, when &GAP; is exiting due to a <K>quit</K> or end-of-file (i.e. not due
to a <K>QUIT</K>) the variable <Ref Var="SaveOnExitFile"/> is bound
to a string value,
then the system will try to save the workspace to that file.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Line Editing">
<Heading>Line Editing</Heading>

In most installations &GAP; will be compiled to use the
Gnu readline library (see the line <C>Libs used:</C> on &GAP; startup).
In that case skip to the next section <Ref Sect="sec:readline"/>.
(The line editing commands described in the rest of this section were
available in previous versions of &GAP;, they will work almost the same 
in the standard configuration of the Gnu readline library.)
<P/>
&GAP; allows one you to edit the current input line with a number of editing
commands. Those commands are accessible either as <E>control keys</E> or as
<E>escape keys</E>.
You enter a control key by pressing the <B>Ctrl</B> key, and,
while still holding the <B>Ctrl</B> key down,
hitting another key <C>key</C>.
You enter an escape key by hitting <B>Esc</B> and then hitting another
key <C>key</C>.
Below we denote control keys by <B>Ctrl-</B><C>key</C> and escape keys by
<B>Esc-</B><C>key</C>.
The case of <C>key</C> does not matter, i.e., <B>Ctrl-A</B> and
<B>Ctrl-a</B> are equivalent.
<P/>
Normally, line editing will be enabled if the input is connected to a
terminal. Line editing can be enabled or disabled using the command line
options <C>-f</C> and <C>-n</C> respectively
(see&nbsp;<Ref Sect="Command Line Options"/>), however
this is a machine dependent feature of &GAP;.
<P/>
Typing <B>Ctrl-key</B> or <B>Esc-key</B> for characters not mentioned below
always inserts <B>Ctrl-</B><C>key</C> resp.&nbsp;<B>Esc-</B><C>key</C>
at the current cursor position.
<P/>
The first few commands allow you to move the cursor on the current line.
<P/>
<List>
<Mark><B>Ctrl-A</B></Mark>
<Item>
  move the cursor to the beginning of the line.
</Item>
<Mark><B>Esc-B</B></Mark>
<Item>
  move the cursor to the beginning of the previous word.
</Item>
<Mark><B>Ctrl-B</B></Mark>
<Item>
  move the cursor backward one character.
</Item>
<Mark><B>Ctrl-F</B></Mark>
<Item>
  move the cursor forward one character. 
</Item>
<Mark><B>Esc-F</B></Mark>
<Item>
  move the cursor to the end of the next word. 
</Item>
<Mark><B>Ctrl-E</B></Mark>
<Item>
  move the cursor to the end of the line.
</Item>
</List>
<P/>
The next commands delete or kill text.
The last killed text can be reinserted, possibly at a different position,
with the <Q>yank</Q> command <B>Ctrl-Y</B>.
<List>
<Mark><B>Ctrl-H</B> or <A>del</A></Mark>
<Item>
  delete the character left of the cursor. 
</Item>
<Mark><B>Ctrl-D</B></Mark>
<Item>
  delete the character under the cursor. 
</Item>
<Mark><B>Ctrl-K</B></Mark>
<Item>
  kill up to the end of the line. 
</Item>
<Mark><B>Esc-D</B></Mark>
<Item>
  kill forward to the end of the next word. 
</Item>
<Mark><B>Esc-del</B></Mark>
<Item>
  kill backward to the beginning of the last word. 
</Item>
<Mark><B>Ctrl-X</B></Mark>
<Item>
  kill entire input line, and discard all pending input. 
</Item>
<Mark><B>Ctrl-Y</B></Mark>
<Item>
  insert (yank) a just killed text.
</Item>
</List>
<P/>
The next commands allow you to change the input.
<P/>
<List>
<Mark><B>Ctrl-T</B></Mark>
<Item>
  exchange (twiddle) current and previous character. 
</Item>
<Mark><B>Esc-U</B></Mark>
<Item>
  uppercase next word. 
</Item>
<Mark><B>Esc-L</B></Mark>
<Item>
  lowercase next word. 
</Item>
<Mark><B>Esc-C</B></Mark>
<Item>
  capitalize next word.
</Item>
</List>
<P/>
The <B>Tab</B> character,
which is in fact the control key <B>Ctrl-I</B>, looks at
the characters before the cursor, interprets them as the beginning of an
identifier and tries to complete this identifier. If there is more than
one possible completion, it completes to the longest common prefix of all
those completions. If the characters to the left of the cursor are
already the longest common prefix of all completions hitting <B>Tab</B> a
second time will display all possible completions.
<P/>
<List>
<Mark><B>tab</B></Mark>
<Item>
  complete the identifier before the cursor.
</Item>
</List>
<P/>
The next commands allow you to fetch previous lines, e.g., to correct
typos, etc. 
<P/>
<List>
<Mark><B>Ctrl-L</B></Mark>
<Item>
  insert last input line before current character.
</Item>
<Mark><B>Ctrl-P</B></Mark>
<Item>
  redisplay the last input line,
  another <B>Ctrl-P</B> will redisplay the line before that, etc.
  If the cursor is not in the first column only the lines starting with the
  string to the left of the cursor are taken.
</Item>
<Mark><B>Ctrl-N</B></Mark>
<Item>
  Like <B>Ctrl-P</B> but goes the other way round through the history.
</Item>
<Mark><B>Esc-&lt;</B></Mark>
<Item>
  goes to the beginning of the history.
</Item>
<Mark><B>Esc-></B></Mark>
<Item>
  goes to the end of the history.
</Item>
<Mark><B>Ctrl-O</B></Mark>
<Item>
  accepts this line and perform a <B>Ctrl-N</B>.
</Item>
</List>
<P/>
Finally there are a few miscellaneous commands.
<P/>
<List>
<Mark><B>Ctrl-V</B></Mark>
<Item>
  enter next character literally, i.e., enter it even if it
  is one of the control keys.
</Item>
<Mark><B>Ctrl-U</B></Mark>
<Item>
  execute the next line editing command 4 times.
</Item>
<Mark><B>Esc-</B><C>num</C></Mark>
<Item>
  execute the next line editing command <C>num</C> times.
</Item>
<Mark><B>Esc-Ctrl-L</B></Mark>
<Item>
  redisplay input line.
</Item>
</List>
<P/>
The four arrow keys (cursor keys) can be used instead of
<B>Ctrl-B</B>, <B>Ctrl-F</B>, <B>Ctrl-P</B>, and <B>Ctrl-N</B>,
respectively.

</Section>

<Section Label="sec:readline">
<Heading>Editing using the <C>readline</C> library</Heading>

The  descriptions  in  this  section   are  valid  only  if  your  &GAP;
installation uses the <C>readline</C>  library for command line editing.
You  can check  by <C>IsBound(GAPInfo.UseReadline);</C>  if this  is the
case. <P/>

You        can        use        all       the        features        of
<C>readline</C>,         as         for        example         explained
in   <URL>http://tiswww.case.edu/php/chet/readline/rluserman.html</URL>.
Therefore  the  command  line  editing   in  &GAP;  is  similar  to  the
<C>bash</C> shell  and many other  programs. On a Unix/Linux  system you
may also have a manpage, try <C>man readline</C>. <P/>

Compared  to the  command line  editing which  was used  in &GAP;  up to
version&nbsp;4.4 (or compared to  not using the <C>readline</C> library)
using <C>readline</C> has several advantages:
<List>
<Item>Most keys still do the  same as explained in 
<Ref Sect="Line Editing"/> (in the default configuration).
</Item>
<Item>There are many additional commands, e.g. undoing (<B>Ctrl-_</B>, 
keyboard macros (<B>Ctrl-x(</B>, <B>Ctrl-x)</B> and <B>Ctrl-xe</B>), 
file name completion (hit <B>Esc</B> two or four times),
showing matching parentheses, 
<C>vi</C>-style key bindings, deleting and yanking text, ...</Item>
<Item>Lines which are longer than a physical terminal row can be edited 
more conveniently.</Item>
<Item>Arbitrary unicode characters can be typed into string literals.
</Item>
<Item>The   key   bindings   can   be  configured,   either   via   your
<File>~/.inputrc</File>   file   or   by  &GAP;   commands,   see   <Ref
Subsect="ssec:readlineCustom"/>.</Item>
<Item>The command line history can be saved to and read from a file, see
<Ref Subsect="ssec:cmdlinehistory"/>.</Item>
<!-- <Item>demo mode <Ref Subsect="ssec:demoreadline"/>???</Item> -->
<Item>Adventurous users can even implement completely new 
command line editing functions on &GAP; level, see <Ref
Subsect="ssec:readlineUserFuncs"/>.</Item>

</List>
<P/>

<Subsection Label="ssec:readlineCustom">
<Index Key="ReadlineInitLine"><C>ReadlineInitLine</C></Index>
<Heading>Readline customization</Heading>

You can use your readline  init file (by default <File>~/.inputrc</File>
on Unix/Linux) to  customize key bindings. If you want  settings be used
only within  &GAP; you  can write them  between lines  containing <C>$if
GAP</C> and <C>$endif</C>. For a detailed documentation of the available
settings and functions see <URL
Text="here">http://tiswww.case.edu/php/chet/readline/rluserman.html</URL>.

<Listing Type="From readline init file">
$if GAP
  set blink-matching-paren on
  "\C-n": dump-functions
  "\ep": kill-region
$endif
</Listing>

Alternatively,       from      within       &GAP;      the       command
<C>ReadlineInitLine(<A>line</A>);</C> can be  used, where <A>line</A> is
a string containing a line as in the init file.
<P/>

Note that after pressing <B>Ctrl-v</B> the next special character is 
input verbatim. This is very useful to bind keys or key sequences.
For example, binding the function key <B>F3</B> to the command
<C>kill-whole-line</C> by using the sequence <B>Ctrl-v</B> <B>F3</B>
looks on many terminals like this:
<C>ReadlineInitLine("\"^[OR\":kill-whole-line");</C>.
(You can get the line back later with <B>Ctrl-y</B>.)
<P/>

The <B>Ctrl-g</B> key can be used to type any unicode character by its code
point. The number of the character can either be given as a count, or if the
count is one the input characters before the cursor are taken (as decimal
number or as hex number which starts with <C>0x</C>. For example, the 
double stroke character &#8484; can be input by any of the three key
sequences <B>Esc 8484 Ctrl-g</B>, <B>8484 Ctrl-g</B> or <B>0x2124
Ctrl-g</B>.
<P/>

Some terminals bind the <B>Ctrl-s</B> and <B>Ctrl-q</B> keys to stop and
restart terminal  output. Furthermore,  sometimes <B>Ctrl-\</B>  quits a
program. To disable this behaviour (and maybe use these keys for command
line editing)  you can use  <C>Exec("stty stop undef; stty  start undef;
stty quit undef");</C> in your &GAP; session or your <F>gaprc</F> file
(see <Ref Sect="sect:gap.ini"/>).
<P/>
</Subsection>

<Subsection Label="ssec:cmdlinehistory">
<Heading>The command line history</Heading>

&GAP; can save your input lines for later reuse. The keys <B>Ctrl-p</B>
(or <B>Up</B>), <B>Ctrl-n</B> (or <B>Down</B>), 
<B>ESC&lt;</B> and <B>ESC&gt;</B> work as documented in <Ref
Sect="Line Editing"/>, that is they scroll backward and
forward in the history or go to its beginning or end. 
Also, <B>Ctrl-o</B> works as documented, it is useful for repeating a
sequence of previous lines.
(But <B>Ctrl-l</B> clears the screen as in other programs.) 
<P/>

The command line history can be used across several instances of &GAP;
via the following two commands.
</Subsection>

<ManSection >
<Func Arg="[fname], [app]" Name="SaveCommandLineHistory" />
<Returns><K>fail</K> or number of saved lines</Returns>
<Func Arg="[fname]" Name="ReadCommandLineHistory" />
<Returns><K>fail</K> or number of added lines</Returns>

<Description>
The first  command saves the  lines in the  command line history  to the
file given by  the string <A>fname</A>. The default  for <A>fname</A> is
<F>history</F> in the user's &GAP; root path <C>GAPInfo.UserGapRoot</C>
or  <F>"~/.gap_hist"</F>  if this directory does not exist.
If   the  optional  argument  <A>app</A>  is
<K>true</K> then the lines are appended  to that file otherwise the file
is overwritten.
<P/>
The  second command  is  the  converse, it  reads  the  lines from  file
<A>fname</A> and <Emph>prepends</Emph> them  to the current command line
history.
<P/>
By  default  an  arbitrary  number  of input  lines  is  stored  in  the
command  line  history.  For  very   long  &GAP;  sessions  or  if  <Ref
Func="SaveCommandLineHistory"/> and <Ref Func="ReadCommandLineHistory"/>
are used repeatedly  it can be sensible to restrict  the number of saved
lines via <C>SetUserPreference("HistoryMaxLines", num);</C>
to a non negative number <C>num</C> (the default is <K>infinity</K>).
An automatic storing and restoring  of the command line history can
be configured via 
<C>SetUserPreference("SaveAndRestoreHistory", true);</C>.
<P/>
Note that these functions are only available if your &GAP; is configured
to use the <C>readline</C> library.
</Description>
</ManSection>

<Subsection Label="ssec:readlineUserFuncs">
<Index Key="InstallReadlineMacro"><C>InstallReadlineMacro</C></Index>
<Index Key="InvocationReadlineMacro"><C>InvocationReadlineMacro</C></Index>

<Heading>Writing your own command line editing functions</Heading>
It is possible to write new command line editing functions in &GAP; as
follows.
<P/>
The functions have one argument <A>l</A> which is a list with five
entries of the form <C>[count, key, line, cursorpos, markpos]</C> where
<C>count</C> and <C>key</C> are the last pressed key and its count 
(these are not so useful here because users probably do not want to
overwrite the binding of a single key), then <C>line</C> is a string
containing the line typed so far, <C>cursorpos</C> is the current 
position of the cursor (point), and <C>markpos</C> the current position
of the mark. 
<P/>
The result of such a  function must  be a list which can have various
forms:
<List >
<Mark><C>[str]</C></Mark>
<Item>with a string <C>str</C>. In this case the text <C>str</C> is
inserted at the cursor position.</Item>
<Mark><C>[kill, begin, end]</C></Mark> 
<Item> where <C>kill</C> is <K>true</K> or <K>false</K> and <C>begin</C>
and <C>end</C> are positions on the input line. This removes the text 
from the lower position to before the higher position. If <C>kill</C>
is <K>true</K> the text is killed, i.e. put in the kill ring for later 
yanking.
</Item>
<Mark><C>[begin, end, str]</C></Mark>
<Item>where <C>begin</C> and <C>end</C> are positions on the input line
and <C>str</C> is a string.
Then the text from position <C>begin</C> to before <C>end</C> is
substituted by <C>str</C>.
</Item>
<Mark><C>[1, lstr]</C></Mark>
<Item>
where <C>lstr</C> is a list of strings. Then these strings are displayed
like a list of possible completions. The input line is not changed.
</Item>
<Mark><C>[2, chars]</C></Mark>
<Item>where <C>chars</C> is a string. The characters from <C>chars</C>
are used as the next characters from the input. (At most 512 characters
are possible.)</Item>
<Mark><C>[100]</C></Mark>
<Item>This rings the bell as configured in the terminal.</Item>
</List>

In the first three cases the result list can contain a position as a
further entry, this becomes the new cursor position. Or it
can contain two positions as further entries, these become the new
cursor position and the new position of the mark.
<P/>

Such a function can be installed as a macro for <C>readline</C> via
<C>InstallReadlineMacro(name, fun);</C> where <C>name</C> is a string
used as name of the macro and <C>fun</C> is a function as above.
This macro can be called by a key sequence which is returned by
<C>InvocationReadlineMacro(name);</C>.
<P/>
As an example we define a function which puts double quotes around the
word under or before the cursor position. The space character, the 
characters in <C>"(,)"</C>, and the beginning and end of the line
are considered as word boundaries. The function is then installed as a 
macro and bound to the key sequence <B>Esc</B> <B>Q</B>. 
<P/>
<Example>
gap> EditAddQuotes := function(l)
>   local str, pos, i, j, new;
>   str := l[3];
>   pos := l[4];
>   i := pos; 
>   while i > 1 and (not str[i-1] in ",( ") do
>     i := i-1;
>   od;
>   j := pos;
>   while IsBound(str[j]) and not str[j] in ",) " do
>     j := j+1;
>   od;
>   new := "\"";
>   Append(new, str{[i..j-1]});
>   Append(new, "\"");
>   return [i, j, new];
> end;;
gap> InstallReadlineMacro("addquotes", EditAddQuotes);
gap> invl := InvocationReadlineMacro("addquotes");;
gap> ReadlineInitLine(Concatenation("\"\\eQ\":\"",invl,"\""));;
</Example>
</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Editing Files">
<Heading>Editing Files</Heading>

In most cases, it is preferable to create longer input (in particular &GAP;
programs) separately in an editor,
and to read in the result via <Ref Func="Read"/>.
Note that <Ref Func="Read"/> by default reads from the directory
in which &GAP; was started (respectively under Windows the directory
containing the &GAP; binary),
so you might have to give an absolute path to the file.
<P/>
If you cannot create several windows,
the <Ref Func="Edit"/> command may be used to leave &GAP;, start an editor,
and read in the edited file automatically.

<ManSection>
<Func Name="Edit" Arg='filename'/>

<Description>
<Ref Func="Edit"/> starts an editor with the file whose filename is given
by the string <A>filename</A>, and reads the file back into &GAP;
when you exit the editor again.
<P/>
&GAP; will call your preferred editor if you call
<C>SetUserPreference("Editor", <A>path</A>);</C>
where <A>path</A> is the  path to your editor, 
e.g., <F>/usr/bin/vim</F>.
On Windows you can use <C>edit.com</C>. 
<P/>
Under Mac OS X, you should use
<C>SetUserPreference("Editor", "open");</C>, this will open 
the file in the default editor. If you call 
<C>SetUserPreference("EditorOptions", ["-t"]);</C>, the file
will open in <F>TextEdit</F>, and 
<C>SetUserPreference("EditorOptions", ["-a", "&lt;appl&gt;"]);</C>
will open the file using the application <C>&lt;appl&gt;</C>.
<P/>
This can for example be done in your <F>gap.ini</F> file,
see Section <Ref Subsect="subsect:gap.ini file"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Editor Support">
<Heading>Editor Support</Heading>

<Index>utilities for editing GAP files</Index>
<Index Key="vi"><C>vi</C></Index>
<Index Key="vim"><C>vim</C></Index>
<Index Key="emacs"><C>emacs</C></Index>
In the <F>etc</F> subdirectory of the &GAP; installation
we provide some setup files for the editors <C>vim</C> and
<C>emacs</C>/<C>xemacs</C>.
<P/>
<C>vim</C> is a powerful editor that understands the basic <C>vi</C> commands
but provides much more functionality. You can find more information about it
(and download it) from <URL>http://www.vim.org</URL>.
<P/>
To get support for &GAP; syntax in vim, create in your home directory a
directory <F>.vim</F> with  subdirectories  <F>.vim/syntax</F> and
<F>.vim/indent</F>
(If you are not using Unix, refer to the <C>vim</C> documentation
on where to place syntax files).
Then copy the file <F>etc/gap.vim</F> to <F>.vim/syntax/gap.vim</F> 
and  the file <F>etc/gap_indent.vim</F> to <F>.vim/indent/gap.vim</F>.
<P/>
Then edit the <F>.vimrc</F> file in your home directory.
Add lines as in the following example:
<P/>
<Log><![CDATA[
if has("syntax")
  syntax on             " Default to no syntax highlightning 
endif

" For GAP files
augroup gap
  " Remove all gap autocommands
  au!
autocmd BufRead,BufNewFile *.g,*.gi,*.gd set filetype=gap comments=s:##\ \ ,m:##\ \ ,e:##\ \ b:#

" I'm using the external program `par' for formating comment lines starting
" with `##  '. Include these lines only when you have par installed.
  autocmd BufRead,BufNewFile *.g,*.gi,*.gd set formatprg="par w76p4s0j"
  autocmd BufWritePost,FileWritePost *.g,*.gi,*.gd set formatprg="par w76p0s0j"
augroup END
]]></Log>
<P/>
See the headers  of the two mentioned files for  additional comments and
adjust details according to  your personal taste.
Send comments  and suggestions to <Email>support@gap-system.org</Email>.
Setup files for <C>emacs</C>/<C>xemacs</C> are contained in the
<F>etc/emacs</F> subdirectory.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:SizeScreen">
<Heading>Changing the Screen Size</Heading>

<ManSection>
<Func Name="SizeScreen" Arg='[sz]'/>

<Description>
Called with no arguments, <Ref Func="SizeScreen"/> returns the size of the
screen as a list with two entries.
The first is the length of each line, the second is the number of lines.
<P/>
Called with one argument that is a list <A>sz</A>,
<Ref Func="SizeScreen"/> sets the size of the screen;
The first entry of <A>sz</A>, if bound, is the length of each line,
and the second entry of <A>sz</A>, if bound, is the number of lines.
The values for unbound entries of <A>sz</A> are left unaffected.
The function returns the new values.
<P/>
Note that those parameters can also be set with the command line options
<C>-x</C> for the line length and <C>-y</C> for the number of lines
(see Section&nbsp;<Ref Sect="Command Line Options"/>).
<P/>
To check/change whether line breaking occurs for files and streams 
see&nbsp;<Ref Func="PrintFormattingStatus"/>
and&nbsp;<Ref Func="SetPrintFormattingStatus"/>.
<P/>
The line length must be between <M>20</M> and <M>4096</M> characters
(inclusive) and the number of lines must be at least <M>10</M>.
Values outside this range will be adjusted to the nearest endpoint of the
range.
</Description>
</ManSection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Teaching Mode">
<Heading>Teaching Mode</Heading>

When using &GAP; in the context of (undergraduate) teaching it is often
desirable to simplify some of the system output and functionality defaults
(potentially at the cost of making the printing of objects more expensive).
This can be achieved by turning on a teaching mode:

<ManSection>
<Func Name="TeachingMode" Arg='[switch]'/>
<Description>
When called with a boolean argument <A>switch</A>, this function will turn
teaching mode respectively on or off.
<Example><![CDATA[
gap> a:=Z(11)^3;
Z(11)^3
gap> TeachingMode(true);
#I  Teaching mode is turned ON
gap> a;
ZmodnZObj(8,11)
gap> TeachingMode(false);
#I  Teaching mode is turned OFF
gap> a;
Z(11)^3
]]></Example>

At the moment, teaching mode changes the following things
<P/>
<List>
<Mark>Prime Field Elements</Mark>
<Item>
Elements of fields of prime order are printed as
<Ref Func="ZmodnZObj" Label="for two integers"/>
instead as power of a primitive root.
</Item>
<Mark>Quadratic Irrationalities</Mark>
<Item>
Elements of a quadratic extension of the rationals are printed using the
square root <Ref Func="ER"/> instead of using roots of unity.
</Item>
<Mark>Creation of some small groups</Mark>
<Item>
The group creator functions
<Ref Func="CyclicGroup"/>,
<Ref Func="AbelianGroup"/>,
<Ref Func="ElementaryAbelianGroup"/>, and
<Ref Func="DihedralGroup"/>
create by default (if no other representation is specified) not a pc group,
but a finitely presented group, which makes the generators easier to
interpret.
</Item>
</List>

</Description>
</ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  debug.msk                 GAP manual                    Thomas Breuer -->
<!-- %W                                                       Alexander Hulpke -->
<!-- %W                                                       Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: debug.msk,v 1.26 2006/03/07 22:05:56 jjm Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Debugging and Profiling Facilities">
<Heading>Debugging and Profiling Facilities</Heading>

This chapter describes some functions that are useful mainly for
debugging and profiling purposes.
<P/>
Probably the most important debugging tool in &GAP; is the break loop
(see Section <Ref Sect="Break Loops"/>) which can be entered by putting
an <Ref Func="Error"/> statement into your code or by hitting Control-C.
In the break loop one can inspect variables, stack traces and issue 
commands as usual in an interactive &GAP; session. See also the
<Ref Func="DownEnv"/>, <Ref Func="UpEnv"/> and <Ref Func="Where"/>
functions.
<P/>
Sections&nbsp;<Ref Sect="sect:ApplicableMethod"/>
and&nbsp;<Ref Sect="Tracing Methods"/> show how to get
information about the methods chosen by the method selection mechanism
(see chapter&nbsp;<Ref Chap="Method Selection"/>).
<P/>
The final sections describe functions for collecting statistics about
computations (see <Ref Func="Runtime"/>, <Ref Sect="Profiling"/>).


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Recovery from NoMethodFound-Errors">
<Heading>Recovery from NoMethodFound-Errors</Heading>

When the method selection fails because there is no applicable method, an
error as in the following example occurs and a break loop is entered:
<P/>
<Log><![CDATA[
gap> IsNormal(2,2);
Error, no method found! For debugging hints type ?Recovery from NoMethodFound
Error, no 1st choice method found for `IsNormal' on 2 arguments called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> 
]]></Log>
<P/>
This only says, that the method selection tried to find a method for 
<C>IsNormal</C> on two arguments and failed. In this situation it is
crucial to find out, why this happened. Therefore there are a few functions
which can display further information.
Note that you can leave the break loop by the <K>quit</K> command
(see&nbsp;<Ref Subsect="quit"/>)
and that the information about the incident is no longer accessible
afterwards.
<P/>
<!-- %If you use <K>return</K> you have to supply a method -->
<!-- %which matches. -->
<ManSection>
<Func Name="ShowArguments" Arg=''/>

<Description>
This function is only available within a break loop caused by a <Q>No
Method Found</Q>-error. It prints as a list the arguments of the operation
call for which no method was found.
<!-- %%  <C>ShowArguments</C> can -->
<!-- %%  be called with any number of arguments. They are ignored. -->
</Description>
</ManSection>

<ManSection>
<Func Name="ShowArgument" Arg='nr'/>

<Description>
This function is only available within a break loop caused by a <Q>No
Method Found</Q>-error.
It prints the <A>nr</A>-th arguments of the operation call
for which no method was found.
<Ref Func="ShowArgument"/> needs exactly one
argument which is an integer between 0 and the number of arguments the
operation was called with.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowDetails" Arg=''/>

<Description>
This function is only available within a break loop caused by a <Q>No
Method Found</Q>-error. It prints the details of this error: The
operation, the number of arguments, a flag which indicates whether the
operation is being traced, a flag which indicates whether the
operation is a constructor method, and the number of methods that
refused to apply by calling <Ref Func="TryNextMethod"/>.
The last number is called <C>Choice</C> and is printed as an ordinal.
So if exactly <M>k</M> methods were found but called
<Ref Func="TryNextMethod"/> and there were no more methods
it says <C>Choice: </C><M>k</M><C>th</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowMethods" Arg='[verbosity]'/>

<Description>
This function is only available within a break loop caused by a <Q>No
Method Found</Q>-error. It prints an overview about the installed methods
for those arguments the operation was called with (using
<Ref Sect="sect:ApplicableMethod"/>. The verbosity can be
controlled by the optional integer parameter <A>verbosity</A>. The default
is 2, which lists all applicable methods. With verbosity 1
<Ref Func="ShowMethods"/> only shows the number of installed methods and the
methods matching, which can only be those that were already called but
refused to work by calling <Ref Func="TryNextMethod"/>.
With verbosity 3 not only
all installed methods but also the reasons why they do not match are
displayed.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowOtherMethods" Arg='[verbosity]'/>

<Description>
This function is only available within a break loop caused by a <Q>No
Method Found</Q>-error. It prints an overview about the installed methods
for a different number of arguments than the number of arguments the
operation was called with (using <Ref Sect="sect:ApplicableMethod"/>.
The verbosity can be controlled by the optional
integer parameter <A>verbosity</A>. The default is 1 which lists only the
number of applicable methods.
With verbosity 2 <Ref Func="ShowOtherMethods"/> lists
all installed methods and with verbosity 3 also the reasons, why they
are not applicable.
Calling <Ref Func="ShowOtherMethods"/> with verbosity 3 in this
function will normally not make any sense, because the different
numbers of arguments are simulated by supplying the corresponding
number of ones, for which normally no reasonable methods will be
installed.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:ApplicableMethod">
<Heading>Inspecting Applicable Methods</Heading>

<ManSection>
<Func Name="ApplicableMethod" Arg='opr, args[, printlevel[, nr]]'/>
<Func Name="ApplicableMethodTypes" Arg='opr, args[, printlevel[, nr]]'/>

<Description>
Called with two arguments, <Ref Func="ApplicableMethod"/> returns the
method of highest rank that is applicable for the operation <A>opr</A>
with the arguments in the list <A>args</A>.
The default <A>printlevel</A> is <C>0</C>.
If no method is applicable then <K>fail</K> is returned.
<P/>
If a positive integer is given as the fourth argument <A>nr</A> then
<Ref Func="ApplicableMethod"/> returns the <A>nr</A>-th applicable method
for the operation <A>opr</A> with the arguments in the list <A>args</A>,
where the methods are ordered according to descending rank.
If less than <A>nr</A> methods are applicable then <K>fail</K> is
returned.
<P/>
If the fourth argument <A>nr</A> is the string <C>"all"</C> then
<Ref Func="ApplicableMethod"/>
returns a list of all applicable methods for <A>opr</A> with arguments
<A>args</A>, ordered according to descending rank.
<P/>
Depending on the integer value <A>printlevel</A>, additional information is
printed.  Admissible values and their meaning are as follows.
<P/>
<List>
<Mark>0</Mark>
<Item>
    no information,
</Item>
<Mark>1</Mark>
<Item>
    information about the applicable method,
</Item>
<Mark>2</Mark>
<Item>
    also information about the not applicable methods of higher rank,
</Item>
<Mark>3</Mark>
<Item>
    also for each not applicable method the first reason why it is not
    applicable,
</Item>
<Mark>4</Mark>
<Item>
    also for each not applicable method all reasons why it is not
    applicable.
</Item>
<Mark>6</Mark>
<Item>
    also the function body of the selected method(s)
</Item>
</List>
<P/>
When a method returned by <Ref Func="ApplicableMethod"/> is called then
it returns either the desired result or the string
<C>"TRY_NEXT_METHOD"</C>, which corresponds to a call to
<Ref Func="TryNextMethod"/> in the method and means that
the method selection would call the next applicable method.
<P/>
<E>Note:</E>
The &GAP; kernel provides special treatment for the infix operations
<C>\+</C>, <C>\-</C>, <C>\*</C>, <C>\/</C>, <C>\^</C>, <C>\mod</C> and
<C>\in</C>.
For some kernel objects (notably cyclotomic numbers,
finite field elements and row vectors thereof) it calls kernel methods
circumventing the method selection mechanism.
Therefore for these operations <Ref Func="ApplicableMethod"/> may return
a method which is not the kernel method actually used.
<P/>
The function <Ref Func="ApplicableMethodTypes"/> takes the <E>types</E>
or <E>filters</E> of the arguments as argument (if only filters are given
of course family predicates cannot be tested).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tracing Methods">
<Heading>Tracing Methods</Heading>

<ManSection>
<Func Name="TraceMethods" Arg='opr1, opr2, ...' Label ="for operations"/>
<Func Name="TraceMethods" Arg='oprs' Label ="for a list of operations"/>

<Description>
After the call of <C>TraceMethods</C>,  whenever a method of one of 
the operations <A>opr1</A>, <A>opr2</A>, ... is called, the
information string used in the installation of the method is printed.
The second form has the same effect for each operation from the list
<A>oprs</A> of operations.
</Description>
</ManSection>

<ManSection>
<Func Name="TraceAllMethods" Arg=""/>

<Description>
Invokes <C>TraceMethods</C> for all operations.
</Description>
</ManSection>

<ManSection>
<Func Name="UntraceMethods" Arg='opr1, opr2, ...' Label ="for operations"/>
<Func Name="UntraceMethods" Arg='oprs' Label ="for a list of operations"/>

<Description>
turns the tracing off for all operations <A>opr1</A>, <A>opr2</A>, ... or
in the second form, for all operations in the list <A>oprs</A>.
<Log><![CDATA[
gap> TraceMethods( [ Size ] );
gap> g:= Group( (1,2,3), (1,2) );;
gap> Size( g );
#I  Size: for a permutation group at /gap5/lib/grpperm.gi:487
#I  Setter(Size): system setter
#I  Size: system getter
#I  Size: system getter
6
gap> UntraceMethods( [ Size ] );
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="UntraceAllMethods" Arg=""/>

<Description>
Equivalent to calling <C>UntraceMethods</C> for all operations.
</Description>
</ManSection>

<ManSection>
<Func Name="TraceImmediateMethods" Arg='[flag]'/>
<Func Name="UntraceImmediateMethods" Arg=''/>

<Description>
<Ref Func="TraceImmediateMethods"/> enables tracing for all immediate methods
if <A>flag</A> is either <K>true</K>, or not present.
<Ref Func="UntraceImmediateMethods"/>, or <Ref Func="TraceImmediateMethods"/>
with <A>flag</A> equal <K>false</K> turns tracing off.
(There is no facility to trace <E>specific</E> immediate methods.)
<Example><![CDATA[
gap> TraceImmediateMethods( );
gap> g:= Group( (1,2,3), (1,2) );;
#I  immediate: Size
#I  immediate: IsCyclic
#I  immediate: IsCommutative
#I  immediate: IsTrivial
gap> Size( g );
#I  immediate: IsNonTrivial
#I  immediate: Size
#I  immediate: IsFreeAbelian
#I  immediate: IsTorsionFree
#I  immediate: IsNonTrivial
#I  immediate: GeneralizedPcgs
#I  immediate: IsPerfectGroup
#I  immediate: IsEmpty
6
gap> UntraceImmediateMethods( );
gap> UntraceMethods( [ Size ] );
]]></Example>
<P/>
This example gives an explanation for the two calls of the
<Q>system getter</Q> for <Ref Func="Size"/>.
Namely, there are immediate methods that access the known size
of the group.
Note that the group <C>g</C> was known to be finitely generated already
before the size was computed,
the calls of the immediate method for
<Ref Func="IsFinitelyGeneratedGroup"/> after the call of
<Ref Func="Size"/> have other arguments than <C>g</C>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Info Functions">
<Heading>Info Functions</Heading>

The <Ref Func="Info"/> mechanism permits operations to display intermediate results or
information about the progress of the algorithms.
Information is always given according to one or more <E>info classes</E>. Each of the
info classes defined in the &GAP; library usually covers a certain range
of algorithms, so for example <C>InfoLattice</C> covers all the cyclic extension
algorithms for the computation of a subgroup lattice.
<P/>
The amount of information to be displayed can be specified by the user for
each info class separately by a <E>level</E>, the higher the level the more
information will be displayed.
Ab initio all info classes have level zero except
<Ref Func="InfoWarning"/> which initially has level 1.
<P/>
<ManSection>
<Oper Name="NewInfoClass" Arg='name'/>

<Description>
creates a new info class with name <A>name</A>.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="DeclareInfoClass" Arg='name'/>

<Description>
creates a new info class with name <A>name</A> and binds it to the global
variable <A>name</A>. The variable must previously be writable, and is made 
readonly by this function.
</Description>
</ManSection>
<P/>
<ManSection>
<Oper Name="SetInfoLevel" Arg='infoclass, level'/>

<Description>
Sets the info level for <A>infoclass</A> to <A>level</A>.
</Description>
</ManSection>
<P/>
<ManSection>
<Oper Name="InfoLevel" Arg='infoclass'/>

<Description>
returns the info level of <A>infoclass</A>.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="Info" Arg='infoclass, level, info[, moreinfo ...]'/>

<Description>
If the info level of <A>infoclass</A> is at least <A>level</A> the remaining
arguments, <A>info</A> and possibly <A>moreinfo</A> and so on, are evaluated.
(Technically, <Ref Func="Info"/> is a keyword and not a function.)
<P/>
By default, they are 
viewed, preceded by the string <C>"#I  "</C> and followed by a newline.
Otherwise the third and subsequent arguments are not evaluated.
(The latter can save substantial time when displaying difficult results.)
<P/>
The behaviour can be customized with <Ref Func="SetInfoHandler"/>.
<P/>
<Example><![CDATA[
gap> InfoExample:=NewInfoClass("InfoExample");;
gap> Info(InfoExample,1,"one");Info(InfoExample,2,"two");
gap> SetInfoLevel(InfoExample,1);
gap> Info(InfoExample,1,"one");Info(InfoExample,2,"two");
#I  one
gap> SetInfoLevel(InfoExample,2);
gap> Info(InfoExample,1,"one");Info(InfoExample,2,"two");
#I  one
#I  two
gap> InfoLevel(InfoExample);
2
gap> Info(InfoExample,3,Length(Combinations([1..9999])));
]]></Example>
<P/>
Note that the last <Ref Func="Info"/> call is executed without problems,
since the actual level <C>2</C> of <C>InfoExample</C> causes <Ref Func="Info"/> to ignore
the last argument, which prevents <C>Length(Combinations([1..9999]))</C>
from being evaluated;
note that an evaluation would be impossible due to memory restrictions.
<P/>

A set of info classes (called an <E>info selector</E>) may be passed to a
single <Ref Func="Info"/> statement. As a shorthand, info classes and selectors
may be combined with <C>+</C> rather than <Ref Func="Union" Label="for a list"/>.
In this case, the
message is triggered if the level of <E>any</E> of the classes is high enough.
<P/>
<Example><![CDATA[
gap> InfoExample:=NewInfoClass("InfoExample");;
gap> SetInfoLevel(InfoExample,0);
gap> Info(InfoExample + InfoWarning, 1, "hello");
#I  hello
gap> Info(InfoExample + InfoWarning, 2, "hello");
gap> SetInfoLevel(InfoExample,2);
gap> Info(InfoExample + InfoWarning, 2, "hello");
#I  hello
gap> InfoLevel(InfoWarning);
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Customizing <Ref Func="Info"/> statements</Heading>
<Func Arg="infoclass, handler" Name="SetInfoHandler" />
<Func Arg="infoclass, out" Name="SetInfoOutput" />
<Func Arg="out" Name="SetDefaultInfoOutput" />
<Returns>nothing</Returns>
<Description>
This allows to customize what happens in an
<C>Info(<A>infoclass</A>, <A>level</A>, ...)</C> statement.<P/> 
In the first function <A>handler</A>
must be a function with three arguments <A>infoclass</A>, <A>level</A>,
<A>list</A>. Here <A>list</A> is the list containing the third to last
argument of the <Ref Func="Info"/> call.
<P/>
The default handler is the function <C>DefaultInfoHandler</C>.
<Index Key="DefaultInfoHandler"><C>DefaultInfoHandler</C></Index>
It prints <C>"#I  "</C>, then the third and further arguments of 
the info statement, and finally a <C>"\n"</C>.
<P/>
If the first argument of an <Ref Func="Info"/> statement is a sum of
Info classes, the handler of the first summand is used.
<P/>
The file or stream to which <Ref Func="Info"/> statements for individual
<Ref Func="Info"/> classes print can be changed with 
<Ref Func="SetInfoOutput"/>. The initial default for all <Ref Func="Info"/>
classes is the string <C>"*Print*"</C> which means the current output
file. The default can be changed with <Ref Func="SetDefaultInfoOutput"/>.  
The argument <A>out</A> can be a filename or an open stream, 
the special names <C>"*Print*"</C>, <C>"*errout*</C> and <C>"*stdout*</C>
are also recognized.<P/>
For example,
<C>SetDefaultInfoOutput("*errout*");</C> would send <Ref Func="Info"/> 
output to standard error, which can be interesting if &GAP;s output is
redirected.
</Description>
</ManSection>

<ManSection>
<Var Name="InfoWarning"/>

<Description>
is an info class to which general warnings are sent at level 1,
which is its default level.
More specialised warnings are shown via calls of <Ref Func="Info"/> at
<Ref Func="InfoWarning"/> level 2,
e.g.&nbsp;information about the autoloading of &GAP; packages and the
initial line matched when displaying an on-line help topic.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Assertions">
<Heading>Assertions</Heading>

Assertions are used to find errors in algorithms.
They test whether intermediate results conform to required conditions
and issue an error if not.
<P/>
<ManSection>
<Func Name="SetAssertionLevel" Arg='lev'/>

<Description>
assigns the global assertion level to <A>lev</A>. By default it is zero.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="AssertionLevel" Arg=''/>

<Description>
returns the current assertion level.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="Assert" Arg='lev, cond[, message]'/>

<Description>
With two arguments, if the global assertion level is at least <A>lev</A>,
condition <A>cond</A> is tested and if it does not return <K>true</K> an
error is raised.
Thus <C>Assert(lev, <A>cond</A>)</C> is equivalent to the code
<Log><![CDATA[
if AssertionLevel() >= lev and not <cond> then
  Error("Assertion failure");
fi;
]]></Log>
<P/>
With the <A>message</A> argument form of the <Ref Func="Assert"/> statement,
if the global assertion level is at least <A>lev</A>, condition <A>cond</A>
is tested and if it does not return <K>true</K> then <A>message</A> is
evaluated and printed.
<P/>
Assertions are used at various places in the library.
Thus turning assertions on can slow code execution significantly.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Timing">
<Heading>Timing</Heading>

<ManSection>
<Func Name="Runtimes" Arg=''/>

<Description>
<Ref Func="Runtimes"/> returns a record with components bound to integers
or <K>fail</K>. 
Each integer is the cpu time (processor time) in milliseconds spent by &GAP;
in a certain status:
<P/>
<List>
<Mark><C>user_time</C></Mark>
<Item>
   cpu time spent with &GAP; functions (without child processes).
</Item>
<Mark><C>system_time</C></Mark>
<Item>
   cpu time spent in system calls, e.g., file access 
   (<K>fail</K> if not available).
</Item>
<Mark><C>user_time_children</C></Mark>
<Item>
   cpu time spent in child processes (<K>fail</K> if not available).
</Item>
<Mark><C>system_time_children</C></Mark>
<Item>
   cpu time spent in system calls by child processes
   (<K>fail</K> if not available).
</Item>
</List>
<P/>
Note that this function is not fully supported on all systems. Only the
<C>user_time</C> component is (and may on some systems include the system
time). 
<P/>
The following example demonstrates tasks which contribute to the different
time components:
<P/>
<Log><![CDATA[
gap> Runtimes(); # after startup
rec( user_time := 3980, system_time := 60, user_time_children := 0, 
  system_time_children := 0 )
gap> Exec("cat /usr/bin/*||wc"); # child process with a lot of file access
 893799 7551659 200928302
gap> Runtimes();
rec( user_time := 3990, system_time := 60, user_time_children := 1590, 
  system_time_children := 600 )
gap> a:=0;;for i in [1..100000000] do a:=a+1; od; # GAP user time
gap> Runtimes();  
rec( user_time := 12980, system_time := 70, user_time_children := 1590, 
  system_time_children := 600 )
gap> ?blabla  # first call of help, a lot of file access
Help: no matching entry found
gap> Runtimes();
rec( user_time := 13500, system_time := 440, user_time_children := 1590, 
  system_time_children := 600 )
]]></Log>
</Description>
</ManSection>


<ManSection>
<Func Name="Runtime" Arg=''/>

<Description>
<Ref Func="Runtime"/> returns the time spent by &GAP;
in milliseconds as an integer.
It is the same as the value of the <C>user_time</C> component given by
<Ref Func="Runtimes"/>, as explained above.
<P/>
See <Ref Func="StringTime"/> for a translation from milliseconds into
hour/minute format.
</Description>
</ManSection>


<ManSection>
<Var Name="time"/>

<Description>
In the read-eval-print loop,
<Ref Var="time"/> stores the time the last command took.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Profiling">
<Heading>Profiling</Heading>

Profiling of code can be used to determine in which parts of a program
how much time has been spent and how much memory has been allocated
during runtime.

GAP has two different methods of profiling. GAP can either profile by
function, or line-by-line. Line by line profiling is currently only
used for code coverage, while function profiling tracks memory and time
usage.

<Subsection Label="FunctionProfiling">
<Heading>Function Profiling</Heading>

This section describes how to profiling at the function level.
The idea is that
<List>
<Item>
    first one switches on profiling for those &GAP; functions
    the performance of which one wants to check,
</Item>
<Item>
    then one runs some &GAP; computations,
</Item>
<Item>
    then one looks at the profile information collected during these
    computations,
</Item>
<Item>
    then one runs more computations (perhaps clearing all profile information
    before, see <Ref Func="ClearProfile"/>),
</Item>
<Item>
    and finally one switches off profiling.
</Item>
</List>
<P/>
For switching on and off profiling, &GAP; supports entering a list of
functions
(see <Ref Func="ProfileFunctions"/>, <Ref Func="UnprofileFunctions"/>)
or a list of operations whose methods shall be (un)profiled
(<Ref Func="ProfileMethods"/>, <Ref Func="UnprofileMethods"/>),
and <Ref Func="DisplayProfile"/> can be used to show profile information
about functions in a given list.
<P/>
Besides these functions, <Ref Func="ProfileGlobalFunctions"/>,
<Ref Func="ProfileOperations"/>, and
<Ref Func="ProfileOperationsAndMethods"/> can be used for switching on
or off profiling for <E>all</E> global functions, operations, and operations
together with all their methods, respectively,
and for showing profile information about these functions.
<P/>
Note that &GAP; will perform more slowly when profiling than when not.
</Subsection>
<ManSection>
<Func Name="ProfileGlobalFunctions" Arg='[bool]'/>

<Description>
Called with argument <K>true</K>,
<Ref Func="ProfileGlobalFunctions"/>
starts profiling of all functions that have been declared via
<Ref Func="DeclareGlobalFunction"/>.
Old profile information for all these functions is cleared.
A function call with the argument <K>false</K>
stops profiling of all these functions.
Recorded information is still kept,
so you can display it even after turning the profiling off.
<P/>
When <Ref Func="ProfileGlobalFunctions"/> is called without argument,
profile information for all global functions is displayed,
see&nbsp;<Ref Func="DisplayProfile"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ProfileOperations" Arg='[bool]'/>

<Description>
Called with argument <K>true</K>,
<Ref Func="ProfileOperations"/>
starts profiling of all operations.
Old profile information for all operations is cleared.
A function call with the argument <K>false</K>
stops profiling of all operations.
Recorded information is still kept,
so you can display it even after turning the profiling off.
<P/>
When <Ref Func="ProfileOperations"/> is called without argument,
profile information for all operations is displayed
(see&nbsp;<Ref Func="DisplayProfile"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="ProfileOperationsAndMethods" Arg='[bool]'/>

<Description>
Called with argument <K>true</K>,
<Ref Func="ProfileOperationsAndMethods"/>
starts profiling of all operations and their methods.
Old profile information for these functions is cleared.
A function call with the argument <K>false</K>
stops profiling of all operations and their methods.
Recorded information is still kept,
so you can display it even after turning the profiling off.
<P/>
When <Ref Func="ProfileOperationsAndMethods"/> is called without
argument,
profile information for all operations and their methods is displayed,
see&nbsp;<Ref Func="DisplayProfile"/>.
</Description>
</ManSection>


<ManSection>
<Func Name="ProfileFunctions" Arg='funcs'/>

<Description>
starts profiling for all function in the list <A>funcs</A>.
You can use <Ref Func="ProfileGlobalFunctions"/>
to turn profiling on for all globally declared functions simultaneously.
</Description>
</ManSection>

<ManSection>
<Func Name="UnprofileFunctions" Arg='funcs'/>

<Description>
stops profiling for all function in the list <A>funcs</A>.
Recorded information is still kept, so you can  display it even after
turning the profiling off.
</Description>
</ManSection>

<ManSection>
<Func Name="ProfileMethods" Arg='ops'/>

<Description>
starts profiling of the methods for all operations in the list
<A>ops</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="UnprofileMethods" Arg='ops'/>

<Description>
stops profiling of the methods for all operations in the list <A>ops</A>.
Recorded information is still kept, so you can  display it even after
turning the profiling off.
</Description>
</ManSection>


<ManSection>
<Func Name="DisplayProfile" Arg="[functions][,][mincount, mintime]"/>
<Var Name="GAPInfo.ProfileThreshold"/>

<Description>
Called without arguments, <Ref Func="DisplayProfile"/> displays the
profile information for profiled operations, methods and functions.
If an argument <A>functions</A> is given, only profile information for
the functions in the list <A>functions</A> is shown.
If two integer values <A>mincount</A>, <A>mintime</A> are given as
arguments then the output is restricted to those functions that were
called at least <A>mincount</A> times or for which the total time spent
(see below) was at least <A>mintime</A> milliseconds.
The defaults for <A>mincount</A> and <A>mintime</A> are the entries of
the list stored in the global variable
<Ref Var="GAPInfo.ProfileThreshold"/>.
<P/>
The default value of <Ref Var="GAPInfo.ProfileThreshold"/> is
<C>[ 10000, 30 ]</C>.
<P/>
Profile information is displayed in a list of lines for all functions
(including operations and methods) which are profiled.
For each function,
<Q>count</Q> gives the number of times the function has been called.
<Q>self/ms</Q> gives the time (in milliseconds) spent in the function
itself,
<Q>chld/ms</Q> the time (in milliseconds) spent in profiled functions
called from within this function,
<Q>stor/kb</Q> the amount of storage (in kilobytes) allocated by the
function itself,
<Q>chld/kb</Q> the amount of storage (in kilobytes) allocated by
profiled functions called from within this function, and
<Q>package</Q> the name of the &GAP; package to which the function
belongs; the entry <Q>GAP</Q> in this column means that the function
belongs to the &GAP; library, the entry <Q>(oprt.)</Q> means that the
function is an operation (which may belong to several packages),
and an empty entry means that <Ref Func="FilenameFunc"/> cannot
determine in which file the function is defined.
<P/>
The list is sorted according to the total time spent in the functions,
that is the sum of the values in the columns
<Q>self/ms</Q> and <Q>chld/ms</Q>.
<P/>
At the end of the list, two lines are printed that show the total time
used and the total memory allocated by the profiled functions not shown
in the list (label <C>OTHER</C>)
and by all profiled functions (label <C>TOTAL</C>), respectively.
<P/>
An interactive variant of <Ref Func="DisplayProfile"/> is the function
<Ref Func="BrowseProfile" BookName="browse"/> that is provided by the
&GAP; package <Package>Browse</Package>.
</Description>
</ManSection>

<ManSection>
<Func Name="ClearProfile" Arg=''/>

<Description>
clears all stored profile information.
</Description>
</ManSection>


<!-- The source of the following subsection is not stored in lib/profile.g
     because the GAP output has to be adjusted from time to time,
     and this is easier if there is no indentation. -->
<Subsection Label="subsect:profiling_example">
<Heading>An Example of Function Profiling</Heading>

Let us suppose we want to get information about the computation of the
conjugacy classes of a certain permutation group.
For that,
first we create the group,
then we start profiling for all global functions and for all operations
and their methods,
then we compute the conjugacy classes,
and then we stop profiling.
<P/>
<Log><![CDATA[
gap> g:= PrimitiveGroup( 24, 1 );;
gap> ProfileGlobalFunctions( true );
gap> ProfileOperationsAndMethods( true );
gap> ConjugacyClasses( g );;
gap> ProfileGlobalFunctions( false );
gap> ProfileOperationsAndMethods( false );
]]></Log>
<P/>
Now the profile information is available.
We can list the information for all profiled functions with
<Ref Func="DisplayProfile"/>.
<P/>
<Log><![CDATA[
gap> DisplayProfile();
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function              
  17647        0        0      275        0  GAP      BasePoint             
  10230        0        0      226        0  (oprt.)  ShallowCopy           
  10139        0        0        0        0           PositionSortedOp: for*
  10001        0        0      688        0           UniteSet: for two int*
  10001        8        0       28      688  (oprt.)  UniteSet              
  14751       12        0        0        0           =: for two families: *
  10830        8        4      182      276  GAP      Concatenation         
   2700       20       12      313       55  GAP      AddRefinement         
   2444       28        4     3924      317  GAP      ConjugateStabChain    
   4368        0       32        7      714  (oprt.)  Size                  
   2174       32        4     1030      116  GAP      List                  
    585        4       32       45      742  GAP      RRefine               
   1532       32        8      194       56  GAP      AddGeneratorsExtendSc*
   1221        8       32      349      420  GAP      Partition             
 185309       28       12        0        0  (oprt.)  Length                
    336        4       40       95      817  GAP      ExtendSeriesPermGroup 
      4       28       20      488      454  (oprt.)  Sortex                
   2798        0       52       54      944  GAP      StabChainForcePoint   
    560        4       48       83      628  GAP      StabChainSwap         
    432       16       40      259      461  GAP      SubmagmaWithInversesNC
 185553       48        8      915       94  (oprt.)  Add                   
     26        0       64        0     2023  (oprt.)  CentralizerOp         
     26        0       64        0     2023  GAP      CentralizerOp: perm g*
     26        0       64        0     2023  GAP      Centralizer: try to e*
    152        4       64        0     2024  (oprt.)  Centralizer           
   1605        0       68        0     2032  (oprt.)  StabilizerOfExternalS*
     26        0       68        0     2024  GAP      Meth(StabilizerOfExte*
    382        0       96       69     1922  GAP      TryPcgsPermGroup      
   5130        4       96      309     3165  GAP      ForAll                
   7980       24      116      330     6434  GAP      ChangeStabChain       
  12076       12      136      351     6478  GAP      ProcessFixpoint       
    192        0      148        4     3029  GAP      StabChainMutable: cal*
   2208        4      148        3     3083  (oprt.)  StabChainMutable      
    217        0      160        0     3177  (oprt.)  StabChainOp           
    217       12      148       60     3117  GAP      StabChainOp: group an*
    216       36      464      334    12546  GAP      PartitionBacktrack    
   1479       12      668      566    18474  GAP      RepOpElmTuplesPermGro*
   1453       12      684       56    18460  GAP      in: perm class rep    
    126        0      728       13    19233  GAP      ConjugacyClassesTry   
      1        0      736        0    19671  GAP      ConjugacyClassesByRan*
      2        0      736        2    19678  (oprt.)  ConjugacyClasses      
      1        0      736        0    19675  GAP      ConjugacyClasses: per*
  13400     1164        0        0        0  (oprt.)  Position              
             484             12052                    OTHER                 
            2048             23319                    TOTAL                 
]]></Log>
<P/>
We can restrict the list to global functions with
<Ref Func="ProfileGlobalFunctions"/>.
<P/>
<Log><![CDATA[
gap> ProfileGlobalFunctions();
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function              
  17647        0        0      275        0  GAP      BasePoint             
  10830        8        4      182      276  GAP      Concatenation         
   2700       20       12      313       55  GAP      AddRefinement         
   2444       28        4     3924      317  GAP      ConjugateStabChain    
   2174       32        4     1030      116  GAP      List                  
    585        4       32       45      742  GAP      RRefine               
   1532       32        8      194       56  GAP      AddGeneratorsExtendSc*
   1221        8       32      349      420  GAP      Partition             
    336        4       40       95      817  GAP      ExtendSeriesPermGroup 
   2798        0       52       54      944  GAP      StabChainForcePoint   
    560        4       48       83      628  GAP      StabChainSwap         
    432       16       40      259      461  GAP      SubmagmaWithInversesNC
    382        0       96       69     1922  GAP      TryPcgsPermGroup      
   5130        4       96      309     3165  GAP      ForAll                
   7980       24      116      330     6434  GAP      ChangeStabChain       
  12076       12      136      351     6478  GAP      ProcessFixpoint       
    216       36      464      334    12546  GAP      PartitionBacktrack    
   1479       12      668      566    18474  GAP      RepOpElmTuplesPermGro*
    126        0      728       13    19233  GAP      ConjugacyClassesTry   
      1        0      736        0    19671  GAP      ConjugacyClassesByRan*
            1804             14536                    OTHER                 
            2048             23319                    TOTAL                 
]]></Log>
<P/>
We can restrict the list to operations with
<Ref Func="ProfileOperations"/>.
<P/>
<Log><![CDATA[
gap> ProfileOperations();
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function              
  10230        0        0      226        0  (oprt.)  ShallowCopy           
  10001        8        0       28      688  (oprt.)  UniteSet              
   4368        0       32        7      714  (oprt.)  Size                  
 185309       28       12        0        0  (oprt.)  Length                
      4       28       20      488      454  (oprt.)  Sortex                
 185553       48        8      915       94  (oprt.)  Add                   
     26        0       64        0     2023  (oprt.)  CentralizerOp         
    152        4       64        0     2024  (oprt.)  Centralizer           
   1605        0       68        0     2032  (oprt.)  StabilizerOfExternalS*
   2208        4      148        3     3083  (oprt.)  StabChainMutable      
    217        0      160        0     3177  (oprt.)  StabChainOp           
      2        0      736        2    19678  (oprt.)  ConjugacyClasses      
  13400     1164        0        0        0  (oprt.)  Position              
             764             21646                    OTHER                 
            2048             23319                    TOTAL                 
]]></Log>
<P/>
We can restrict the list to operations and their methods with
<Ref Func="ProfileOperationsAndMethods"/>.
<P/>
<Log><![CDATA[
gap> ProfileOperationsAndMethods();
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function              
  10230        0        0      226        0  (oprt.)  ShallowCopy           
  10139        0        0        0        0           PositionSortedOp: for*
  10001        0        0      688        0           UniteSet: for two int*
  10001        8        0       28      688  (oprt.)  UniteSet              
  14751       12        0        0        0           =: for two families: *
   4368        0       32        7      714  (oprt.)  Size                  
 185309       28       12        0        0  (oprt.)  Length                
      4       28       20      488      454  (oprt.)  Sortex                
 185553       48        8      915       94  (oprt.)  Add                   
     26        0       64        0     2023  (oprt.)  CentralizerOp         
     26        0       64        0     2023  GAP      CentralizerOp: perm g*
     26        0       64        0     2023  GAP      Centralizer: try to e*
    152        4       64        0     2024  (oprt.)  Centralizer           
   1605        0       68        0     2032  (oprt.)  StabilizerOfExternalS*
     26        0       68        0     2024  GAP      Meth(StabilizerOfExte*
    192        0      148        4     3029  GAP      StabChainMutable: cal*
   2208        4      148        3     3083  (oprt.)  StabChainMutable      
    217        0      160        0     3177  (oprt.)  StabChainOp           
    217       12      148       60     3117  GAP      StabChainOp: group an*
   1453       12      684       56    18460  GAP      in: perm class rep    
      2        0      736        2    19678  (oprt.)  ConjugacyClasses      
      1        0      736        0    19675  GAP      ConjugacyClasses: per*
  13400     1164        0        0        0  (oprt.)  Position              
             728             20834                    OTHER                 
            2048             23319                    TOTAL                 
]]></Log>
<P/>
Finally, we can restrict the list to explicitly given functions with
<Ref Func="DisplayProfile"/>,
by entering the list of functions as an argument.
<P/>
<Log><![CDATA[
gap> DisplayProfile( [ StabChainOp, Centralizer ] );
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function              
    152        4       64        0     2024  (oprt.)  Centralizer           
    217        0      160        0     3177  (oprt.)  StabChainOp           
            2044             23319                    OTHER                 
            2048             23319                    TOTAL                 
]]></Log>

<!-- extend this example by changing the thresholds, and call ClearProfile -->

</Subsection>
<Subsection Label="linebylineprofiling">
<Heading>Line By Line Profiling</Heading>
Line By Line profiling tracks which lines have been executed in a piece
of GAP code. Built into GAP are the methods necessary to generate profiles,
the resulting profiles can be displayed with the 'profiling' package.
</Subsection> 

<Subsection Label="subsect:linebylineprofexample">
<Heading>Line by Line profiling example</Heading>
There are two kinds of profiles GAP can build:

<List>
  <Item> Coverage : This records which lines of code are executed</Item>
  <Item> Timing : This records how much time is spend executing each line of code </Item>
</List>

A timing profile provides more information, but will take longer to generate
and parse.

A timing profile is generated using the functions <Ref Func="ProfileLineByLine"/>
and <Ref Func="UnprofileLineByLine"/>, as follows:

<Log><![CDATA[
gap> ProfileLineByLine("output.gz");
gap> Size(AlternatingGroup(10)); ; # Execute some GAP code you want to profile
gap> UnprofileLineByLine();
]]></Log>

For code coverage, use instead the functions <Ref Func="CoverageLineByLine"/>
and <Ref Func="UncoverageLineByLine"/>.

The profiler will only record lines which are read and executed while
the profiler is running. If you want to perform code coverage or profile
GAP's library, then you can use the GAP command  line option '--cover filename.gz',
which executes  <Ref Func="CoverageLineByLine"/> before GAP starts. Similarly
the option '--prof filename.gz' executes <Ref Func="ProfileLineByLine"/> before
GAP starts.


The profiler is designed for high performance, because of this, there are some
limitations which users should be aware of:

<List>
  <Item> By default the profiler records the wall-clock time which has passed,
    rather than the CPU time taken (because it is lower overhead), so any time
    taken writing commands will be charged to the last GAP statement which was
    executed. Therefore it is better to write a function which starts profiling,
    executes your code, and then stops profiling.
  </Item>
  <Item>
    If you end the filename with ".gz", the resulting file will automatically
    be compressed. This is highly recommended!
  </Item>
  <Item>
    The profiler can only track GAP code which occurs in a function -- this
    is most obvious when looking at code coverage examples, which will appear
    to miss lines of code in files not in a function.
  </Item>
</List>

Profiles are transformed into a human-readable form with
'profiling' package, for example with the 'OutputAnnotatedCodeCoverageFiles' function.

</Subsection>

<ManSection>
<Func Name="ProfileLineByLine" Arg="filename[,options]"/>

<Description>
<Ref Func="ProfileLineByLine"/> begins GAP recording profiling
data to the file <A>filename</A>. This file will get *very* large
very quickly. This file is compressed using gzip to reduce its size.

<A>options</A> is an optional dictionary, which sets various
configuration options. These are
<List>
<Mark>coverage</Mark>
    <Item> Boolean (defaults to false). If this is enabled,
    only information about which lines are read and executed is
    stored. Enabling this is the same as calling
    <Ref Func="CoverageLineByLine"/>. Using this ignores all other
    options.</Item>

<Mark>justStat</Mark>
    <Item> Boolean (defaults to false). This switches profiling to only
    consider entire statements, rather than parts of statements.
    In general this will provide a courser profile, but produce smaller
    files.</Item>

<Mark>wallTime</Mark>
    <Item> Boolean (defaults to true). Sets if time should be measured
    using wall-clock time or CPU time.
    (measuring wall-clock time is lower overhead).
    </Item>

<Mark>resolution</Mark>
    <Item> Integer (defaults to 0). How frequently (in nanoseconds) 
    to check which line is being executed. Setting this to a
    non-zero value improves performance and produces smaller
    traces, at the cost of accuracy. Setting this to a non-zero
    value will also make the number of executions per
    statement become inaccurance. However,i profiling
    will still accurately record which statements
    are executed at all.</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="CoverageLineByLine" Arg="filename"/>

<Description>
<Ref Func="CoverageLineByLine"/> begins GAP recording code coverage
to the file <A>filename</A>. This is equivalent to calling
<Ref Func="ProfileLineByLine"/> with coverage=true.
</Description>
</ManSection>

<ManSection>
<Func Name="UnprofileLineByLine" Arg=""/>

<Description>
Stops profiling which was previously started with
<Ref Func="ProfileLineByLine"/> or <Ref Func="CoverageLineByLine"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="UncoverageLineByLine" Arg=""/>

<Description>
Stops profiling which was previously started with
<Ref Func="ProfileLineByLine"/> or <Ref Func="CoverageLineByLine"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ActivateProfileColour" Arg=""/>

<Description>
Called with argument <K>true</K>,
<Ref Func="ActivateProfileColour"/>
makes GAP colour functions when printing them to show which lines
have been executed while profiling was active via
<Ref Func="ProfileLineByLine" /> at any time during this GAP session.
Passing <K>false</K> disables this behaviour.
</Description>
</ManSection>

<ManSection>
<Func Name="IsLineByLineProfileActive" Arg=""/>

<Description>
<Ref Func="IsLineByLineProfileActive"/> returns if line-by-line
profiling is currently activated.
</Description>
</ManSection>



<ManSection>
<Func Name="DisplayCacheStats" Arg=''/>

<Description>
displays statistics about the different caches used by the method
selection.
</Description>
</ManSection>

<ManSection>
<Func Name="ClearCacheStats" Arg=''/>

<Description>
clears all statistics about the different caches used by the method
selection.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Information about the version used">
<Heading>Information about the version used</Heading>

<Index Key="GAPInfo.Version"><C>GAPInfo.Version</C></Index>

The global variable <C>GAPInfo.Version</C> (see <Ref Var="GAPInfo"/>)
contains the version number of the version of &GAP;. Its value can be 
checked other version number using <Ref Func="CompareVersionNumbers"/>.
<P/>
To produce sample citations for the used version of &GAP; or for a 
package available in this &GAP; installation, use <Ref Func="Cite"/>.
<P/>
If you wish to report a problem to &GAP; Support or &GAP; Forum, it may
be useful to not only report the version used, but also to include the 
&GAP; banner displays the information about the architecture for which 
the &GAP; binary is built, used libraries and loaded packages.
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Test Files">
<Heading>Test Files</Heading>

Test files are used to check that &GAP; produces correct results in
certain computations. A selection of test files for the library can be
found in the <F>tst</F> directory of the &GAP; distribution.

<ManSection>
<Heading>Starting and stopping test</Heading>
<Func Name="START_TEST" Arg='id'/>
<Func Name="STOP_TEST" Arg='file, fac'/>

<Description>
<Ref Func="START_TEST"/> and <Ref Func="STOP_TEST"/> may be optionally
used in files that are read via <Ref Func="Test"/>. If used,
<Ref Func="START_TEST"/> reinitialize the caches and the global
random number generator, in order to be independent of the reading
order of several test files. Furthermore, the assertion level
(see&nbsp;<Ref Func="Assert"/>) is set to <M>2</M> (if it was lower before) by
<Ref Func="START_TEST"/> and set back to the previous value in the
subsequent <Ref Func="STOP_TEST"/> call.
<P/>
To use these options, a test file should be started with a line
<P/>
<Log><![CDATA[
gap> START_TEST( "arbitrary identifier string" );
]]></Log>
<P/>
(Note that the <C>gap> </C> prompt is part of the line!)
<P/>
and should be finished with a line
<P/>
<Log><![CDATA[
gap> STOP_TEST( "filename", 10000 );
]]></Log>
<P/>
Here the string <C>"filename"</C> should give the name of the test file.
The number is a proportionality factor that is used to output a
<Q>&GAP;stone</Q> speed ranking after the file has been completely
processed.
For the files provided with the distribution this scaling is roughly
equalized to yield the same numbers as produced by the test file
<F>tst/combinat.tst</F>.
<P/>
Note that the functions in <F>tst/testutil.g</F> temporarily replace
<Ref Func="STOP_TEST"/> before they call <Ref Func="Test"/>.
</Description>
</ManSection>


If you want to run a quick test of your &GAP; installation 
(though this is not required), you can read in a test script 
that exercises some &GAP;'s capabilities.
<P/>
<Log><![CDATA[
gap> Read( Filename( DirectoriesLibrary( "tst" ), "testinstall.g" ) );
]]></Log>
<P/>
The test requires up to 1 GB of memory and runs about one
minute on an Intel Core 2 Duo / 2.53 GHz machine.
You will get a large number of lines with output about the progress
of the tests.


<Log><![CDATA[
test file         GAP4stones     time(msec)
-------------------------------------------
testing: ................/gap4r5/tst/zlattice.tst
zlattice.tst               0              0
testing: ................/gap4r5/tst/gaussian.tst
gaussian.tst               0             10
[ further lines deleted ]
]]></Log>

If you want to run a more advanced check (this is not required and 
make take up to an hour), you can read <File>teststandard.g</File>
which is an extended test script performing all tests from the 
<File>tst</File> directory.
<P/>
<Log><![CDATA[
gap> Read( Filename( DirectoriesLibrary( "tst" ), "teststandard.g" ) );
]]></Log>
<P/>
The test requires up to 1 GB of memory and runs about one hour on an
Intel Core 2 Duo / 2.53 GHz machine, and produces an output similar 
to the <File>testinstall.g</File> test.

<P/>

<ManSection>
<Func Name="Test" Arg='fname[, optrec]'/>
<Returns><K>true</K> or <K>false</K>.</Returns>
<Description>
The argument <Arg>fname</Arg> must be the name of a file or an 
open input stream. The content of this file or stream should contain
&GAP; input and output. The function <Ref Func="Test" /> runs the input
lines, compares the actual output with the output stored in 
<Arg>fname</Arg> and reports differences. With an optional record as
argument <Arg>optrec</Arg> details of this process can be adjusted.
<P/>
More precisely, the content of <Arg>fname</Arg> must have the following
format. <Br/>
Lines starting with <C>"gap> "</C> are considered as &GAP; input, 
they can be followed by lines starting with <C>"> "</C> if the input is
continued over several lines. <Br/>
To allow for comments in <Arg>fname</Arg> the following lines are ignored
by default: lines at the beginning of <Arg>fname</Arg> that start with
<C>"#"</C>, and one empty line together with one or more lines starting 
with <C>"#"</C>.<Br/>
All other lines are considered as &GAP; output from the
preceding &GAP; input.
<P/>
By default the actual &GAP; output is compared exactly with the
stored output, and if these are different some information about the 
differences is printed.
<P/>
If any differences are found then <Ref Func="Test" /> returns <K>false</K>,
otherwise <K>true</K>.
<P/>
If the optional argument <Arg>optrec</Arg> is given it must be a record.
The following components of <Arg>optrec</Arg> are recognized and can change
the default behaviour of <Ref Func="Test" />:
<List >
<Mark><C>ignoreComments</C></Mark>
<Item>If set to <K>false</K> then no lines in <Arg>fname</Arg>
are ignored as explained above (default is <K>true</K>).</Item>
<Mark><C>width</C></Mark>
<Item>The screen width used for the new output (default is <C>80</C>).
</Item>
<Mark><C>compareFunction</C></Mark>
<Item>This must be a function that gets two strings as input, the newly
generated and the stored output of some &GAP; input. The function must
return <K>true</K> or <K>false</K>, indicating if the strings should
be considered equivalent or not. By default <Ref Oper="\=" /> is used.
<Br/>
Two strings are recognized as abbreviations in this component: 
<C>"uptowhitespace"</C> checks if the two strings become equal after
removing all white space. And <C>"uptonl"</C> compares the string up
to trailing newline characters.
</Item>
<Mark><C>reportDiff</C></Mark>
<Item>A function that gets six arguments and reports a difference in the
output: the &GAP; input, the expected &GAP; output, the newly generated
output, the name of tested file, the line number of the input, the
time to run the input. (The default is demonstrated in the example
below.)</Item>
<Mark><C>rewriteToFile</C></Mark>
<Item>If this is bound to a string it is considered as a file name
and that file is written with the same input and comment lines as
<Arg>fname</Arg> but the output substituted by the newly generated
version (default is <K>false</K>).</Item>
<Mark><C>writeTimings</C></Mark>
<Item>If this is bound to a string it is considered as a file name,
that file is written and contains timing information for each input 
in <Arg>fname</Arg>. </Item>
<Mark><C>compareTimings</C></Mark>
<Item>If this is bound to a string it is considered as name of a file to 
which timing information was stored via <C>writeTimings</C> in a previous
call. The new timings are compared to the stored ones. 
By default only commands which take more than a threshold of 
100 milliseconds are considered, and only differences of more than 20% are
considered significant. These defaults can be overwritten by assigning a 
list <C>[timingfile, threshold, percentage]</C> to this component.
(The default of <C>compareTimings</C> is <K>false</K>.)</Item>
<Mark><C>reportTimeDiff</C></Mark>
<Item>This component can be used to overwrite the default function to
display timing differences. It must be a function with 5 arguments:
&GAP; input, name of test file, line number, stored time, new time.
</Item>
<Mark><C>ignoreSTOP_TEST</C></Mark>
<Item>By default set to <K>true</K>, in that case the output of &GAP;
input starting with <C>"STOP_TEST"</C> is not checked.</Item>
<!--  don't document now, needs some work to become useful
<Mark><C>breakOnError</C></Mark>
<Item>If this is <K>true</K> then &GAP; enters a break loop in case of 
an error (default is <K>false</K>).</Item>
-->
<Mark><C>showProgress</C></Mark>
<Item>If this is <K>true</K> then &GAP; prints position information
and the input line before it is processed
(default is <K>false</K>).</Item>
<Mark><C>subsWindowsLineBreaks</C></Mark>
<Item>If this is <K>true</K> then &GAP; substitutes DOS/Windows style
line breaks "\r\n" by UNIX style line breaks "\n" after reading the test
file. (default is <K>true</K>).</Item>
</List>

<Example>
gap> tnam := Filename(DirectoriesLibrary(), "../doc/ref/demo.tst");;
gap> mask := function(str) return Concatenation("| ", 
>          JoinStringsWithSeparator(SplitString(str, "\n", ""), "\n| "),
>          "\n"); end;;
gap> Print(mask(StringFile(tnam)));
| # this is a demo file for the 'Test' function
| #
| gap> g := Group((1,2), (1,2,3));
| Group([ (1,2), (1,2,3) ])
| 
| # another comment following an empty line
| # the following fails:
| gap> a := 13+29;
| 41
gap> ss := InputTextString(StringFile(tnam));;
gap> Test(ss);
########> Diff in test stream, line 8:
# Input is:
a := 13+29;
# Expected output:
41
# But found:
42
########
false
gap> RewindStream(ss);
true
gap> dtmp := DirectoryTemporary();;
gap> ftmp := Filename(dtmp,"demo.tst");;
gap> Test(ss, rec(reportDiff := Ignore, rewriteToFile := ftmp));
false
gap> Test(ftmp);
true
gap> Print(mask(StringFile(ftmp)));
| # this is a demo file for the 'Test' function
| #
| gap> g := Group((1,2), (1,2,3));
| Group([ (1,2), (1,2,3) ])
| 
| # another comment following an empty line
| # the following fails:
| gap> a := 13+29;
| 42
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TestDirectory" Arg='inlist[, optrec]'/>
<Returns><K>true</K> or <K>false</K>.</Returns>
<Description>
The argument <Arg>inlist</Arg> must be either a single filename
or directory name, or a list of filenames and directories.
The function <Ref Func="TestDirectory" /> will take create a list of files
to be tested by taking any files in <Arg>inlist</Arg>, and recursively searching
any directories in <Arg>inlist</Arg> for files ending in <C>.tst</C>.
Each of these files is then run through <Ref Func="Test" />, and the results
printed, and <K>true</K> returned if all tests passed.
<P/>
If the optional argument <Arg>optrec</Arg> is given it must be a record.
The following components of <Arg>optrec</Arg> are recognized and can change
the default behaviour of <Ref Func="TestDirectory" />:
<List >
<Mark><C>testOptions</C></Mark>
<Item>A record which will be passed on as the second argument of <Ref Func="Test" />
if present.</Item>
<Mark><C>earlyStop</C></Mark>
<Item>If <K>true</K>, stop as soon as any <Ref Func="Test" /> fails (defaults to <K>false</K>).
</Item>
<Mark><C>showProgress</C></Mark>
<Item>Print information about how tests are progressing (defaults to <K>true</K>).
</Item>
<Mark><C>exitGAP</C></Mark>
<Item>Rather than returning <K>true</K> or <K>false</K>, exit GAP with the return value
of GAP set to success or fail, depending on if all tests passed (defaults to <K>false</K>).
</Item>
<Mark><C>stonesLimit</C></Mark>
<Item>Only try tests which take less than <C>stonesLimit</C> stones (defaults to infinity)</Item>
<Mark><C>renormaliseStones</C></Mark>
<Item>Re-normalise the stones number given in every tst files's 'STOP_TEST'</Item>
</List>

</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Debugging Recursion">
<Heading>Debugging Recursion</Heading>

The &GAP; interpreter monitors the level of nesting of &GAP;
functions during execution.
By default, whenever this nesting reaches a multiple of <M>5000</M>,
&GAP; enters a break loop (<Ref Sect="Break Loops"/>) allowing you
to terminate the calculation, or enter <B>Return</B><C>;</C> to continue it. 
<P/>
<Log><![CDATA[
gap> dive:= function(depth) if depth>1 then dive(depth-1); fi; return; end;
function( depth ) ... end
gap> dive(100);
gap> OnBreak:= function() Where(1); end; # shorter traceback
function(  ) ... end
gap> dive(6000);
recursion depth trap (5000)
 at
dive( depth - 1 );
 called from
dive( depth - 1 ); called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you may 'return;' to continue
brk> return;
gap> dive(11000);
recursion depth trap (5000)
 at
dive( depth - 1 );
 called from
dive( depth - 1 ); called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you may 'return;' to continue
brk> return;
recursion depth trap (10000)
 at
dive( depth - 1 );
 called from
dive( depth - 1 ); called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you may 'return;' to continue
brk> return;
gap> 
]]></Log>
<P/>
This behaviour can be controlled using the following procedure.

<ManSection>
<Func Name="SetRecursionTrapInterval" Arg='interval'/>

<Description>
<A>interval</A> must be a non-negative small integer (between 0 and
<M>2^{28}</M>). An <A>interval</A> of 0 suppresses the monitoring of recursion
altogether. In this case excessive recursion may cause &GAP; to crash.
<P/>
<Log><![CDATA[
gap> dive:= function(depth) if depth>1 then dive(depth-1); fi; return; end;
function( depth ) ... end
gap> SetRecursionTrapInterval(1000);
gap> dive(2500);
recursion depth trap (1000)
 at
dive( depth - 1 );
 called from
dive( depth - 1 ); called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you may 'return;' to continue
brk> return;
recursion depth trap (2000)
 at
dive( depth - 1 );
 called from
dive( depth - 1 ); called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you may 'return;' to continue
brk> return;
gap> SetRecursionTrapInterval(-1);
SetRecursionTrapInterval( <interval> ): <interval> must be a non-negative smal\
l integer
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can replace <interval> via 'return <interval>;' to continue
brk> return ();
SetRecursionTrapInterval( <interval> ): <interval> must be a non-negative smal\
l integer
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can replace <interval> via 'return <interval>;' to continue
brk> return 0;
gap> dive(20000);
gap> dive(2000000);
Segmentation fault
]]></Log>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Global Memory Information">
<Heading>Global Memory Information</Heading>

The &GAP; environment provides automatic memory management, so that
the programmer does not need to concern themselves with allocating
space for objects, or recovering space when objects are no longer
needed. The component of the kernel which provides this is called
<C>GASMAN</C> (&GAP; Storage MANager).  Messages reporting garbage
collections performed by <C>GASMAN</C> can be switched on
by the <C>-g</C> command
line option (see section <Ref Sect="Command Line Options"/>).
There are also some
facilities to access information from <C>GASMAN</C> from &GAP; programs.

<ManSection>
<Func Name="GasmanStatistics" Arg=''/>

<Description>
<Ref Func="GasmanStatistics"/> returns a record containing some
information from the garbage collection mechanism.
The record may contain up to four components:
<C>full</C>, <C>partial</C>, <C>npartial</C>, and <C>nfull</C>.
<P/>
The <C>full</C> component will be present if a full garbage collection
has taken place since &GAP; started. It contains information about
the most recent full garbage collection. It is a record, with six
components: <C>livebags</C> contains the number of bags which survived
the garbage collection; <C>livekb</C> contains the total number of
kilobytes occupied by those bags; <C>deadbags</C> contains the total
number of bags which were reclaimed by that garbage collection and
all the partial garbage collections preceding it, since the
previous full garbage collection; <C>deadkb</C> contains the total
number of kilobytes occupied by those bags; <C>freekb</C> reports the
total number of kilobytes available in the &GAP; workspace for new
objects and <C>totalkb</C> the actual size of the workspace.
<P/>
These figures should be viewed with some caution. They are
stored internally in fixed length integer formats, and <C>deadkb</C>
and <C>deadbags</C> are liable to overflow if there are many partial
collections before a full collection. Also, note that <C>livekb</C> and
<C>freekb</C> will not usually add up to <C>totalkb</C>. The difference is
essentially the space overhead of the memory management system.
<P/>
The <C>partial</C> component will be present if there has been a
partial garbage collection since the last full one. It is also a
record with the same six components as <C>full</C>. In this case
<C>deadbags</C> and <C>deadkb</C> refer only to the number and total size of
the garbage bags reclaimed in this partial garbage collection and
<C>livebags</C>and <C>livekb</C> only to the numbers and total size of the
young bags that were considered for garbage collection, and survived.
<P/>
The <C>npartial</C> and <C>nfull</C> components will contain the number 
of full and partial garbage collections performed since &GAP; started.
</Description>
</ManSection>

<ManSection>
<Func Name="GasmanMessageStatus" Arg=''/>
<Func Name="SetGasmanMessageStatus" Arg='stat'/>

<Description>
<Ref Func="GasmanMessageStatus"/> returns one of the strings
<C>"none"</C>, <C>"full"</C>, or <C>"all"</C>,
depending on whether the garbage collector is currently set to print
messages on
no collections, full collections only, or all collections, respectively. 
<P/>
Calling <Ref Func="SetGasmanMessageStatus"/> with the argument
<A>stat</A>, which should be one of the three strings mentioned above,
sets the garbage collector messaging level.
</Description>
</ManSection>

<ManSection>
<Func Name="GasmanLimits" Arg=''/>

<Description>
<Ref Func="GasmanLimits"/> returns a record with three components:
<C>min</C> is the minimum workspace size as set by the <C>-m</C>
command line option in kilobytes.
The workspace size will never be reduced below this by the garbage
collector.
<C>max</C> is the maximum workspace size,
as set by the '-o' command line option, also in kilobytes.
If the workspace would need to grow past this point,
&GAP; will enter a break loop to warn the user.
A value of 0 indicates no limit.
<C>kill</C> is the absolute maximum, set by the <C>-K</C> command line
option.
The workspace will never be allowed to grow past this limit.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  options.msk                    GAP documentation             Steve Linton -->
<!-- %% -->
<!-- %A  @(#)<M>Id: options.msk,v 1.9 2002/06/07 14:04:42 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Options Stack">
<Heading>Options Stack</Heading>

&GAP; supports a <E>global options system</E>. This is intended as a
way for the user to provide guidance to various algorithms that
might be used in a computation. Such guidance should not change
mathematically the specification of the computation to be
performed, although it may change the algorithm used. A typical
example is the selection of a strategy for the Todd-Coxeter coset
enumeration procedure. An example of something not suited to the
options mechanism is the imposition of exponent laws in the
<M>p</M>-Quotient algorithm.
<P/>
The basis of this system is a global stack of records. All the
entries of each record are thought of as options settings, and the 
effective setting of an option is given by the topmost record
in which the relevant field is bound.
<P/>
The reason for the choice of a stack is the intended pattern of use:
<P/>
<C>PushOptions( rec( <A>stuff</A> ) );</C>
<P/>
<C>DoSomething( <A>args</A> );</C>
<P/>
<C>PopOptions();</C>
<P/>
This can be abbreviated,
to <C>DoSomething( <A>args</A> : <A>stuff</A> );</C> with
a small additional abbreviation of <A>stuff</A> permitted. See
<Ref Subsect="Function Call With Options"/> for details. The full form
can be used where the same options are to run across several
calls, or where the <C>DoSomething</C> procedure is actually an infix
operator, or other function with special syntax. 
<P/>
An alternative to this system is the use of additional optional
arguments in procedure calls. This is not felt to be sufficient
because many procedure calls might cause, for example, a coset
enumeration and each would need to make provision for the
possibility of extra arguments. In this system the options are
pushed when the user-level procedure is called, and remain in
effect (unless altered) for all procedures called by it.
<P/>
Note that in some places in the system optional records containing
options which are valid only for the immediate function or method
call are in fact used.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Options Stack">
<Heading>Functions Dealing with the Options Stack</Heading>

<ManSection>
<Func Name="PushOptions" Arg='options record'/>

<Description>
This function pushes a record of options onto the global option stack.
Note that <C>PushOptions( rec( <A>opt</A>:= fail ) )</C> has the effect
of resetting the option <A>opt</A>, since an option that has never been
set has the value <K>fail</K> returned by <Ref Func="ValueOption"/>.
<P/>
Note that there is no check for misspelt or undefined options.
</Description>
</ManSection>

<ManSection>
<Func Name="PopOptions" Arg=''/>

<Description>
This function removes the top-most options record from the options stack
if there is one.
</Description>
</ManSection>

<ManSection>
<Func Name="ResetOptionsStack" Arg=''/>

<Description>
unbinds (i.e. removes) all the options records from the options stack.
<P/>
<E>Note:</E>
<Ref Func="ResetOptionsStack"/> should <E>not</E> be used within a
function.
Its intended use is to clean up the options stack in the event
that the user has <K>quit</K> from a <K>break</K> loop,
so leaving a stack of no-longer-needed options
(see&nbsp;<Ref Subsect="quit"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="OnQuit" Arg=''/>

<Description>
called when a user selects to <C>quit;</C> a break loop entered via
execution of <Ref Func="Error"/>.
As &GAP; starts up, <Ref Func="OnQuit"/> is defined to do nothing,
in case an error is encountered during &GAP; start-up.
Later in the loading process we redefine <Ref Func="OnQuit"/> to do a variant of
<Ref Func="ResetOptionsStack"/> to ensure the options stack is empty
after a user quits an <Ref Func="Error"/>-induced break loop.
(<Ref Func="OnQuit"/> differs from <Ref Func="ResetOptionsStack"/>
in that it warns when it does something rather than the other way round.)
Currently, <Ref Func="OnQuit"/> is not advertised,
since exception handling may make it obsolete.
</Description>
</ManSection>

<ManSection>
<Func Name="ValueOption" Arg='opt'/>

<Description>
This function is a method for accessing the options stack without
changing it;
<A>opt</A> should be the name of an option, i.e.&nbsp;a string.
A function which makes decisions that might be affected by options
should examine the result of <Ref Func="ValueOption"/>.
If <A>opt</A> is currently not set then <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Func Name="DisplayOptionsStack" Arg=''/>

<Description>
This function prints a human-readable display of the complete
options stack.
<P/>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoOptions"/>

<Description>
This info class can be used to enable messages about options being 
changed (level 1) or accessed (level 2).
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Options Stack Example">
<Heading>Options Stack &ndash; an Example</Heading>

The example below shows simple manipulation of the Options Stack,
first using <Ref Func="PushOptions"/> and <Ref Func="PopOptions"/>
and then using the special function calling syntax. 
<P/>
<Example><![CDATA[
gap> foo := function()
> Print("myopt1 = ", ValueOption("myopt1"),
>       " myopt2 = ",ValueOption("myopt2"),"\n");
> end;
function(  ) ... end
gap> foo();
myopt1 = fail myopt2 = fail
gap> PushOptions(rec(myopt1 := 17));
gap> foo();
myopt1 = 17 myopt2 = fail
gap> DisplayOptionsStack();
[ rec(
      myopt1 := 17 ) ]
gap> PopOptions();
gap> foo();
myopt1 = fail myopt2 = fail
gap> foo( : myopt1, myopt2 := [Z(3),"aardvark"]);
myopt1 = true myopt2 = [ Z(3), "aardvark" ]
gap> DisplayOptionsStack();
[  ]
gap> 
]]></Example>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  files.msk                 GAP documentation              Frank Celler -->
<!-- %W                                                     & Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: files.msk,v 1.4 2003/03/26 17:46:07 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<!-- %%  This file    contains the  description of   the   file, filename  and -->
<!-- %%  directory functions. -->
<!-- %% -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Files and Filenames">
<Heading>Files and Filenames</Heading>

Files are identified by filenames, which are represented in &GAP; as
strings.  Filenames can be created directly by the user or a program, but
of course this is operating system dependent.
<P/>
Filenames for some files can  be constructed in  a system independent way
using the following functions.  This is done by first getting a directory
object for the directory the file shall  reside in, and then constructing
the filename.  However, it is  sometimes necessary to construct filenames
of files in subdirectories relative to a given directory object.  In this
case the directory separator is <E>always</E> <C>/</C> even under DOS or
MacOS.
<P/>
Section <Ref Sect="Directories"/> describes how to construct directory objects
for the common &GAP; and system directories.
Using the command <Ref Func="Filename" Label="for a directory and a string"/>
it is possible to construct a filename pointing to a file in these
directories.
There are also functions to test for accessibility of files,
see&nbsp;<Ref Sect="File Access"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Portability">
<Heading>Portability</Heading>

For portability filenames and directory  names should be restricted to at
most   8 alphanumerical characters  optionally followed  by a dot <C>.</C>
and between 1 and 3 alphanumerical characters.  Upper case letters should
be  avoided because some  operating systems  do  not make any distinction
between case,  so that <C>NaMe</C>, <C>Name</C>  and  <C>name</C> all  refer to the same
file  whereas  some   operating  systems are case   sensitive.   To avoid
problems only lower case characters should be used.
<P/>
Another function which is system-dependent is <Ref Func="LastSystemError"/>.

<ManSection>
<Func Name="LastSystemError" Arg=''/>

<Description>
<Ref Func="LastSystemError"/> returns a record describing the last system
error that has occurred.
This record  contains at least the component <C>message</C> which is a
string. This message is, however, highly operating system dependent and
should only be used as an informational message for the user.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="GAP Root Directories">
<Heading>GAP Root Directories</Heading>
<Index Key="GAPInfo.RootPaths"><C>GAPInfo.RootPaths</C></Index>
<Index Key="GAPInfo.UserGapRoot"><C>GAPInfo.UserGapRoot</C></Index>

When &GAP; is started it determines a list of directories which we
call the <E>&GAP; root directories</E>. In a running &GAP; session  
this list can be found in <C>GAPInfo.RootPaths</C>.
<P/>
The core part of &GAP; knows which files to read relative to its root 
directories. For example when &GAP; wants to read its library file 
<F>lib/group.gd</F>, it appends this path to each path in 
<C>GAPInfo.RootPaths</C> until it finds the path of an existing file.
The first file found this way is read.
<P/>
Furthermore, &GAP; looks for available packages by examining the
subdirectories <F>pkg/</F> in each of the directories in 
<C>GAPInfo.RootPaths</C>.
<P/>
The root directories are specified via one or several of the 
<C>-l paths</C> command line options, see <Ref Sect="Command Line Options"/>.
Furthermore, by default &GAP; automatically prepends a user specific &GAP; root
directory to the list; this can be avoided by calling &GAP; with 
the <C>-r</C>  option. The name of this user specific directory depends
on your operating system, it can be found in <C>GAPInfo.UserGapRoot</C>.
This directory can be used to tell &GAP; about personal preferences,
to always load some additional code, to install additional packages,
or to overwrite some &GAP; files. See <Ref Sect="sect:gap.ini"/>
for more information how to do this.
<P/>

<!--
  FL: An example how to overwrite the library file lib/files.gd doesn't
      look useful for me. We should not encourage users to make use
      of this possibility. That it can be done in principle as described below
      is also clear from the shorter description above.

<Index Key=".gap directory"><F>.gap</F> directory</Index>


When starting &GAP; it is possible to specify various directories as
root directories.  In &GAP;'s view of the world these directories are
merged into one meta-directory.  This directory is called <E>&GAP; root
directory</E> in the following.
<P/>
For example, suppose that <C>root1;root2;...</C> is passed as argument
to <C>-l</C> when &GAP; is started and &GAP; wants to locate a file
<F>lib/group.gd</F> in the &GAP; root directory.
If the command line option <C>-r</C> is not given then &GAP; will first
check if the file exists in the <F>.gap</F> subdirectory of the user's
home directory. On Mac OS X, the directory <F>Library/Preferences/GAP</F>
in the user's home directory will be searched next.
If the command line option <C>-r</C> is given or if the file does not
exist inside <F>.gap</F> (or <F>Library/Preferences/GAP</F>) 
then the directory <C>root1</C> is checked next,
and if the file is not found there, <C>root2</C> is checked, and so on.
<P/>
This layout makes it possible to have one system-wide installation of &GAP;
which is read-only but still allows users to modify individual files.
Therefore instead of constructing an absolute path name to a file
you should always use <Ref Func="DirectoriesLibrary"/> or
<Ref Func="DirectoriesPackageLibrary"/> together with
<Ref Func="Filename" Label="for a directory and a string"/>
to construct a filename for a file in the &GAP; root directory.
<P/>
<E>For example</E>,
suppose that the system-wide installation lives in <F>/usr/local/lib/gap4</F>
and you want to modify the file <F>lib/files.gd</F> without disturbing the
system installation.
<P/>
The simplest way to achieve this is to create a directory <F>.gap</F>
in your home directory, and a subdirectory <F>lib</F> which contains
the modified <F>lib/files.gd</F>.
Afterwards, when you start &GAP; then the modified file is read
instead of <F>/usr/local/lib/gap4/lib/files.gd</F>,
except if the <C>-r</C> command line option
(see <Ref Sect="Command Line Options"/>) is given.
<P/>
As an alternative to the <F>.gap</F> directory,
you can also use another directory which then must be mentioned in the
directories that are passed as argument to <C>-l</C>.
This variant can be useful if the changed files shall be used by several
users.
For example, you may create a new directory <F>/home/myhome/gap</F>
containing a subdirectory <F>lib</F> which contains the modified
<F>lib/files.gd</F>.
<P/>
The directory/file structure now looks like
<P/>
<Log><![CDATA[
/usr/local/lib/gap4/
/usr/local/lib/gap4/lib/
/usr/local/lib/gap4/lib/files.gd
/home/myhome/gap/
/home/myhome/gap/lib
/home/myhome/gap/lib/files.gd
]]></Log>
<P/>

If you start &GAP; using (under UNIX)
<P/>
<Log><![CDATA[
you@unix> gap -l '/home/myhome/gap;/usr/local/lib/gap4'
]]></Log>
<P/>
then the file <F>/home/myhome/gap/lib/files.gd</F> will be used whenever
&GAP; references the file with filename <F>lib/files.gd</F> relative to
the &GAP; root directory.
<P/>
This setup also allows one to easily install new &GAP; packages or bugfixes
even if no write access to the system &GAP; installation is possible.
Simply unpack the files into your <F>.gap</F> directory
or into <F>/home/myhome/gap</F>, respectively.
-->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Directories">
<Heading>Directories</Heading>

<ManSection>
<Filt Name="IsDirectory" Arg='obj' Type='Category'/>

<Description>
<Ref Filt="IsDirectory"/> is a category of directories. 
</Description>
</ManSection>

<ManSection>
<Oper Name="Directory" Arg='string'/>

<Description>
returns a directory object for the string <A>string</A>.
<Ref Func="Directory"/> understands <C>"."</C> for
<Q>current directory</Q>, that is,
the directory in which &GAP; was started.
It also understands absolute paths.
<P/>
If the variable <C>GAPInfo.UserHome</C> is defined (this may depend on
the operating system) then <Ref Func="Directory"/> understands a string
with a leading <C>~</C> (tilde) character for a path relative to the
user's home directory (but a  string beginning with <C>"~other_user"</C>
is <E>not</E> interpreted as a path relative to <C>other_user</C>'s
home directory, as in a UNIX shell).
<P/>
Paths are otherwise taken relative to the current directory.
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoryTemporary" Arg=''/>

<Description>
returns a directory object in the category <Ref Filt="IsDirectory"/>
for a <E>new</E> temporary directory.
This is guaranteed to be newly created and empty immediately after the
call to <Ref Func="DirectoryTemporary"/>.
&GAP; will make a reasonable effort to remove this directory
upon termination of the &GAP; job that created the directory.
<P/>
If <Ref Func="DirectoryTemporary"/> is unable to create a new directory,
<K>fail</K> is returned.
In this case <Ref Func="LastSystemError"/> can be used to get information
about the error.
<P/>
A warning message is given if more than 1000 temporary directories are 
created in any &GAP; session.
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoryCurrent" Arg=''/>

<Description>
returns the directory object for the current directory.
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoriesLibrary" Arg='[name]'/>

<Description>
<Ref Func="DirectoriesLibrary"/> returns the directory objects for the
&GAP; library <A>name</A> as a list.
<A>name</A> must be one of <C>"lib"</C> (the default), <C>"doc"</C>,
<C>"tst"</C>, and so on.
<P/>
The string <C>""</C> is also legal and with this argument
<Ref Func="DirectoriesLibrary"/> returns the list of
&GAP; root directories.
The return value of this call differs from <C>GAPInfo.RootPaths</C>
in that the former is a list of directory objects
and the latter a list of strings.
<P/>
The directory <A>name</A> must exist in at least one of the
root directories,
otherwise <K>fail</K> is returned.
<!-- why the hell was this defined that way?-->
<!-- returning an empty list would be equally good!-->
<P/>
As the files in the &GAP; root directories
(see&nbsp;<Ref Sect="GAP Root Directories"/>) can be distributed into
different directories in the filespace a list of directories is returned.
In order to find an existing file in a &GAP; root directory you should
pass that list to
<Ref Func="Filename" Label="for a directory and a string"/> as the first
argument.
In order to create a filename for a new file inside a &GAP; root
directory you should pass the first entry of that list.
However, creating files inside the &GAP; root directory is not
recommended, you should use <Ref Func="DirectoryTemporary"/> instead.
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoriesSystemPrograms" Arg=''/>

<Description>
<Ref Func="DirectoriesSystemPrograms"/> returns the directory objects
for the list of directories where the system programs reside, as a list.
Under UNIX this would usually represent <C>$PATH</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoryContents" Arg='dir'/>

<Description>
This function returns a list of filenames/directory names that reside in
the directory <A>dir</A>. The argument <A>dir</A> can either be given as 
a string indicating the name of the directory or as a directory object
(see <Ref Filt="IsDirectory"/>).
It is an error, if such a directory does not exist. 
<P/>
The ordering of the list entries can depend on the operating system.
<P/>
An interactive way to show the contents of a directory is provided by the
function <Ref Func="BrowseDirectory" BookName="browse"/> from the
&GAP; package <Package>Browse</Package>.
</Description>
</ManSection>

<ManSection>
<Oper Name="DirectoryDesktop" Arg=''/>

<Description>
returns a directory object for the users desktop directory as defined on
many modern operating systems. 
The function is intended to provide a cross-platform interface to a
directory that is easily accessible by the user.

Under Unix systems (including Mac OS X) this will be the
<C>Desktop</C> directory in the users home directory if it exists, and
the users home directory otherwise. 
Under Windows it will the users <C>Desktop</C> folder
(or the appropriate name under different
languages).
</Description>
</ManSection>

<ManSection>
<Oper Name="DirectoryHome" Arg=''/>

<Description>
returns a directory object for the users home directory, defined as a
directory in which the user will typically have full read and write
access.
The function is intended to provide a cross-platform interface to a
directory that is easily accessible by the user.

Under Unix systems (including Mac OS X) this will be the
usual user home directory. Under Windows it will the users 
<C>My Documents</C> folder (or the appropriate name under different
languages).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="File Names">
<Heading>File Names</Heading>

<ManSection>
<Heading>Filename</Heading>
<Oper Name="Filename" Arg='dir, name'
 Label="for a directory and a string"/>
<Oper Name="Filename" Arg='list-of-dirs, name'
 Label="for a list of directories and a string"/>

<Description>
If the first argument is a directory object <A>dir</A>,
<Ref Func="Filename" Label="for a directory and a string"/> returns the
(system dependent) filename as a string for the file with name
<A>name</A> in the directory <A>dir</A>.
<Ref Func="Filename" Label="for a directory and a string"/> returns the
filename regardless of whether the directory contains a file with name
<A>name</A> or not.
<P/>
If the first argument is a list <A>list-of-dirs</A>
(possibly of length 1) of directory objects, then
<Ref Func="Filename" Label="for a list of directories and a string"/>
searches the directories in order, and returns the filename for the file
<A>name</A> in the first directory which contains a file <A>name</A> or
<K>fail</K> if no directory contains a file <A>name</A>.
<P/>
<E>For example</E>,
in order to locate the system program <C>date</C> use
<Ref Func="DirectoriesSystemPrograms"/> together with the second form of
<Ref Func="Filename" Label="for a list of directories and a string"/>.
<P/>
<Log><![CDATA[
gap> path := DirectoriesSystemPrograms();;
gap> date := Filename( path, "date" );
"/bin/date"
]]></Log>
<P/>
In order to locate the library file <F>files.gd</F> use
<Ref Func="DirectoriesLibrary"/> together with the second form of
<Ref Func="Filename" Label="for a list of directories and a string"/>.
<P/>
<Log><![CDATA[
gap> path := DirectoriesLibrary();;
gap> Filename( path, "files.gd" );
"./lib/files.gd"
]]></Log>
<P/>
In order to construct filenames for new files in a temporary directory
use <Ref Func="DirectoryTemporary"/> together with the first form of
<Ref Func="Filename" Label="for a directory and a string"/>.
<P/>
<Log><![CDATA[
gap> tmpdir := DirectoryTemporary();;
gap> Filename( [ tmpdir ], "file.new" );
fail
gap> Filename( tmpdir, "file.new" );
"/var/tmp/tmp.0.021738.0001/file.new"
]]></Log>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Special Filenames">
<Heading>Special Filenames</Heading>

The special filename <C>"*stdin*"</C> denotes the standard input, i.e.,
the stream through which the user enters commands to &GAP;.
The exact behaviour of reading from <C>"*stdin*"</C> is operating system
dependent, but usually the following happens.
If &GAP; was started with no input redirection,
statements are read from the terminal stream until the user enters the
end of file character, which is usually <B>Ctrl-D</B>.
Note that terminal streams are special, in that they may yield ordinary input
<E>after</E> an end of file.
Thus when control returns to the main read-eval-print loop the user can
continue with &GAP;.
If &GAP; was started with an input redirection, statements are read from the
current position in the input file up to the end of the file.
When control returns to the main read eval view loop the input stream will
still return end of file, and &GAP; will terminate.
<P/>
The  special filename <C>"*errin*"</C> denotes the stream connected to the
UNIX <C>stderr</C> output.
This stream is usually connected to the terminal, even if the standard input
was redirected, unless the standard error stream was also redirected,
in which case opening of <C>"*errin*"</C> fails.
<P/>
The special filename <C>"*stdout*"</C> can be used to print to the standard
output.
<P/>
The special filename <C>"*errout*"</C> can be used to print to the standard
error output file, which is usually connected to the terminal,
even if the standard output was redirected.
    
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="File Access">
<Heading>File Access</Heading>

When the following functions return <K>false</K> one can use
<Ref Func="LastSystemError"/> to find out the reason (as provided by the
operating system), see the examples.

<ManSection>
<Func Name="IsExistingFile" Arg='filename'/>

<Description>
<Ref Func="IsExistingFile"/>
returns <K>true</K> if a file with the filename <A>filename</A> exists
and can be seen by the &GAP; process. Otherwise <K>false</K> is returned.
<P/>
<Example><![CDATA[
gap> IsExistingFile( "/bin/date" );     # file `/bin/date' exists
true
gap> IsExistingFile( "/bin/date.new" ); # non existing `/bin/date.new'
false
gap> IsExistingFile( "/bin/date/new" ); # `/bin/date' is not a directory
false
gap> LastSystemError().message;
"Not a directory"
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="IsReadableFile" Arg='filename'/>

<Description>
<Ref Func="IsReadableFile"/>
returns <K>true</K> if a file with the filename <A>filename</A> exists
<E>and</E> the &GAP; process has read permissions for the file,
or <K>false</K> if this is not the case.
<P/>
<Example><![CDATA[
gap> IsReadableFile( "/bin/date" );     # file `/bin/date' is readable
true
gap> IsReadableFile( "/bin/date.new" ); # non-existing `/bin/date.new'
false
gap> LastSystemError().message;        
"No such file or directory"
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="IsWritableFile" Arg='filename'/>

<Description>
<Ref Func="IsWritableFile"/>
returns <K>true</K> if a file with the filename <A>filename</A> exists
<E>and</E> the &GAP; process has write permissions for the file,
or <K>false</K> if this is not the case.
<P/>
<Example><![CDATA[
gap> IsWritableFile( "/bin/date" );  # file `/bin/date' is not writable
false
]]></Example>
<P/>
</Description>
</ManSection>


<ManSection>
<Func Name="IsExecutableFile" Arg='filename'/>

<Description>
<Ref Func="IsExecutableFile"/>
returns <K>true</K> if a file with the filename <A>filename</A> exists
<E>and</E> the &GAP; process has execute permissions for the file,
or <K>false</K> if this is not the case.
Note that execute permissions do not imply that it is possible
to execute the file, e.g., it may only be executable on a different machine.
<P/>
<Example><![CDATA[
gap> IsExecutableFile( "/bin/date" );   # ... but executable
true
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="IsDirectoryPath" Arg='filename'/>

<Description>
<Ref Func="IsDirectoryPath"/>
returns <K>true</K> if the file with the filename <A>filename</A> exists
<E>and</E> is a directory,
and <K>false</K> otherwise.
Note that this function does not check if the &GAP; process actually has
write or execute permissions for the directory.
You can use <Ref Func="IsWritableFile"/>,
resp. <Ref Func="IsExecutableFile"/> to check such permissions.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="File Operations">
<Heading>File Operations</Heading>

<ManSection>
<Oper Name="Read" Arg='filename'/>

<Description>
reads the input from the file with the filename <A>filename</A>,
which must be given as a string.
<P/>
<Ref Func="Read"/> first opens the file <A>filename</A>.
If the file does not exist, or if &GAP; cannot open it,
e.g., because of access restrictions, an error is signalled.
<P/>
Then the contents of the file are read and evaluated, but the results are
not printed.  The reading and evaluations happens exactly as described
for the main loop (see <Ref Sect="Main Loop"/>).
<P/>
If a statement in the file causes an error a break loop is entered
(see&nbsp;<Ref Sect="Break Loops"/>).
The input for this break loop is not taken from the file, but from the
input connected to the <C>stderr</C> output of &GAP;.
If <C>stderr</C> is not connected to a terminal,
no break loop is entered.
If this break loop is left with <K>quit</K> (or <B>Ctrl-D</B>),
&GAP; exits from the <Ref Func="Read"/> command, and from all enclosing
<Ref Func="Read"/> commands, so that control is normally returned to an
interactive prompt.
The <K>QUIT</K> statement (see&nbsp;<Ref Sect="Leaving GAP"/>) can also
be used in the break loop to exit &GAP; immediately.
<P/>
Note that a statement must not begin in one file and end in another.
I.e., <E>eof</E> (<E>e</E>nd-<E>o</E>f-<E>f</E>ile) is not treated as
whitespace,
but as a special symbol that must not appear inside any statement.
<P/>
Note that one file may very well contain a read statement causing another
file to be read, before input is again taken from the first file.
There is an upper limit of 15 on the number of files
that may be open simultaneously.
</Description>
</ManSection>

<ManSection>
<Oper Name="ReadAsFunction" Arg='filename'/>

<Description>
reads the file with filename <A>filename</A> as a function
and returns this function.
<P/>
<E>Example</E>
<P/>
Suppose that the file <F>/tmp/example.g</F> contains the following
<P/>
<Log><![CDATA[
local a;

a := 10;
return a*10;
]]></Log>
<P/>
Reading the file as a function will not affect a global variable <C>a</C>.
<P/>
<Log><![CDATA[
gap> a := 1;
1
gap> ReadAsFunction("/tmp/example.g")();
100
gap> a;
1
]]></Log>
</Description>
</ManSection>


<ManSection>
<Heading>PrintTo and AppendTo</Heading>
<Func Name="PrintTo" Arg='filename[, obj1, ...]'/>
<Func Name="AppendTo" Arg='filename[, obj1, ...]'/>

<Description>
<Ref Func="PrintTo"/> works like <Ref Func="Print"/>,
except that the arguments <A>obj1</A>, <M>\ldots</M> (if present) are printed
to the file with the name <A>filename</A> instead of the standard output.
This file must of course be writable by &GAP;.
Otherwise an error is signalled.
Note that <Ref Func="PrintTo"/> will <E>overwrite</E> the previous contents
of this file if it already existed;
in particular, <Ref Func="PrintTo"/> with just the <A>filename</A> argument
empties that file.
<P/>
<Ref Func="AppendTo"/> works like <Ref Func="PrintTo"/>,
except that the output does not overwrite the previous contents of the file,
but is appended to the file.
<P/>
There is an upper limit of 15 on the number of output files 
that may be open simultaneously.
<P/>
<E>Note</E> that one should be careful not to write to a logfile
(see <Ref Func="LogTo" Label="for a filename"/>) with
<Ref Func="PrintTo"/> or <Ref Func="AppendTo"/>.
<!-- % The same holds of course for the redirection of output to a file. -->
</Description>
</ManSection>


<ManSection>
<Heading>LogTo</Heading>
<Oper Name="LogTo" Arg='filename' Label="for a filename"/>
<Oper Name="LogTo" Arg='' Label="stop logging"/>

<Description>
Calling <Ref Func="LogTo" Label="for a filename"/> with a string
<A>filename</A> causes the subsequent interaction to be logged to the file
with the name <A>filename</A>,
i.e., everything you see on your terminal will also appear in this file.
(<Ref Func="LogTo" Label="for streams"/> may also be used to log to a stream.)
This file must of course be writable by &GAP;, otherwise an error is
signalled.
Note that <Ref Func="LogTo" Label="for a filename"/> will overwrite the
previous contents of this file if it already existed.
<P/>
Called without arguments,
<Ref Func="LogTo" Label="stop logging"/> stops logging to a file or stream.
</Description>
</ManSection>


<ManSection>
<Heading>InputLogTo</Heading>
<Oper Name="InputLogTo" Arg='filename' Label="for a filename"/>
<Oper Name="InputLogTo" Arg='' Label="stop logging input"/>

<Description>
Calling <Ref Func="InputLogTo" Label="for a filename"/> with a string
<A>filename</A> causes the subsequent input to be logged to the file
with the name <A>filename</A>,
i.e., everything you type on your terminal will also appear in this file.
Note that <Ref Func="InputLogTo" Label="for a filename"/> and
<Ref Func="LogTo" Label="for a filename"/> cannot be used at the same time
while <Ref Func="InputLogTo" Label="for a filename"/> and
<Ref Func="OutputLogTo" Label="for a filename"/> can.
Note that <Ref Func="InputLogTo" Label="for a filename"/> will overwrite the
previous contents of this file if it already existed.
<P/>
Called without arguments,
<Ref Func="InputLogTo" Label="stop logging input"/> stops logging to a file
or stream.
</Description>
</ManSection>


<ManSection>
<Heading>OutputLogTo</Heading>
<Oper Name="OutputLogTo" Arg='filename' Label="for a filename"/>
<Oper Name="OutputLogTo" Arg='' Label="stop logging output"/>

<Description>
Calling <Ref Func="OutputLogTo" Label="for a filename"/> with a string
<A>filename</A> causes the subsequent output to be logged to the file
with the name <A>filename</A>,
i.e., everything &GAP; prints on your terminal will also appear in this file.
Note that <Ref Func="OutputLogTo" Label="for a filename"/> and
<Ref Func="LogTo" Label="for a filename"/> cannot be used at the same time
while <Ref Func="InputLogTo" Label="for a filename"/> and
<Ref Func="OutputLogTo" Label="for a filename"/> can.
Note that <Ref Func="OutputLogTo" Label="for a filename"/> will overwrite the
previous contents of this file if it already existed.
<P/>
Called without arguments,
<Ref Func="OutputLogTo" Label="stop logging output"/> stops logging to a file
or stream.
</Description>
</ManSection>

<ManSection>
<Func Name="CrcFile" Arg='filename'/>

<Description>
CRC (cyclic redundancy check) numbers provide a certain method of doing
checksums. They are used by &GAP; to check whether
files have changed.
<P/>
<Ref Func="CrcFile"/> computes a checksum value for the file with
filename <A>filename</A> and returns this value as an integer.
The function returns <K>fail</K> if a system error occurred, say,
for example, if <A>filename</A> does not exist.
In this case the function <Ref Func="LastSystemError"/>
can be used to get information about the error.
<P/>
<Log><![CDATA[
gap> CrcFile( "lib/morpheus.gi" );
2705743645
]]></Log>
</Description>
</ManSection>



<ManSection>
<Func Name="RemoveFile" Arg='filename'/>

<Description>
will remove the file with filename <A>filename</A> and returns <K>true</K> in case
of  success.  The function returns <K>fail</K> if a system error occurred, for
example, if your permissions do not allow the removal of <A>filename</A>.
In this case the function <Ref Func="LastSystemError"/>
can be used to get information about the error.
</Description>
</ManSection>



<ManSection>
<Func Name="Reread" Arg='filename'/>
<Var Name="REREADING"/>

<Description>
In general, it is not possible to read the same &GAP; library file
twice, or to read a compiled version after reading a &GAP; version,
because crucial global variables are made read-only
(see <Ref Sect="More About Global Variables"/>)
and filters and methods are added to global tables.
<P/>
A partial solution to this problem is provided by the function
<Ref Func="Reread"/> (and related functions <C>RereadLib</C> etc.).
<C>Reread( <A>filename</A> )</C> sets the global variable
<Ref Var="REREADING"/> to <K>true</K>,
reads the file named by <A>filename</A> and then resets
<Ref Var="REREADING"/>.
Various system functions behave differently when <Ref Var="REREADING"/>
is set to <K>true</K>.
In particular, assignment to read-only global variables is permitted,
calls to <Ref Func="NewRepresentation"/>
and <Ref Func="NewInfoClass"/> with parameters identical to those
of an existing representation or info class will return the existing
object, and methods installed with
<Ref Func="InstallMethod"/> may sometimes displace
existing methods.
<P/>
This function may not entirely produce the intended results,
especially if what has changed is the super-representation of a
representation or the requirements of a method. In these cases, it is
necessary to restart &GAP; to read the modified file.
<P/>
An additional use of <Ref Func="Reread"/> is to load the compiled version
of a file for which the &GAP; language version had previously been read
(or perhaps was included in a saved workspace).
See <Ref Label="Kernel modules"/> and
<Ref Sect="Saving and Loading a Workspace"/> for more information.
<P/>
It is not advisable to use <Ref Func="Reread"/> programmatically.
For example, if a file that contains calls to <Ref Func="Reread"/>
is read with <Ref Func="Reread"/> then <Ref Var="REREADING"/> may be
reset too early.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  streams.msk               GAP documentation              Frank Celler -->
<!-- %W                                                       Martin Schönert -->
<!-- %W                                                         & Steve Linton -->
<!-- %% -->
<!-- %H  @(#)<M>Id: streams.msk,v 1.18 2006/07/02 12:01:48 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %Y  Copyright 2000,  St Andrews -->
<!-- %% -->
<!-- %%  This file contains the description of streams. -->
<!-- %% -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Streams">
<Heading>Streams</Heading>

<E>Streams</E> provide flexible access to &GAP;'s input and output
processing. An <E>input stream</E> takes characters from some source and
delivers them to &GAP; which <E>reads</E> them from the stream.  When an
input stream has delivered all characters it is at <C>end-of-stream</C>.  An
<E>output stream</E> receives characters from &GAP; which <E>writes</E> them to
the stream, and delivers them to some destination.
<P/>
A major use of streams is to provide efficient and flexible access to
files.  Files can be read and written using 
<Ref Oper="Read"/> and <Ref Func="AppendTo"/>,
however the former only allows a complete file to be read as &GAP;
input and the latter imposes a high time penalty if many small pieces of
output are written to a large file. Streams allow input files in other
formats to be read and processed, and files to be built up efficiently
from small pieces of output. Streams may also be used for other purposes, 
for example to read from and print to &GAP; strings, or to read input
directly from the user.
<P/>
Any stream is either a <E>text stream</E>, which translates the <C>end-of-line</C>
character (<C>\n</C>) to or from the system's representation of
<C>end-of-line</C> (e.g., <E>new-line</E> under UNIX and
<E>carriage-return</E>-<E>new-line</E> under DOS), or a <E>binary stream</E>,
which does not translate the <C>end-of-line</C> character. The processing of
other unprintable characters by text streams is undefined. Binary streams
pass them unchanged.
<P/>
Whereas it is  cheap  to append  to a  stream, streams do  consume system
resources, and only a  limited number can  be open at any time, therefore
it is   necessary   to close   a  stream  as   soon as   possible  using
<Ref Func="CloseStream"/>.   If creating  a stream
failed then <Ref Func="LastSystemError"/> can be used to get
information about the failure. 


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Categories for Streams and the StreamsFamily">
<Heading>Categories for Streams and the StreamsFamily</Heading>

<ManSection>
<Filt Name="IsStream" Arg='obj' Type='Category'/>

<Description>
Streams are &GAP; objects and all open streams, input, output, text
and binary, lie in this category.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsClosedStream" Arg='obj' Type='Category'/>

<Description>
When a stream is closed, its type changes to lie in
<Ref Filt="IsClosedStream"/>. This category is used to install methods that trap
accesses to closed streams.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsInputStream" Arg='obj' Type='Category'/>

<Description>
All input streams lie in this category, and support input
operations such as <Ref Oper="ReadByte"/> (see <Ref Sect="Operations for Input Streams"/>)
</Description>
</ManSection>

<ManSection>
<Filt Name="IsInputTextStream" Arg='obj' Type='Category'/>

<Description>
All <E>text</E> input streams lie in this category. They translate new-line
characters read.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsInputTextNone" Arg='obj' Type='Category'/>

<Description>
It is convenient to use a category to distinguish dummy streams
(see <Ref Sect="Dummy Streams"/>) from others. Other distinctions are usually
made using representations
</Description>
</ManSection>

<ManSection>
<Filt Name="IsOutputStream" Arg='obj' Type='Category'/>

<Description>
All output streams lie in this category and support basic
operations such as <Ref Oper="WriteByte"/>
(see Section <Ref Sect="Operations for Output Streams"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsOutputTextStream" Arg='obj' Type='Category'/>

<Description>
All <E>text</E> output streams lie in this category and translate
new-line characters on output.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsOutputTextNone" Arg='obj' Type='Category'/>

<Description>
It is convenient to use a category to distinguish dummy streams
(see <Ref Sect="Dummy Streams"/>) from others. Other distinctions are usually
made using representations
</Description>
</ManSection>

<ManSection>
<Fam Name="StreamsFamily"/>

<Description>
All streams lie in the <Ref Fam="StreamsFamily"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations applicable to All Streams">
<Heading>Operations applicable to All Streams</Heading>

<ManSection>
<Oper Name="CloseStream" Arg='stream'/>

<Description>
In order  to preserve system resources  and to flush output streams every
stream should  be  closed  as soon   as  it is   no longer   used using
<Ref Oper="CloseStream"/>.
<P/>
It is an error to  try to read  characters from or  write characters to a
closed  stream.   Closing a  stream tells  the &GAP;   kernel and/or the
operating system kernel  that the file is  no longer needed.  This may be
necessary  because  the &GAP; kernel  and/or  the  operating  system may
impose a limit on how many streams may be open simultaneously.
</Description>
</ManSection>

<ManSection>
<Oper Name="FileDescriptorOfStream" Arg='stream'/>

<Description>
returns the UNIX file descriptor of the underlying file. This is mainly
useful for the <Ref Func="UNIXSelect"/> function call. This is
as of now only available on UNIX-like operating systems and only for
streams to local processes and local files.
</Description>
</ManSection>


<ManSection>
<Func Name="UNIXSelect"
 Arg='inlist, outlist, exclist, timeoutsec, timeoutusec'/>

<Description>
makes the UNIX C-library function <C>select</C> accessible from &GAP;
for streams. The functionality is as described in the man page (see

UNIX file descriptors (integers) for streams. They can be obtained via
<Ref Func="FileDescriptorOfStream"/> for streams
to local processes and to local files. The argument <A>timeoutsec</A> is a
timeout in seconds as in the <C>struct timeval</C> on the C level. The argument
<A>timeoutusec</A> is
analogously in microseconds. The total timeout is the sum of both. If
one of those timeout arguments is not a small integer then no timeout is
applicable (<K>fail</K> is allowed for the timeout arguments).
<P/>
The return value is the number of streams that are ready, this may be
0 if a timeout was specified. All file descriptors in the three lists
that are not yet ready are replaced by <K>fail</K> in this function. So 
the lists are changed!
<P/>
This function is not available on the Macintosh architecture and is
only available if your operating system has <C>select</C>, which is detected
during compilation of &GAP;.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Input Streams">
<Heading>Operations for Input Streams</Heading>

Two operations normally used to read files: <Ref Oper="Read"/> and
<Ref Oper="ReadAsFunction"/> can also be used to read &GAP; input from a
stream. The input is immediately parsed and executed. When reading
from a stream <A>str</A>, the &GAP; kernel generates calls to
<C>ReadLine(<A>str</A>)</C> to supply text to the parser. 
<P/>
Three further operations: <Ref Oper="ReadByte"/>, <Ref Oper="ReadLine"/> 
and <Ref Oper="ReadAll"/>, support
reading characters from an input stream without parsing them. This can be
used to read data in any format and process it in &GAP;.
<P/>
Additional operations for input streams support detection of end of
stream, and (for those streams for which it is appropriate) random access 
to the data.
<P/>

<ManSection>
<Oper Name="Read" Arg='input-text-stream' Label="for streams"/>

<Description>
reads the input-text-stream as  input  until <C>end-of-stream</C> occurs.  See
<Ref Sect="File Operations"/> for details.
</Description>
</ManSection>


<ManSection>
<Oper Name="ReadAsFunction" Arg='input-text-stream' Label="for streams"/>

<Description>
reads the input-text-stream as function and returns this function. See
<Ref Sect="File Operations"/> for details.

<Example><![CDATA[
gap> # a function with local `a' does not change the global one
gap> a := 1;;
gap> i := InputTextString( "local a; a := 10; return a*10;" );;
gap> ReadAsFunction(i)();
100
gap> a;
1
gap> # reading it via `Read' does
gap> i := InputTextString( "a := 10;" );;
gap> Read(i);
gap> a;
10
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ReadByte" Arg='input-stream'/>

<Description>
<Ref Oper="ReadByte"/> returns  one character (returned  as  integer) from  the input
stream <A>input-stream</A>.  <Ref Oper="ReadByte"/> returns <K>fail</K> if there is no character
available, in particular if it is at the end of a file.
<P/>
If <A>input-stream</A> is the input stream of  a input/output process, <Ref Oper="ReadByte"/>
may also return <K>fail</K> if no byte is currently available.
<P/>
<Ref Oper="ReadByte"/> is the basic operation for input streams. If a <Ref Oper="ReadByte"/>
method is installed for a user-defined type of stream which does
not block, then all the other
input stream operations will work (although possibly not at peak
efficiency).
<P/>
<Ref Oper="ReadByte"/> will wait (block) until a byte is available. For
instance if the stream is a connection to another process, it will
wait for the process to output a byte.
</Description>
</ManSection>

<ManSection>
<Oper Name="ReadLine" Arg='input-stream'/>

<Description>
<Ref Oper="ReadLine"/> returns one line (returned as string <E>with</E> the newline) from
the input stream <A>input-stream</A>.  <Ref Oper="ReadLine"/> reads in the input until  a
newline is read or the end-of-stream is encountered.
<P/>
If <A>input-stream</A> is the input stream of a input/output process, <Ref Oper="ReadLine"/>
may also return <K>fail</K> or return an incomplete line if the other
process has not yet written any more. It will always wait (block) for at
least one byte to be available, but will then return as much input
as is available, up to a limit of one  line
<P/>
A default method is supplied for <Ref Oper="ReadLine"/> which simply calls <Ref Oper="ReadByte"/>
repeatedly. This is only safe for streams that cannot block. The kernel 
uses calls to <Ref Oper="ReadLine"/> to supply input to the
parser when reading from a stream.
</Description>
</ManSection>

<ManSection>
<Oper Name="ReadAll" Arg='input-stream[, limit]'/>

<Description>
<Ref Oper="ReadAll"/> returns all characters as string from the input stream
<A>stream-in</A>.  It waits (blocks) until at least one
character is available from the stream, or until there is evidence
that no characters will ever be available again. This last indicates
that the stream is at end-of-stream.
Otherwise, it reads as much input as it can from the stream without
blocking further and returns it to the user. If the stream is
already at end of file, so that no bytes are available, <K>fail</K> is
returned. In the case of a file
stream connected to a normal file (not a pseudo-tty or named pipe
or similar), all the bytes should be immediately available and
this function will read the remainder of the file.
<P/>
With a second argument, at most <A>limit</A> bytes will be
returned. Depending on the stream a bounded number of additional bytes
may have been read into an internal buffer.  
<P/>
A default method is supplied for <Ref Oper="ReadAll"/> which simply calls 
<Ref Oper="ReadLine"/> repeatedly.
This is only really safe for streams which cannot block.
Other streams should install a method for <Ref Oper="ReadAll"/>
<P/>
<Example><![CDATA[
gap> i := InputTextString( "1Hallo\nYou\n1" );;
gap> ReadByte(i);
49
gap> CHAR_INT(last);
'1'
gap> ReadLine(i);
"Hallo\n"
gap> ReadLine(i);
"You\n"
gap> ReadLine(i);
"1"
gap> ReadLine(i);
fail
gap> ReadAll(i);
""
gap> RewindStream(i);;
gap> ReadAll(i);
"1Hallo\nYou\n1"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsEndOfStream" Arg='input-stream'/>

<Description>
<Ref Oper="IsEndOfStream"/> returns <K>true</K> if the input stream is at <E>end-of-stream</E>,
and <K>false</K> otherwise.  Note   that <Ref Oper="IsEndOfStream"/> might  return <K>false</K>
even if the next <Ref Oper="ReadByte"/> fails.
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionStream" Arg='input-stream'/>

<Description>
Some input streams, such as string streams and file streams attached to
disk files, support a form of random access by way of the operations
<Ref Oper="PositionStream"/>, <Ref Oper="SeekPositionStream"/> and
<Ref Oper="RewindStream"/>. <Ref Oper="PositionStream"/> 
returns a non-negative integer denoting
the current position in the stream (usually the number of characters
<E>before</E> the next one to be read.
<P/>
If this is not possible, for example for an input stream attached to
standard input (normally the keyboard), then <K>fail</K> is returned
</Description>
</ManSection>

<ManSection>
<Oper Name="RewindStream" Arg='input-stream'/>

<Description>
<Ref Oper="RewindStream"/> attempts to return an input stream to its starting
condition, so that all the same characters can be read again. It returns
<K>true</K> if the rewind succeeds and <K>fail</K> otherwise
<P/>
A default method implements RewindStream using <Ref Oper="SeekPositionStream"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="SeekPositionStream" Arg='input-stream, pos'/>

<Description>
<Ref Oper="SeekPositionStream"/> attempts to rewind or wind forward an input stream
to the specified position. This is not possible for all streams. It
returns <K>true</K> if the seek is successful and <K>fail</K> otherwise.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Output Streams">
<Heading>Operations for Output Streams</Heading>

<ManSection>
<Oper Name="WriteByte" Arg='output-stream, byte'/>

<Description>
writes the  next  character  (given  as <E>integer</E>)  to the  output stream
<A>output-stream</A>.  The function  returns <K>true</K> if  the write succeeds and
<K>fail</K> otherwise.
<P/>
<Ref Func="WriteByte"/> is the basic operation for output streams. If a <Ref Func="WriteByte"/>
method is installed for a user-defined type of stream, then all the other
output stream operations will work (although possibly not at peak
efficiency).
</Description>
</ManSection>

<ManSection>
<Oper Name="WriteLine" Arg='output-stream, string'/>

<Description>
appends  <A>string</A> to <A>output-stream</A>.   A  final newline is written.
The function returns <K>true</K> if the write succeeds and <K>fail</K> otherwise.
<P/>
A default method is installed which implements <Ref Func="WriteLine"/> by repeated
calls to <Ref Func="WriteByte"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="WriteAll" Arg='output-stream, string'/>

<Description>
appends <A>string</A> to <A>output-stream</A>.
No final  newline is written.
The function returns <K>true</K> if the write succeeds
and <K>fail</K> otherwise.
It will block as long as necessary for the write operation to
complete (for example for a child process to clear its input buffer )
<P/>
A default method is installed which implements <Ref Func="WriteAll"/>
by repeated calls to <Ref Func="WriteByte"/>.
<P/>
When printing or appending to a stream (using <Ref Func="PrintTo"/>,
or <Ref Func="AppendTo"/> or when logging to a stream),
the kernel generates a call to <Ref Func="WriteAll"/> for each line
output.
<P/>
<Example><![CDATA[
gap> str := "";; a := OutputTextString(str,true);;
gap> WriteByte(a,INT_CHAR('H'));
true
gap> WriteLine(a,"allo");
true
gap> WriteAll(a,"You\n");
true
gap> CloseStream(a);
gap> Print(str);
Hallo
You
]]></Example>
</Description>
</ManSection>


<ManSection>
<Heading>PrintTo and AppendTo (for streams)</Heading>
<Func Name="PrintTo" Arg='output-stream, arg1, ...' Label="for streams"/>
<Func Name="AppendTo" Arg='output-stream, arg1, ...' Label="for streams"/>

<Description>
These functions work like <Ref Func="Print"/>, except that the output is
appended to the output stream <A>output-stream</A>.
<P/>
<Example><![CDATA[
gap> str := "";; a := OutputTextString(str,true);;
gap> AppendTo( a, (1,2,3), ":", Z(3) );
gap> CloseStream(a);
gap> Print( str, "\n" );
(1,2,3):Z(3)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LogTo" Arg='stream' Label="for streams"/>

<Description>
causes the subsequent interaction to  be  logged  to  the  output  stream
<A>stream</A>. It works in precisely  the  same  way  as  it  does  for  files
(see&nbsp;<Ref Func="LogTo" Label="for a filename"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="InputLogTo" Arg='stream' Label="for streams"/>

<Description>
causes the subsequent input to be logged to the output stream
<A>stream</A>.
It works just like it does for files
(see&nbsp;<Ref Func="InputLogTo" Label="for a filename"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="OutputLogTo" Arg='stream' Label="for streams"/>

<Description>
causes the subsequent output to be logged to the output stream
<A>stream</A>.
It works just like it does for files
(see&nbsp;<Ref Func="OutputLogTo" Label="for a filename"/>).
<P/>
</Description>
</ManSection>

<ManSection>
<Oper Name="SetPrintFormattingStatus" Arg='stream, newstatus'/>
<Oper Name="PrintFormattingStatus" Arg='stream'/>

<Description>
When text is being sent to an output text stream via
<Ref Func="PrintTo"/>, <Ref Func="AppendTo"/>,
<Ref Oper="LogTo" Label="for streams"/>, etc., it is
by default formatted just as it would be were it being printed to the
screen.
Thus, it is broken into lines of reasonable length at (where possible)
sensible places, lines containing elements of lists or records are
indented, and so forth.
This is appropriate if the output is eventually to be viewed by a human,
and harmless if it to passed as input to &GAP;,
but may be unhelpful if the output is to be passed as input to another
program.
It is possible to turn off this behaviour for a stream using the
<Ref Func="SetPrintFormattingStatus"/> operation, and to test whether it
is on or off using <Ref Func="PrintFormattingStatus"/>.
<P/>
<Ref Func="SetPrintFormattingStatus"/> sets whether output sent to the
output stream <A>stream</A> via <Ref Oper="PrintTo"/>,
<Ref Oper="AppendTo"/>, etc. 
will be formatted with line breaks and 
indentation.  If  the  second  argument <A>newstatus</A> is <K>true</K> 
then output will be so formatted, and if <K>false</K> then it will not. 
If the stream is not a text stream, only <K>false</K> is allowed.
<P/>
<Ref Func="PrintFormattingStatus"/> returns <K>true</K> if output sent to
the output text stream <A>stream</A>  via <Ref Oper="PrintTo"/>,
<Ref Oper="AppendTo"/>, etc.  
will be formatted with line breaks and
indentation, and <K>false</K> otherwise.
For non-text streams, it returns <K>false</K>.
If as argument <A>stream</A> the string <C>"*stdout*"</C> is given, these
functions refer to the formatting status of the standard output (so usually
the users terminal screen).<P/>
These functions do not influence the behaviour of the low level functions 
<Ref Func="WriteByte"/>, 
<Ref Func="WriteLine"/> or  <Ref Func="WriteAll"/> which always write
without formatting.
<P/>
<Example><![CDATA[
gap> s := "";; str := OutputTextString(s,false);;
gap> PrintTo(str,Primes{[1..30]});
gap> s;
"[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
 \n  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ]"
gap> Print(s,"\n");
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 
  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ]
gap> SetPrintFormattingStatus(str, false);
gap> PrintTo(str,Primes{[1..30]});
gap> s;
"[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
 \n  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ][ 2, 3, 5, 7\
, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, \
79, 83, 89, 97, 101, 103, 107, 109, 113 ]"
gap> Print(s,"\n");
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 
  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113 ][ 2, 3, 5, 7, 1\
1, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
 83, 89, 97, 101, 103, 107, 109, 113 ]
]]></Example>
<P/>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="File Streams">
<Heading>File Streams</Heading>

File streams  are  streams associated with  files.  An  input file stream
reads  the characters  it delivers from  a  file,  an output  file stream
prints the characters it receives to a file.  The following functions can
be used to create such streams.  They return <K>fail</K> if an error occurred,
in this case <Ref Func="LastSystemError"/> can be used to get
information about the error.

<ManSection>
<Oper Name="InputTextFile" Arg='filename'/>

<Description>
<C>InputTextFile( <A>filename</A> )</C> returns an input stream in the category
<Ref Filt="IsInputTextStream"/> that delivers the characters from the file
<A>filename</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="OutputTextFile" Arg='filename, append'/>

<Description>
<C>OutputTextFile( <A>filename</A>, <A>append</A> )</C> returns an output stream in the
category <C>IsOutputTextFile</C> that writes received characters to the file
<A>filename</A>.  If <A>append</A> is <K>false</K>, then the file is emptied first,
otherwise received characters are added at the end of the file.
<P/>
<Example><![CDATA[
gap> # use a temporary directory
gap> name := Filename( DirectoryTemporary(), "test" );;
gap> # create an output stream, append output, and close again
gap> output := OutputTextFile( name, true );;
gap> AppendTo( output, "Hallo\n", "You\n" );
gap> CloseStream(output);
gap> # create an input, print complete contents of file, and close
gap> input := InputTextFile(name);;
gap> Print( ReadAll(input) );
Hallo
You
gap> CloseStream(input);
gap> # append a single line
gap> output := OutputTextFile( name, true );;
gap> AppendTo( output, "AppendLine\n" );
gap> # close output stream to flush the output
gap> CloseStream(output);
gap> # create an input, print complete contents of file, and close
gap> input := InputTextFile(name);;
gap> Print( ReadAll(input) );
Hallo
You
AppendLine
gap> CloseStream(input);
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="User Streams">
<Heading>User Streams</Heading>

The commands described in this section create streams which accept characters
from, or deliver characters to, the user, via the keyboard or the &GAP; session
display.

<ManSection>
<Func Name="InputTextUser" Arg=''/>

<Description>
returns an input text stream which delivers characters typed by the user
(or from the standard input device if it has been redirected). In normal
circumstances, characters are delivered one by one as they are typed,
without waiting until the end of a line. No prompts are printed.
</Description>
</ManSection>

<ManSection>
<Func Name="OutputTextUser" Arg=''/>

<Description>
returns an output stream which delivers characters to the user's display
(or the standard output device if it has been redirected). Each character
is delivered immediately it is written, without waiting for a full line
of output. Text written in this way is <E>not</E> written to the session log
(see <Ref Oper="LogTo" Label="for a filename"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="InputFromUser" Arg='arg'/>

<Description>
prints the <A>arg</A> as a prompt, then waits until a text is typed by the
user (or from the standard input device if it has been redirected).
This text must be a <E>single</E> expression, followed by one <E>enter</E>.
This is evaluated (see <Ref Func="EvalString"/>) and the result is returned.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="String Streams">
<Heading>String Streams</Heading>

String streams   are streams associated  with   strings.  An input string
stream reads  the characters it delivers  from a string, an output string
stream  appends the characters  it receives  to  a string.  The following
functions can be used to create such streams.

<ManSection>
<Oper Name="InputTextString" Arg='string'/>

<Description>
<C>InputTextString(  <A>string</A>  )</C>  returns an  input  stream
that  delivers the  characters  from the  string <A>string</A>.  The
<A>string</A> is  not changed  when reading  characters from  it and
changing the <A>string</A> after the call to
<Ref Oper="InputTextString"/> has no influence on the input stream.
</Description>
</ManSection>

<ManSection>
<Oper Name="OutputTextString" Arg='list, append'/>

<Description>
returns an output stream that puts all received characters into the list
<A>list</A>.
If <A>append</A> is <K>false</K>, then the list is emptied first,
otherwise received characters are added at the end of the list. 
<P/>
<Example><![CDATA[
gap> # read input from a string
gap> input := InputTextString( "Hallo\nYou\n" );;
gap> ReadLine(input);
"Hallo\n"
gap> ReadLine(input);
"You\n"
gap> # print to a string
gap> str := "";;
gap> out := OutputTextString( str, true );;
gap> PrintTo( out, 1, "\n", (1,2,3,4)(5,6), "\n" );
gap> CloseStream(out);
gap> Print( str );
1
(1,2,3,4)(5,6)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Input-Output Streams">
<Heading>Input-Output Streams</Heading>

Input-output streams capture bidirectional 
communications between &GAP; and another process, either locally
or (@as yet unimplemented@) remotely.
<P/>
Such streams support the basic operations of both input and output 
streams. They should provide some buffering, allowing output data to be
written to the stream, even when input data is waiting to be read,
but the amount of this buffering is operating system dependent,
and the user should take care not to get too far ahead in writing, or 
behind in reading, or deadlock may occur.
<P/>
At present the only type of Input-Output streams that are
implemented provide communication with a local child process,
using a pseudo-tty.
<P/>
Like other streams, write operations are blocking, read operations
will block to get the first character, but not thereafter. 
<P/>
As far as possible, no translation is done on characters written
to, or read from the stream, and no control characters have special
effects, but the details of particular pseudo-tty implementations 
may effect this. 

<ManSection>
<Filt Name="IsInputOutputStream" Arg='obj' Type='Category'/>

<Description>
<Ref Filt="IsInputOutputStream"/> is the Category of Input-Output Streams; it returns
<K>true</K> if the <A>obj</A> is an input-output stream and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Func Name="InputOutputLocalProcess" Arg='dir, executable, args'/>

<Description>
starts up a slave process, whose executable file is <A>executable</A>, with
<Q>command line</Q> arguments <A>args</A> in the directory <A>dir</A>. (Suitable 
choices for <A>dir</A> are <C>DirectoryCurrent()</C> or <C>DirectoryTemporary()</C>
(see Section&nbsp;<Ref Sect="Directories"/>); <C>DirectoryTemporary()</C> may be a good choice
when <A>executable</A> generates output files that it doesn't itself remove
afterwards.) 
<Ref Func="InputOutputLocalProcess"/> returns an InputOutputStream object. Bytes
written to this stream are received by the slave process as if typed
at a terminal on standard input. Bytes written to standard output
by the slave process can be read from the stream. 
<P/>
When the stream is closed, the signal SIGTERM is delivered to the child
process, which is expected to exit.
<Log><![CDATA[
gap> d := DirectoryCurrent();
dir("./")
gap> f := Filename(DirectoriesSystemPrograms(), "rev");
"/usr/bin/rev"
gap> s := InputOutputLocalProcess(d,f,[]);
< input/output stream to rev >
gap> WriteLine(s,"The cat sat on the mat");
true
gap> Print(ReadLine(s));
tam eht no tas tac ehT
gap> x := ListWithIdenticalEntries(10000,'x');;
gap> ConvertToStringRep(x);
gap> WriteLine(s,x);
true
gap> WriteByte(s,INT_CHAR('\n'));
true
gap> y := ReadAll(s);;
gap> Length(y);
4095
gap> CloseStream(s);
gap> s;
< closed input/output stream to rev >
]]></Log>
</Description>
</ManSection>

<ManSection>
<Oper Name="ReadAllLine" Arg='iostream[, nofail][, IsAllLine]'/>

<Description>
For an input/output stream <A>iostream</A> <Ref Oper="ReadAllLine"/> reads until a newline
character if any input is found or returns <K>fail</K> if no input  is  found,
i.e.&nbsp;if any input is found <Ref Oper="ReadAllLine"/> is non-blocking.
<P/>
If the argument <A>nofail</A> (which must be <K>false</K> or  <K>true</K>)  is  provided
and it is set to <K>true</K> then <Ref Oper="ReadAllLine"/> will wait, if  necessary,  for
input and never return <K>fail</K>.
<P/>
If the argument <A>IsAllLine</A> (which must be a function that takes a string
argument and returns either  <K>true</K>  or  <K>false</K>)  then  it  is  used  to
determine what  constitutes  a  whole  line.  The  default  behaviour  is
equivalent to passing the function
<P/>
<Log><![CDATA[
line -> 0 < Length(line) and line[Length(line)] = '\n'
]]></Log>
<P/>
for the <A>IsAllLine</A> argument. The purpose of the <A>IsAllLine</A> argument  is
to cater for the case where the input being  read  is  from  an  external
process that writes a <Q>prompt</Q> for data that does not terminate with  a
newline.
<P/>
If the first argument is an input stream but not an  input/output  stream
then <Ref Oper="ReadAllLine"/> behaves as if <Ref Oper="ReadLine"/>  was  called  with  just  the
first argument and any additional arguments are ignored.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Dummy Streams">
<Heading>Dummy Streams</Heading>

The following  two commands create  dummy streams  which will consume all
characters and never deliver one.

<ManSection>
<Func Name="InputTextNone" Arg=''/>

<Description>
returns a dummy input text stream, which delivers no characters, i.e., it
is always at end of stream.  Its main use is for calls to
<Ref Oper="Process"/> when the started program does not read anything.
</Description>
</ManSection>

<ManSection>
<Func Name="OutputTextNone" Arg=''/>

<Description>
returns a dummy output stream, which discards all received characters. 
Its main use is for calls to <Ref Oper="Process"/> when the started
program does not write anything.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Handling of Streams in the Background">
<Heading>Handling of Streams in the Background</Heading>

This section describes a feature of the &GAP; kernel that can be used
to handle pending streams somehow <Q>in the background</Q>. This is currently
not available on the Macintosh architecture and only on operating
systems that have <C>select</C>.
<P/>
Right before &GAP; reads a keypress from the keyboard it calls a little
subroutine that can handle streams that are ready to be read or ready to
be written. This means that &GAP; can handle these streams during
user input on the command line. Note that this does not work when &GAP;
is in the middle of some calculation.
<P/>
This feature is used in the following way. One can install handler
functions for reading or writing streams via
<Ref Func="InstallCharReadHookFunc"/>.
Handlers can be removed via
<Ref Func="UnInstallCharReadHookFunc"/>
<P/>
Note that handler functions must not return anything and get one integer
argument, which refers to an index in one of the following arrays
(according to whether the function was installed for input, output or
exceptions on the stream). Handler functions usually should not output
anything on the standard output because this ruins the command line
during command line editing.

<ManSection>
<Func Name="InstallCharReadHookFunc" Arg='stream, mode, func'/>

<Description>
installs the function <A>func</A> as a handler function for the stream
<A>stream</A>. The argument <A>mode</A> decides, for what operations on the
stream this function is installed. <A>mode</A> must be a string, in which
a letter <C>r</C> means <Q>read</Q>, <C>w</C> means <Q>write</Q> and <C>x</C> means
<Q>exception</Q>, according to the <C>select</C> function call in the UNIX
C-library (see <C>man select</C> and <Ref Func="UNIXSelect"/>). More than one letter 
is allowed in <A>mode</A>. As described above the function is called
in a situation when &GAP; is reading a character from the keyboard.
Handler functions should not use much time to complete.
<P/>
This functionality does not work on the Macintosh architecture and
only works if the operating system has a <C>select</C> function.
</Description>
</ManSection>

<ManSection>
<Func Name="UnInstallCharReadHookFunc" Arg='stream, func'/>

<Description>
uninstalls the function <A>func</A> as a handler function for the stream
<A>stream</A>. All instances are deinstalled, regardless of the mode
of operation (read, write, exception).
<P/>
This functionality does not work on the Macintosh architecture and
only works if the operating system has a <C>select</C> function.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comma separated files">
<Heading>Comma separated files</Heading>
<Index>Spreadsheet</Index>
<Index>Excel</Index>

In some situations it can be desirable to process data given in the form of
a spreadsheet (such as Excel). &GAP; can do this using the CSV (comma
separated values) format, which spreadsheet programs can usually read in or
write out.
<P/>
The first line of the spreadsheet is used as labels of record components,
each subsequent line then corresponds to a record. Entries enclosed in
double quotes are considered as strings and are permitted to contain the
separation character (usually a comma).

<ManSection>
<Func Name="ReadCSV" Arg='filename[, nohead][, separator]'/>

<Description>
This function reads in a spreadsheet, saved in CSV format
(<E>c</E>omma <E>s</E>eparated <E>v</E>alues) and returns its entries as
a list of records.
The entries of the first line of the spreadsheet are used to denote
the names of the record components. Blanks will be translated into
underscore characters.
If the parameter <A>nohead</A> is given as <K>true</K>,
instead the record components will be called <C>fieldn</C>.
Each subsequent line will create one record.
If given, <A>separator</A> is the character used to separate fields.
Otherwise it defaults to a comma.
</Description>
</ManSection>

<ManSection>
<Func Name="PrintCSV" Arg='filename, list[, fields]'/>

<Description>
This function prints a list of records as a spreadsheet in CSV format
(which can be read in for example into Excel). The names of the record
components will be printed as entries in the first line.
If the argument <A>fields</A> is given only the record fields listed in
this list will be printed
and they will be printed in the same arrangement as given in this list.
If the option noheader is set to true the line with the record field
names will not be printed.
</Description>
</ManSection>


</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  process.msk               GAP documentation              Frank Celler -->
<!-- %W                                                     & Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: process.msk,v 1.3 2001/09/21 12:29:29 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<!-- %%  This file contains the description of processes. -->
<!-- %% -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Processes">
<Heading>Processes</Heading>

&GAP; can call other programs, such programs are called <E>processes</E>.
There are two kinds of processes:
first there are processes that are started, run and return a result,
while &GAP; is suspended until the process terminates.
Then there are processes that will run in parallel to &GAP; as
subprocesses and &GAP; can communicate and control the processes using
streams (see&nbsp;<Ref Func="InputOutputLocalProcess"/>).



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Process and Exec">
<Heading>Process and Exec</Heading>

<ManSection>
<Oper Name="Process" Arg='dir, prg, stream-in, stream-out, options'/>

<Description>
<Ref Oper="Process"/> runs a new process and returns when the process terminates.
It returns the return value of the process if the operating system
supports such a concept.
<P/>
The first argument <A>dir</A> is a directory object (see&nbsp;<Ref Sect="Directories"/>)
which will be the current directory (in the usual UNIX or MSDOS sense)
when the program is run.
This will only matter if the program accesses files (including running
other programs) via relative path names.
In particular, it has nothing to do with finding the binary to run.
<P/>
In general the directory will either be the current directory, which is
returned by <Ref Func="DirectoryCurrent"/>
&ndash;this was the behaviour of &GAP;&nbsp;3&ndash;
or a temporary directory returned by <Ref Func="DirectoryTemporary"/>.
If one expects that the process creates temporary or log files the latter
should be used because &GAP; will attempt to remove these directories
together with all the files in them when quitting.
<P/>
If a program of a &GAP; package which does not only consist of &GAP;
code needs to be launched in a directory relative to certain data
libraries, then the first entry of <Ref Func="DirectoriesPackageLibrary"/> 
should be used.
The argument of <Ref Func="DirectoriesPackageLibrary"/> should be the path to the
data library relative to the package directory.
<P/>
If a program calls other programs and needs to be launched in a directory
containing the executables for such a &GAP; package then the first entry
of <Ref Func="DirectoriesPackagePrograms"/> should be used.
<P/>
The latter two alternatives should only be used if absolutely necessary
because otherwise one risks accumulating log or core files in the package
directory.
<P/>
<Log><![CDATA[
gap> path := DirectoriesSystemPrograms();;
gap> ls := Filename( path, "ls" );;
gap> stdin := InputTextUser();;
gap> stdout := OutputTextUser();;
gap> Process( path[1], ls, stdin, stdout, ["-c"] );;
awk    ls     mkdir
gap> # current directory, here the root directory
gap> Process( DirectoryCurrent(), ls, stdin, stdout, ["-c"] );;
bin    lib    trans  tst    CVS    grp    prim   thr    two
src    dev    etc    tbl    doc    pkg    small  tom
gap> # create a temporary directory
gap> tmpdir := DirectoryTemporary();;
gap> Process( tmpdir, ls, stdin, stdout, ["-c"] );;
gap> PrintTo( Filename( tmpdir, "emil" ) );
gap> Process( tmpdir, ls, stdin, stdout, ["-c"] );;
emil
]]></Log>
<P/>
<A>prg</A> is the filename of the program to launch,
for portability it should be the result of
<Ref Func="Filename" Label="for a directory and a string"/>
and should pass <Ref Func="IsExecutableFile"/>.
Note that <Ref Func="Process"/> does <E>no</E> searching through a list
of directories, this is done by
<Ref Func="Filename" Label="for a directory and a string"/>.
<P/>
<A>stream-in</A> is the input stream that delivers the characters to the
process.
For portability it should either be <Ref Func="InputTextNone"/> 
(if the process reads no characters), <Ref Func="InputTextUser"/>, 
the result of a call to <Ref Oper="InputTextFile"/>
from which no characters have been read, or the result of a call to
<Ref Oper="InputTextString"/>.
<P/>
<Ref Func="Process"/> is free to consume <E>all</E> the input even if the program itself
does not require any input at all.
<P/>
<A>stream-out</A> is the output stream which receives the characters from the
process.
For portability it should either be <Ref Func="OutputTextNone"/> (if the process
writes no characters), <Ref Func="OutputTextUser"/>, the result of a call to
<Ref Oper="OutputTextFile"/> to which no characters have been written, or the result
of a call to <Ref Oper="OutputTextString"/>.
<P/>
<A>options</A> is a list of strings which are passed to the process as command
line argument.
Note that no substitutions are performed on the strings,
i.e., they are passed immediately to the process and are not processed by
a command interpreter (shell).
Further note that each string is passed as one argument,
even if it contains <E>space</E> characters.
Note that input/output redirection commands are <E>not</E> allowed as
<A>options</A>.
<P/>
In order to find a system program use <Ref Func="DirectoriesSystemPrograms"/>
together with <Ref Oper="Filename" Label="for a directory and a string"/>.
<P/>
<Example><![CDATA[
gap> path := DirectoriesSystemPrograms();;
gap> date := Filename( path, "date" );
"/bin/date"
]]></Example>
<P/>
The next example shows how to execute <C>date</C> with no argument and no input, 
and collect the output into a string stream.
<P/>
<Log><![CDATA[
gap> str := "";; a := OutputTextString(str,true);;
gap> Process( DirectoryCurrent(), date, InputTextNone(), a, [] );
0
gap> CloseStream(a);
gap> Print(str);
Fri Jul 11 09:04:23 MET DST 1997
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="Exec" Arg='cmd, option1, ..., optionN'/>

<Description>
<Ref Func="Exec"/> runs a shell in the current directory to execute the command given
by the string <A>cmd</A> with options <A>option1</A>, ..., <A>optionN</A>.
<P/>
<Log><![CDATA[
gap> Exec( "date" );
Thu Jul 24 10:04:13 BST 1997
]]></Log>
<P/>
<A>cmd</A> is interpreted by the shell and therefore we can make use of the
various features that a shell offers as in following example.
<P/>
<Log><![CDATA[
gap> Exec( "echo \"GAP is great!\" > foo" );
gap> Exec( "cat foo" );
GAP is great!
gap> Exec( "rm foo" );
]]></Log>
<P/>
<Ref Func="Exec"/> calls the more general operation <Ref Oper="Process"/>.
The function <Ref Func="Edit"/> should be used to call an editor from 
within &GAP;.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  objects.msk              GAP manual                     Thomas Breuer -->
<!-- %W                                                       Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: objects.msk,v 1.28 2006/03/23 19:40:39 stefan Exp </M> -->
<!-- %% -->

<!-- %T modify and use the text in <C>object.gd</C> for the discussion of -->
<!-- %T mutability and copyability -->
<!-- %T (in particular for <C>IsMutable</C> and <C>IsCopyable</C>). -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Objects and Elements">
<Heading>Objects and Elements</Heading>

An <E>object</E> is anything in &GAP; that can be assigned to a variable,
so nearly everything in &GAP; is an object.
<P/>
Different objects can be regarded as equal with respect to the equivalence
relation <Q><C>=</C></Q>,
in this case we say that the objects describe the same <E>element</E>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Objects">
<Heading>Objects</Heading>

Nearly all things one deals with in &GAP; are <E>objects</E>.
For example, an integer is an object, as is a list of integers, a matrix,
a permutation, a function, a list of functions, a record, a group,
a coset or a conjugacy class in a group.
<P/>
Examples of things that are not objects are
comments which are only lexical constructs,
<K>while</K> loops which are only syntactical constructs,
and expressions, such as <C>1 + 1</C>;
but note that the value of an expression, in this case the integer <C>2</C>,
is an object.
<P/>
Objects can be assigned to variables,
and everything that can be assigned to a variable is an object.
Analogously, objects can be used as arguments of functions, and can be 
returned by functions.

<ManSection>
<Filt Name="IsObject" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsObject"/> returns <K>true</K> if the object <A>obj</A> is an
object.  Obviously it can never return <K>false</K>.
<P/>
It can be used as a filter in <Ref Func="InstallMethod"/>
when one of the arguments can be anything.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elements as equivalence classes">
<Heading>Elements as equivalence classes</Heading>

<Index Subkey="definition">elements</Index>
The equality operation <Q><C>=</C></Q> defines an equivalence relation on all
&GAP; objects.
The equivalence classes are called <E>elements</E>.
<P/>
There are basically three reasons to regard different objects as
equal.  Firstly the same information may be stored in different
places.  Secondly the same information may be stored in different
ways; for example, a polynomial can be stored sparsely or densely.
Thirdly different information may be equal modulo a mathematical
equivalence relation.  For example, in a finitely presented group with
the relation <M>a^2 = 1</M> the different objects <M>a</M> and <M>a^3</M> describe
the same element.
<P/>
As an example of all three reasons, consider the possibility of storing
an integer in several places of the memory,
of representing it as a fraction with denominator 1,
or of representing it as a fraction with any denominator, and numerator
a suitable multiple of the denominator. 

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sets">
<Heading>Sets</Heading>

In &GAP; there is no category whose definition corresponds to the
mathematical property of being a set, however 
in the manual we will often refer to an object as a <E>set</E> 
in order to convey the fact that mathematically, we are thinking of
it as a set. In particular, two sets <M>A</M> and <M>B</M> are equal if and only if,
<M>x \in A \iff x \in B</M>.  
<P/>
There are two types of object in &GAP; which exhibit this kind of behaviour
with respect to equality, namely domains (see Section&nbsp;<Ref Sect="Domains"/>) and lists 
whose elements are strictly sorted see <Ref Func="IsSSortedList"/>.
In general, <E>set</E> in this manual
will mean an object of one of these types.
<P/>
More precisely: two domains can be compared with <Q>{<C>=</C>}</Q>,
the answer being <K>true</K> if and only if the sets of elements
are equal (regardless of any additional structure) and;
a domain and a list can be compared with <Q><C>=</C></Q>,
the answer being <K>true</K> if and only if the list is equal to
the strictly sorted list of elements of the domain.
<P/>
A discussion about sorted lists and sets can be found
in Section <Ref Sect="Sorted Lists and Sets"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Domains">
<Heading>Domains</Heading>

An especially important class of objects in &GAP; are those whose
underlying mathematical abstraction is that of a  structured set, for
example a group, a conjugacy class, or a vector space.  Such objects
are called <E>domains</E>.  The equality relation between domains is always 
equality <E>as sets</E>, so that two domains are equal if and only if they
contain the same elements.
<P/>
Domains play a central role in &GAP;.  In a sense, the only reason
that &GAP; supports objects such as integers and permutations is the
wish to form domains of them and compute the properties of those domains.
<P/>
Domains are described in Chapter&nbsp;<Ref Chap="Domains and their Elements"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Identical Objects">
<Heading>Identical Objects</Heading>

Two objects that are equal <E>as objects</E> (that is they actually refer
to the same area of computer memory) and not only w.r.t. the equality
relation <Q><C>=</C></Q> are called <E>identical</E>.
Identical objects do of course describe the same element.

<ManSection>
<Func Name="IsIdenticalObj" Arg='obj1, obj2'/>

<Description>
<Ref Func="IsIdenticalObj"/> tests whether the objects
<A>obj1</A> and <A>obj2</A> are identical (that is they are either
equal immediate objects or are both stored at the same location in 
memory.
<P/>
If two copies of a simple constant object
(see section <Ref Sect="Mutability and Copyability"/>) are created,
it is not defined whether &GAP; will
actually store two equal but non-identical objects, or just a single
object. For mutable objects, however, it is important to know whether
two values refer to identical or non-identical objects, and the
documentation of operations that return mutable values should make
clear whether the values returned are new, or may be identical to
values stored elsewhere.
<P/>
<Example><![CDATA[
gap> IsIdenticalObj( 10^6, 10^6);
true
gap> IsIdenticalObj( 10^30, 10^30);
false
gap> IsIdenticalObj( true, true);
true
]]></Example>
<P/>
Generally, one may compute with objects but think of the results in
terms of the underlying elements because one is not interested in
locations in memory, data formats or information beyond underlying
equivalence relations. But there are cases where it is important to
distinguish the relations identity and equality.  This is best
illustrated with an example.  (The reader who is not familiar with
lists in &GAP;, in particular element access and assignment, is
referred to Chapter&nbsp;<Ref Chap="Lists"/>.)
<Example><![CDATA[
gap> l1:= [ 1, 2, 3 ];; l2:= [ 1, 2, 3 ];;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
false
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 3 ]
gap> l1 = l2;
false
]]></Example>
The two lists <C>l1</C> and <C>l2</C> are equal but not identical.
Thus a change in <C>l1</C> does not affect <C>l2</C>.
<Example><![CDATA[
gap> l1:= [ 1, 2, 3 ];; l2:= l1;;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
true
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 4 ]
gap> l1 = l2;
true
]]></Example>
Here, <C>l1</C> and <C>l2</C> are identical objects,
so changing <C>l1</C> means a change to <C>l2</C> as well.
</Description>
</ManSection>

<ManSection>
<Func Name="IsNotIdenticalObj" Arg='obj1, obj2'/>

<Description>
tests whether the objects <A>obj1</A> and <A>obj2</A> are not identical.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mutability and Copyability">
<Heading>Mutability and Copyability</Heading>

An object in &GAP; is said to be <E>immutable</E> if its mathematical value
(as defined by <M>=</M>) does not change under any operation.
More explicitly,
suppose <M>a</M> is immutable and <M>O</M> is some operation on <M>a</M>,
then if <M>a = b</M> evaluates to <K>true</K> before executing <M>O(a)</M>,
<M>a = b</M> also evaluates to <K>true</K> afterwards. 
(Examples for operations <M>O</M> that change mutable objects are
<Ref Func="Add"/> and <Ref Func="Unbind" Label="unbind a list entry"/>
which are used to change list objects, see Chapter&nbsp;<Ref Chap="Lists"/>.)
An immutable object <E>may</E> change, for example to store
new information, or to adopt a more efficient representation,
but this does not affect its behaviour under <M>=</M>.
<P/>
There are two points here to note. Firstly, <Q>operation</Q> above 
refers to the functions and methods which can legitimately be
applied to the object, and not the <C>!.</C> operation whereby 
virtually any aspect of any &GAP; level object may be changed.
The second point which follows from this, is that when 
implementing new types of objects, it is the programmer's
responsibility to ensure that the functions and methods they write
never change immutable objects mathematically.
<P/>
In fact, most objects with which one deals in &GAP; are immutable. 
For instance, the permutation <C>(1,2)</C> will never become a
different permutation or a non-permutation (although a variable which
previously had <C>(1,2)</C> stored in it may subsequently have some other
value). 
<P/>
For many purposes, however, <E>mutable</E> objects are useful.  These
objects may be changed to represent different mathematical objects during 
their life. For example, mutable lists can be changed by assigning values to
positions or by unbinding values at certain positions.  Similarly, one
can assign values to components of a mutable record, or unbind them.

<ManSection>
<Filt Name="IsCopyable" Arg='obj' Type='Category'/>

<Description>
If a mutable form of an object <A>obj</A> can be made in &GAP;,
the object is called <E>copyable</E>. Examples of copyable objects are of
course lists and records. A new mutable version of the object can
always be obtained by the operation <Ref Func="ShallowCopy"/>.
<P/>
Objects for which only an immutable form exists in &GAP; are called
<E>constants</E>.
Examples of constants are integers, permutations, and domains.
Called with a constant as argument,
<Ref Func="Immutable"/> and <Ref Func="ShallowCopy"/> return this
argument.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMutable" Arg='obj' Type='Category'/>

<Description>
tests whether <A>obj</A> is mutable.
<P/>
If an object is mutable then it is also copyable
(see&nbsp;<Ref Func="IsCopyable"/>),
and a <Ref Func="ShallowCopy"/> method should be supplied for it.
Note that <Ref Func="IsMutable"/> must not be implied by another filter,
since otherwise <Ref Func="Immutable"/> would be able to create
paradoxical objects in the sense that <Ref Func="IsMutable"/> for such an
object is <K>false</K> but the filter that implies
<Ref Func="IsMutable"/> is <K>true</K>.
<P/>
In many situations, however, one wants to ensure that objects are
<E>immutable</E>. For example, take the identity of a matrix group.
Since this matrix may be referred to as the identity of the group in
several places, it would be fatal to modify its entries,
or add or unbind rows.
We can obtain an immutable copy of an object with
<Ref Func="Immutable"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Immutable" Arg='obj'/>

<Description>
returns an immutable structural copy
(see&nbsp;<Ref Func="StructuralCopy"/>) of <A>obj</A>
in which the subobjects are immutable <E>copies</E> of the subobjects of
<A>obj</A>.
If <A>obj</A> is immutable then <Ref Func="Immutable"/> returns
<A>obj</A> itself.
<P/>
&GAP; will complain with an error if one tries to change an
immutable object.
</Description>
</ManSection>



<ManSection>
<Func Name="MakeImmutable" Arg='obj'/>

<Description>
One can turn the (mutable or immutable) object <A>obj</A> into an immutable
one with <Ref Func="MakeImmutable"/>;
note that this also makes all subobjects of <A>obj</A> immutable,
so one should call <Ref Func="MakeImmutable"/> only if <A>obj</A> and
its mutable subobjects are newly created.
If one is not sure about this, <Ref Func="Immutable"/> should be used.
<P/>
Note that it is <E>not</E> possible to turn an immutable object into a
mutable one;
only mutable copies can be made (see&nbsp;<Ref Sect="Duplication of Objects"/>).
<P/>
Using <Ref Func="Immutable"/>, it is possible to store an immutable identity
matrix or an immutable list of generators, and to pass around
references to this immutable object safely.  Only when a mutable
copy is really needed does the actual object have to be duplicated.
Compared to the situation without immutable objects, much unnecessary
copying is avoided this way.  Another advantage of immutability is
that lists of immutable objects may remember whether they are sorted
(see&nbsp;<Ref Sect="Sorted Lists and Sets"/>), which is not possible for lists of
mutable objects.
<P/>
Since the operation <Ref Func="Immutable"/> must work for any object
in &GAP;, it 
follows that an immutable form of every object must be possible, even
if it is not sensible, and user-defined objects must allow for the
possibility of becoming immutable without notice. 
</Description>
</ManSection>


<Subsection Label="subsect:mutability iterators">
<Heading>Mutability of Iterators</Heading>

An interesting example of mutable (and thus copyable) objects is
provided by <E>iterators</E>, see&nbsp;<Ref Sect="Iterators"/>.
(Of course an immutable form of an iterator is not very useful,
but clearly <Ref Func="Immutable"/> will yield such an object.)
Every call of <Ref Func="NextIterator"/> changes a mutable iterator until it is
exhausted, and this is the only way to change an iterator.
<Ref Func="ShallowCopy"/> for an iterator <A>iter</A> is defined so as to return a
mutable iterator that has no mutable data in common with <A>iter</A>,
and that behaves equally to <A>iter</A> w.r.t.&nbsp;<Ref Func="IsDoneIterator"/> and (if <A>iter</A>
is mutable) <Ref Func="NextIterator"/>.
Note that this meaning of the <Q>shallow copy</Q> of an iterator
that is returned by <Ref Func="ShallowCopy"/> is not as obvious as for lists and records,
and must be explicitly defined.

</Subsection>


<Subsection Label="subsect:mutability arithmetic operations">
<Heading>Mutability of Results of Arithmetic Operations</Heading>

Many operations return immutable results, among those in particular
attributes (see&nbsp;<Ref Sect="Attributes"/>).  Examples of attributes are <Ref Attr="Size"/>,
<Ref Func="Zero"/>, <Ref Func="AdditiveInverse"/>, <Ref Func="One"/>, and <Ref Func="Inverse"/>.  Arithmetic
operations, such as the binary infix operations <C>+</C>, <C>-</C>, <C>*</C>, <C>/</C>,
<C>^</C>, <K>mod</K>, the unary <C>-</C>, and operations such as <Ref Func="Comm"/> and
<Ref Func="LeftQuotient"/>, return <E>mutable</E> results, <E>except</E> if all arguments
are immutable.  So the product of two matrices or of a vector and a
matrix is immutable if and only if the two matrices or both the vector
and the matrix are immutable (see also&nbsp;<Ref Sect="Arithmetic for Lists"/>). There
is one exception to this rule, which arises where the result is less
deeply nested than at least one of the argument, where mutable
arguments may sometimes lead to an immutable result. For instance, a
mutable matrix with immutable rows, multiplied by an immutable vector
gives an immutable vector result. The exact rules are given 
in&nbsp;<Ref Sect="Arithmetic for Lists"/>.
<P/>

It should be noted that
<C>0 * <A>obj</A></C> is equivalent to <C>ZeroSM( <A>obj</A> )</C>,
<C>-<A>obj</A></C> is equivalent to <C>AdditiveInverseSM( <A>obj</A> )</C>,
<C><A>obj</A>^0</C> is equivalent to <C>OneSM( <A>obj</A>)</C>,
and <C><A>obj</A>^-1</C> is equivalent to <C>InverseSM( <A>obj</A> )</C>.
The <Q>SM</Q> stands for <Q>same mutability</Q>, and indicates that the result is
mutable if and only if the argument is mutable.
<P/>
The operations <Ref Func="ZeroOp"/>, <Ref Func="AdditiveInverseOp"/>, <Ref Func="OneOp"/>, and <Ref Func="InverseOp"/>
return <E>mutable</E> results whenever a mutable version of the result exists,
contrary to the attributes <Ref Func="Zero"/>, <Ref Func="AdditiveInverse"/>, <Ref Func="One"/>, and <Ref Func="Inverse"/>.
<P/>
If one introduces new arithmetic objects then one need not install
methods for the attributes <Ref Func="One"/>, <Ref Func="Zero"/>, etc.
The methods for the associated operations <Ref Func="OneOp"/> and <Ref Func="ZeroOp"/>
will be called, and then the results made immutable. 
<P/>
All methods installed for the arithmetic operations must obey the rule
about the mutability of the result.  This means that one may try to
avoid the perhaps expensive creation of a new object if both operands
are immutable, and of course no problems of this kind arise at all in
the (usual) case that the objects in question do not admit a mutable form,
i.e., that these objects are not copyable.
<P/>
In a few, relatively low-level algorithms, one wishes to treat a
matrix partly as a data structure, and manipulate and change its
entries.  For this, the matrix needs to be mutable, and the rule that
attribute values are immutable is an obstacle.  For these situations,
a number of additional operations are provided, for example
<Ref Func="TransposedMatMutable"/> constructs a mutable matrix (contrary to the
attribute <Ref Func="TransposedMat"/>), while <Ref Func="TriangulizeMat"/> modifies a mutable
matrix (in place) into upper triangular form.
<P/>
Note that being immutable does not forbid an object to store
knowledge.  For example, if it is found out that an immutable list is
strictly sorted then the list may store this information.  More
precisely, an immutable object may change in any way, provided that it
continues to represent the same mathematical object.

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Duplication of Objects">
<Heading>Duplication of Objects</Heading>

<Index>Copy</Index>
<Index Subkey="an object">copy</Index>
<Index Subkey="an object">clone</Index>
<ManSection>
<Oper Name="ShallowCopy" Arg='obj'/>

<Description>
<Ref Func="ShallowCopy"/> returns a <E>new mutable</E> object <E>equal</E> 
to its argument, if this is possible.
The subobjects of <C>ShallowCopy( <A>obj</A> )</C> are <E>identical</E>
to the subobjects of <A>obj</A>.
<P/>
If &GAP; does not support a mutable form of the immutable object <A>obj</A>
(see&nbsp;<Ref Sect="Mutability and Copyability"/>) then 
<Ref Func="ShallowCopy"/> returns <A>obj</A> itself.
<P/>
Since <Ref Func="ShallowCopy"/> is an operation, the concrete meaning of
<Q>subobject</Q> depends on the type of <A>obj</A>.
But for any copyable object <A>obj</A>, the definition should reflect the
idea of <Q>first level copying</Q>.
<P/>
The definition of <Ref Func="ShallowCopy"/> for lists (in particular for
matrices) can be found in&nbsp;<Ref Sect="Duplication of Lists"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="StructuralCopy" Arg='obj'/>

<Description>
In a few situations, one wants to make a <E>structural copy</E>
<C>scp</C> of an object <A>obj</A>.
This is defined as follows.
<C>scp</C> and <A>obj</A> are identical if <A>obj</A> is immutable.
Otherwise, <C>scp</C> is a mutable copy of <A>obj</A> such that
each subobject of <C>scp</C> is a structural copy of the corresponding
subobject of <A>obj</A>.
Furthermore, if two subobjects of <A>obj</A> are identical then
also the corresponding subobjects of <C>scp</C> are identical.
<Example><![CDATA[
gap> obj:= [ [ 0, 1 ] ];;
gap> obj[2]:= obj[1];;
gap> obj[3]:= Immutable( obj[1] );;
gap> scp:= StructuralCopy( obj );;
gap> scp = obj; IsIdenticalObj( scp, obj );
true
false
gap> IsIdenticalObj( scp[1], obj[1] );
false
gap> IsIdenticalObj( scp[3], obj[3] );
true
gap> IsIdenticalObj( scp[1], scp[2] );
true
]]></Example>
<P/>
That both <Ref Func="ShallowCopy"/> and <Ref Func="StructuralCopy"/>
return the argument <A>obj</A> itself if it is not copyable
is consistent with this definition,
since there is no way to change <A>obj</A> by modifying the result of any
of the two functions,
because in fact there is no way to change this result at all.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Other Operations Applicable to any Object">
<Heading>Other Operations Applicable to any Object</Heading>

There are a number of general operations which can be applied, in
principle, to any object in &GAP;. Some of these are documented
elsewhere &ndash;see <Ref Func="String"/>, <Ref Func="PrintObj"/> and
<Ref Func="Display"/>. Others are mainly somewhat technical.


<ManSection>
<Func Name="SetName" Arg='obj, name'/>

<Description>
for a suitable object <A>obj</A> sets that object to have  name  <A>name</A>  (a
string).
</Description>
</ManSection>


<ManSection>
<Attr Name="Name" Arg='obj'/>

<Description>
returns the name, a string, previously assigned to <A>obj</A> via a call
to <Ref Func="SetName"/>.
The name of an object is used <E>only</E> for viewing the object via this
name.
<P/>
There are no methods installed for computing names of objects,
but the name may be set for suitable objects,
using <Ref Func="SetName"/>.
<Example><![CDATA[
gap> R := PolynomialRing(Integers,2);
Integers[x_1,x_2]
gap> SetName(R,"Z[x,y]");
gap> R;
Z[x,y]
gap> Name(R);
"Z[x,y]"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="InfoText" Arg='obj'/>

<Description>
is a mutable string with information about the object <A>obj</A>.
There is no default method to create an info text.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsInternallyConsistent" Arg='obj'/>

<Description>
For debugging purposes, it may be useful to check the consistency of
an object <A>obj</A> that is composed from other (composed) objects.
<P/>
There is a default method of <Ref Func="IsInternallyConsistent"/>,
with rank zero, that returns <K>true</K>.
So it is possible (and recommended) to check the consistency of
subobjects of <A>obj</A> recursively by
<Ref Func="IsInternallyConsistent"/>.
<P/>
(Note that <Ref Func="IsInternallyConsistent"/> is not an attribute.)
</Description>
</ManSection>


<ManSection>
<Oper Name="MemoryUsage" Arg='obj'/>

<Description>
returns the amount of memory in bytes used by the object <A>obj</A> and its
subobjects. Note that in general, objects can reference each other
in very difficult ways such that determining the memory usage is
a recursive procedure. In particular, computing the memory usage
of a complicated structure itself uses some additional memory,
which is however no longer used after completion of this operation.
This procedure descends into lists and records, positional and
component objects, however it does not take into account the type
and family objects! For functions, it only takes the memory usage
of the function body, not of the local context the function was
created in, although the function keeps a reference to that as well!
</Description>
</ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  types.msk                 GAP manual                    Thomas Breuer -->
<!-- %W                                                       Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: types.msk,v 1.30 2006/03/07 14:48:33 sal Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Types of Objects">
<Heading>Types of Objects</Heading>

Every &GAP; object has a <E>type</E>. The type of an object is the
information which is used to decide whether an operation is admissible
or possible with that object as an argument, and if so, how it is to
be performed
(see Chapter&nbsp;<Ref Chap="Method Selection"/>).
<P/>
For example, the types determine whether two objects can be multiplied
and what function is called to compute the product.  Analogously, the
type of an object determines whether and how the size of the object
can be computed. It is sometimes useful in discussing the type system,
to identify types with the set of objects that have this type. Partial
types can then also be regarded as sets, such that any type is the
intersection of its parts.
<P/>
The type of an object consists of two main parts, which describe
different aspects of the object.
<P/>
The <E>family</E> determines the relation of the object to other objects.
For example, all permutations form a family.  Another family consists
of all collections of permutations, this family contains the set of
permutation groups as a subset.  A third family consists of all
rational functions with coefficients in a certain family.
<P/>
The other part of a type is a collection of <E>filters</E> (actually stored
as a bit-list indicating, from the complete set of possible filters,
which are included in this particular type). These filters are all
treated equally by the method selection, but, from the viewpoint of
their creation and use, they can be divided (with a small number of
unimportant exceptions) into categories, representations, attribute
testers and properties. Each of these is described in more detail below.
<P/>
This chapter does not describe how types and their constituent parts
can be created.  Information about this topic can be found in
Chapter&nbsp;<Ref Chap="Creating New Objects"/>.
<P/>
<E>Note:</E> Detailed understanding of the type system is not
required to use &GAP;. It can be helpful, however, to understand how things
work and why &GAP; behaves the way it does.
<P/>
<!-- %%  The type system of &GAP; was devised by Thomas Breuer, Frank Celler, Steve -->
<!-- %%  Linton and Martin Schönert, -->
A discussion of the type system can be found in <Cite Key="BreuerLinton98"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Families">
<Heading>Families</Heading>

The family of an object determines its relationship to other objects.
<P/>
More precisely, the families form a partition of all &GAP; objects
such that the following two conditions hold: objects that are equal
w.r.t. <C>=</C> lie in the same family; and the family of the result of
an operation depends only on the families of its operands.
<P/>
The first condition means that a family can be regarded as a set of
elements instead of a set of objects.  Note that this does not hold
for categories and representations (see below), two objects that are
equal w.r.t. <C>=</C> need not lie in the same categories and
representations.  For example, a sparsely represented matrix can be
equal to a densely represented matrix.  Similarly, each domain is
equal w.r.t. <C>=</C> to the sorted list of its elements, but a domain
is not a list, and a list is not a domain.

<ManSection>
<Func Name="FamilyObj" Arg='obj'/>

<Description>
returns the family of the object <A>obj</A>.
<P/>
The family of the object <A>obj</A> is itself an object,
its family is <C>FamilyOfFamilies</C>.
<P/>
It should be emphasized that families may be created when they are
needed.  For example, the family of elements of a finitely presented
group is created only after the presentation has been constructed.
Thus families are the dynamic part of the type system, that is, the
part that is not fixed after the initialisation of &GAP;.
<P/>
Families can be parametrized.  For example, the elements of each
finitely presented group form a family of their own.  Here the family
of elements and the finitely presented group coincide when viewed as
sets.  Note that elements in different finitely presented groups lie
in different families.  This distinction allows &GAP; to forbid
multiplications of elements in different finitely presented groups.
<P/>
As a special case, families can be parametrized by other families.  An
important example is the family of <E>collections</E> that can be formed
for each family.  A collection consists of objects that lie in the
same family, it is either a nonempty dense list of objects from the
same family or a domain.
<P/>
Note that every domain is a collection, that is, it is not possible to
construct domains whose elements lie in different families.  For
example, a polynomial ring over the rationals cannot contain the
integer <C>0</C> because the family that contains the integers does not
contain polynomials.  So one has to distinguish the integer zero from
each zero polynomial.
<P/>
Let us look at this example from a different viewpoint.  A polynomial
ring and its coefficients ring lie in different families, hence the
coefficients ring cannot be embedded <Q>naturally</Q> into the polynomial
ring in the sense that it is a subset.  But it is possible to allow,
e.g., the multiplication of an integer and a polynomial over the
integers.  The relation between the arguments, namely that one is a
coefficient and the other a polynomial, can be detected from the
relation of their families.  Moreover, this analysis is easier than in
a situation where the rationals would lie in one family together with
all polynomials over the rationals, because then the relation of
families would not distinguish the multiplication of two polynomials,
the multiplication of two coefficients, and the multiplication of a
coefficient with a polynomial.  So the wish to describe relations
between elements can be taken as a motivation for the introduction of
families.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Filters">
<Heading>Filters</Heading>

A <E>filter</E> is a special unary &GAP; function that returns either <K>true</K>
or <K>false</K>, depending on whether or not the argument lies in the set defined
by the filter.
Filters are used to express different aspects of information about a &GAP;
object, which are described below
(see&nbsp;<Ref Sect="Categories"/>, <Ref Sect="Representation"/>, <Ref Sect="Attributes"/>,
<Ref Sect="Setter and Tester for Attributes"/>, <Ref Sect="Properties"/>, <Ref Sect="Other Filters"/>).
<P/>
Presently any filter in &GAP; is implemented as a function which
corresponds to a set of positions in the bitlist which forms part of the
type of each &GAP; object, and returns <K>true</K> if and only if the bitlist
of the type of the argument has the value <K>true</K> at all of these positions.
<P/>
The intersection (or meet) of two filters <A>filt1</A>, <A>filt2</A> is again a
filter, it can be formed as
<P/>
<Index Key="and" Subkey="for filters"><K>and</K></Index>
<A>filt1</A> <K>and</K> <A>filt2</A>
<P/>
See <Ref Sect="Operations for Booleans"/> for more details.
<P/>
For example, <C>IsList and IsEmpty</C> is a filter that returns <K>true</K> if
its argument is an empty list, and <K>false</K> otherwise.
The filter <Ref Func="IsGroup"/> is defined as the intersection of
the category <Ref Func="IsMagmaWithInverses"/>
and the property <Ref Func="IsAssociative"/>.
<P/>
A filter that is not the meet of other filters is called a <E>simple
filter</E>.
For example, each attribute tester (see&nbsp;<Ref Sect="Setter and Tester for Attributes"/>)
is a simple filter.
Each simple filter corresponds to a position in the bitlist currently
used as part of the data structure representing a type.
<P/>
Every filter has a <E>rank</E>,
which is used to define a ranking of the methods installed for an operation,
see Section&nbsp;<Ref Sect="Method Installation"/>.
The rank of a filter can be accessed with <Ref Func="RankFilter"/>.

<ManSection>
<Func Name="RankFilter" Arg='filt'/>

<Description>
For simple filters, an <E>incremental rank</E> is defined when the filter is
created, see the sections about the creation of filters:
<Ref Sect="Creating Categories"/>,
<Ref Sect="Creating Representations"/>,
<Ref Sect="Creating Attributes and Properties"/>,
<Ref Sect="Creating Other Filters"/>.
For an arbitrary filter, its rank is given by the sum of the incremental
ranks of the <E>involved</E> simple filters;
in addition to the implied filters, these are also the required filters
of attributes (again see the sections about the creation of filters).
In other words, for the purpose of computing the rank and <E>only</E> for this
purpose, attribute testers are treated as if they would imply the
requirements of their attributes.
<!-- % say something about the implementation via <C>InstallHiddenTrueMethod</C>? -->
</Description>
</ManSection>

<ManSection>
<Func Name="NamesFilter" Arg='filt'/>

<Description>
<Ref Func="NamesFilter"/> returns a list of names of the <E>implied</E>
simple filters of the filter <A>filt</A>,
these are all those simple filters <C>imp</C> such that every object in
<A>filt</A> also lies in <C>imp</C>.
For implications between filters, see <Ref Func="ShowImpliedFilters"/>
as well as sections&nbsp;<Ref Sect="Logical Implications"/>,
<Ref Sect="Creating Categories"/>,
<Ref Sect="Creating Representations"/>,
<Ref Sect="Creating Attributes and Properties"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowImpliedFilters" Arg='filter'/>

<Description>
Displays information about the filters that may be implied by 
<A>filter</A>. They are given by their names. <C>ShowImpliedFilters</C> first
displays the names of all filters that are unconditionally implied by
<A>filter</A>. It then displays implications that require further filters to
be present (indicating by <C>+</C> the required further filters).
The function displays only first-level implications, implications that
follow in turn are not displayed (though &GAP; will do these).
<Example><![CDATA[
gap> ShowImpliedFilters(IsMatrix);
Implies:
   IsGeneralizedRowVector
   IsNearAdditiveElementWithInverse
   IsAdditiveElement
   IsMultiplicativeElement


May imply with:
+IsGF2MatrixRep
   IsOrdinaryMatrix

+CategoryCollections(CategoryCollections(IsAdditivelyCommutativeElement))
   IsAdditivelyCommutativeElement

+IsInternalRep
   IsOrdinaryMatrix

]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Categories">
<Heading>Categories</Heading>

The <E>categories</E> of an object are filters (see&nbsp;<Ref Sect="Filters"/>)
that determine what operations an object admits.
For example, all integers form a category, all rationals form a category,
and all rational functions form a category.
An object which claims to lie in a certain category is accepting the
requirement that it should have methods for certain operations (and
perhaps that their behaviour should satisfy certain axioms).
For example, an object lying in the category <Ref Filt="IsList"/> must have
methods for <Ref Attr="Length"/>, <Ref Oper="IsBound\[\]"/>
and the list element access operation <Ref Oper="\[\]"/>.
<P/>
An object can lie in several categories.  For example, a row vector
lies in the categories <Ref Filt="IsList"/> and <Ref Filt="IsVector"/>;
each list lies in the category <Ref Filt="IsCopyable"/>,
and depending on whether or not it is mutable,
it may lie in the category <Ref Filt="IsMutable"/>.
Every domain lies in the category <Ref Filt="IsDomain"/>.
<P/>
Of course some categories of a mutable object may change when the
object is changed.  For example, after assigning values to positions
of a mutable non-dense list, this list may become part of the category
<Ref Filt="IsDenseList"/>.
<P/>
However, if an object is immutable then the set of categories it lies
in is fixed.
<P/>
All categories in the library are created during initialization, in
particular they are not created dynamically at runtime.
<P/>
The following list gives an overview of important categories of
arithmetic objects.  Indented categories are to be understood as
subcategories of the non indented category listed above it.
<Log><![CDATA[
    IsObject
        IsExtLElement
        IsExtRElement
            IsMultiplicativeElement
                IsMultiplicativeElementWithOne
                    IsMultiplicativeElementWithInverse
        IsExtAElement
            IsAdditiveElement
                IsAdditiveElementWithZero
                    IsAdditiveElementWithInverse
]]></Log>
Every object lies in the category <Ref Filt="IsObject"/>.
<P/>
The categories <Ref Filt="IsExtLElement"/> and <Ref Filt="IsExtRElement"/> 
contain objects that can be multiplied with other objects via <C>*</C> from 
the left and from the right, respectively. These categories are required 
for the operands of the operation <C>*</C>.
<P/>
The category <Ref Filt="IsMultiplicativeElement"/> contains objects that 
can be multiplied from the left and from the right with objects from the 
same family. <Ref Filt="IsMultiplicativeElementWithOne"/> contains objects 
<C>obj</C> for which a multiplicatively neutral element can be obtained by 
taking the <M>0</M>-th power <C>obj^0</C>.
<Ref Filt="IsMultiplicativeElementWithInverse"/> contains objects 
<C>obj</C> for which a multiplicative inverse can be obtained by
forming <C>obj^-1</C>.
<P/>
Likewise, the categories <Ref Filt="IsExtAElement"/>, 
<Ref Filt="IsAdditiveElement"/>, <Ref Filt="IsAdditiveElementWithZero"/>
and <Ref Filt="IsAdditiveElementWithInverse"/>
contain objects that can be added via <C>+</C> to other objects, objects
that can be added to objects of the same family, objects for which an
additively neutral element can be obtained by multiplication with
zero, and objects for which an additive inverse can be obtained by
multiplication with <C>-1</C>.
<P/>
So a vector lies in <Ref Filt="IsExtLElement"/>, <Ref Filt="IsExtRElement"/>
and <Ref Filt="IsAdditiveElementWithInverse"/>. A ring element must 
additionally lie in <Ref Filt="IsMultiplicativeElement"/>.
<P/>
As stated above it is not guaranteed by the categories of objects
whether the result of an operation with these objects as arguments is
defined.  For example, the category <Ref Filt="IsMatrix"/> is a subcategory 
of <Ref Filt="IsMultiplicativeElementWithInverse"/>. Clearly not every 
matrix has a multiplicative inverse. But the category <Ref Filt="IsMatrix"/> 
makes each matrix an admissible argument of the operation 
<Ref Oper="Inverse"/>, which may sometimes return <K>fail</K>.
Likewise, two matrices can be multiplied only if they are of appropriate
shapes.
<P/>
Analogous to the categories of arithmetic elements, there are
categories of domains of these elements.
<Log><![CDATA[
    IsObject
        IsDomain
            IsMagma
                IsMagmaWithOne
                    IsMagmaWithInversesIfNonzero
                        IsMagmaWithInverses
            IsAdditiveMagma
                IsAdditiveMagmaWithZero
                    IsAdditiveMagmaWithInverses
            IsExtLSet
            IsExtRSet
]]></Log>
Of course <Ref Func="IsDomain"/> is a subcategory of <Ref Func="IsObject"/>.
A domain that is
closed under multiplication <C>*</C> is called a magma and it lies in the
category <Ref Func="IsMagma"/>.
If a magma is closed under taking the identity,
it lies in <Ref Filt="IsMagmaWithOne"/>, and if it is also closed under 
taking inverses, it lies in <Ref Filt="IsMagmaWithInverses"/>. The category
<Ref Filt="IsMagmaWithInversesIfNonzero"/> denotes closure under taking 
inverses only for nonzero elements, every division ring lies in this category.
<P/>
Note that every set of categories constitutes its own notion of
generation, for example a group may be generated as a magma with
inverses by some elements, but to generate it as a magma with one it
may be necessary to take the union of these generators and their
inverses.

<ManSection>
<Oper Name="CategoriesOfObject" Arg='object'/>

<Description>
returns a list of the names of the categories in which <A>object</A> lies.
<Example><![CDATA[
gap> g:=Group((1,2),(1,2,3));;
gap> CategoriesOfObject(g);
[ "IsListOrCollection", "IsCollection", "IsExtLElement",
  "CategoryCollections(IsExtLElement)", "IsExtRElement",
  "CategoryCollections(IsExtRElement)",
  "CategoryCollections(IsMultiplicativeElement)",
  "CategoryCollections(IsMultiplicativeElementWithOne)",
  "CategoryCollections(IsMultiplicativeElementWithInverse)",
  "CategoryCollections(IsAssociativeElement)",
  "CategoryCollections(IsFiniteOrderElement)", "IsGeneralizedDomain",
  "CategoryCollections(IsPerm)", "IsMagma", "IsMagmaWithOne",
  "IsMagmaWithInversesIfNonzero", "IsMagmaWithInverses" ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Representation">
<Heading>Representation</Heading>

The <E>representation</E> of an object is a set of filters (see&nbsp;<Ref Sect="Filters"/>)
that determines how an object is actually represented.
For example, a matrix or a polynomial can be stored sparsely or
densely; all dense polynomials form a representation. An object which
claims to lie in a certain representation is accepting the requirement
that certain fields in the data structure be present and have
specified meanings.
<P/>
&GAP; distinguishes four essentially different ways to represent
objects.  First there are the representations <C>IsInternalRep</C> for
internal objects such as integers and permutations, and
<C>IsDataObjectRep</C> for other objects that are created and whose data
are accessible only by kernel functions. The data structures
underlying such objects cannot be manipulated at the &GAP; level.
<P/>
All other objects are either in the representation
<C>IsComponentObjectRep</C> or in the representation
<C>IsPositionalObjectRep</C>,
see&nbsp;<Ref Sect="Component Objects"/>
and&nbsp;<Ref Sect="Positional Objects"/>.
<P/>
An object can belong to several representations in the sense that it
lies in several subrepresentations of <C>IsComponentObjectRep</C> or of
<C>IsPositionalObjectRep</C>.  The representations to which an object
belongs should form a chain and either two representations are disjoint
or one is contained in the other.  So the subrepresentations of
<C>IsComponentObjectRep</C> and <C>IsPositionalObjectRep</C> each form
trees. In the language of Object Oriented Programming, we support only
single inheritance for representations.
<P/>
These trees are typically rather shallow, since for one representation
to be contained in another implies that all the components of the data
structure implied by the containing representation, are present in,
and have the same meaning in, the smaller representation (whose data
structure presumably contains some additional components).
<P/>
Objects may change their representation, for example a mutable list
of characters can be converted into a string.
<P/>
All representations in the library are created during initialization,
in particular they are not created dynamically at runtime.
<P/>
Examples of subrepresentations of <C>IsPositionalObjectRep</C> are
<C>IsModulusRep</C>, which is used for residue classes in the ring of
integers, and <C>IsDenseCoeffVectorRep</C>, which is used for elements of
algebras that are defined by structure constants.
<P/>
An important subrepresentation of <C>IsComponentObjectRep</C> is
<C>IsAttributeStoringRep</C>, which is used for many domains and some other
objects.  It provides automatic storing of all attribute values (see
below).

<ManSection>
<Oper Name="RepresentationsOfObject" Arg='object'/>

<Description>
returns a list of the names of the representations <A>object</A> has.
<Example><![CDATA[
gap> g:=Group((1,2),(1,2,3));;
gap> RepresentationsOfObject(g);
[ "IsComponentObjectRep", "IsAttributeStoringRep" ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes">
<Heading>Attributes</Heading>

The attributes of an object describe knowledge about it. 
<P/>
An attribute is a unary operation without side-effects.
<P/>
An object may store values of its attributes once they have been
computed, and claim that it knows these values.  Note that <Q>store</Q>
and <Q>know</Q> have to be understood in the sense that it is very cheap
to get such a value when the attribute is called again.
<P/>
The stored value of an attribute is in general immutable
(see&nbsp;<Ref Sect="Mutability and Copyability"/>),
except if the attribute had been specially constructed as
<Q>mutable attribute</Q>.
<P/>
It depends on the representation of an object (see&nbsp;<Ref Sect="Representation"/>)
which attribute values it stores.  An object in the representation
<C>IsAttributeStoringRep</C> stores <E>all</E> attribute values once they are
computed.  Moreover, for an object in this representation, subsequent
calls to an attribute will return the <E>same</E> object; this is achieved
via a special method for each attribute setter that stores the
attribute value in an object in <C>IsAttributeStoringRep</C>, and a special
method for the attribute itself that fetches the stored attribute
value.  (These methods are called the <Q>system setter</Q> and the
<Q>system getter</Q> of the attribute, respectively.)<Index>system
getter</Index><Index>system setter</Index>
<P/>
Note also that it is impossible to get rid of a stored attribute
value because the system may have drawn conclusions from the old
attribute value, and just removing the value might leave the data
structures in an inconsistent state. If necessary, a new object can be
constructed.
<P/>
Several attributes have methods for more than one argument.  For example
<Ref Prop="IsTransitive" Label="for a group, an action domain, etc."/>
is an attribute for a <M>G</M>-set that
can also be called for the two arguments, being a group <M>G</M> and its action
domain.  If attributes are called with more than one argument then the
return value is not stored in any of the arguments.
<P/>
Properties are a special form of attributes that have the value <K>true</K>
or <K>false</K>, see section&nbsp;<Ref Sect="Properties"/>.
<P/>
Examples of attributes for multiplicative elements are
<Ref Func="Inverse"/>, <Ref Func="One"/>,
and <Ref Func="Order"/>.
<Ref Func="Size"/> is an attribute for domains,
<Ref Func="Centre"/> is an attribute for magmas,
and <Ref Func="DerivedSubgroup"/> is an attribute for groups.

<ManSection>
<Oper Name="KnownAttributesOfObject" Arg='object'/>

<Description>
returns a list of the names of the attributes whose values are known for 
<A>object</A>.
<Example><![CDATA[
gap> g:=Group((1,2),(1,2,3));;Size(g);;
gap> KnownAttributesOfObject(g);
[ "Size", "OneImmutable", "NrMovedPoints", "MovedPoints", 
  "GeneratorsOfMagmaWithInverses", "MultiplicativeNeutralElement", 
  "HomePcgs", "Pcgs", "GeneralizedPcgs", "StabChainMutable", 
  "StabChainOptions" ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Setter and Tester for Attributes">
<Heading>Setter and Tester for Attributes</Heading>

<Index>setter</Index>
<Index>tester</Index>
For every attribute, the <E>attribute setter</E>
and the <E>attribute tester</E> are defined.
<P/>
To check whether an object belongs to an attribute <A>attr</A>,
the tester of the attribute is used, see <Ref Func="Tester"/>.
To store a value for the attribute <A>attr</A> in an object,
the setter of the attribute is used, see <Ref Func="Setter"/>.


<ManSection>
<Func Name="Tester" Arg='attr'/>

<Description>
For an attribute <A>attr</A>, <C>Tester(<A>attr</A>)</C> 
is a filter (see&nbsp;<Ref Sect="Filters"/>) 
that returns <K>true</K> or <K>false</K>,
depending on whether or not the value of <A>attr</A> for the object is known.
For example, <C>Tester( Size )( <A>obj</A> )</C> is <K>true</K> if the size
of the object <A>obj</A> is known.
</Description>
</ManSection>

<ManSection>
<Func Name="Setter" Arg='attr'/>

<Description>
For an attribute <A>attr</A>, <C>Setter(<A>attr</A>)</C> 
is called automatically when the attribute value has been
computed for the first time.
One can also call the setter explicitly,
for example, <C>Setter( Size )( <A>obj</A>, <A>val</A> )</C> 
sets <A>val</A> as size of the
object <A>obj</A> if the size was not yet known.
<P/>
For each attribute <A>attr</A> that is declared with
<Ref Func="DeclareAttribute"/>
resp.&nbsp;<Ref Func="DeclareProperty"/>
(see&nbsp;<Ref Sect="Global Variables in the Library"/>),
tester and setter are automatically made accessible by the names
<C>Has<A>attr</A></C> and <C>Set<A>attr</A></C>, respectively.
For example, the tester for <Ref Func="Size"/> is called <C>HasSize</C>,
and the setter is called <C>SetSize</C>.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;Size(g);
24
gap> HasSize(g);
true
gap> SetSize(g,99);
gap> Size(g);
24
]]></Example>
<P/>
For two properties <A>prop1</A> and <A>prop2</A>,
the intersection <C><A>prop1</A> and <A>prop2</A></C> (see&nbsp;<Ref Sect="Filters"/>) is again a property
for which a setter and a tester exist.
Setting the value of this intersection to <K>true</K> for a &GAP; object
means to set the values of <A>prop1</A> and <A>prop2</A> to <K>true</K> for this object.
<P/>
<Example><![CDATA[
gap> prop:= IsFinite and IsCommutative;
<Property "<<and-filter>>">
gap> g:= Group( (1,2,3), (4,5) );;
gap> Tester( prop )( g );
false
gap> Setter( prop )( g, true );
gap> Tester( prop )( g );  prop( g );
true
true
]]></Example>
<P/>
It is <E>not allowed</E> to set the value of such an intersection to <K>false</K>
for an object.
<P/>
<Log><![CDATA[
gap> Setter( prop )( Rationals, false );
You cannot set an "and-filter" except to true
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can type 'return true;' to set all components true
(but you might really want to reset just one component) to continue
brk> 
]]></Log>
</Description>
</ManSection>


<ManSection>
<Func Name="AttributeValueNotSet" Arg='attr, obj'/>

<Description>
If the value of the attribute <A>attr</A> is already stored for <A>obj</A>,
<C>AttributeValueNotSet</C> simply returns this value.
Otherwise the value of <C><A>attr</A>( <A>obj</A> )</C> is computed and returned
<E>without storing it</E> in <A>obj</A>.
This can be useful when <Q>large</Q> attribute values (such as element lists)
are needed only once and shall not be stored in the object.
<P/>
<Example><![CDATA[
gap> HasAsSSortedList(g);
false
gap> AttributeValueNotSet(AsSSortedList,g);
[ (), (4,5), (1,2,3), (1,2,3)(4,5), (1,3,2), (1,3,2)(4,5) ]
gap> HasAsSSortedList(g);
false
]]></Example>
<P/>
The normal behaviour of attributes (when called with just one argument)
is that once a method has been selected and executed, and has returned a
value the setter of the attribute is called, to (possibly) store the
computed value. In special circumstances, this behaviour can be altered
dynamically on an attribute-by-attribute basis, using the functions
<C>DisableAttributeValueStoring</C> and <C>EnableAttributeValueStoring</C>.
<P/>
In general, the code in the library assumes, for efficiency, but not for
correctness, that attribute values <E>will</E> be stored (in suitable
objects), so disabling storing may cause substantial computations to be
repeated.

</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoAttributes"/>

<Description>
This info class (together with <Ref Func="InfoWarning"/> is  used
for messages about attribute storing  being  disabled  (at  level  2)  or
enabled (level 3). It may be  used  in  the  future  for  other  messages
concerning changes to attribute behaviour.
</Description>
</ManSection>

<ManSection>
<Func Name="DisableAttributeValueStoring" Arg='attr'/>

<Description>
disables the usual call of <C>Setter( <A>attr</A> )</C> when a  method  for  <A>attr</A>
returns a value. In consequence the values will  never  be  stored.  Note
that <A>attr</A> must be an attribute and <E>not</E> a property.
</Description>
</ManSection>

<ManSection>
<Func Name="EnableAttributeValueStoring" Arg='attr'/>

<Description>
enables the usual call of <C>Setter( <A>attr</A> )</C> when  a  method  for  <A>attr</A>
returns a value. In consequence the  values  may  be  stored.  This  will
usually  have  no  effect   unless   <C>DisableAttributeValueStoring</C>   has
previously been used for <A>attr</A>. Note that <A>attr</A> must  be  an  attribute
and <E>not</E> a property.
<Example><![CDATA[
gap> g := Group((1,2,3,4,5),(1,2,3));
Group([ (1,2,3,4,5), (1,2,3) ])
gap> KnownAttributesOfObject(g);
[ "LargestMovedPoint", "GeneratorsOfMagmaWithInverses", 
  "MultiplicativeNeutralElement" ]
gap> SetInfoLevel(InfoAttributes,3);
gap> DisableAttributeValueStoring(Size);
#I  Disabling value storing for Size
gap> Size(g);
60
gap> KnownAttributesOfObject(g);
[ "OneImmutable", "LargestMovedPoint", "NrMovedPoints", 
  "MovedPoints", "GeneratorsOfMagmaWithInverses", 
  "MultiplicativeNeutralElement", "StabChainMutable", 
  "StabChainOptions" ]
gap> Size(g);
60
gap> EnableAttributeValueStoring(Size);
#I  Enabling value storing for Size
gap> Size(g);
60
gap> KnownAttributesOfObject(g);
[ "Size", "OneImmutable", "LargestMovedPoint", "NrMovedPoints", 
  "MovedPoints", "GeneratorsOfMagmaWithInverses", 
  "MultiplicativeNeutralElement", "StabChainMutable", 
  "StabChainOptions" ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties">
<Heading>Properties</Heading>

The properties of an object are those of its attributes (see&nbsp;<Ref Sect="Attributes"/>)
whose values can only be <K>true</K> or <K>false</K>.
<P/>
The main difference between attributes and properties is that a
property defines two sets of objects, namely the usual set of all
objects for which the value is known, and the set of all objects for
which the value is known to be <K>true</K>.
<P/>
(Note that it makes no sense to consider a third set, namely the set
of objects for which the value of a property is <K>true</K> whether or not
it is known, since there may be objects for which the containment in
this set cannot be decided.)
<P/>
For a property <A>prop</A>, the containment of an object <A>obj</A> in the first
set is checked again by applying <C>Tester( <A>prop</A> )</C> to <A>obj</A>,
and <A>obj</A> lies in the second set if and only if
<C>Tester( <A>prop</A> )( <A>obj</A> ) and <A>prop</A>( <A>obj</A> )</C> is <K>true</K>.
<P/>
If a property value is known for an immutable object then this value is
also stored, as part of the type of the object.
To some extent, property values of mutable objects also can be stored,
for example a mutable list all of whose entries are immutable can store
whether it is strictly sorted. When the object is mutated (for example
by list assignment) the type may need to be adjusted.
<P/>
Important properties for domains are <Ref Func="IsAssociative"/>,
<Ref Func="IsCommutative"/>, <Ref Func="IsAnticommutative"/>,
<Ref Func="IsLDistributive"/> and <Ref Func="IsRDistributive"/>,
which mean that the multiplication of elements in the domain satisfies
<M>( a * b ) * c = a * ( b * c )</M>, <M>a * b = b * a</M>,
<M>a * b = - ( b * a )</M>, <M>a * ( b + c ) = a * b + a * c</M>,
and <M>( a + b ) * c = a * c + b * c</M>, respectively,
for all <M>a</M>, <M>b</M>, <M>c</M> in the domain.
<P/>
<ManSection>
<Oper Name="KnownPropertiesOfObject" Arg='object'/>

<Description>
returns a list of the names of the properties whose values are known for
<A>object</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="KnownTruePropertiesOfObject" Arg='object'/>

<Description>
returns a list of the names of the properties known to be <K>true</K> for
<A>object</A>.
<Example><![CDATA[
gap> g:=Group((1,2),(1,2,3));;
gap> KnownPropertiesOfObject(g);
[ "IsFinite", "CanEasilyCompareElements", "CanEasilySortElements", 
  "IsDuplicateFree", "IsGeneratorsOfMagmaWithInverses", 
  "IsAssociative", "IsGeneratorsOfSemigroup", "IsSimpleSemigroup", 
  "IsRegularSemigroup", "IsInverseSemigroup", 
  "IsCompletelyRegularSemigroup", "IsCompletelySimpleSemigroup", 
  "IsGroupAsSemigroup", "IsMonoidAsSemigroup", "IsOrthodoxSemigroup", 
  "IsFinitelyGeneratedGroup", "IsSubsetLocallyFiniteGroup", 
  "KnowsHowToDecompose", "IsNilpotentByFinite" ]
gap> Size(g);
6
gap> KnownPropertiesOfObject(g);
[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", 
  "CanEasilyCompareElements", "CanEasilySortElements", 
  "IsDuplicateFree", "IsGeneratorsOfMagmaWithInverses", 
  "IsAssociative", "IsGeneratorsOfSemigroup", "IsSimpleSemigroup", 
  "IsRegularSemigroup", "IsInverseSemigroup", 
  "IsCompletelyRegularSemigroup", "IsCompletelySimpleSemigroup", 
  "IsGroupAsSemigroup", "IsMonoidAsSemigroup", "IsOrthodoxSemigroup", 
  "IsFinitelyGeneratedGroup", "IsSubsetLocallyFiniteGroup", 
  "KnowsHowToDecompose", "IsPerfectGroup", "IsSolvableGroup", 
  "IsPolycyclicGroup", "IsNilpotentByFinite", "IsTorsionFree", 
  "IsFreeAbelian" ]
gap> KnownTruePropertiesOfObject(g);
[ "IsNonTrivial", "IsFinite", "CanEasilyCompareElements", 
  "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfMagmaWithInverses", "IsAssociative", 
  "IsGeneratorsOfSemigroup", "IsSimpleSemigroup", 
  "IsRegularSemigroup", "IsInverseSemigroup", 
  "IsCompletelyRegularSemigroup", "IsCompletelySimpleSemigroup", 
  "IsGroupAsSemigroup", "IsMonoidAsSemigroup", "IsOrthodoxSemigroup", 
  "IsFinitelyGeneratedGroup", "IsSubsetLocallyFiniteGroup", 
  "KnowsHowToDecompose", "IsSolvableGroup", "IsPolycyclicGroup", 
  "IsNilpotentByFinite" ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Other Filters">
<Heading>Other Filters</Heading>

There are situations where one wants to express a kind of knowledge
that is based on some heuristic.
<P/>
For example, the filters (see&nbsp;<Ref Sect="Filters"/>)
<Ref Filt="CanEasilyTestMembership"/> and
<Ref Filt="CanEasilyComputePcgs"/> are defined in the &GAP; library.
Note that such filters do not correspond to a mathematical concept,
contrary to properties (see&nbsp;<Ref Sect="Properties"/>).
Also it need not be defined what <Q>easily</Q> means for an arbitrary &GAP;
object, and in this case one cannot compute the value for an arbitrary
&GAP; object.
In order to access this kind of knowledge as a part of the type of an object,
&GAP; provides filters for which the value is <K>false</K> by default,
and it is changed to <K>true</K> in certain situations,
either explicitly (for the given object) or via a logical implication
(see&nbsp;<Ref Sect="Logical Implications"/>)
from other filters.
<P/>
For example, a <K>true</K> value of <Ref Filt="CanEasilyComputePcgs"/> 
for a group means that certain methods are applicable that use a pcgs
(see&nbsp;<Ref Sect="Polycyclic Generating Systems"/>) for the group.
There are logical implications to set the filter value to <K>true</K>
for permutation groups that are known to be solvable,
and for groups that have already a (sufficiently nice) pcgs stored.
In the case one has a solvable matrix group and wants to enable methods
that use a pcgs, one can set the <Ref Filt="CanEasilyComputePcgs"/> 
value to <K>true</K> for this particular group.
<P/>
A filter <A>filt</A> of the kind described here is different from
the other filters introduced in the previous sections.
In particular, <A>filt</A> is not a category (see&nbsp;<Ref Sect="Categories"/>) or a property
(see&nbsp;<Ref Sect="Properties"/>) because its value may change for a given object,
and <A>filt</A> is not a representation (see&nbsp;<Ref Sect="Representation"/>) because it has
nothing to do with the way an object is made up from some data.
<A>filt</A> is similar to an attribute tester
(see&nbsp;<Ref Sect="Setter and Tester for Attributes"/>),
the only difference is that <A>filt</A> does not refer to an attribute value;
note that <A>filt</A> is also used in the same way as an attribute tester;
namely, the <K>true</K> value may be required for certain methods to be
applicable.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Types">
<Heading>Types</Heading>

We stated above (see <Ref Chap="Types of Objects"/>) that, for an object <A>obj</A>,
its <E>type</E> is formed from its family and its filters.  There is a also
a third component, used in a few situations, namely defining data of
the type.

<ManSection>
<Func Name="TypeObj" Arg='obj'/>

<Description>
returns the type of the object <A>obj</A>. 
<P/>
The type of an object is itself an object.
<P/>
Two types are equal if and only if the two families are identical,
the filters are equal, and, if present, also the defining data of the
types are equal.
</Description>
</ManSection>


<ManSection>
<Func Name="DataType" Arg='type'/>

<Description>
The last part of the type, defining data, has not been mentioned
before and seems to be of minor importance.
It can be used, e.g., for cosets <M>U g</M> of a group <M>U</M>,
where the type of each coset may contain the group <M>U</M> as defining
data.
As a consequence, two such cosets mod <M>U</M> and <M>V</M> can have the
same type only if <M>U = V</M>.
The defining data of the type <A>type</A> can be accessed via
<Ref Func="DataType"/>.
</Description>
</ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  integers.msk                GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: integers.msk,v 1.26 2006/08/22 09:55:00 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->

<Chapter Label="Integers">
<Heading>Integers</Heading>

One of the most fundamental datatypes in every programming language is
the integer type.  &GAP; is no exception.
<P/>
&GAP; integers are entered as a sequence of decimal digits optionally 
preceded by a <Q><C>+</C></Q> sign for positive integers or 
a <Q><C>-</C></Q> sign for negative integers.
The size of integers in &GAP; is only limited by the amount of available
memory, so you can compute with integers having thousands of digits.
<P/>
<Example><![CDATA[
gap> -1234;
-1234
gap> 123456789012345678901234567890123456789012345678901234567890;
123456789012345678901234567890123456789012345678901234567890
]]></Example>
<P/>

Many more functions that are mainly related to the prime residue group of
integers modulo an integer are described in chapter&nbsp;<Ref Chap="Number Theory"/>,
and functions dealing with combinatorics can be found
in chapter&nbsp;<Ref Chap="Combinatorics"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Integers: Global Variables">
<Heading>Integers: Global Variables</Heading>

<ManSection>
<Var Name="Integers" Label="global variable"/>
<Var Name="PositiveIntegers"/>
<Var Name="NonnegativeIntegers"/>

<Description>
These global variables represent the ring of integers and the semirings
of positive and nonnegative integers, respectively.
<Example><![CDATA[
gap> Size( Integers ); 2 in Integers;
infinity
true
]]></Example>
<P/>
<Ref Var="Integers" Label="global variable"/> is a subset of
<Ref Var="Rationals"/>, which is a subset of <Ref Var="Cyclotomics"/>.
See Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/>
for arithmetic operations and comparison of integers.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsIntegers" Arg='obj' Type='Category'/>
<Filt Name="IsPositiveIntegers" Arg='obj' Type='Category'/>
<Filt Name="IsNonnegativeIntegers" Arg='obj' Type='Category'/>

<Description>
are the defining categories for the domains
<Ref Var="Integers" Label="global variable"/>,
<Ref Var="PositiveIntegers"/>, and <Ref Var="NonnegativeIntegers"/>.
<Example><![CDATA[
gap> IsIntegers( Integers );  IsIntegers( Rationals );  IsIntegers( 7 );
true
false
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elementary Operations for Integers">
<Heading>Elementary Operations for Integers</Heading>

<ManSection>
<Filt Name="IsInt" Arg='obj' Type='Category'/>

<Description>
Every rational integer lies in the category <Ref Func="IsInt"/>,
which is a subcategory of <Ref Func="IsRat"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPosInt" Arg='obj' Type='Category'/>

<Description>
Every positive integer lies in the category <Ref Func="IsPosInt"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="Int" Arg='elm'/>

<Description>
<Ref Attr="Int"/> returns an integer <C>int</C> whose meaning depends
on the type of <A>elm</A>.
<P/>
If <A>elm</A> is a rational number
(see Chapter&nbsp;<Ref Chap="Rational Numbers"/>) then <C>int</C> is the
integer part of the quotient of numerator and denominator of <A>elm</A>
(see&nbsp;<Ref Func="QuoInt"/>).
<P/>
If <A>elm</A> is an element of a finite prime field
(see Chapter&nbsp;<Ref Chap="Finite Fields"/>) then <C>int</C> is the
smallest nonnegative integer such that
<C><A>elm</A> = int * One( <A>elm</A> )</C>.
<P/>
If <A>elm</A> is a string
(see Chapter&nbsp;<Ref Chap="Strings and Characters"/>) consisting of
digits <C>'0'</C>, <C>'1'</C>, <M>\ldots</M>, <C>'9'</C>
and <C>'-'</C> (at the first position) then <C>int</C> is the integer
described by this string.
The operation <Ref Func="String"/> can be used to compute a string for
rational integers, in fact for all cyclotomics.
<P/>
<Example><![CDATA[
gap> Int( 4/3 );  Int( -2/3 );
1
0
gap> int:= Int( Z(5) );  int * One( Z(5) );
2
Z(5)
gap> Int( "12345" );  Int( "-27" );  Int( "-27/3" );
12345
-27
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsEvenInt" Arg='n'/>

<Description>
tests if the integer <A>n</A> is divisible by 2.
</Description>
</ManSection>

<ManSection>
<Func Name="IsOddInt" Arg='n'/>

<Description>
tests if the integer <A>n</A> is not divisible by 2.
</Description>
</ManSection>

<ManSection>
<Func Name="AbsInt" Arg='n'/>

<Description>
<Index>absolute value of an integer</Index>
<Ref Func="AbsInt"/> returns the absolute value of the integer <A>n</A>,
i.e., <A>n</A> if <A>n</A> is positive,
-<A>n</A> if <A>n</A> is negative and 0 if <A>n</A> is 0.
<P/>
<Ref Func="AbsInt"/> is a special case of the general operation
<Ref Func="EuclideanDegree"/>.
<P/>
See also <Ref Func="AbsoluteValue"/>.

<Example><![CDATA[
gap> AbsInt( 33 );
33
gap> AbsInt( -214378 );
214378
gap> AbsInt( 0 );
0
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SignInt" Arg='n'/>

<Description>
<Index Subkey="of an integer">sign</Index>
<Ref Func="SignInt"/> returns the sign of the integer <A>n</A>,
i.e., 1 if <A>n</A> is positive,
-1 if <A>n</A> is negative and 0 if <A>n</A> is 0.
<Example><![CDATA[
gap> SignInt( 33 );
1
gap> SignInt( -214378 );
-1
gap> SignInt( 0 );
0
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LogInt" Arg='n, base'/>

<Description>
<Ref Func="LogInt"/> returns the integer part of the logarithm of the
positive integer <A>n</A> with respect to the positive integer
<A>base</A>, i.e.,
the largest positive integer <M>e</M> such that
<M><A>base</A>^e \leq <A>n</A></M>. 
The function
<Ref Func="LogInt"/>
will signal an error if either <A>n</A> or <A>base</A> is not positive.
<P/>
For <A>base</A> <M>= 2</M> this is very efficient because the internal
binary representation of the integer is used. 
<P/>
<Example><![CDATA[
gap> LogInt( 1030, 2 );
10
gap> 2^10;
1024
gap> LogInt( 1, 10 );
0
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootInt" Arg='n[, k]'/>

<Description>
<Index Subkey="of an integer">root</Index>
<Index Subkey="of an integer">square root</Index>
<Ref Func="RootInt"/> returns the integer part of the <A>k</A>th root of
the integer <A>n</A>.
If the optional integer argument <A>k</A> is not given it defaults to 2,
i.e., <Ref Func="RootInt"/> returns the integer part of the square root
in this case.
<P/>
If <A>n</A> is positive, <Ref Func="RootInt"/> returns the largest
positive integer <M>r</M> such that <M>r^{<A>k</A>} \leq <A>n</A></M>.
If <A>n</A> is negative and <A>k</A> is odd <Ref Func="RootInt"/>
returns <C>-RootInt( -<A>n</A>,  <A>k</A> )</C>.
If <A>n</A> is negative and <A>k</A> is even
<Ref Func="RootInt"/> will cause an error.
<Ref Func="RootInt"/> will also cause an error if <A>k</A>
is 0 or negative.
<Example><![CDATA[
gap> RootInt( 361 );
19
gap> RootInt( 2 * 10^12 );
1414213
gap> RootInt( 17000, 5 );
7
gap> 7^5;
16807
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SmallestRootInt" Arg='n'/>

<Description>
<Index Subkey="of an integer, smallest">root</Index>
<Ref Func="SmallestRootInt"/> returns the smallest root of the integer
<A>n</A>.
<P/>
The smallest root of an integer <A>n</A> is the integer <M>r</M> of
smallest absolute value for which a positive integer <M>k</M> exists
such that <M><A>n</A> = r^k</M>.
<Example><![CDATA[
gap> SmallestRootInt( 2^30 );
2
gap> SmallestRootInt( -(2^30) );
-4
]]></Example>
<P/>
Note that <M>(-2)^{30} = +(2^{30})</M>.
<P/>
<Example><![CDATA[
gap> SmallestRootInt( 279936 );
6
gap> LogInt( 279936, 6 );
7
gap> SmallestRootInt( 1001 );
1001
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ListOfDigits" Arg='n'/>

<Description>
For a positive integer <A>n</A> this function returns a list <A>l</A>,
consisting of the digits of <A>n</A> in decimal representation.
<Example><![CDATA[
gap> ListOfDigits(3142);   
[ 3, 1, 4, 2 ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="Random" Arg='Integers' Label="for integers"/>

<Description>
<Ref Func="Random" Label="for integers"/> for integers returns
pseudo random integers between <M>-10</M> and
<M>10</M> distributed according to a binomial distribution.
To generate uniformly distributed integers from a range,
use the construction <C>Random( [ <A>low</A> .. <A>high</A> ] )</C>
&nbsp;(see&nbsp;<Ref Func="Random" Label="for lower and upper bound"/>).
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Quotients and Remainders">
<Heading>Quotients and Remainders</Heading>

<ManSection>
<Func Name="QuoInt" Arg='n, m'/>

<Description>
<Index>integer part of a quotient</Index>
<Ref Func="QuoInt"/> returns the integer part of the quotient of its
integer operands.
<P/>
If <A>n</A> and <A>m</A> are positive, <Ref Func="QuoInt"/> returns
the largest positive integer <M>q</M> such that
<M>q * <A>m</A> \leq <A>n</A></M>.
If <A>n</A> or <A>m</A> or both are negative the absolute value of the
integer part of the quotient is the quotient of the absolute values of
<A>n</A> and <A>m</A>,
and the sign of it is the product of the signs of <A>n</A> and <A>m</A>.
<P/>
<Ref Func="QuoInt"/> is used in a method for the general operation
<Ref Func="EuclideanQuotient"/>.
<Example><![CDATA[
gap> QuoInt(5,3);  QuoInt(-5,3);  QuoInt(5,-3);  QuoInt(-5,-3);
1
-1
-1
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BestQuoInt" Arg='n, m'/>

<Description>
<Ref Func="BestQuoInt"/> returns the best quotient <M>q</M>
of the integers <A>n</A> and <A>m</A>.
This is the quotient such that <M><A>n</A>-q*<A>m</A></M>
has minimal absolute value.
If there are two quotients whose remainders have the same absolute value,
then the quotient with the smaller absolute value is chosen.
<Example><![CDATA[
gap> BestQuoInt( 5, 3 );  BestQuoInt( -5, 3 );
2
-2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RemInt" Arg='n, m'/>

<Description>
<Index>remainder of a quotient</Index>
<Ref Func="RemInt"/> returns the remainder of its two integer operands.
<P/>
If <A>m</A> is not equal to zero, <Ref Func="RemInt"/> returns
<C><A>n</A> - <A>m</A> * QuoInt( <A>n</A>, <A>m</A> )</C>.
Note that the rules given for <Ref Func="QuoInt"/> imply that the return
value of <Ref Func="RemInt"/> has the same sign as <A>n</A>
and its absolute value is strictly less than the absolute value
of <A>m</A>.
Note also that the return value equals <C><A>n</A> mod <A>m</A></C>
when both <A>n</A> and <A>m</A> are nonnegative.
Dividing by <C>0</C> signals an error.
<P/>
<Ref Func="RemInt"/> is used in a method for the general operation
<Ref Func="EuclideanRemainder"/>.
<Example><![CDATA[
gap> RemInt(5,3);  RemInt(-5,3);  RemInt(5,-3);  RemInt(-5,-3);
2
-2
2
-2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GcdInt" Arg='m, n'/>

<Description>
<Ref Func="GcdInt"/> returns the greatest common divisor
of its two integer operands <A>m</A> and <A>n</A>, i.e.,
the greatest integer that divides both <A>m</A> and <A>n</A>.
The greatest common divisor is never negative, even if the arguments are.
We define
<C>GcdInt( <A>m</A>, 0 ) = GcdInt( 0, <A>m</A> ) = AbsInt( <A>m</A> )</C>
and <C>GcdInt( 0, 0 ) = 0</C>.
<P/>
<Ref Func="GcdInt"/> is a method used by the general function
<Ref Func="Gcd" Label="for (a ring and) several elements"/>.
<P/>
<Example><![CDATA[
gap> GcdInt( 123, 66 );
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Gcdex" Arg='m, n'/>

<Description>
returns a record <C>g</C> describing the extended greatest common divisor
of <A>m</A> and <A>n</A>.
The component <C>gcd</C> is this gcd,
the components <C>coeff1</C> and <C>coeff2</C> are integer cofactors
such that <C>g.gcd = g.coeff1 * <A>m</A> + g.coeff2 * <A>n</A></C>,
and the components <C>coeff3</C> and <C>coeff4</C> are integer cofactors
such that <C>0 = g.coeff3 * <A>m</A> + g.coeff4 * <A>n</A></C>.
<P/>
If <A>m</A> and <A>n</A> both are nonzero,
<C>AbsInt( g.coeff1 )</C> is less than or
equal to <C>AbsInt(<A>n</A>) / (2 * g.gcd)</C>,
and <C>AbsInt( g.coeff2 )</C> is less
than or equal to <C>AbsInt(<A>m</A>) / (2 * g.gcd)</C>.
<P/>
If <A>m</A> or <A>n</A> or both are zero
<C>coeff3</C> is <C>-<A>n</A> / g.gcd</C> and
<C>coeff4</C> is <C><A>m</A> / g.gcd</C>.
<P/>
The coefficients always form a unimodular matrix, i.e.,
the determinant
<C>g.coeff1 * g.coeff4 - g.coeff3 * g.coeff2</C>
is <M>1</M> or <M>-1</M>.
<Example><![CDATA[
gap> Gcdex( 123, 66 );
rec( coeff1 := 7, coeff2 := -13, coeff3 := -22, coeff4 := 41, 
  gcd := 3 )
]]></Example>
This means <M>3 = 7 * 123 - 13 * 66</M>, <M>0 = -22 * 123 + 41 * 66</M>.
<Example><![CDATA[
gap> Gcdex( 0, -3 );
rec( coeff1 := 0, coeff2 := -1, coeff3 := 1, coeff4 := 0, gcd := 3 )
gap> Gcdex( 0, 0 );
rec( coeff1 := 1, coeff2 := 0, coeff3 := 0, coeff4 := 1, gcd := 0 )
]]></Example>
<P/>
<Ref Func="GcdRepresentation" Label="for (a ring and) several elements"/> 
provides similar functionality over arbitrary Euclidean rings.
</Description>
</ManSection>

<ManSection>
<Func Name="LcmInt" Arg='m, n'/>

<Description>
returns the least common multiple of the integers <A>m</A> and <A>n</A>.
<P/>
<Ref Func="LcmInt"/> is a method used by the general operation
<Ref Oper="Lcm" Label="for (a ring and) several elements"/>.
<Example><![CDATA[
gap> LcmInt( 123, 66 );
2706
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CoefficientsQadic" Arg='i, q'/>

<Description>
returns the <A>q</A>-adic representation of the integer <A>i</A>
as a list <M>l</M> of coefficients satisfying the equality
<M><A>i</A> = \sum_{{j = 0}} <A>q</A>^j \cdot l[j+1]</M>
for an integer <M><A>q</A> > 1</M>.
<Example><![CDATA[
gap> l:=CoefficientsQadic(462,3);
[ 0, 1, 0, 2, 2, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CoefficientsMultiadic" Arg='ints, int'/>

<Description>
returns the multiadic expansion of the integer <A>int</A>
modulo the integers given in <A>ints</A> (in ascending order).
It returns a list of coefficients in the <E>reverse</E> order
to that in <A>ints</A>.
<!-- The syntax is quite weird and should be adapted according to
CoefficientsQadic. -->
</Description>
</ManSection>

<ManSection>
<Func Name="ChineseRem" Arg='moduli, residues'/>

<Description>
<Index>Chinese remainder</Index>
<Ref Func="ChineseRem"/> returns the combination of the <A>residues</A>
modulo the <A>moduli</A>, i.e.,
the unique integer <C>c</C>  from <C>[0..Lcm(<A>moduli</A>)-1]</C>
such that
<C>c = <A>residues</A>[i]</C> modulo <C><A>moduli</A>[i]</C>
for all <C>i</C>, if it exists.
If no such combination exists <Ref Func="ChineseRem"/> signals an error.
<P/>
Such a combination does exist if and only if
<C><A>residues</A>[i] = <A>residues</A>[k] mod Gcd( <A>moduli</A>[i], <A>moduli</A>[k] )</C>
for every pair <C>i</C>, <C>k</C>.
Note that this implies that such a combination exists
if the moduli are pairwise relatively prime.
This is called the Chinese remainder theorem.
<Example><![CDATA[
gap> ChineseRem( [ 2, 3, 5, 7 ], [ 1, 2, 3, 4 ] );
53
gap> ChineseRem( [ 6, 10, 14 ], [ 1, 3, 5 ] );
103
]]></Example>
<Log><![CDATA[
gap> ChineseRem( [ 6, 10, 14 ], [ 1, 2, 3 ] );
Error, the residues must be equal modulo 2 called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> gap> 
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="PowerModInt" Arg='r, e, m'/>

<Description>
returns <M><A>r</A>^{<A>e</A>} \pmod{<A>m</A>}</M> for integers <A>r</A>,
<A>e</A> and <A>m</A> (<M><A>e</A> \geq 0</M>).
<P/>
Note that <Ref Func="PowerModInt"/> can reduce intermediate results and
thus will generally be faster than using
<A>r</A><C>^</C><A>e</A><C> mod </C><A>m</A>,
which would compute <M><A>r</A>^{<A>e</A>}</M> first and reduces
the result afterwards.
<P/>
<Ref Func="PowerModInt"/> is a method for the general operation
<Ref Oper="PowerMod"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Prime Integers and Factorization">
<Heading>Prime Integers and Factorization</Heading>

<ManSection>
<Var Name="Primes"/>

<Description>
<Ref Var="Primes"/> is a strictly sorted list of the 168 primes less than
1000.
<P/>
This is used in <Ref Func="IsPrimeInt"/> and <Ref Func="FactorsInt"/>
to cast out small primes quickly.
<Example><![CDATA[
gap> Primes[1];
2
gap> Primes[100];
541
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPrimeInt" Arg='n'/>
<Func Name="IsProbablyPrimeInt" Arg='n'/>

<Description>
<Ref Func="IsPrimeInt"/> returns <K>false</K> if it can  prove that
the integer <A>n</A> is composite and <K>true</K> otherwise.
By  convention <C>IsPrimeInt(0) = IsPrimeInt(1) = false</C>
and we define
<C>IsPrimeInt(-</C><A>n</A><C>) = IsPrimeInt(</C><A>n</A><C>)</C>.
<P/>
<Ref Func="IsPrimeInt"/> will return <K>true</K> for every prime <A>n</A>.
<Ref Func="IsPrimeInt"/> will return <K>false</K> for all composite
<A>n</A> <M>&lt; 10^{18}</M> and for all composite <A>n</A> that have
a factor <M>p &lt; 1000</M>. So for integers <A>n</A> <M>&lt; 10^{18}</M>,
<Ref Func="IsPrimeInt"/> is a proper primality test. It is conceivable that
<Ref Func="IsPrimeInt"/> may  return <K>true</K> for some  composite
<A>n</A> <M>&gt; 10^{18}</M>, but no such <A>n</A> is currently known.
So for integers <A>n</A> <M>&gt; 10^{18}</M>, <Ref Func="IsPrimeInt"/>
is a  probable-primality test. <Ref Func="IsPrimeInt"/> will issue a
warning when its argument is probably prime but not a proven prime.
(The function <Ref Func="IsProbablyPrimeInt"/> will do a similar
calculation but not issue a warning.) The warning can be switched off by
<C>SetInfoLevel( InfoPrimeInt, 0 );</C>, the default level is <M>1</M>
(also see <Ref Oper="SetInfoLevel"/> ).
<P/>
If composites that  fool <Ref Func="IsPrimeInt"/> do exist, they  would be extremely
rare, and finding one by pure chance might be less likely than finding a
bug in &GAP;. We would appreciate being informed about any example of a
composite number <A>n</A> for which <Ref Func="IsPrimeInt"/> returns <K>true</K>.
<P/>
<Ref Func="IsPrimeInt"/> is a deterministic algorithm, i.e., the computations involve
no random numbers, and repeated calls will always return the same result.
<Ref Func="IsPrimeInt"/> first does trial divisions by the primes less than 1000.
Then it tests that <A>n</A> is a strong pseudoprime w.r.t. the base 2.
Finally it tests whether <A>n</A> is a Lucas pseudoprime w.r.t. the smallest
quadratic nonresidue of  <A>n</A>. A better description can be found in the
comment in the library file <File>primality.gi</File>.
<P/>
The time taken by <Ref Func="IsPrimeInt"/> is approximately proportional to the third
power  of  the number  of  digits of <A>n</A>. Testing numbers with several
hundreds digits is quite feasible.
<P/>
<Ref Func="IsPrimeInt"/> is a method for the general operation <Ref Oper="IsPrime"/>.
<P/>
Remark: In future versions of &GAP; we hope to change the definition of
<Ref Func="IsPrimeInt"/> to return <K>true</K> only for proven primes (currently, we lack
a sufficiently good primality proving function). In applications, use
explicitly <Ref Func="IsPrimeInt"/> or <Ref Func="IsProbablyPrimeInt"/>
with this change in mind.
<Example><![CDATA[
gap> IsPrimeInt( 2^31 - 1 );
true
gap> IsPrimeInt( 10^42 + 1 );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrimalityProof" Arg='n'/>

<Description>
Construct a machine verifiable proof of the primality of (the probable
prime) <A>n</A>, following the ideas of <Cite Key="BLS1975"/>.

The proof consists of various Fermat and Lucas pseudoprimality tests,
which taken as a whole prove the primality.  The proof is represented
as a list of witnesses of two kinds.  The first kind, <C>[ "F", divisor,
base ]</C>, indicates a successful Fermat pseudoprimality test, where
<A>n</A> is a strong pseudoprime at <K>base</K> with order not divisible by
<M>(<A>n</A>-1)/divisor</M>.  The second kind, <C>[ "L", divisor,
discriminant, P ]</C> indicates a successful Lucas pseudoprimality test,
for a quadratic form of given <K>discriminant</K> and middle term <K>P</K>
with an extra check at <M>(<A>n</A>+1)/divisor</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="IsPrimePowerInt" Arg='n'/>

<Description>
<Ref Func="IsPrimePowerInt"/> returns <K>true</K> if the integer <A>n</A>
is a prime power and <K>false</K> otherwise.
<P/>
An integer <M>n</M> is a <E>prime power</E> if there exists a prime <M>p</M> and a
positive integer <M>i</M> such that <M>p^i = n</M>.
If <M>n</M> is negative the condition is that there
must exist a negative prime <M>p</M> and an odd positive integer <M>i</M>
such that <M>p^i = n</M>.
The integers 1 and -1 are not prime powers.
<P/>
Note that <Ref Func="IsPrimePowerInt"/> uses
<Ref Func="SmallestRootInt"/>
and a probable-primality test (see <Ref Func="IsPrimeInt"/>).
<Example><![CDATA[
gap> IsPrimePowerInt( 31^5 );
true
gap> IsPrimePowerInt( 2^31-1 );  # 2^31-1 is actually a prime
true
gap> IsPrimePowerInt( 2^63-1 );
false
gap> Filtered( [-10..10], IsPrimePowerInt );
[ -8, -7, -5, -3, -2, 2, 3, 4, 5, 7, 8, 9 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NextPrimeInt" Arg='n'/>

<Description>
<Ref Func="NextPrimeInt"/> returns the smallest prime which is strictly
larger than the integer <A>n</A>.
<P/>
Note that <Ref Func="NextPrimeInt"/> uses a probable-primality test
(see <Ref Func="IsPrimeInt"/>).
<Example><![CDATA[
gap> NextPrimeInt( 541 ); NextPrimeInt( -1 );
547
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrevPrimeInt" Arg='n'/>

<Description>
<Ref Func="PrevPrimeInt"/> returns the largest prime which is strictly
smaller than the integer <A>n</A>.
<P/>
Note that <Ref Func="PrevPrimeInt"/> uses a probable-primality test
(see <Ref Func="IsPrimeInt"/>).
<Example><![CDATA[
gap> PrevPrimeInt( 541 ); PrevPrimeInt( 1 );
523
-2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FactorsInt" Arg='n'/>
<Func Name="FactorsInt" Arg='n:RhoTrials:=trials' Label="using Pollard's Rho"/>

<Description>
<Ref Func="FactorsInt"/> returns a list of factors of a given integer 
<A>n</A> such that <C>Product( FactorsInt( <A>n</A> ) ) = <A>n</A></C>.
If <M>|n| \leq 1</M> the list <C>[<A>n</A>]</C> is returned. Otherwise
the result contains probable primes, sorted by absolute value. The
entries will all be positive except for the first one in case of
a negative <A>n</A>.
<P/>
See <Ref Attr="PrimeDivisors"/> for a function that returns a set of
(probable) primes dividing <A>n</A>.
<P/>
Note that <Ref Func="FactorsInt"/> uses a probable-primality test
(see&nbsp;<Ref Func="IsPrimeInt"/>).
Thus <Ref Func="FactorsInt"/> might return a list which contains
composite integers.
In such a case you will get a warning about the use of a probable prime.
You can switch off these warnings by
<C>SetInfoLevel( InfoPrimeInt, 0 );</C> 
(also see <Ref Oper="SetInfoLevel"/>).
<P/>
The time taken by <Ref Func="FactorsInt"/> is approximately proportional
to the square root of the second largest prime factor of <A>n</A>,
which is the last one that <Ref Func="FactorsInt"/> has to find,
since the largest factor is simply
what remains when all others have been removed.  Thus the time is roughly
bounded by the fourth root of <A>n</A>.
<Ref Func="FactorsInt"/> is guaranteed to find all factors less than
<M>10^6</M> and will find most factors less than <M>10^{10}</M>.
If <A>n</A> contains multiple factors larger than that
<Ref Func="FactorsInt"/> may not be able to factor <A>n</A>
and will then signal an error.
<P/>
<Ref Func="FactorsInt"/> is used in a method for the general operation
<Ref Oper="Factors"/>.
<P/>
In the second form, <Ref Func="FactorsInt"/> calls
<C>FactorsRho</C> with a limit of <A>trials</A>
on the number of trials it performs. The default is 8192.
Note that Pollard's Rho is the fastest method for finding prime
factors with roughly 5-10 decimal digits, but becomes more and more
inferior to other factorization techniques like e.g. the Elliptic
Curves Method (ECM) the bigger the prime factors are. Therefore
instead of performing a huge number of Rho <A>trials</A>, it is usually
more advisable to install the <Package>FactInt</Package> package and
then simply to use the operation <Ref Oper="Factors"/>. The factorization
of the 8-th Fermat number by Pollard's Rho below takes already a while.

<Example><![CDATA[
gap> FactorsInt( -Factorial(6) );
[ -2, 2, 2, 2, 3, 3, 5 ]
gap> Set( FactorsInt( Factorial(13)/11 ) );
[ 2, 3, 5, 7, 13 ]
gap> FactorsInt( 2^63 - 1 );
[ 7, 7, 73, 127, 337, 92737, 649657 ]
gap> FactorsInt( 10^42 + 1 );
[ 29, 101, 281, 9901, 226549, 121499449, 4458192223320340849 ]
gap> FactorsInt(2^256+1:RhoTrials:=100000000);
[ 1238926361552897, 
  93461639715357977769163558199606896584051237541638188580280321 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PrimeDivisors" Arg='n'/>
<Description>
<Ref Attr="PrimeDivisors"/> returns for a non-zero integer <A>n</A> a set 
of its positive (probable) primes divisors. In rare cases the result could 
contain a composite number which passed certain primality tests, see 
<Ref Func="IsProbablyPrimeInt"/> and <Ref Func="FactorsInt"/> for more details.
<Example>
gap> PrimeDivisors(-12);
[ 2, 3 ]
gap> PrimeDivisors(1);
[  ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PartialFactorization" Arg='n[, effort]'/>

<Description>
<Ref Oper="PartialFactorization"/> returns a partial factorization of the
integer <A>n</A>.
No assertions are made about the primality of the factors,
except of those mentioned below.
<P/>
The argument <A>effort</A>, if given, specifies how intensively the
function should try to determine factors of <A>n</A>.
The default is <A>effort</A>&nbsp;=&nbsp;5.
<P/>
<List>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;0, trial division by the primes below 100
 is done.
 Returned factors below <M>10^4</M> are guaranteed to be prime.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;1, trial division by the primes below 1000
 is done.
 Returned factors below <M>10^6</M> are guaranteed to be prime.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;2, additionally trial division by the
 numbers in the lists <C>Primes2</C> and
 <C>ProbablePrimes2</C> is done, and perfect powers are detected.
 Returned factors below <M>10^6</M> are guaranteed to be prime.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;3, additionally <C>FactorsRho</C>
 (Pollard's Rho) with <C>RhoTrials</C> = 256 is used.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;4, as above, but <C>RhoTrials</C> = 2048.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;5, as above, but <C>RhoTrials</C> = 8192.
 Returned factors below <M>10^{12}</M> are guaranteed to be prime,
 and all prime factors below <M>10^6</M> are guaranteed to be found.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;6 and the package <Package>FactInt</Package>
 is loaded, in addition to the above quite a number of special cases are
 handled.
</Item>
<Item>
 If <A>effort</A>&nbsp;=&nbsp;7 and the package <Package>FactInt</Package>
 is loaded, the only thing which is not attempted to obtain a full
 factorization into Baillie-Pomerance-Selfridge-Wagstaff pseudoprimes
 is the application of the MPQS to a remaining composite with more
 than 50 decimal digits.
</Item>
</List>
<P/>
Increasing the value of the argument <A>effort</A> by one usually results
in an increase of the runtime requirements by a factor of (very roughly!)
3 to&nbsp;10.
(Also see <Ref Func="CheapFactorsInt" BookName="EDIM"/>).
<Example><![CDATA[
gap> List([0..5],i->PartialFactorization(97^35-1,i)); 
[ [ 2, 2, 2, 2, 2, 3, 11, 31, 43, 
      2446338959059521520901826365168917110105972824229555319002965029 ], 
  [ 2, 2, 2, 2, 2, 3, 11, 31, 43, 967, 
      2529823122088440042297648774735177983563570655873376751812787 ],
  [ 2, 2, 2, 2, 2, 3, 11, 31, 43, 967, 
      2529823122088440042297648774735177983563570655873376751812787 ],
  [ 2, 2, 2, 2, 2, 3, 11, 31, 43, 967, 39761, 262321, 
      242549173950325921859769421435653153445616962914227 ], 
  [ 2, 2, 2, 2, 2, 3, 11, 31, 43, 967, 39761, 262321, 687121, 
      352993394104278463123335513593170858474150787 ], 
  [ 2, 2, 2, 2, 2, 3, 11, 31, 43, 967, 39761, 262321, 687121, 
      20241187, 504769301, 34549173843451574629911361501 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrintFactorsInt" Arg='n'/>

<Description>
prints the prime factorization of the integer <A>n</A> in human-readable
form.
<Example><![CDATA[
gap> PrintFactorsInt( Factorial( 7 ) ); Print( "\n" );
2^4*3^2*5*7
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrimePowersInt" Arg='n'/>

<Description>
returns the prime factorization of the integer <A>n</A> as a list
<M>[ p_1, e_1, \ldots, p_k, e_k ]</M> with
<A>n</A> = <M>p_1^{{e_1}} \cdot p_2^{{e_2}} \cdot ... \cdot p_k^{{e_k}}</M>.
<P/>
<Example><![CDATA[
gap> PrimePowersInt( Factorial( 7 ) );
[ 2, 4, 3, 2, 5, 1, 7, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DivisorsInt" Arg='n'/>

<Description>
<Index Subkey="of an integer">divisors</Index>
<Ref Func="DivisorsInt"/> returns a list of all divisors of the integer
<A>n</A>.
The list is sorted, so that it starts with 1 and ends with <A>n</A>.
We  define that <C>DivisorsInt( -<A>n</A> ) = DivisorsInt( <A>n</A> )</C>.
<P/>
Since the  set of divisors of 0 is infinite
calling <C>DivisorsInt( 0 )</C> causes an error.
<P/>
<Ref Func="DivisorsInt"/> may call <Ref Func="FactorsInt"/>
to obtain the prime factors.
<Ref Func="Sigma"/> and <Ref Func="Tau"/> compute the sum and the
number of positive divisors, respectively.
<Example><![CDATA[
gap> DivisorsInt( 1 ); DivisorsInt( 20 ); DivisorsInt( 541 );
[ 1 ]
[ 1, 2, 4, 5, 10, 20 ]
[ 1, 541 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Residue Class Rings">
<Heading>Residue Class Rings</Heading>

<Index Key="mod" Subkey="residue class rings"><K>mod</K></Index>
<Index Subkey="residue class rings">modulo</Index>
<Ref Func="ZmodnZ"/> returns a residue class ring of <Ref Var="Integers"/>
modulo an ideal.
These residue class rings are rings, thus all operations for rings
(see Chapter&nbsp;<Ref Chap="Rings"/>) apply.
See also Chapters&nbsp;<Ref Chap="Finite Fields"/> and
<Ref Chap="Number Theory"/>.

<ManSection>
<Oper Name="\mod" Arg="r/s, n" Label="for residue class rings"/>
<Description>
If <A>r</A>, <A>s</A> and <A>n</A> are integers, <C><A>r</A> / <A>s</A></C> as a  reduced  fraction  is
<C>p/q</C>, where <C>q</C> and <A>n</A> are coprime, then <C><A>r</A> / <A>s</A> mod <A>n</A></C>  is
defined to be the product of <C>p</C> and the inverse of <C>q</C> modulo  <A>n</A>. See
Section&nbsp;<Ref Sect="Arithmetic Operators"/> for more details and definitions.
<P/>
With the above definition, <C>4 / 6 mod 32</C> equals <C>2 / 3 mod 32</C> and hence
exists (and is equal to 22), despite the  fact  that  6  has  no  inverse
modulo 32.
</Description>
</ManSection>

<ManSection>
<Func Name="ZmodnZ" Arg='n'/>
<Func Name="ZmodpZ" Arg='p'/>
<Func Name="ZmodpZNC" Arg='p'/>

<Description>
<Ref Func="ZmodnZ"/> returns a ring <M>R</M> isomorphic to the residue
class ring of the integers modulo the ideal generated by <A>n</A>.
The element corresponding to the residue class of the integer <M>i</M>
in this ring can be obtained by <C>i * One( R )</C>,
and a representative of the residue class corresponding to the element
<M>x \in R</M> can be computed by <C>Int</C><M>( x )</M>.
<P/>
<Index Subkey="Integers">mod</Index>
<C>ZmodnZ( <A>n</A> )</C> is equal to <C>Integers mod <A>n</A></C>.
<P/>
<Ref Func="ZmodpZ"/> does the same if the argument <A>p</A> is a prime
integer, additionally the result is a field.
<Ref Func="ZmodpZNC"/> omits the check whether <A>p</A> is a prime.
<P/>
Each ring returned by these functions contains the whole family of its
elements
if <A>n</A> is not a prime, and is embedded into the family of finite
field elements of characteristic <A>n</A> if <A>n</A> is a prime.
</Description>
</ManSection>

<ManSection>
<Oper Name="ZmodnZObj"
 Arg='Fam, r' Label="for a residue class family and integer"/>
<Oper Name="ZmodnZObj" Arg='r, n' Label="for two integers"/>

<Description>
If the first argument is a residue class family <A>Fam</A> then
<Ref Oper="ZmodnZObj" Label="for a residue class family and integer"/>
returns the element in <A>Fam</A> whose coset is represented by the
integer <A>r</A>.
<P/>
If the two arguments are an integer <A>r</A> and a positive integer
<A>n</A> then <Ref Oper="ZmodnZObj" Label="for two integers"/>
returns the element in <C>ZmodnZ( <A>n</A> )</C>
(see&nbsp;<Ref Func="ZmodnZ"/>) whose coset is represented by the integer
<A>r</A>.
<P/>
<Example><![CDATA[
gap> r:= ZmodnZ(15);
(Integers mod 15)
gap> fam:=ElementsFamily(FamilyObj(r));;
gap> a:= ZmodnZObj(fam,9);
ZmodnZObj( 9, 15 )
gap> a+a;
ZmodnZObj( 3, 15 )
gap> Int(a+a);
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsZmodnZObj" Arg='obj' Type='Category'/>
<Filt Name="IsZmodnZObjNonprime" Arg='obj' Type='Category'/>
<Filt Name="IsZmodpZObj" Arg='obj' Type='Category'/>
<Filt Name="IsZmodpZObjSmall" Arg='obj' Type='Category'/>
<Filt Name="IsZmodpZObjLarge" Arg='obj' Type='Category'/>

<Description>
The elements in the rings <M>Z / n Z</M> are in the category
<Ref Filt="IsZmodnZObj"/>.
If <M>n</M> is a prime then the elements are of course also in the
category <Ref Func="IsFFE"/>,
otherwise they are in <Ref Filt="IsZmodnZObjNonprime"/>.
<Ref Filt="IsZmodpZObj"/> is an abbreviation of
<C>IsZmodnZObj and IsFFE</C>.
This category is the disjoint union of <Ref Filt="IsZmodpZObjSmall"/> and
<Ref Filt="IsZmodpZObjLarge"/>, the former containing all elements with
<M>n</M> at most <C>MAXSIZE_GF_INTERNAL</C>.
<P/>
The reasons to distinguish the prime case from the nonprime case are
<List>
<Item>
  that objects in <Ref Filt="IsZmodnZObjNonprime"/> have an external
  representation (namely the residue in the range
  <M>[ 0, 1, \ldots, n-1 ]</M>),
</Item>
<Item>
  that the comparison of elements can be defined as comparison of the
  residues, and
</Item>
<Item>
  that the elements lie in a family of type
  <C>IsZmodnZObjNonprimeFamily</C>
  (note that for prime <M>n</M>, the family must be an
  <C>IsFFEFamily</C>).
</Item>
</List>
<P/>
The reasons to distinguish the small and the large case are
that for small <M>n</M> the elements must be compatible with the internal
representation of finite field elements, whereas we are free to define
comparison as comparison of residues for large <M>n</M>.
<P/>
Note that we <E>cannot</E> claim that every finite field element of
degree 1 is in <Ref Filt="IsZmodnZObj"/>, since finite field elements in
internal representation may not know that they lie in the prime field.
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Check Digits">
<Heading>Check Digits</Heading>

<ManSection>
<Func Name="CheckDigitISBN" Arg='n'/>
<Func Name="CheckDigitISBN13" Arg='n'/>
<Func Name="CheckDigitPostalMoneyOrder" Arg='n'/>
<Func Name="CheckDigitUPC" Arg='n'/>

<Description>
These functions can be used to compute, or check, check digits for some
everyday items. In each case what is submitted as input is either the number
with check digit (in which case the function returns <C>true</C> or
<C>false</C>), or the number without check digit (in which case the function
returns the missing check digit). The number can be specified as integer, as
string (for example in case of leading zeros) or as a sequence of arguments,
each representing a single digit.

The check digits tested are the 10-digit ISBN (International Standard Book
Number) using <Ref Func="CheckDigitISBN"/> (since arithmetic is module 11, a
digit 11 is represented by an X);
the newer 13-digit ISBN-13 using <Ref Func="CheckDigitISBN13"/>;
the numbers of 11-digit US postal money orders using
<Ref Func="CheckDigitPostalMoneyOrder"/>; and
the 12-digit UPC bar code found on groceries using
<Ref Func="CheckDigitUPC"/>.
<Example><![CDATA[
gap> CheckDigitISBN("052166103");
Check Digit is 'X'
'X'
gap> CheckDigitISBN("052166103X");
Checksum test satisfied
true
gap> CheckDigitISBN(0,5,2,1,6,6,1,0,3,1);
Checksum test failed
false
gap> CheckDigitISBN(0,5,2,1,6,6,1,0,3,'X'); # note single quotes!
Checksum test satisfied
true
gap> CheckDigitISBN13("9781420094527");
Checksum test satisfied
true
gap> CheckDigitUPC("07164183001");
Check Digit is 1
1
gap> CheckDigitPostalMoneyOrder(16786457155);
Checksum test satisfied
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CheckDigitTestFunction" Arg='l,m,f'/>

<Description>
This function creates check digit test functions such as
<Ref Func="CheckDigitISBN"/> for check digit schemes that use the inner
products with a fixed vector modulo a number. The scheme creates will use
strings of <A>l</A> digits (including the check digits), the check consists
of taking the standard product of the vector of digits with the fixed vector
<A>f</A> modulo <A>m</A>; the result needs to be 0.

The function returns a function that then can be used for testing or
determining check digits.
<Example><![CDATA[
gap> isbntest:=CheckDigitTestFunction(10,11,[1,2,3,4,5,6,7,8,9,-1]); 
function( arg... ) ... end
gap> isbntest("038794680");
Check Digit is 2
2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Random Sources">
<Heading>Random Sources</Heading>

&GAP; provides <Ref Func="Random" Label="for a list or collection"/> methods
for many collections of objects. 
On a lower level these methods use <E>random sources</E> which provide 
random integers and random choices from lists. 

<ManSection>
<Filt Name="IsRandomSource" Arg='obj' Type='Category'/>

<Description>
This is the category of random source objects which are defined to have,
for  an  object  <A>rs</A>  in  this  category,  methods  available  for
the  following operations  which  are explained  in  more detail  below:
<C>Random( <A>rs</A>,  <A>list</A> )</C>  giving a  random element  of a
list,  <C>Random(  <A>rs</A>,  <A>low</A>, <A>high</A>  )</C>  giving  a
random  integer between  <A>low</A>  and  <A>high</A> (inclusive),  <Ref
Oper="Init"/>, <Ref Oper="State"/> and <Ref Oper="Reset"/>.
<P/>
Use <Ref Func="RandomSource"/> to construct new random sources.
<P/>
One idea behind providing several independent (pseudo) random sources is
to make algorithms which use some sort of random choices deterministic.
They can use their own new random source created with a fixed seed and 
so do exactly the same in different calls.
<P/>
Random source objects lie in the family <C>RandomSourcesFamily</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Random" Arg='rs, list' Label="for random source and list"/>
<Oper Name="Random" Arg='rs, low, high' 
                    Label="for random source and two integers"/>

<Description>
This operation returns a random element from list <A>list</A>, or an integer 
in the range from the given (possibly large) integers <A>low</A> to <A>high</A>,
respectively. 
<P/>
The choice should only depend on the random source <A>rs</A> and have no 
effect on other random sources.
<Example>
gap> mysource := RandomSource(IsMersenneTwister, 42);;
gap> Random(mysource, 1, 10^60);
999331861769949319194941485000557997842686717712198687315183
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="State" Arg='rs'/>
<Oper Name="Reset" Arg='rs[, seed]'/>
<Oper Name="Init" Arg='prers[, seed]'/>

<Description>
These are the basic operations for which random sources (see
<Ref Func="IsRandomSource"/>) must have methods. 
<P/>
<Ref Oper="State"/> should return a data structure which allows to recover the state
of the random source such that a sequence of random calls using this 
random source can be reproduced. If a random source cannot be reset 
(say, it uses truly random physical data) then <Ref Oper="State"/>
should return  <K>fail</K>.
<P/>
<C>Reset( <A>rs</A>, <A>seed</A> )</C> resets the random source <A>rs</A> to a state described
by <A>seed</A>, if the random source can be reset (otherwise it should do
nothing). Here <A>seed</A> can be an output of <Ref Oper="State"/> and then should reset
to that state. Also, the methods should always allow integers as <A>seed</A>.
Without the <A>seed</A> argument the default <M><A>seed</A> = 1</M> is used.
<P/>
<Ref Oper="Init"/> is the constructor of a random source, it gets an empty component 
object <A>prers</A> which has already the correct type and should fill in the actual 
data which are needed. Optionally, it should allow one to specify a 
<A>seed</A> for the initial state, as explained for <Ref Oper="Reset"/>.
<P/>
Most methods for <Ref Oper="Random" Label="for a list or collection"/> 
in the &GAP; library use the 
<Ref Var="GlobalMersenneTwister"/> as random source. It can be reset 
into a known state as in the following example.
<Example><![CDATA[
gap> seed := State(GlobalMersenneTwister);;
gap> List([1..10],i->Random(Integers));
[ -1, -3, -2, 1, -2, -1, 0, 1, 0, 1 ]
gap> List([1..10],i->Random(Integers));
[ -1, 0, 2, 0, 4, -1, -3, 1, -4, -1 ]
gap> Reset(GlobalMersenneTwister, seed);;
gap> List([1..10],i->Random(Integers));
[ -1, -3, -2, 1, -2, -1, 0, 1, 0, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMersenneTwister" Arg='rs' Type='Category'/>
<Filt Name="IsGAPRandomSource" Arg='rs' Type='Category'/>
<Filt Name="IsGlobalRandomSource" Arg='rs' Type='Category'/>
<Var Name="GlobalMersenneTwister"/>
<Var Name="GlobalRandomSource"/>

<Description>
Currently, the &GAP; library provides three types of random sources,
distinguished by the three listed categories.
<P/>
<Ref  Var="IsMersenneTwister"/>  are random  sources  which  use a  fast
random generator  of 32  bit numbers, called  the Mersenne  twister. The
pseudo  random  sequence has  a  period  of <M>2^{19937}-1</M>  and  the
numbers have a <M>623</M>-dimensional equidistribution. For more details
and the origin of the code used in the &GAP; kernel, see:
<URL>http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html</URL>.
<P/>
Use the Mersenne twister if possible, in particular for generating many 
large random integers. 
<P/>
There is also a predefined global random source 
<Ref Var="GlobalMersenneTwister"/> which is used by most of the library
methods for <Ref Oper="Random" Label="for a list or collection"/>.
<P/>
<Ref Filt="IsGAPRandomSource"/> uses the same number generator as 
<Ref Filt="IsGlobalRandomSource"/>, but you can create several of these 
random sources which generate their random numbers independently of 
all other random sources. 
<P/>
<Ref Filt="IsGlobalRandomSource"/> gives access to the <E>classical</E> 
global random generator which was used by &GAP; in former releases. 
You do not need to construct new random sources of this kind which would
all use the same global data structure. Just use the existing random
source <Ref Var="GlobalRandomSource"/>. This uses the additive random number 
generator described in  <Cite Key="TACP2"/> (Algorithm A in&nbsp;3.2.2 
with lag <M>30</M>).
<P/>
</Description>
</ManSection>

<ManSection>
<Oper Name="RandomSource" Arg='cat[, seed]'/>

<Description>
This operation is used to create new random sources. The first argument 
<A>cat</A> is the category describing the type of the random generator, 
an optional <A>seed</A> which can be an integer or a type specific data 
structure can be given to specify the initial state.
<P/>
<Example><![CDATA[
gap> rs1 := RandomSource(IsMersenneTwister);
<RandomSource in IsMersenneTwister>
gap> state1 := State(rs1);;
gap> l1 := List([1..10000], i-> Random(rs1, [1..6]));;  
gap> rs2 := RandomSource(IsMersenneTwister);;
gap> l2 := List([1..10000], i-> Random(rs2, [1..6]));;
gap> l1 = l2;
true
gap> l1 = List([1..10000], i-> Random(rs1, [1..6])); 
false
gap> n := Random(rs1, 1, 2^220);
1598617776705343302477918831699169150767442847525442557699717518961
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  numtheor.msk                GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: numtheor.msk,v 1.18 2004/06/01 17:40:32 stefan Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Number Theory">
<Heading>Number Theory</Heading>

<Index>prime residue group</Index>
&GAP; provides a couple of elementary number theoretic functions.
Most of these deal with the group of integers coprime to <M>m</M>,
called the <E>prime residue group</E>.
The order of this group is <M>\phi(m)</M> (see&nbsp;<Ref Func="Phi"/>),
and <M>\lambda(m)</M> (see&nbsp;<Ref Func="Lambda"/>) is its exponent.
This group is cyclic if and only if <M>m</M> is 2, 4, 
an odd prime power <M>p^n</M>, or twice an odd prime power <M>2 p^n</M>.
In this case the generators  of the group, i.e., elements of order
<M>\phi(m)</M>,
are called <E>primitive roots</E>
(see&nbsp;<Ref Func="PrimitiveRootMod"/>).
<P/>
Note that neither the arguments nor the return values of the functions
listed below are groups or group elements in the sense of &GAP;.
The arguments are simply integers.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:InfoNumtheor">
<Heading>InfoNumtheor (Info Class)</Heading>

<ManSection>
<InfoClass Name="InfoNumtheor"/>

<Description>
<Ref InfoClass="InfoNumtheor"/> is the info class
(see&nbsp;<Ref Sect="Info Functions"/>)
for the functions in the number theory chapter.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Prime Residues">
<Heading>Prime Residues</Heading>

<Index>prime residue group</Index>
<ManSection>
<Func Name="PrimeResidues" Arg='m'/>

<Description>
<Ref Func="PrimeResidues"/> returns the set of integers from the range
<C>[ 0 .. Abs( <A>m</A> )-1 ]</C>
that are coprime to the integer <A>m</A>.
<P/>
<C>Abs(<A>m</A>)</C> must be less than <M>2^{28}</M>,
otherwise the set would probably be too large anyhow.
<P/>
<Example><![CDATA[
gap> PrimeResidues( 0 );  PrimeResidues( 1 );  PrimeResidues( 20 );
[  ]
[ 0 ]
[ 1, 3, 7, 9, 11, 13, 17, 19 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Phi" Arg='m'/>

<Description>
<Index Subkey="of the prime residue group">order</Index>
<Index Subkey="order">prime residue group</Index>
<Index>Euler's totient function</Index>
<Ref Oper="Phi"/> returns the number <M>\phi(<A>m</A>)</M> of positive
integers less than the positive integer <A>m</A>
that are coprime to <A>m</A>.
<P/>
Suppose that <M>m = p_1^{{e_1}} p_2^{{e_2}} \cdots p_k^{{e_k}}</M>.
Then <M>\phi(m)</M> is
<M>p_1^{{e_1-1}} (p_1-1) p_2^{{e_2-1}} (p_2-1) \cdots p_k^{{e_k-1}} (p_k-1)</M>.
<Example><![CDATA[
gap> Phi( 12 );
4
gap> Phi( 2^13-1 );  # this proves that 2^(13)-1 is a prime
8190
gap> Phi( 2^15-1 );
27000
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Lambda" Arg='m'/>

<Description>
<Index>Carmichael's lambda function</Index>
<Index Subkey="exponent">prime residue group</Index>
<Index Subkey="of the prime residue group">exponent</Index>
<Ref Oper="Lambda"/> returns the exponent <M>\lambda(<A>m</A>)</M>
of the group of prime residues modulo the integer <A>m</A>.
<P/>
<M>\lambda(<A>m</A>)</M> is the smallest positive integer <M>l</M> such that for every
<M>a</M> relatively prime to <A>m</A> we have <M>a^l \equiv 1 \pmod{<A>m</A>}</M>.
Fermat's theorem asserts
<M>a^{{\phi(<A>m</A>)}} \equiv 1 \pmod{<A>m</A>}</M>;
thus <M>\lambda(<A>m</A>)</M> divides <M>\phi(<A>m</A>)</M> (see&nbsp;<Ref Func="Phi"/>).
<P/>
Carmichael's theorem states that <M>\lambda</M> can be computed as follows:
<M>\lambda(2) = 1</M>, <M>\lambda(4) = 2</M> and
<M>\lambda(2^e) = 2^{{e-2}}</M>
if <M>3 \leq e</M>,
<M>\lambda(p^e) = (p-1) p^{{e-1}}</M> (i.e. <M>\phi(m)</M>) if <M>p</M>
is an odd prime and
<M>\lambda(m*n) = </M><C>Lcm</C><M>( \lambda(m), \lambda(n) )</M> if <M>m, n</M> are coprime.
<P/>
Composites for which <M>\lambda(m)</M> divides <M>m - 1</M> are called Carmichaels.
If <M>6k+1</M>, <M>12k+1</M> and <M>18k+1</M> are primes their product is such a number.
There are only  1547  Carmichaels below <M>10^{10}</M> but  455052511  primes.
<Example><![CDATA[
gap> Lambda( 10 );
4
gap> Lambda( 30 );
4
gap> Lambda( 561 );  # 561 is the smallest Carmichael number
80
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GeneratorsPrimeResidues" Arg='n'/>

<Description>
Let <A>n</A> be a positive integer.
<Ref Func="GeneratorsPrimeResidues"/> returns a description of generators
of the group of prime residues modulo <A>n</A>.
The return value is a record with components
<List>
<Mark><C>primes</C>: </Mark>
<Item>
    a list of the prime factors of <A>n</A>,
</Item>
<Mark><C>exponents</C>: </Mark>
<Item>
    a list of the exponents of these primes in the factorization of <A>n</A>,
    and
</Item>
<Mark><C>generators</C>: </Mark>
<Item>
    a list describing generators of the group of prime residues;
    for the prime factor <M>2</M>, either a primitive root or a list of two
    generators is stored,
    for each other prime factor of <A>n</A>, a primitive root is stored.
</Item>
</List>
<Example><![CDATA[
gap> GeneratorsPrimeResidues( 1 );
rec( exponents := [  ], generators := [  ], primes := [  ] )
gap> GeneratorsPrimeResidues( 4*3 );
rec( exponents := [ 2, 1 ], generators := [ 7, 5 ], 
  primes := [ 2, 3 ] )
gap> GeneratorsPrimeResidues( 8*9*5 );
rec( exponents := [ 3, 2, 1 ], 
  generators := [ [ 271, 181 ], 281, 217 ], primes := [ 2, 3, 5 ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Primitive Roots and Discrete Logarithms">
<Heading>Primitive Roots and Discrete Logarithms</Heading>

<ManSection>
<Func Name="OrderMod" Arg='n, m'/>

<Description>
<Index>multiplicative order of an integer</Index>
<Ref Func="OrderMod"/> returns the multiplicative order of the integer
<A>n</A> modulo the positive integer <A>m</A>.
If <A>n</A> and <A>m</A> are not coprime the order of <A>n</A> is not
defined and <Ref Func="OrderMod"/> will return <C>0</C>.
<P/>
If <A>n</A> and <A>m</A> are relatively prime the multiplicative order of
<A>n</A> modulo <A>m</A> is the smallest positive integer <M>i</M>
such that  <M><A>n</A>^i \equiv 1 \pmod{<A>m</A>}</M>.
If the group of prime residues modulo <A>m</A> is cyclic then
each element of maximal order is called a primitive root modulo <A>m</A>
(see&nbsp;<Ref Func="IsPrimitiveRootMod"/>).
<P/>
<Ref Func="OrderMod"/> usually spends most of its time factoring <A>m</A>
and <M>\phi(<A>m</A>)</M> (see&nbsp;<Ref Func="FactorsInt"/>).
<Example><![CDATA[
gap> OrderMod( 2, 7 );
3
gap> OrderMod( 3, 7 );  # 3 is a primitive root modulo 7
6
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LogMod" Arg='n, r, m'/>
<Func Name="LogModShanks" Arg='n, r, m'/>

<Description>
<Index Subkey="discrete">logarithm</Index>
computes the discrete <A>r</A>-logarithm of the integer <A>n</A>
modulo the integer <A>m</A>.
It returns a number <A>l</A> such that
<M><A>r</A>^{<A>l</A>} \equiv <A>n</A> \pmod{<A>m</A>}</M>
if such a number exists.
Otherwise <K>fail</K> is returned.
<P/>
<Ref Func="LogModShanks"/> uses the Baby Step - Giant Step Method
of Shanks (see for example <Cite Key="Coh93" Where="section 5.4.1"/>)
and in general requires more memory than a call to <Ref Func="LogMod"/>.
<Example><![CDATA[
gap> l:= LogMod( 2, 5, 7 );  5^l mod 7 = 2;
4
true
gap> LogMod( 1, 3, 3 );  LogMod( 2, 3, 3 );
0
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrimitiveRootMod" Arg='m[, start]'/>

<Description>
<Index>primitive root modulo an integer</Index>
<Index Subkey="generator">prime residue group</Index>
<Index Subkey="of the prime residue group">generator</Index>
<Ref Func="PrimitiveRootMod"/> returns the smallest primitive root modulo
the positive integer <A>m</A> and <K>fail</K> if no such primitive root
exists.
If the optional second integer argument <A>start</A> is given
<Ref Func="PrimitiveRootMod"/> returns the smallest primitive root that
is strictly larger than <A>start</A>.
<Example><![CDATA[
gap> # largest primitive root for a prime less than 2000:
gap> PrimitiveRootMod( 409 ); 
21
gap> PrimitiveRootMod( 541, 2 );
10
gap> # 327 is the largest primitive root mod 337:
gap> PrimitiveRootMod( 337, 327 );
fail
gap> # there exists no primitive root modulo 30:
gap> PrimitiveRootMod( 30 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPrimitiveRootMod" Arg='r, m'/>

<Description>
<Index Subkey="for a primitive root">test</Index>
<Index Subkey="generator">prime residue group</Index>
<Index Subkey="of the prime residue group">generator</Index>
<Ref Func="IsPrimitiveRootMod"/> returns <K>true</K> if the integer
<A>r</A> is a primitive root modulo the positive integer <A>m</A>,
and <K>false</K> otherwise.
If <A>r</A> is less than 0 or larger than <A>m</A> it is replaced by its
remainder.
<Example><![CDATA[
gap> IsPrimitiveRootMod( 2, 541 );
true
gap> IsPrimitiveRootMod( -539, 541 );  # same computation as above;
true
gap> IsPrimitiveRootMod( 4, 541 );
false
gap> ForAny( [1..29], r -> IsPrimitiveRootMod( r, 30 ) );
false
gap> # there is no a primitive root modulo 30
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Roots Modulo Integers">
<Heading>Roots Modulo Integers</Heading>

<ManSection>
<Func Name="Jacobi" Arg='n, m'/>

<Description>
<Index>quadratic residue</Index>
<Index Subkey="quadratic">residue</Index>
<Ref Func="Jacobi"/> returns the value of the
<E>Kronecker-Jacobi symbol</E> <M>J(<A>n</A>,<A>m</A>)</M> of the integer
<A>n</A> modulo the integer <A>m</A>.
It is defined as follows:
<P/>
If <M>n</M> and <M>m</M> are not coprime then <M>J(n,m) = 0</M>.  
Furthermore, <M>J(n,1) = 1</M> and <M>J(n,-1) = -1</M> if <M>m &lt; 0</M>
and  <M>+1</M>  otherwise.
And for odd <M>n</M> it is <M>J(n,2) = (-1)^k</M> with
<M>k = (n^2-1)/8</M>.
For odd primes <M>m</M> which are coprime to <M>n</M> the
Kronecker-Jacobi symbol has the same value as the Legendre symbol
(see&nbsp;<Ref Func="Legendre"/>).
<P/>
For the general case suppose that <M>m = p_1 \cdot p_2 \cdots p_k</M>
is a product of <M>-1</M> and of primes, not necessarily distinct,
and that <M>n</M> is coprime to <M>m</M>.
Then  <M>J(n,m) = J(n,p_1) \cdot J(n,p_2) \cdots J(n,p_k)</M>.
<P/>
Note that the Kronecker-Jacobi symbol coincides with the Jacobi symbol
that is defined for odd <M>m</M> in many number theory books.
For odd primes <M>m</M> and <M>n</M> coprime to <M>m</M> it coincides
with the Legendre symbol.
<P/>
<Ref Func="Jacobi"/> is very efficient, even for large values of
<A>n</A> and <A>m</A>, it is about as fast as the Euclidean algorithm
(see&nbsp;<Ref Func="Gcd" Label="for (a ring and) several elements"/>).

<Example><![CDATA[
gap> Jacobi( 11, 35 );  # 9^2 = 11 mod 35
1
gap> # this is -1, thus there is no r such that r^2 = 6 mod 35
gap> Jacobi( 6, 35 );
-1
gap> # this is 1 even though there is no r with r^2 = 3 mod 35
gap> Jacobi( 3, 35 );
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Legendre" Arg='n, m'/>

<Description>
<Index>quadratic residue</Index>
<Index Subkey="quadratic">residue</Index>
<Ref Func="Legendre"/> returns the value of the <E>Legendre symbol</E>
of the integer <A>n</A> modulo the positive integer <A>m</A>.
<P/>
The value  of  the Legendre  symbol <M>L(n/m)</M> is 1 if  <M>n</M> is a 
<E>quadratic residue</E> modulo <M>m</M>, i.e., if there exists an integer <M>r</M> such
that <M>r^2 \equiv n \pmod{m}</M> and <M>-1</M> otherwise.
<P/>
If a root of <A>n</A> exists it can be found by <Ref Func="RootMod"/>.
<P/>
While the value of the Legendre symbol usually  is only defined for <A>m</A> a
prime, we have extended the  definition to include composite moduli  too.
The  Jacobi  symbol  (see <Ref Func="Jacobi"/>)  is    another generalization  of the
Legendre symbol for composite moduli that is  much  cheaper  to  compute,
because it does not need the factorization of <A>m</A> (see <Ref Func="FactorsInt"/>).
<P/>
A description of the Jacobi symbol, the Legendre symbol, and related
topics can be found  in <Cite Key="Baker84"/>.

<Example><![CDATA[
gap> Legendre( 5, 11 );  # 4^2 = 5 mod 11
1
gap> # this is -1, thus there is no r such that r^2 = 6 mod 11
gap> Legendre( 6, 11 );
-1
gap> # this is -1, thus there is no r such that r^2 = 3 mod 35
gap> Legendre( 3, 35 );
-1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootMod" Arg='n[, k], m'/>

<Description>
<Index>quadratic residue</Index>
<Index Subkey="quadratic">residue</Index>
<Index Subkey="of an integer modulo another">root</Index>
<Ref Func="RootMod"/> computes a <A>k</A>th root of the integer <A>n</A>
modulo the positive integer <A>m</A>,
i.e., a <M>r</M> such that
<M>r^{<A>k</A>} \equiv <A>n</A> \pmod{<A>m</A>}</M>.
If no such root exists <Ref Func="RootMod"/> returns <K>fail</K>.
If only the arguments <A>n</A> and <A>m</A> are given,
the default value for <A>k</A> is <M>2</M>.
<P/>
A square root of <A>n</A> exists only if <C>Legendre(<A>n</A>,<A>m</A>) = 1</C>
(see&nbsp;<Ref Func="Legendre"/>).
If <A>m</A> has <M>r</M> different prime factors then  there are <M>2^r</M>  different
roots of <A>n</A> mod  <A>m</A>.
It is unspecified which one <Ref Func="RootMod"/> returns.
You can, however, use <Ref Func="RootsMod"/> to compute the full set
of roots.
<P/>
<Ref Func="RootMod"/> is efficient even for large values of <A>m</A>,
in fact the most time is usually spent factoring <A>m</A>
(see <Ref Func="FactorsInt"/>).

<Example><![CDATA[
gap> # note 'RootMod' does not return 8 in this case but -8:
gap> RootMod( 64, 1009 );
1001
gap> RootMod( 64, 3, 1009 );
518
gap> RootMod( 64, 5, 1009 );
656
gap> List( RootMod( 64, 1009 ) * RootsUnityMod( 1009 ),
>       x -> x mod 1009 );  # set of all square roots of 64 mod 1009
[ 1001, 8 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootsMod" Arg='n[, k], m'/>

<Description>
<Ref Func="RootsMod"/> computes the set of <A>k</A>th roots of the
integer <A>n</A> modulo the positive integer <A>m</A>, i.e., the list of 
all <M>r</M> such that <M>r^{<A>k</A>} \equiv <A>n</A> \pmod{<A>m</A>}</M>.
If only the arguments <A>n</A> and <A>m</A> are given,
the default value for <A>k</A> is <M>2</M>.
<Example><![CDATA[
gap> RootsMod( 1, 7*31 );  # the same as `RootsUnityMod( 7*31 )'
[ 1, 92, 125, 216 ]
gap> RootsMod( 7, 7*31 );
[ 21, 196 ]
gap> RootsMod( 5, 7*31 );
[  ]
gap> RootsMod( 1, 5, 7*31 );
[ 1, 8, 64, 78, 190 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootsUnityMod" Arg='[k,] m'/>

<Description>
<Index>modular roots</Index>
<Index Subkey="of 1 modulo an integer">root</Index>
<Ref Func="RootsUnityMod"/> returns the set of <A>k</A>-th roots of unity
modulo the positive integer <A>m</A>, i.e.,
the list of all solutions <M>r</M> of
<M>r^{<A>k</A>} \equiv <A>n</A> \pmod{<A>m</A>}</M>.
If only the argument <A>m</A> is given,
the default value for <A>k</A> is <M>2</M>.
<P/>
In general there are <M><A>k</A>^n</M> such roots if the modulus <A>m</A>
has  <M>n</M> different prime factors <M>p</M> such that
<M>p \equiv 1 \pmod{<A>k</A>}</M>.
If <M><A>k</A>^2</M> divides <A>m</A> then there are
<M><A>k</A>^{{n+1}}</M> such roots;
and especially if <M><A>k</A> = 2</M> and 8 divides <A>m</A>
there are <M>2^{{n+2}}</M> such roots.
<P/>
In the current implementation <A>k</A> must be a prime.
<Example><![CDATA[
gap> RootsUnityMod( 7*31 );  RootsUnityMod( 3, 7*31 );
[ 1, 92, 125, 216 ]
[ 1, 25, 32, 36, 67, 149, 156, 191, 211 ]
gap> RootsUnityMod( 5, 7*31 );
[ 1, 8, 64, 78, 190 ]
gap> List( RootMod( 64, 1009 ) * RootsUnityMod( 1009 ),
>          x -> x mod 1009 );  # set of all square roots of 64 mod 1009
[ 1001, 8 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Multiplicative Arithmetic Functions">
<Heading>Multiplicative Arithmetic Functions</Heading>

<ManSection>
<Oper Name="Sigma" Arg='n'/>

<Description>
<Ref Func="Sigma"/> returns the sum of the positive divisors of the
nonzero integer <A>n</A>.
<P/>
<Ref Func="Sigma"/> is a multiplicative arithmetic function, i.e.,
if <M>n</M> and <M>m</M> are relatively prime we have that
<M>\sigma(n \cdot m) = \sigma(n) \sigma(m)</M>.
<P/>
Together with the formula <M>\sigma(p^k) = (p^{{k+1}}-1) / (p-1)</M>
this allows us to compute <M>\sigma(<A>n</A>)</M>.
<P/>
Integers <A>n</A> for which <M>\sigma(<A>n</A>) = 2 <A>n</A></M>
are called perfect.
Even perfect integers are exactly of the form
<M>2^{{<A>n</A>-1}}(2^{<A>n</A>}-1)</M>
where <M>2^{<A>n</A>}-1</M> is prime.
Primes of the form <M>2^{<A>n</A>}-1</M> are called
<E>Mersenne primes</E>, and
42 among the known Mersenne primes are obtained for <A>n</A> <M>=</M> 2, 3, 5, 7, 13, 17, 19,
31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689,
9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091,
756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917,
20996011, 24036583 and 25964951. Please find more up to date information
about Mersenne primes at <URL>http://www.mersenne.org</URL>.
It is not known whether odd perfect integers exist,
however&nbsp;<Cite Key="BC89"/> show that any such integer must have
at least 300 decimal digits.
<P/>
<Ref Func="Sigma"/> usually spends most of its time factoring <A>n</A>
(see&nbsp;<Ref Func="FactorsInt"/>).
<P/>
<Example><![CDATA[
gap> Sigma( 1 );
1
gap> Sigma( 1009 );  # 1009 is a prime
1010
gap> Sigma( 8128 ) = 2*8128;  # 8128 is a perfect number
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Tau" Arg='n'/>

<Description>
<Ref Func="Tau"/> returns the number of the positive divisors of the
nonzero integer <A>n</A>.
<P/>
<Ref Func="Tau"/> is a multiplicative arithmetic function, i.e.,
if <M>n</M> and  <M>m</M> are relative prime we have
<M>\tau(n \cdot m) = \tau(n) \tau(m)</M>.
Together with the formula <M>\tau(p^k) = k+1</M> this allows us
to compute <M>\tau(<A>n</A>)</M>.
<P/>
<Ref Func="Tau"/> usually spends most of its time factoring <A>n</A>
(see&nbsp;<Ref Func="FactorsInt"/>).
<Example><![CDATA[
gap> Tau( 1 );
1
gap> Tau( 1013 );  # thus 1013 is a prime
2
gap> Tau( 8128 );
14
gap> # result is odd if and only if argument is a perfect square:
gap> Tau( 36 );
9
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MoebiusMu" Arg='n'/>

<Description>
<Ref Func="MoebiusMu"/> computes the value of Moebius inversion function
for the nonzero integer <A>n</A>.
This is 0 for integers which are not squarefree, i.e.,
which are divided by a square <M>r^2</M>.
Otherwise it is 1 if <A>n</A> has a even number and <M>-1</M> if <A>n</A>
has an odd number of prime factors.
<P/>
The importance of <M>\mu</M> stems from the so called inversion formula.
Suppose <M>f</M> is a multiplicative arithmetic function
defined on the positive integers and let
<M>g(n) = \sum_{{d \mid  n}} f(d)</M>.
Then <M>f(n) = \sum_{{d \mid n}} \mu(d) g(n/d)</M>.
As a special case we have
<M>\phi(n) = \sum_{{d \mid n}} \mu(d) n/d</M>
since <M>n = \sum_{{d \mid n}} \phi(d)</M>
(see&nbsp;<Ref Func="Phi"/>).
<P/>
<Ref Func="MoebiusMu"/> usually spends all of its time factoring <A>n</A>
(see <Ref Func="FactorsInt"/>).
<Example><![CDATA[
gap> MoebiusMu( 60 );  MoebiusMu( 61 );  MoebiusMu( 62 );
0
-1
1
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Continued Fractions">
<Heading>Continued Fractions</Heading>

<ManSection>
<Func Name="ContinuedFractionExpansionOfRoot" Arg='f, n'/>

<Description>
The first <A>n</A> terms of the continued fraction expansion of the only
positive real root of the polynomial <A>f</A> with integer coefficients.
The leading coefficient of <A>f</A> must be positive and the value of <A>f</A> at 0
must be negative. If the degree of <A>f</A> is 2 and <A>n</A> = 0, the function
computes one period of the continued fraction expansion of the root in
question. Anything may happen if <A>f</A> has three or more positive real
roots.
<Example><![CDATA[
gap> x := Indeterminate(Integers);;
gap> ContinuedFractionExpansionOfRoot(x^2-7,20);
[ 2, 1, 1, 1, 4, 1, 1, 1, 4, 1, 1, 1, 4, 1, 1, 1, 4, 1, 1, 1 ]
gap> ContinuedFractionExpansionOfRoot(x^2-7,0);
[ 2, 1, 1, 1, 4 ]
gap> ContinuedFractionExpansionOfRoot(x^3-2,20);
[ 1, 3, 1, 5, 1, 1, 4, 1, 1, 8, 1, 14, 1, 10, 2, 1, 4, 12, 2, 3 ]
gap> ContinuedFractionExpansionOfRoot(x^5-x-1,50);
[ 1, 5, 1, 42, 1, 3, 24, 2, 2, 1, 16, 1, 11, 1, 1, 2, 31, 1, 12, 5, 
  1, 7, 11, 1, 4, 1, 4, 2, 2, 3, 4, 2, 1, 1, 11, 1, 41, 12, 1, 8, 1, 
  1, 1, 1, 1, 9, 2, 1, 5, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ContinuedFractionApproximationOfRoot" Arg='f, n'/>

<Description>
The <A>n</A>th continued fraction approximation of the only positive real root
of the polynomial <A>f</A> with integer coefficients. The leading coefficient
of <A>f</A> must be positive and the value of <A>f</A> at 0 must be negative.
Anything may happen if <A>f</A> has three or more positive real roots.
<Example><![CDATA[
gap> ContinuedFractionApproximationOfRoot(x^2-2,10);
3363/2378
gap> 3363^2-2*2378^2;
1
gap> z := ContinuedFractionApproximationOfRoot(x^5-x-1,20);
499898783527/428250732317
gap> z^5-z-1;
486192462527432755459620441970617283/
14404247382319842421697357558805709031116987826242631261357
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Miscellaneous">
<Heading>Miscellaneous</Heading>

<ManSection>
<Func Name="TwoSquares" Arg='n'/>

<Description>
<Index Subkey="as a sum of two squares">representation</Index>
<Ref Func="TwoSquares"/> returns a list of two integers <M>x \leq y</M>
such that the sum of the squares of <M>x</M> and <M>y</M> is equal to the
nonnegative integer <A>n</A>, i.e., <M>n = x^2 + y^2</M>.
If no such representation exists
<Ref Func="TwoSquares"/> will return <K>fail</K>.
<Ref Func="TwoSquares"/> will return a representation for which the gcd
of <M>x</M> and <M>y</M> is as small as possible.
It is not specified which representation <Ref Func="TwoSquares"/> returns
if there is more than one.
<P/>
Let <M>a</M> be the product of all maximal powers of primes of the form
<M>4k+3</M> dividing <A>n</A>.
A representation of <A>n</A> as a sum of two squares exists
if and only if <M>a</M> is a perfect square.
Let <M>b</M> be the maximal power of <M>2</M> dividing <A>n</A> or its
half, whichever is a perfect square.
Then the minimal possible gcd of <M>x</M> and <M>y</M> is the square root
<M>c</M> of <M>a \cdot b</M>.
The number of different minimal representation with <M>x \leq y</M> is
<M>2^{{l-1}}</M>, where <M>l</M> is the number of different prime factors
of the form <M>4k+1</M> of <A>n</A>.
<P/>
The algorithm first finds a square root <M>r</M> of <M>-1</M> modulo
<M><A>n</A> / (a \cdot b)</M>, which must exist,
and applies the Euclidean algorithm to <M>r</M> and <A>n</A>.
The first residues in the sequence that are smaller than
<M>\sqrt{{<A>n</A>/(a \cdot b)}}</M> times <M>c</M> are a possible pair
<M>x</M> and <M>y</M>.
<P/>
Better descriptions of the algorithm and related topics can be found in
<Cite Key="Wagon90"/> and <Cite Key="Zagier90"/>.

<Example><![CDATA[
gap> TwoSquares( 5 );
[ 1, 2 ]
gap> TwoSquares( 11 );  # there is no representation
fail
gap> TwoSquares( 16 );
[ 0, 4 ]
gap> # 3 is the minimal possible gcd because 9 divides 45:
gap> TwoSquares( 45 );
[ 3, 6 ]
gap> # it is not [5,10] because their gcd is not minimal:
gap> TwoSquares( 125 );
[ 2, 11 ]
gap> # [10,11] would be the other possible representation:
gap> TwoSquares( 13*17 );
[ 5, 14 ]
gap> TwoSquares( 848654483879497562821 );  # argument is prime
[ 6305894639, 28440994650 ]
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  combinat.msk                GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: combinat.msk,v 1.19 2002/09/04 11:27:01 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Combinatorics">
<Heading>Combinatorics</Heading>

This chapter describes functions that deal with combinatorics.
We mainly concentrate on two areas.
One is about <E>selections</E>,
that is the ways one can select elements from a set.
The other is about <E>partitions</E>,
that is the ways one can partition a set into the union of pairwise disjoint
subsets.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Combinatorial Numbers">
<Heading>Combinatorial Numbers</Heading>

<ManSection>
<Func Name="Factorial" Arg='n'/>

<Description>
returns the <E>factorial</E> <M>n!</M> of the positive integer <A>n</A>,
which is defined as the product <M>1 \cdot 2 \cdot 3 \cdots n</M>.
<P/>
<M>n!</M> is the number of permutations of a set of <M>n</M> elements.
<M>1 / n!</M> is the coefficient of <M>x^n</M> in the formal series
<M>\exp(x)</M>,
which is the generating function for factorial.
<P/>
<Example><![CDATA[
gap> List( [0..10], Factorial );
[ 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 ]
gap> Factorial( 30 );
265252859812191058636308480000000
]]></Example>
<P/>
<Ref Func="PermutationsList"/> computes the set of all permutations
of a list.
</Description>
</ManSection>

<ManSection>
<Func Name="Binomial" Arg='n, k'/>

<Description>
returns the <E>binomial coefficient</E>
<Index Subkey="binomial">coefficient</Index>
<Index Subkey="binomial">number</Index>
<M>{{n \choose k}}</M> of integers <A>n</A> and <A>k</A>,
which is defined as <M>n! / (k! (n-k)!)</M>
(see <Ref Func="Factorial"/>).
We define <M>{{0 \choose 0}} = 1, {{n \choose  k}} = 0</M> if
<M>k &lt; 0</M> or <M>n &lt; k</M>,
and <M>{{n \choose k}} = (-1)^k {{-n+k-1 \choose k}}</M>
if <M>n &lt; 0</M>,
which is consistent with the equivalent definition
<M>{{n \choose k}} = {{n-1 \choose k}} + {{n-1 \choose k-1}}</M>.
<P/>
<M>{{n \choose k}}</M> is the number of combinations with <M>k</M>
elements, i.e.,
the number of subsets with <M>k</M> elements, of a set with <M>n</M>
elements.
<M>{{n \choose k}}</M> is the coefficient of the term <M>x^k</M> of the
polynomial <M>(x + 1)^n</M>,
which is the generating function for <M>{{n \choose .}}</M>,
hence the name.
<P/>
<Example><![CDATA[
gap> # Knuth calls this the trademark of Binomial:
gap> List( [0..4], k->Binomial( 4, k ) );
[ 1, 4, 6, 4, 1 ]
gap> List( [0..6], n->List( [0..6], k->Binomial( n, k ) ) );;
gap> # the lower triangle is called Pascal's triangle:
gap> PrintArray( last );
[ [   1,   0,   0,   0,   0,   0,   0 ],
  [   1,   1,   0,   0,   0,   0,   0 ],
  [   1,   2,   1,   0,   0,   0,   0 ],
  [   1,   3,   3,   1,   0,   0,   0 ],
  [   1,   4,   6,   4,   1,   0,   0 ],
  [   1,   5,  10,  10,   5,   1,   0 ],
  [   1,   6,  15,  20,  15,   6,   1 ] ]
gap> Binomial( 50, 10 );
10272278170
]]></Example>
<P/>
<Ref Func="NrCombinations"/> is the generalization of
<Ref Func="Binomial"/> for multisets.
<Ref Func="Combinations"/> computes the set of all combinations of a
multiset.
</Description>
</ManSection>

<ManSection>
<Func Name="Bell" Arg='n'/>

<Description>
returns the <E>Bell number</E>
<Index Subkey="Bell">number</Index>
<M>B(n)</M>.
The Bell numbers are defined by
<M>B(0) = 1</M> and the recurrence
<M>B(n+1) = \sum_{{k = 0}}^n {{n \choose k}} B(k)</M>.
<P/>
<M>B(n)</M> is the number of ways to partition a set of <A>n</A> elements
into pairwise disjoint nonempty subsets
(see <Ref Func="PartitionsSet"/>).
This implies of course that <M>B(n) = \sum_{{k = 0}}^n S_2(n,k)</M>
(see <Ref Func="Stirling2"/>).
<M>B(n)/n!</M> is the coefficient of <M>x^n</M> in the formal series
<M>\exp( \exp(x)-1 )</M>, which is the generating function for <M>B(n)</M>.
<P/>
<Example><![CDATA[
gap> List( [0..6], n -> Bell( n ) );
[ 1, 1, 2, 5, 15, 52, 203 ]
gap> Bell( 14 );
190899322
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Bernoulli" Arg='n'/>

<Description>
returns the <A>n</A>-th <E>Bernoulli number</E>
<Index Subkey="Bernoulli">sequence</Index>
<M>B_n</M>, which is defined by
<M>B_0 = 1</M> and
<M>B_n = -\sum_{{k = 0}}^{{n-1}} {{n+1 \choose k}} B_k/(n+1)</M>.
<P/>
<M>B_n / n!</M> is the coefficient of <M>x^n</M> in the power series of
<M>x / (\exp(x)-1)</M>.
Except for <M>B_1 = -1/2</M>
the Bernoulli numbers for odd indices are zero.
<P/>
<Example><![CDATA[
gap> Bernoulli( 4 );
-1/30
gap> Bernoulli( 10 );
5/66
gap> Bernoulli( 12 );  # there is no simple pattern in Bernoulli numbers
-691/2730
gap> Bernoulli( 50 );  # and they grow fairly fast
495057205241079648212477525/66
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Stirling1" Arg='n, k'/>

<Description>
returns the <E>Stirling number of the first kind</E>
<Index>Stirling number of the first kind</Index>
<Index Subkey="Stirling, of the first kind">number</Index>
<M>S_1(n,k)</M> of the integers <A>n</A> and <A>k</A>.
Stirling numbers of the first kind are defined by
<M>S_1(0,0) = 1</M>, <M>S_1(n,0) = S_1(0,k) = 0</M> if <M>n, k \ne 0</M>
and the recurrence <M>S_1(n,k) = (n-1) S_1(n-1,k) + S_1(n-1,k-1)</M>.
<P/>
<M>S_1(n,k)</M> is the number of permutations of <A>n</A> points with
<A>k</A> cycles.
Stirling numbers of the first kind appear as coefficients in the series
<M>n! {{x \choose n}} = \sum_{{k = 0}}^n S_1(n,k) x^k</M>
which is the generating function for Stirling numbers of the first kind.
Note the similarity to
<M>x^n = \sum_{{k = 0}}^n S_2(n,k) k! {{x \choose k}}</M>
(see <Ref Func="Stirling2"/>).
Also the definition of <M>S_1</M> implies <M>S_1(n,k) = S_2(-k,-n)</M> if
<M>n, k &lt; 0</M>.
There are many formulae relating Stirling numbers of the first kind to
Stirling numbers of the second kind, Bell numbers,
and Binomial coefficients.
<P/>
<Example><![CDATA[
gap> # Knuth calls this the trademark of S_1:
gap> List( [0..4], k -> Stirling1( 4, k ) );
[ 0, 6, 11, 6, 1 ]
gap> List( [0..6], n->List( [0..6], k->Stirling1( n, k ) ) );;
gap> # note the similarity with Pascal's triangle for Binomial numbers
gap> PrintArray( last );
[ [    1,    0,    0,    0,    0,    0,    0 ],
  [    0,    1,    0,    0,    0,    0,    0 ],
  [    0,    1,    1,    0,    0,    0,    0 ],
  [    0,    2,    3,    1,    0,    0,    0 ],
  [    0,    6,   11,    6,    1,    0,    0 ],
  [    0,   24,   50,   35,   10,    1,    0 ],
  [    0,  120,  274,  225,   85,   15,    1 ] ]
gap> Stirling1(50,10);
101623020926367490059043797119309944043405505380503665627365376
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Stirling2" Arg='n, k'/>

<Description>
returns the <E>Stirling number of the second kind</E>
<Index>Stirling number of the second kind</Index>
<Index Subkey="Stirling, of the second kind">number</Index>
<M>S_2(n,k)</M> of the integers <A>n</A> and <A>k</A>.
Stirling numbers of the second kind are defined by
<M>S_2(0,0) = 1</M>, <M>S_2(n,0) = S_2(0,k) = 0</M> if <M>n, k \ne 0</M>
and the recurrence <M>S_2(n,k) = k S_2(n-1,k) + S_2(n-1,k-1)</M>.
<P/>
<M>S_2(n,k)</M> is the number of ways to partition a set of <A>n</A>
elements into <A>k</A> pairwise disjoint nonempty subsets
(see <Ref Func="PartitionsSet"/>).
Stirling numbers of the second kind  appear as coefficients in the
expansion of <M>x^n = \sum_{{k = 0}}^n S_2(n,k) k! {{x \choose k}}</M>.
Note the similarity to
<M>n! {{x \choose n}} = \sum_{{k = 0}}^n S_1(n,k) x^k</M>
(see <Ref Func="Stirling1"/>).
Also the definition of <M>S_2</M> implies <M>S_2(n,k) = S_1(-k,-n)</M> if
<M>n, k &lt; 0</M>.
There are many formulae relating Stirling numbers of the second kind to
Stirling numbers of the first kind, Bell numbers,
and Binomial coefficients.
<P/>
<Example><![CDATA[
gap> # Knuth calls this the trademark of S_2:
gap> List( [0..4], k->Stirling2( 4, k ) );
[ 0, 1, 7, 6, 1 ]
gap> List( [0..6], n->List( [0..6], k->Stirling2( n, k ) ) );;
gap> # note the similarity with Pascal's triangle for Binomial numbers
gap> PrintArray( last );
[ [   1,   0,   0,   0,   0,   0,   0 ],
  [   0,   1,   0,   0,   0,   0,   0 ],
  [   0,   1,   1,   0,   0,   0,   0 ],
  [   0,   1,   3,   1,   0,   0,   0 ],
  [   0,   1,   7,   6,   1,   0,   0 ],
  [   0,   1,  15,  25,  10,   1,   0 ],
  [   0,   1,  31,  90,  65,  15,   1 ] ]
gap> Stirling2( 50, 10 );
26154716515862881292012777396577993781727011
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Combinations, Arrangements and Tuples">
<Heading>Combinations, Arrangements and Tuples</Heading>

<ManSection>
<Func Name="Combinations" Arg='mset[, k]'/>

<Description>
returns the set of all combinations of the multiset <A>mset</A>
(a list of objects which may contain the same object several times)
with <A>k</A> elements;
if <A>k</A> is not given it returns all combinations of <A>mset</A>.
<P/>
A <E>combination</E> of <A>mset</A> is an unordered selection without
repetitions and is represented by a sorted sublist of <A>mset</A>.
If <A>mset</A> is a proper set,
there are <M>{{|<A>mset</A>| \choose <A>k</A>}}</M>
(see <Ref Func="Binomial"/>) combinations with <A>k</A> elements,
and the set of all combinations is just the <E>power set</E>
<Index>power set</Index>
<Index>subsets</Index>
of <A>mset</A>, which contains all <E>subsets</E> of <A>mset</A> and has
cardinality <M>2^{{|<A>mset</A>|}}</M>.
<P/>
To loop over combinations of a larger multiset use <Ref
Func="IteratorOfCombinations" /> which produces combinations one by one
and may save a lot of memory. Another memory efficient representation of 
the list of all combinations is provided by <Ref
Func="EnumeratorOfCombinations" />.
</Description>
</ManSection>

<ManSection>
<Heading>Iterator and enumerator of combinations</Heading>
<Func Name="IteratorOfCombinations" Arg='mset[, k]'/>
<Func Name="EnumeratorOfCombinations" Arg='mset'/>

<Description>
<Ref Func="IteratorOfCombinations" /> returns an <Ref Oper="Iterator" /> 
for  combinations (see <Ref Func="Combinations"/>) of the given multiset
<A>mset</A>. If a non-negative integer <A>k</A> is given as second argument
then only the combinations with <A>k</A> entries are produced, otherwise
all combinations. 
<P/>
<Ref Func="EnumeratorOfCombinations"/> returns an <Ref Oper="Enumerator" />
of the given multiset <A>mset</A>. Currently only a variant without second 
argument <A>k</A> is implemented.
<P/>
The ordering of combinations from these functions can be different and also
different from the list returned by <Ref Func="Combinations"/>.
<P/>
<Example>
gap> m:=[1..15];; Add(m, 15);
gap> NrCombinations(m);
49152
gap> i := 0;; for c in Combinations(m) do i := i+1; od;
gap> i;
49152
gap> cm := EnumeratorOfCombinations(m);;
gap> cm[1000];
[ 1, 2, 3, 6, 7, 8, 9, 10 ]
gap> Position(cm, [1,13,15,15]);
36866
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NrCombinations" Arg='mset[, k]'/>

<Description>
returns the number of <C>Combinations(<A>mset</A>,<A>k</A>)</C>.
<P/>
<Example><![CDATA[
gap> Combinations( [1,2,2,3] );
[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 2 ], [ 1, 2, 2, 3 ], [ 1, 2, 3 ], 
  [ 1, 3 ], [ 2 ], [ 2, 2 ], [ 2, 2, 3 ], [ 2, 3 ], [ 3 ] ]
gap> # number of different hands in a game of poker:
gap> NrCombinations( [1..52], 5 );
2598960
]]></Example>
<P/>
The function <Ref Func="Arrangements"/> computes ordered selections
without repetitions,
<Ref Func="UnorderedTuples"/> computes unordered selections with
repetitions, and
<Ref Func="Tuples"/> computes ordered selections with repetitions.
</Description>
</ManSection>

<ManSection>
<Func Name="Arrangements" Arg='mset [,k]'/>

<Description>
returns the  set of arrangements of the multiset <A>mset</A> that contain <A>k</A>
elements. If <A>k</A> is not given it returns all arrangements of <A>mset</A>.
<P/>
An  <E>arrangement</E> of <A>mset</A>  is an ordered selection  without
repetitions and is represented by a list that contains only elements
from <A>mset</A>, but maybe  in a different  order. If <A>mset</A>  is  a proper
set there  are <M>|mset|!  /  (|mset|-k)!</M> (see  <Ref Func="Factorial"/>)
arrangements  with  <A>k</A> elements.
</Description>
</ManSection>

<ManSection>
<Func Name="NrArrangements" Arg='mset [,k]'/>

<Description>
returns the number of <C>Arrangements(<A>mset</A>,<A>k</A>)</C>.
<P/>
As an example of arrangements of a multiset, think of the game Scrabble.
Suppose you have the six characters of the word <C>"settle"</C>
and you have to make a four letter word.
Then the possibilities are given by
<P/>
<Log><![CDATA[
gap> Arrangements( ["s","e","t","t","l","e"], 4 );
[ [ "e", "e", "l", "s" ], [ "e", "e", "l", "t" ], [ "e", "e", "s", "l" ],
  [ "e", "e", "s", "t" ], [ "e", "e", "t", "l" ], [ "e", "e", "t", "s" ],
  ... 93 more possibilities ...
  [ "t", "t", "l", "s" ], [ "t", "t", "s", "e" ], [ "t", "t", "s", "l" ] ]
]]></Log>
<P/>
Can you find the five proper English words,
where <C>"lets"</C> does not count?
Note that the fact that the  list  returned by <Ref Func="Arrangements"/>
is a proper set means in this example that the possibilities are listed
in  the same order as they appear in the dictionary.
<P/>
<Example><![CDATA[
gap> NrArrangements( ["s","e","t","t","l","e"] );
523
]]></Example>
<P/>
The function <Ref Func="Combinations"/> computes unordered selections
without repetitions,
<Ref Func="UnorderedTuples"/> computes unordered selections with
repetitions, and
<Ref Func="Tuples"/> computes ordered selections with repetitions.
</Description>
</ManSection>

<ManSection>
<Func Name="UnorderedTuples" Arg='set, k'/>

<Description>
returns the set of all unordered tuples of length <A>k</A> of the set
<A>set</A>.
<P/>
An <E>unordered tuple</E> of length <A>k</A> of <A>set</A> is an
unordered selection with repetitions of <A>set</A> and is represented by
a sorted list of length <A>k</A> containing elements from <A>set</A>.
There  are <M>{{|set| + k - 1 \choose k}}</M> (see <Ref Func="Binomial"/>)
such unordered tuples.
<P/>
Note that the fact that <Ref Func="UnorderedTuples"/> returns a set
implies that the last index runs fastest.
That means the first tuple contains the smallest element from <A>set</A>
<A>k</A> times, the second tuple contains the smallest element of
<A>set</A> at all positions except at the last positions,
where it contains the second smallest element from <A>set</A> and so on.
</Description>
</ManSection>

<ManSection>
<Func Name="NrUnorderedTuples" Arg='set, k'/>

<Description>
returns the number of <C>UnorderedTuples(<A>set</A>,<A>k</A>)</C>.
<P/>
As an example for unordered tuples think of a poker-like game played with
5  dice.
Then each possible hand corresponds to an unordered five-tuple
from the set <M>\{ 1, 2, \ldots, 6 \}</M>.
<P/>
<Log><![CDATA[
gap> NrUnorderedTuples( [1..6], 5 );
252
gap> UnorderedTuples( [1..6], 5 );
[ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 2 ], [ 1, 1, 1, 1, 3 ], [ 1, 1, 1, 1, 4 ],
  [ 1, 1, 1, 1, 5 ], [ 1, 1, 1, 1, 6 ], [ 1, 1, 1, 2, 2 ], [ 1, 1, 1, 2, 3 ],
  ... 100 more tuples ...
  [ 1, 3, 5, 5, 6 ], [ 1, 3, 5, 6, 6 ], [ 1, 3, 6, 6, 6 ], [ 1, 4, 4, 4, 4 ],
  ... 100 more tuples ...
  [ 3, 3, 5, 5, 5 ], [ 3, 3, 5, 5, 6 ], [ 3, 3, 5, 6, 6 ], [ 3, 3, 6, 6, 6 ],
  ... 32 more tuples ...
  [ 5, 5, 5, 6, 6 ], [ 5, 5, 6, 6, 6 ], [ 5, 6, 6, 6, 6 ], [ 6, 6, 6, 6, 6 ] ]
]]></Log>
<P/>
The function <Ref Func="Combinations"/> computes unordered selections
without repetitions,
<Ref Func="Arrangements"/> computes ordered selections without
repetitions, and
<Ref Func="Tuples"/> computes ordered selections with repetitions.
</Description>
</ManSection>

<ManSection>
<Func Name="Tuples" Arg='set, k'/>

<Description>
returns the set of all ordered tuples of length <A>k</A> of the set
<A>set</A>.
<P/>
An <E>ordered tuple</E> of length <A>k</A> of <A>set</A> is an ordered
selection with repetition and is represented by a list of length <A>k</A>
containing elements of <A>set</A>.
There are <M>|<A>set</A>|^{<A>k</A>}</M> such ordered tuples.
<P/>
Note that the fact that <Ref Func="Tuples"/> returns a set implies that
the last index runs fastest.
That means the first tuple contains the smallest element from <A>set</A>
<A>k</A> times, the second tuple contains the smallest element of
<A>set</A> at all positions except at the last positions,
where it contains the second smallest element from <A>set</A> and so on.
</Description>
</ManSection>

<ManSection>
<Func Name="EnumeratorOfTuples" Arg='set, k'/>

<Description>
This function is referred to as an example of enumerators that are
defined by functions but are not constructed from a domain.
The result is equal to that of <C>Tuples( <A>set</A>, <A>k</A> )</C>.
However, the entries are not stored physically in the list but are
created/identified on demand.
<P/>
</Description>
</ManSection>

<ManSection>
<Func Name="IteratorOfTuples" Arg='set, k'/>

<Description>
For a set <A>set</A> and a positive integer <A>k</A>,
<Ref Func="IteratorOfTuples"/>
returns an iterator (see&nbsp;<Ref Sect="Iterators"/>) of the set of
all ordered tuples (see&nbsp;<Ref Func="Tuples"/>) of length <A>k</A>
of the set <A>set</A>. The tuples are returned in lexicographic order.
</Description>
</ManSection>

<ManSection>
<Func Name="NrTuples" Arg='set, k'/>

<Description>
returns the number of <C>Tuples(<A>set</A>,<A>k</A>)</C>.
<Example><![CDATA[
gap> Tuples( [1,2,3], 2 );
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ]
gap> NrTuples( [1..10], 5 );
100000
]]></Example>
<P/>
<C>Tuples(<A>set</A>,<A>k</A>)</C> can also be viewed as the
<A>k</A>-fold cartesian product of <A>set</A>
(see <Ref Func="Cartesian" Label="for a list"/>).
<P/>
The function <Ref Func="Combinations"/> computes unordered selections
without repetitions,
<Ref Func="Arrangements"/> computes ordered selections without
repetitions, and finally the function
<Ref Func="UnorderedTuples"/> computes unordered selections
with repetitions.
</Description>
</ManSection>

<ManSection>
<Func Name="PermutationsList" Arg='mset'/>

<Description>
<Ref Func="PermutationsList"/> returns the set of permutations of the
multiset <A>mset</A>.
<P/>
A <E>permutation</E> is represented by a list that contains exactly the
same elements as <A>mset</A>, but possibly in different order.
If <A>mset</A> is a proper set there are <M>|<A>mset</A>| !</M>
(see <Ref Func="Factorial"/>) such permutations.
Otherwise if the first elements appears <M>k_1</M> times,
the second element appears <M>k_2</M> times and so on,
the number of permutations is
<M>|<A>mset</A>| ! / (k_1! k_2! \ldots)</M>,
which is sometimes called multinomial coefficient.
</Description>
</ManSection>

<ManSection>
<Func Name="NrPermutationsList" Arg='mset'/>

<Description>
returns the number of <C>PermutationsList(<A>mset</A>)</C>.
<Example><![CDATA[
gap> PermutationsList( [1,2,3] );
[ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 3 ], [ 2, 3, 1 ], [ 3, 1, 2 ], 
  [ 3, 2, 1 ] ]
gap> PermutationsList( [1,1,2,2] );
[ [ 1, 1, 2, 2 ], [ 1, 2, 1, 2 ], [ 1, 2, 2, 1 ], [ 2, 1, 1, 2 ], 
  [ 2, 1, 2, 1 ], [ 2, 2, 1, 1 ] ]
gap> NrPermutationsList( [1,2,2,3,3,3,4,4,4,4] );
12600
]]></Example>
<P/>
The function <Ref Func="Arrangements"/> is the generalization of
<Ref Func="PermutationsList"/> that allows you to specify the size of the
permutations.
<Ref Func="Derangements"/> computes permutations that have no fixed
points.
</Description>
</ManSection>

<ManSection>
<Func Name="Derangements" Arg='list'/>

<Description>
returns the set of all derangements of the list <A>list</A>.
<P/>
A <E>derangement</E> is a fixpointfree permutation of <A>list</A> and
is represented by a list that contains exactly the same elements as
<A>list</A>, but in such an order that the derangement has at no position
the same element as <A>list</A>.
If the list <A>list</A> contains no element twice there are exactly
<M>|<A>list</A>|! (1/2! - 1/3! + 1/4! - \cdots + (-1)^n / n!)</M>
derangements.
<P/>
Note that the ratio
<C>NrPermutationsList( [ 1 .. n ] ) / NrDerangements( [ 1 .. n ] )</C>,
which is <M>n! / (n! (1/2! - 1/3! + 1/4! - \cdots + (-1)^n / n!))</M>
is an approximation for the base of the natural logarithm
<M>e = 2.7182818285\ldots</M>, which is correct to about <M>n</M> digits.
</Description>
</ManSection>

<ManSection>
<Func Name="NrDerangements" Arg='list'/>

<Description>
returns the number of <C>Derangements(<A>list</A>)</C>.
<P/>
As an  example of  derangements suppose    that  you have  to  send  four
different letters  to   four  different  people.    Then  a   derangement
corresponds  to a way  to send those letters such  that no letter reaches
the intended person.
<P/>
<Example><![CDATA[
gap> Derangements( [1,2,3,4] );
[ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ], 
  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ], 
  [ 4, 3, 2, 1 ] ]
gap> NrDerangements( [1..10] );
1334961
gap> Int( 10^7*NrPermutationsList([1..10])/last );
27182816
gap> Derangements( [1,1,2,2,3,3] );
[ [ 2, 2, 3, 3, 1, 1 ], [ 2, 3, 1, 3, 1, 2 ], [ 2, 3, 1, 3, 2, 1 ], 
  [ 2, 3, 3, 1, 1, 2 ], [ 2, 3, 3, 1, 2, 1 ], [ 3, 2, 1, 3, 1, 2 ], 
  [ 3, 2, 1, 3, 2, 1 ], [ 3, 2, 3, 1, 1, 2 ], [ 3, 2, 3, 1, 2, 1 ], 
  [ 3, 3, 1, 1, 2, 2 ] ]
gap> NrDerangements( [1,2,2,3,3,3,4,4,4,4] );
338
]]></Example>
<P/>
The function  <Ref Func="PermutationsList"/>  computes all
permutations of a list.
</Description>
</ManSection>

<ManSection>
<Func Name="PartitionsSet" Arg='set [,k]'/>

<Description>
returns the  set  of  all unordered
partitions of the set <A>set</A> into  <A>k</A> pairwise disjoint nonempty sets.
If <A>k</A> is not given it returns all unordered partitions of <A>set</A> for all
<A>k</A>.
<P/>
An <E>unordered partition</E> of <A>set</A> is  a set of pairwise disjoint
nonempty sets with union <A>set</A>  and is represented by  a sorted list of
such sets.  There are <M>B( |set| )</M> (see <Ref Func="Bell"/>) partitions of  the
set  <A>set</A>  and <M>S_2( |set|, k )</M> (see <Ref Func="Stirling2"/>) partitions with
<A>k</A> elements.
</Description>
</ManSection>

<ManSection>
<Func Name="NrPartitionsSet" Arg='set[, k]'/>

<Description>
returns the number of <C>PartitionsSet(<A>set</A>,<A>k</A>)</C>.
<Example><![CDATA[
gap> PartitionsSet( [1,2,3] );
[ [ [ 1 ], [ 2 ], [ 3 ] ], [ [ 1 ], [ 2, 3 ] ], [ [ 1, 2 ], [ 3 ] ], 
  [ [ 1, 2, 3 ] ], [ [ 1, 3 ], [ 2 ] ] ]
gap> PartitionsSet( [1,2,3,4], 2 );
[ [ [ 1 ], [ 2, 3, 4 ] ], [ [ 1, 2 ], [ 3, 4 ] ], 
  [ [ 1, 2, 3 ], [ 4 ] ], [ [ 1, 2, 4 ], [ 3 ] ], 
  [ [ 1, 3 ], [ 2, 4 ] ], [ [ 1, 3, 4 ], [ 2 ] ], 
  [ [ 1, 4 ], [ 2, 3 ] ] ]
gap> NrPartitionsSet( [1..6] );
203
gap> NrPartitionsSet( [1..10], 3 );
9330
]]></Example>
<P/>
Note that <Ref Func="PartitionsSet"/> does currently not support
multisets and that there is currently no ordered counterpart.
</Description>
</ManSection>

<ManSection>
<Func Name="Partitions" Arg='n[, k]'/>

<Description>
returns the set of all (unordered) partitions of the positive integer
<A>n</A> into sums with <A>k</A> summands.
If <A>k</A> is not given it returns all unordered partitions of
<A>set</A> for all <A>k</A>.
<P/>
An <E>unordered partition</E> is an unordered sum
<M>n = p_1 + p_2 + \cdots + p_k</M>
of positive integers and is represented by the list
<M>p = [ p_1, p_2, \ldots, p_k ]</M>, in nonincreasing order, i.e.,
<M>p_1 \geq p_2 \geq \ldots \geq p_k</M>.
We write <M>p \vdash n</M>.
There are approximately
<M>\exp(\pi \sqrt{{2/3 n}}) / (4 \sqrt{{3}} n)</M> such partitions,
use <Ref Func="NrPartitions"/> to compute the precise number.
<P/>
If you want to loop over all partitions of some larger <A>n</A> use
the more memory efficient <Ref Func="IteratorOfPartitions"/>.
<P/>
It is possible to associate with every partition of the integer <A>n</A>
a conjugacy class of permutations in the symmetric group on <A>n</A>
points and vice versa.
Therefore <M>p(n) := </M><C>NrPartitions</C><M>(n)</M> is the
number of conjugacy classes of the symmetric group on <A>n</A> points.
<P/>
Ramanujan found the identities <M>p(5i+4) = 0</M> mod 5,
<M>p(7i+5) = 0</M>  mod 7 and <M>p(11i+6) = 0</M> mod 11
and many other fascinating things about the number of partitions.
</Description>
</ManSection>

<ManSection>
<Func Name="IteratorOfPartitions" Arg='n'/>

<Description>
For a positive integer <A>n</A>, <Ref Func="IteratorOfPartitions" /> 
returns an iterator
(see&nbsp;<Ref Sect="Iterators"/>) of the set of partitions 
of <A>n</A> (see&nbsp;<Ref Func="Partitions"/>).
The partitions of <A>n</A> are returned in lexicographic order.
</Description>
</ManSection>

<ManSection>
<Func Name="NrPartitions" Arg='n [,k]'/>

<Description>
returns the number of <C>Partitions(<A>set</A>,<A>k</A>)</C>.
<Example><![CDATA[
gap> Partitions( 7 );
[ [ 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1 ], [ 2, 2, 1, 1, 1 ], 
  [ 2, 2, 2, 1 ], [ 3, 1, 1, 1, 1 ], [ 3, 2, 1, 1 ], [ 3, 2, 2 ], 
  [ 3, 3, 1 ], [ 4, 1, 1, 1 ], [ 4, 2, 1 ], [ 4, 3 ], [ 5, 1, 1 ], 
  [ 5, 2 ], [ 6, 1 ], [ 7 ] ]
gap> Partitions( 8, 3 );
[ [ 3, 3, 2 ], [ 4, 2, 2 ], [ 4, 3, 1 ], [ 5, 2, 1 ], [ 6, 1, 1 ] ]
gap> NrPartitions( 7 );
15
gap> NrPartitions( 100 );
190569292
]]></Example>
<P/>
The function <Ref Func="OrderedPartitions"/> is the ordered
counterpart of <Ref Func="Partitions"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="OrderedPartitions" Arg='n [,k]'/>

<Description>
returns the set of all ordered partitions
<Index Subkey="ordered, of an integer">partitions</Index>
<Index Subkey="improper, of an integer">partitions</Index>
of the positive integer <A>n</A> into sums with <A>k</A> summands.
If <A>k</A> is not given it returns all ordered partitions of <A>set</A>
for all <A>k</A>.
<P/>
An <E>ordered partition</E> is an ordered sum
<M>n = p_1 + p_2 + \ldots + p_k</M> of positive integers and is
represented by the list <M>[ p_1, p_2, \ldots, p_k ]</M>.
There are totally <M>2^{{n-1}}</M> ordered partitions and
<M>{{n-1 \choose k-1}}</M> (see <Ref Func="Binomial"/>)
ordered partitions with <A>k</A> summands.
<P/>
Do not call <Ref Func="OrderedPartitions"/> with an <A>n</A> much larger
than <M>15</M>, the list will simply become too large.
</Description>
</ManSection>

<ManSection>
<Func Name="NrOrderedPartitions" Arg='n [,k]'/>

<Description>
returns the number of <C>OrderedPartitions(<A>set</A>,<A>k</A>)</C>.
<P/>
<Example><![CDATA[
gap> OrderedPartitions( 5 );
[ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 1, 3 ], 
  [ 1, 2, 1, 1 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 1, 4 ], [ 2, 1, 1, 1 ], 
  [ 2, 1, 2 ], [ 2, 2, 1 ], [ 2, 3 ], [ 3, 1, 1 ], [ 3, 2 ], 
  [ 4, 1 ], [ 5 ] ]
gap> OrderedPartitions( 6, 3 );
[ [ 1, 1, 4 ], [ 1, 2, 3 ], [ 1, 3, 2 ], [ 1, 4, 1 ], [ 2, 1, 3 ], 
  [ 2, 2, 2 ], [ 2, 3, 1 ], [ 3, 1, 2 ], [ 3, 2, 1 ], [ 4, 1, 1 ] ]
gap> NrOrderedPartitions(20);
524288
]]></Example>
<P/>
The function <Ref Func="Partitions"/> is the unordered counterpart
of <Ref Func="OrderedPartitions"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="PartitionsGreatestLE" Arg='n, m'/>

<Description>
returns the set of all (unordered) partitions of the integer <A>n</A>
having parts less or equal to the integer <A>m</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="PartitionsGreatestEQ" Arg='n, m'/>

<Description>
returns the set of all (unordered) partitions of the integer <A>n</A>
having greatest part equal to the integer <A>m</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="RestrictedPartitions" Arg='n, set [,k]'/>

<Description>
In the first form <Ref Func="RestrictedPartitions"/> returns the set of
all restricted partitions
<Index Subkey="restricted, of an integer">partitions</Index>
of the positive integer <A>n</A> into sums with <A>k</A> summands
with the summands of the partition coming from the set <A>set</A>.
If <A>k</A> is not given all restricted partitions for all <A>k</A> are
returned.
<P/>
A <E>restricted partition</E> is like an ordinary partition
(see <Ref Func="Partitions"/>) an unordered sum
<M>n = p_1 + p_2 + \ldots + p_k</M> of positive integers
and is represented by the list <M>p = [ p_1, p_2, \ldots, p_k ]</M>,
in nonincreasing order.
The difference is that here the <M>p_i</M> must be elements from the set
<A>set</A>,
while for ordinary partitions they may be elements from
<C>[ 1 .. n ]</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="NrRestrictedPartitions" Arg='n, set[, k]'/>

<Description>
returns the number of
<C>RestrictedPartitions(<A>n</A>,<A>set</A>,<A>k</A>)</C>.
<P/>
<Example><![CDATA[
gap> RestrictedPartitions( 8, [1,3,5,7] );
[ [ 1, 1, 1, 1, 1, 1, 1, 1 ], [ 3, 1, 1, 1, 1, 1 ], [ 3, 3, 1, 1 ], 
  [ 5, 1, 1, 1 ], [ 5, 3 ], [ 7, 1 ] ]
gap> NrRestrictedPartitions(50,[1,2,5,10,20,50]);
451
]]></Example>
<P/>
The last example tells us that there are 451 ways to return 50 pence
change using 1, 2, 5, 10, 20 and 50 pence coins.
</Description>
</ManSection>

<ManSection>
<Func Name="SignPartition" Arg='pi'/>

<Description>
returns the sign of a permutation with cycle structure <A>pi</A>.
<P/>
This function actually describes  a homomorphism from  the  symmetric
group <M>S_n</M> into  the  cyclic group of order  2,  whose  kernel  is
exactly the alternating  group <M>A_n</M>  (see <Ref Func="SignPerm"/>).  Partitions  of
sign  1  are called <E>even</E> partitions while partitions of sign <M>-1</M> are
called <E>odd</E>.
<Example><![CDATA[
gap> SignPartition([6,5,4,3,2,1]);
-1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AssociatedPartition" Arg='pi'/>

<Description>
<Ref Func="AssociatedPartition"/> returns the associated partition of the
partition <A>pi</A> which is obtained by transposing the corresponding
Young diagram.
<P/>
<Example><![CDATA[
gap> AssociatedPartition([4,2,1]);
[ 3, 2, 1, 1 ]
gap> AssociatedPartition([6]);
[ 1, 1, 1, 1, 1, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PowerPartition" Arg='pi, k'/>

<Description>
<Ref Func="PowerPartition"/> returns the partition corresponding to the
<A>k</A>-th power of a permutation with cycle structure <A>pi</A>.
<P/>
Each part <M>l</M> of <A>pi</A> is replaced by <M>d = \gcd(l, k)</M>
parts <M>l/d</M>.
So if <A>pi</A> is a partition of <M>n</M> then
<M><A>pi</A>^{<A>k</A>}</M> also is a partition of <M>n</M>.
<Ref Func="PowerPartition"/> describes the power map
<Index Subkey="power map">symmetric group</Index>
of symmetric groups.
<P/>
<Example><![CDATA[
gap> PowerPartition([6,5,4,3,2,1], 3);
[ 5, 4, 2, 2, 2, 2, 1, 1, 1, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PartitionTuples" Arg='n, r'/>

<Description>
<Ref Func="PartitionTuples"/> returns the list of all <A>r</A>-tuples of
partitions which together form a partition of <A>n</A>.
<P/>
<A>r</A>-tuples of partitions describe the classes and the characters
of wreath products of groups with <A>r</A> conjugacy classes with the
symmetric group <M>S_n</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="NrPartitionTuples" Arg='n, r'/>

<Description>
returns the number of <C>PartitionTuples( <A>n</A>, <A>r</A> )</C>.
<Example><![CDATA[
gap> PartitionTuples(3, 2);
[ [ [ 1, 1, 1 ], [  ] ], [ [ 1, 1 ], [ 1 ] ], [ [ 1 ], [ 1, 1 ] ], 
  [ [  ], [ 1, 1, 1 ] ], [ [ 2, 1 ], [  ] ], [ [ 1 ], [ 2 ] ], 
  [ [ 2 ], [ 1 ] ], [ [  ], [ 2, 1 ] ], [ [ 3 ], [  ] ], 
  [ [  ], [ 3 ] ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Fibonacci and Lucas Sequences">
<Heading>Fibonacci and Lucas Sequences</Heading>

<ManSection>
<Func Name="Fibonacci" Arg='n'/>

<Description>
returns the <A>n</A>th number of the <E>Fibonacci sequence</E>.
The Fibonacci sequence <M>F_n</M>
<Index Subkey="Fibonacci">sequence</Index>
is defined by the initial conditions <M>F_1 = F_2 = 1</M> and  the
recurrence relation <M>F_{{n+2}} = F_{{n+1}} + F_n</M>.
For negative <M>n</M> we define <M>F_n = (-1)^{{n+1}} F_{{-n}}</M>,
which is consistent with the recurrence relation.
<P/>
Using generating functions one can prove that
<M>F_n = \phi^n - 1/\phi^n</M>,
where <M>\phi</M> is <M>(\sqrt{{5}} + 1)/2</M>,
i.e., one root of <M>x^2 - x - 1 = 0</M>.
Fibonacci numbers have the property
<M>\gcd( F_m, F_n ) = F_{{\gcd(m,n)}}</M>.
But a pair of Fibonacci numbers requires more division
steps in Euclid's algorithm
(see&nbsp;<Ref Func="Gcd" Label="for (a ring and) several elements"/>)
than any other pair of integers of the same size.
<C>Fibonacci(<A>k</A>)</C> is the special case
<C>Lucas(1,-1,<A>k</A>)[1]</C> (see <Ref Func="Lucas"/>).
<P/>
<Example><![CDATA[
gap> Fibonacci( 10 );
55
gap> Fibonacci( 35 );
9227465
gap> Fibonacci( -10 );
-55
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Lucas" Arg='P, Q, k'/>

<Description>
returns the <A>k</A>-th values of the <E>Lucas sequence</E>
<Index Subkey="Lucas">sequence</Index>
with parameters <A>P</A>
and <A>Q</A>, which must be integers, as a list of three integers.
If <A>k</A> is a negative integer, then the values of the Lucas sequence
may be nonintegral rational numbers,
with denominator roughly <A>Q</A>^<A>k</A>.
<P/>
Let <M>\alpha, \beta</M> be the two roots of  <M>x^2 - P x + Q</M>
then we define
<C>Lucas( <A>P</A>, <A>Q</A>, <A>k</A> )[1]</C> <M>= U_k =
(\alpha^k - \beta^k) / (\alpha - \beta)</M>
and <C>Lucas( <A>P</A>, <A>Q</A>, <A>k</A> )[2]</C>
<M>= V_k = (\alpha^k + \beta^k)</M> and as a convenience
<C>Lucas( <A>P</A>, <A>Q</A>, <A>k</A> )[3]</C> <M>= Q^k</M>.
<P/>
The following recurrence relations are easily derived from the definition
<M>U_0 = 0, U_1 = 1, U_k = P U_{{k-1}} - Q U_{{k-2}}</M> and
<M>V_0 = 2, V_1 = P, V_k = P V_{{k-1}} - Q V_{{k-2}}</M>.
Those relations are actually used to define <Ref Func="Lucas"/> if
<M>\alpha = \beta</M>.
<P/>
Also the more complex relations used in <Ref Func="Lucas"/> can be easily
derived
<M>U_{2k} = U_k V_k</M>, <M>U_{{2k+1}} = (P U_{2k} + V_{2k}) / 2</M> and
<M>V_{2k} = V_k^2 - 2 Q^k</M>,
<M>V_{{2k+1}} = ((P^2-4Q) U_{2k} + P V_{2k}) / 2</M>.
<P/>
<C>Fibonacci(<A>k</A>)</C> (see <Ref Func="Fibonacci"/>) is simply
<C>Lucas(1,-1,<A>k</A>)[1]</C>.
In an abuse of notation, the sequence <C>Lucas(1,-1,<A>k</A>)[2]</C>
is sometimes called the Lucas sequence.
<P/>
<Example><![CDATA[
gap> List( [0..10], i -> Lucas(1,-2,i)[1] );     # 2^k - (-1)^k)/3
[ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341 ]
gap> List( [0..10], i -> Lucas(1,-2,i)[2] );     # 2^k + (-1)^k
[ 2, 1, 5, 7, 17, 31, 65, 127, 257, 511, 1025 ]
gap> List( [0..10], i -> Lucas(1,-1,i)[1] );     # Fibonacci sequence
[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
gap> List( [0..10], i -> Lucas(2,1,i)[1] );      # the roots are equal
[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Permanent of a Matrix">
<Heading>Permanent of a Matrix</Heading>

<ManSection>
<Func Name="Permanent" Arg='mat'/>

<Description>
returns the <E>permanent</E> of the matrix <A>mat</A>.
The permanent is defined by
<M>\sum_{{p \in Sym(n)}} \prod_{{i = 1}}^n mat[i][i^p]</M>.
<P/>
Note the similarity of the definition of the permanent to the
definition of the determinant (see&nbsp;<Ref Func="DeterminantMat"/>).
In fact the only difference is the missing sign of the permutation.
However the permanent is quite unlike the determinant,
for example it is not multilinear or alternating.
It has however important combinatorial properties.
<P/>
<Example><![CDATA[
gap> Permanent( [[0,1,1,1],
>      [1,0,1,1],
>      [1,1,0,1],
>      [1,1,1,0]] );  # inefficient way to compute NrDerangements([1..4])
9
gap> # 24 permutations fit the projective plane of order 2:
gap> Permanent( [[1,1,0,1,0,0,0],
>      [0,1,1,0,1,0,0],
>      [0,0,1,1,0,1,0],
>      [0,0,0,1,1,0,1],
>      [1,0,0,0,1,1,0],
>      [0,1,0,0,0,1,1],
>      [1,0,1,0,0,0,1]] );
24
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  rational.msk                GAP documentation            Martin Schönert -->
<!-- %% -->
<!-- %A  @(#)<M>Id: rational.msk,v 1.8 2003/09/05 07:54:50 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Rational Numbers">
<Heading>Rational Numbers</Heading>

The <E>rationals</E> form a very important field.  On the one hand it is the
quotient field of the integers (see chapter&nbsp;<Ref Chap="Integers"/>).
On the other hand it is the prime field of the fields of characteristic zero
(see chapter&nbsp;<Ref Chap="Abelian Number Fields"/>).
<P/>
The former comment suggests the representation actually used.
A rational is represented as a pair of integers,
called <E>numerator</E> and <E>denominator</E>.
Numerator and denominator are <E>reduced</E>, i.e.,
their greatest common divisor is 1.
If the denominator is 1,
the rational is in fact an integer and is represented as such.
The numerator holds the sign of the rational,
thus the denominator is always positive.
<P/>
Because the underlying integer arithmetic can compute with arbitrary size
integers, the  rational arithmetic is always exact, even for rationals
whose numerators and denominators have thousands of digits.
<P/>
<Example><![CDATA[
gap> 2/3;
2/3
gap> 66/123;  # numerator and denominator are made relatively prime
22/41
gap> 17/-13;  # the numerator carries the sign;
-17/13
gap> 121/11;  # rationals with denominator 1 (when canceled) are integers
11
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Rationals: Global Variables">
<Heading>Rationals: Global Variables</Heading>

<ManSection>
<Var Name="Rationals"/>
<Prop Name="IsRationals" Arg='obj'/>

<Description>
<Ref Var="Rationals"/> is the field <M>&QQ;</M> of rational integers,
as a set of cyclotomic numbers,
see Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/> for basic operations,
Functions for the field <Ref Var="Rationals"/> can be found in the
chapters&nbsp;<Ref Chap="Fields and Division Rings"/>
and&nbsp;<Ref Chap="Abelian Number Fields"/>.
<P/>
<Ref Prop="IsRationals"/> returns <K>true</K> for a prime field that
consists of cyclotomic numbers
&ndash;for example the &GAP; object <Ref Var="Rationals"/>&ndash;
and <K>false</K> for all other &GAP; objects.
<P/>
<Example><![CDATA[
gap> Size( Rationals ); 2/3 in Rationals;
infinity
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elementary Operations for Rationals">
<Heading>Elementary Operations for Rationals</Heading>

<ManSection>
<Filt Name="IsRat" Arg='obj' Type='Category'/>

<Description>
<Index Subkey="for a rational">test</Index>
Every rational number lies in the category <Ref Func="IsRat"/>,
which is a subcategory of <Ref Func="IsCyc"/>.
<P/>
<Example><![CDATA[
gap> IsRat( 2/3 );
true
gap> IsRat( 17/-13 );
true
gap> IsRat( 11 );
true
gap> IsRat( IsRat );  # `IsRat' is a function, not a rational
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPosRat" Arg='obj' Type='Category'/>

<Description>
Every positive rational number lies in the category
<Ref Func="IsPosRat"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNegRat" Arg='obj' Type='Category'/>

<Description>
Every negative rational number lies in the category
<Ref Func="IsNegRat"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="NumeratorRat" Arg='rat'/>

<Description>
<Index Subkey="of a rational">numerator</Index>
<Ref Func="NumeratorRat"/> returns the numerator of the rational
<A>rat</A>.
Because the numerator holds the sign of the rational it may be any
integer.
Integers are rationals with denominator <M>1</M>,
thus <Ref Func="NumeratorRat"/> is the identity function for integers.
<P/>
<Example><![CDATA[
gap> NumeratorRat( 2/3 );
2
gap> # numerator and denominator are made relatively prime:
gap> NumeratorRat( 66/123 );
22
gap> NumeratorRat( 17/-13 );  # numerator holds the sign of the rational
-17
gap> NumeratorRat( 11 );      # integers are rationals with denominator 1
11
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DenominatorRat" Arg='rat'/>

<Description>
<Index Subkey="of a rational">denominator</Index>
<Ref Func="DenominatorRat"/> returns the denominator of the rational
<A>rat</A>.
Because the numerator holds the  sign of the rational the denominator is
always a positive integer.
Integers are rationals with the denominator 1,
thus <Ref Func="DenominatorRat"/> returns 1 for integers.
<P/>
<Example><![CDATA[
gap> DenominatorRat( 2/3 );
3
gap> # numerator and denominator are made relatively prime:
gap> DenominatorRat( 66/123 );
41
gap> # the denominator holds the sign of the rational:
gap> DenominatorRat( 17/-13 );
13
gap> DenominatorRat( 11 ); # integers are rationals with denominator 1
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Rat" Arg='elm'/>

<Description>
<Ref Attr="Rat"/> returns a rational number <A>rat</A> whose meaning
depends on the type of <A>elm</A>.
<P/>
If <A>elm</A> is a string consisting of digits <C>'0'</C>, <C>'1'</C>,
<M>\ldots</M>, <C>'9'</C> and <C>'-'</C> (at the first position),
<C>'/'</C> and the decimal dot <C>'.'</C> then <A>rat</A> is the rational
described by this string.
The operation <Ref Func="String"/> can be used to compute a string for
rational numbers, in fact for all cyclotomics.
<P/>
<Example><![CDATA[
gap> Rat( "1/2" );  Rat( "35/14" );  Rat( "35/-27" );  Rat( "3.14159" );
1/2
5/2
-35/27
314159/100000
]]></Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="Random" Arg='Rationals' Label="for rationals"/>

<Description>
<Ref Oper="Random" Label="for rationals"/> for rationals returns
pseudo random rationals which are the quotient of two random integers.
See the description of <Ref Func="Random" Label="for integers"/> for details.
(Also see&nbsp;<Ref Func="Random" Label="for a list or collection"/>.)
</Description>
</ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  cyclotom.msk                GAP documentation               Thomas Breuer -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: cyclotom.msk,v 1.30 2003/10/30 15:23:58 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<!-- %%  This file is being maintained by Thomas Breuer. -->
<!-- %%  Please do not make any changes without consulting him. -->
<!-- %%  (This holds also for minor changes such as the removal of whitespace or -->
<!-- %%  the correction of typos.) -->
<!-- %% -->
<Chapter Label="Cyclotomic Numbers">
<Heading>Cyclotomic Numbers</Heading>

<Index Subkey="cyclotomic">type</Index>
<Index>irrationalities</Index>
<Index>cyclotomic field elements</Index>

&GAP; admits computations in abelian extension fields of the rational
number field <M>&QQ;</M>,
that is fields with abelian Galois group over <M>&QQ;</M>.
These fields are subfields of <E>cyclotomic fields</E> <M>&QQ;(e_n)</M>
where <M>e_n = \exp(2 \pi i/n)</M> is a primitive complex <M>n</M>-th root of
unity.
The elements of these fields are called <E>cyclotomics</E>.
<P/>
Information concerning operations for domains of cyclotomics,
for example certain integral bases of fields of cyclotomics,
can be found in Chapter&nbsp;<Ref Chap="Abelian Number Fields"/>.
For more general operations that take a field extension as a
&ndash;possibly optional&ndash; argument,
e.g., <Ref Func="Trace" Label="for a field element"/> or
<Ref Func="Coefficients"/>,
see Chapter&nbsp;<Ref Chap="Fields and Division Rings"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Cyclotomics">
<Heading>Operations for Cyclotomics</Heading>

<ManSection>
<Func Name="E" Arg='n'/>

<Description>
<Index>roots of unity</Index>
<Ref Func="E"/> returns the primitive <A>n</A>-th root of unity
<M>e_n = \exp(2\pi i/n)</M>.
Cyclotomics are usually entered as sums of roots of unity,
with rational coefficients,
and irrational cyclotomics are displayed in such a way.
(For special cyclotomics, see&nbsp;<Ref Sect="ATLAS Irrationalities"/>.)
<P/>
<Example><![CDATA[
gap> E(9); E(9)^3; E(6); E(12) / 3;
-E(9)^4-E(9)^7
E(3)
-E(3)^2
-1/3*E(12)^7
]]></Example>
<P/>
A particular basis is used to express cyclotomics,
see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>;
note that <C>E(9)</C> is <E>not</E> a basis element,
as the above example shows.
</Description>
</ManSection>

<ManSection>
<Var Name="Cyclotomics"/>

<Description>
is the domain of all cyclotomics.
<P/>
<Example><![CDATA[
gap> E(9) in Cyclotomics; 37 in Cyclotomics; true in Cyclotomics;
true
true
false
]]></Example>
<P/>
As the cyclotomics are field elements, the usual arithmetic operators
<C>+</C>, <C>-</C>, <C>*</C> and <C>/</C> (and <C>^</C> to take powers by
integers) are applicable.
Note that <C>^</C> does <E>not</E> denote the conjugation of group
elements, so it is <E>not</E> possible to explicitly construct groups of
cyclotomics.
(However, it is possible to compute the inverse and the multiplicative
order of a nonzero cyclotomic.)
Also, taking the <M>k</M>-th power of a root of unity <M>z</M> defines a
Galois automorphism if and only if <M>k</M> is coprime to the conductor
(see <Ref Func="Conductor" Label="for a cyclotomic"/>) of <M>z</M>.
<P/>
<Example><![CDATA[
gap> E(5) + E(3); (E(5) + E(5)^4) ^ 2; E(5) / E(3); E(5) * E(3);
-E(15)^2-2*E(15)^8-E(15)^11-E(15)^13-E(15)^14
-2*E(5)-E(5)^2-E(5)^3-2*E(5)^4
E(15)^13
E(15)^8
gap> Order( E(5) ); Order( 1+E(5) );
5
infinity
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsCyclotomic" Arg='obj' Type='Category'/>
<Filt Name="IsCyc" Arg='obj' Type='Category'/>

<Description>
<Index Key="CyclotomicsFamily"><C>CyclotomicsFamily</C></Index>
Every object in the family <C>CyclotomicsFamily</C> lies in the category
<Ref Func="IsCyclotomic"/>.
This covers integers, rationals, proper cyclotomics, the object
<Ref Var="infinity"/>,
and unknowns (see Chapter&nbsp;<Ref Chap="Unknowns"/>).
All these objects except <Ref Var="infinity"/> and unknowns
lie also in the category <Ref Func="IsCyc"/>,
<Ref Var="infinity"/> lies in (and can be detected from) the category
<Ref Func="IsInfinity"/>,
and unknowns lie in <Ref Func="IsUnknown"/>.
<P/>
<Example><![CDATA[
gap> IsCyclotomic(0); IsCyclotomic(1/2*E(3)); IsCyclotomic( infinity );
true
true
true
gap> IsCyc(0); IsCyc(1/2*E(3)); IsCyc( infinity );
true
true
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsIntegralCyclotomic" Arg='obj'/>

<Description>
A cyclotomic is called <E>integral</E> or a <E>cyclotomic integer</E>
if all coefficients of its minimal polynomial over the rationals are
integers.
Since the underlying basis of the external representation of cyclotomics
is an integral basis
(see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>),
the subring of cyclotomic integers in a cyclotomic field is formed
by those cyclotomics for which the external representation is a list of
integers.
For example, square roots of integers are cyclotomic integers
(see&nbsp;<Ref Sect="ATLAS Irrationalities"/>),
any root of unity is a cyclotomic integer,
character values are always cyclotomic integers,
but all rationals which are not integers are not cyclotomic integers.
<P/>
<Example><![CDATA[
gap> r:= ER( 5 );               # The square root of 5 ...
E(5)-E(5)^2-E(5)^3+E(5)^4
gap> IsIntegralCyclotomic( r ); # ... is a cyclotomic integer.
true
gap> r2:= 1/2 * r;              # This is not a cyclotomic integer, ...
1/2*E(5)-1/2*E(5)^2-1/2*E(5)^3+1/2*E(5)^4
gap> IsIntegralCyclotomic( r2 );
false
gap> r3:= 1/2 * r - 1/2;        # ... but this is one.
E(5)+E(5)^4
gap> IsIntegralCyclotomic( r3 );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Int" Arg='cyc' Label="for a cyclotomic"/>

<Description>
The operation <Ref Func="Int" Label="for a cyclotomic"/>
can be used to find a cyclotomic integer near to an arbitrary cyclotomic,
by applying <Ref Attr="Int"/> to the coefficients.
<P/>
<Example><![CDATA[
gap> Int( E(5)+1/2*E(5)^2 ); Int( 2/3*E(7)-3/2*E(4) );
E(5)
-E(4)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="String" Arg='cyc' Label="for a cyclotomic"/>

<Description>
The operation <Ref Func="String" Label="for a cyclotomic"/>
returns for a cyclotomic <A>cyc</A> a string corresponding to the way
the cyclotomic is printed by <Ref Func="ViewObj"/> and
<Ref Func="PrintObj"/>.
<P/>
<Example><![CDATA[
gap> String( E(5)+1/2*E(5)^2 ); String( 17/3 );
"E(5)+1/2*E(5)^2"
"17/3"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Conductor" Arg='cyc' Label="for a cyclotomic"/>
<Attr Name="Conductor" Arg='C' Label="for a collection of cyclotomics"/>

<Description>
For an element <A>cyc</A> of a cyclotomic field,
<Ref Attr="Conductor" Label="for a cyclotomic"/>
returns the smallest integer <M>n</M> such that <A>cyc</A> is contained
in the <M>n</M>-th cyclotomic field.
For a collection <A>C</A> of cyclotomics (for example a dense list of
cyclotomics or a field of cyclotomics),
<Ref Attr="Conductor" Label="for a collection of cyclotomics"/> returns
the smallest integer <M>n</M> such that all elements of <A>C</A>
are contained in the <M>n</M>-th cyclotomic field.
<P/>
<Example><![CDATA[
gap> Conductor( 0 ); Conductor( E(10) ); Conductor( E(12) );
1
5
12
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AbsoluteValue" Arg='cyc'/>

<Description>
returns the absolute value of a cyclotomic number <A>cyc</A>.
At the moment only methods for rational numbers exist.
<Example><![CDATA[
gap> AbsoluteValue(-3);
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RoundCyc" Arg='cyc'/>

<Description>
is a cyclotomic integer <M>z</M> (see <Ref Func="IsIntegralCyclotomic"/>)
near to the cyclotomic <A>cyc</A> in the following sense:
Let <C>c</C> be the <M>i</M>-th coefficient in the external
representation (see&nbsp;<Ref Func="CoeffsCyc"/>) of <A>cyc</A>.
Then the <M>i</M>-th coefficient in the external representation of
<M>z</M> is <C>Int( c + 1/2 )</C> or <C>Int( c - 1/2 )</C>,
depending on whether <C>c</C> is nonnegative or negative, respectively.
<P/>
Expressed in terms of the Zumbroich basis
(see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>),
rounding the coefficients of <A>cyc</A> w.r.t.&nbsp;this basis to the
nearest integer yields the coefficients of <M>z</M>.
<P/>
<Example><![CDATA[
gap> RoundCyc( E(5)+1/2*E(5)^2 ); RoundCyc( 2/3*E(7)+3/2*E(4) );
E(5)+E(5)^2
-2*E(28)^3+E(28)^4-2*E(28)^11-2*E(28)^15-2*E(28)^19-2*E(28)^23
 -2*E(28)^27
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CoeffsCyc" Arg='cyc, N'/>

<Description>
<Index Subkey="for cyclotomics">coefficients</Index>
Let <A>cyc</A> be a cyclotomic with conductor <M>n</M>
(see <Ref Func="Conductor" Label="for a cyclotomic"/>).
If <A>N</A> is not a multiple of <M>n</M> then <Ref Func="CoeffsCyc"/>
returns <K>fail</K> because <A>cyc</A> cannot be expressed in terms of
<A>N</A>-th roots of unity.
Otherwise <Ref Func="CoeffsCyc"/> returns a list of length <A>N</A> with
entry at position <M>j</M> equal to the coefficient of
<M>\exp(2 \pi i (j-1)/<A>N</A>)</M> if this root
belongs to the <A>N</A>-th Zumbroich basis
(see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>),
and equal to zero otherwise.
So we have
<A>cyc</A> = <C>CoeffsCyc(</C> <A>cyc</A>, <A>N</A> <C>) *
List( [1..</C><A>N</A><C>], j -> E(</C><A>N</A><C>)^(j-1) )</C>.
<P/>
<Example><![CDATA[
gap> cyc:= E(5)+E(5)^2;
E(5)+E(5)^2
gap> CoeffsCyc( cyc, 5 );  CoeffsCyc( cyc, 15 );  CoeffsCyc( cyc, 7 );
[ 0, 1, 1, 0, 0 ]
[ 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, -1, 0 ]
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DenominatorCyc" Arg='cyc'/>

<Description>
For a cyclotomic number <A>cyc</A> (see&nbsp;<Ref Func="IsCyclotomic"/>),
this function returns the smallest positive integer <M>n</M> such that
<M>n</M><C> * </C><A>cyc</A> is a cyclotomic integer
(see&nbsp;<Ref Func="IsIntegralCyclotomic"/>).
For rational numbers <A>cyc</A>, the result is the same as that of
<Ref Func="DenominatorRat"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="ExtRepOfObj" Arg='cyc' Label="for a cyclotomic"/>

<Description>
The external representation of a cyclotomic <A>cyc</A> with conductor
<M>n</M> (see <Ref Func="Conductor" Label="for a cyclotomic"/> is
the list returned by <Ref Func="CoeffsCyc"/>,
called with <A>cyc</A> and <M>n</M>.
<P/>
<Example><![CDATA[
gap> ExtRepOfObj( E(5) ); CoeffsCyc( E(5), 5 );
[ 0, 1, 0, 0, 0 ]
[ 0, 1, 0, 0, 0 ]
gap> CoeffsCyc( E(5), 15 );
[ 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DescriptionOfRootOfUnity" Arg='root'/>

<Description>
<Index Subkey="of a root of unity">logarithm</Index>
<P/>
Given a cyclotomic <A>root</A> that is known to be a root of unity
(this is <E>not</E> checked),
<Ref Func="DescriptionOfRootOfUnity"/> returns a list <M>[ n, e ]</M>
of coprime positive integers such that
<A>root</A> <M>=</M> <C>E</C><M>(n)^e</M> holds.
<P/>
<Example><![CDATA[
gap> E(9);  DescriptionOfRootOfUnity( E(9) );
-E(9)^4-E(9)^7
[ 9, 1 ]
gap> DescriptionOfRootOfUnity( -E(3) );
[ 6, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsGaussInt" Arg='x'/>

<Description>
<Ref Func="IsGaussInt"/> returns <K>true</K> if the object <A>x</A> is
a Gaussian integer (see&nbsp;<Ref Func="GaussianIntegers"/>),
and <K>false</K> otherwise.
Gaussian integers are of the form <M>a + b</M><C>*E(4)</C>,
where <M>a</M> and <M>b</M> are integers.
</Description>
</ManSection>

<ManSection>
<Func Name="IsGaussRat" Arg='x'/>

<Description>
<Ref Func="IsGaussRat"/> returns <K>true</K> if the object <A>x</A> is
a Gaussian rational (see&nbsp;<Ref Func="GaussianRationals"/>),
and <K>false</K> otherwise.
Gaussian rationals are of the form <M>a + b</M><C>*E(4)</C>,
where <M>a</M> and <M>b</M> are rationals.
</Description>
</ManSection>

<ManSection>
<Func Name="DefaultField" Arg="list" Label="for cyclotomics"/>

<Description>
<Ref Func="DefaultField" Label="for cyclotomics"/> for cyclotomics
is defined to return the smallest <E>cyclotomic</E> field containing
the given elements.
<P/>
Note that <Ref Func="Field" Label="for several generators"/> returns
the smallest field containing all given elements,
which need not be a cyclotomic field.
In both cases, the fields represent vector spaces over the rationals
(see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>).
<P/>
<Example><![CDATA[
gap> Field( E(5)+E(5)^4 );  DefaultField( E(5)+E(5)^4 );
NF(5,[ 1, 4 ])
CF(5)
]]></Example>
</Description>
</ManSection>
<!-- what about <C>DefaultRing</C>?? (integral rings are missing!)-->


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Infinity">
<Heading>Infinity and negative Infinity</Heading>

<ManSection>
<Filt Name="IsInfinity" Arg='obj' Type='Category'/>
<Filt Name="IsNegInfinity" Arg='obj' Type='Category'/>
<Var Name="infinity"/>
<Var Name="-infinity"/>

<Description>
<Ref Var="infinity"/> and <Ref Var="-infinity"/> are special &GAP; objects
that lie in <C>CyclotomicsFamily</C>.
They are larger or smaller than all other objects in this family
respectively.
<Ref Var="infinity"/> is mainly used as return value of operations such
as <Ref Func="Size"/>
and <Ref Func="Dimension"/> for infinite and infinite dimensional domains,
respectively.
<P/>
Some arithmetic operations are provided for convenience when using
<Ref Var="infinity"/> and <Ref Var="-infinity"/> as top and bottom element
respectively.
<Example><![CDATA[
gap> -infinity + 1;
-infinity
gap> infinity + infinity;
infinity
]]></Example>
Often it is useful to distinguish <Ref Var="infinity"/>
from <Q>proper</Q> cyclotomics.
For that, <Ref Var="infinity"/> lies in the category
<Ref Func="IsInfinity"/> but not in <Ref Func="IsCyc"/>,
and the other cyclotomics lie in the category <Ref Func="IsCyc"/> but not
in <Ref Func="IsInfinity"/>.
<P/>
<Example><![CDATA[
gap> s:= Size( Rationals );
infinity
gap> s = infinity; IsCyclotomic( s ); IsCyc( s ); IsInfinity( s );
true
true
false
true
gap> s in Rationals; s > 17;
false
true
gap> Set( [ s, 2, s, E(17), s, 19 ] );
[ 2, 19, E(17), infinity ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons of Cyclotomics">
<Heading>Comparisons of Cyclotomics</Heading>

<Index Subkey="for cyclotomics">operators</Index>
To compare cyclotomics, the operators <C>&lt;</C>, <C>&lt;=</C>, <C>=</C>,
<C>>=</C>, <C>></C>, and <C>&lt;></C> can  be used,
the result will be <K>true</K> if the first operand is
smaller, smaller or equal, equal, larger or equal, larger, or unequal,
respectively, and <K>false</K> otherwise.
<P/>
Cyclotomics are ordered as follows:
The relation between rationals is the natural one,
rationals are smaller than irrational cyclotomics,
and <Ref Var="infinity"/> is the largest cyclotomic.
For two irrational cyclotomics with different conductors
(see <Ref Func="Conductor" Label="for a cyclotomic"/>),
the one with smaller conductor is regarded as smaller.
Two irrational cyclotomics with same conductor are compared via their
external representation
(see <Ref Func="ExtRepOfObj" Label="for a cyclotomic"/>).
<P/>
For comparisons of cyclotomics and other &GAP; objects,
see Section&nbsp;<Ref Sect="Comparisons"/>.
<P/>
<Example><![CDATA[
gap> E(5) < E(6);      # the latter value has conductor 3
false
gap> E(3) < E(3)^2;    # both have conductor 3, compare the ext. repr.
false
gap> 3 < E(3); E(5) < E(7);
true
true
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="ATLAS Irrationalities">
<Heading>ATLAS Irrationalities</Heading>

<Index>atomic irrationalities</Index>
<ManSection>
<Heading>EB, EC, <M>\ldots</M>, EH</Heading>
<Func Name="EB" Arg='N'/>
<Func Name="EC" Arg='N'/>
<Func Name="ED" Arg='N'/>
<Func Name="EE" Arg='N'/>
<Func Name="EF" Arg='N'/>
<Func Name="EG" Arg='N'/>
<Func Name="EH" Arg='N'/>

<Description>
<Index Key="b_N"><M>b_N</M> (irrational value)</Index>
<Index Key="c_N"><M>c_N</M> (irrational value)</Index>
<Index Key="d_N"><M>d_N</M> (irrational value)</Index>
<Index Key="e_N"><M>e_N</M> (irrational value)</Index>
<Index Key="f_N"><M>f_N</M> (irrational value)</Index>
<Index Key="g_N"><M>g_N</M> (irrational value)</Index>
<Index Key="h_N"><M>h_N</M> (irrational value)</Index>
For a positive integer <A>N</A>,
let <M>z =</M> <C>E(</C><A>N</A><C>)</C> <M>= \exp(2 \pi i/<A>N</A>)</M>.
The following so-called <E>atomic irrationalities</E>
(see <Cite Key="CCN85" Where="Chapter 7, Section 10"/>)
can be entered using functions.
(Note that the values are not necessary irrational.)
<P/>
<Table Align="lclclcl">
<Row>
  <Item><C>EB(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>b_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^2}} \right) / 2</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{2}</M></Item>
</Row>
<Row>
  <Item><C>EC(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>c_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^3}} \right) / 3</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{3}</M></Item>
</Row>
<Row>
  <Item><C>ED(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>d_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^4}} \right) / 4</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{4}</M></Item>
</Row>
<Row>
  <Item><C>EE(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>e_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^5}} \right) / 5</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{5}</M></Item>
</Row>
<Row>
  <Item><C>EF(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>f_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^6}} \right) / 6</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{6}</M></Item>
</Row>
<Row>
  <Item><C>EG(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>g_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^7}} \right) / 7</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{7}</M></Item>
</Row>
<Row>
  <Item><C>EH(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>h_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>\left( \sum_{{j = 1}}^{{<A>N</A>-1}} z^{{j^8}} \right) / 8</M>
  </Item>
  <Item>,</Item>
  <Item><M><A>N</A> \equiv 1 \pmod{8}</M></Item>
</Row>
</Table>
(Note that in <C>EC(</C><A>N</A><C>)</C>, <M>\ldots</M>,
<C>EH(</C><A>N</A><C>)</C>, <A>N</A> must be a prime.)
<P/>
<Example><![CDATA[
gap> EB(5);  EB(9);
E(5)+E(5)^4
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>EI and ER</Heading>
<Func Name="EI" Arg='N'/>
<Func Name="ER" Arg='N'/>

<Description>
<Index Key="i_N"><M>i_N</M> (irrational value)</Index>
<Index Key="r_N"><M>r_N</M> (irrational value)</Index>
For a rational number <A>N</A>,
<Ref Func="ER"/> returns the square root <M>\sqrt{{<A>N</A>}}</M> of
<A>N</A>,
and <Ref Func="EI"/> returns <M>\sqrt{{-<A>N</A>}}</M>.
By the chosen embedding of cyclotomic fields into the complex numbers,
<Ref Func="ER"/> returns the positive square root if <A>N</A> is
positive, and if <A>N</A> is negative then
<C>ER(</C><A>N</A><C>) = EI(-</C><A>N</A><C>)</C> holds.
In any case, <C>EI(</C><A>N</A><C>) = E(4) * ER(</C><A>N</A><C>)</C>.
<P/>
<Ref Func="ER"/> is installed as method for the operation
<Ref Func="Sqrt"/>, for rational argument.
<P/>
From a theorem of Gauss we know that
<M>b_{<A>N</A>} =</M>
<Table Align="lcl">
<Row>
  <Item><M>(-1 + \sqrt{{<A>N</A>}}) / 2</M></Item>
  <Item>if</Item>
  <Item><M><A>N</A> \equiv 1 \pmod 4</M></Item>
</Row>
<Row>
  <Item><M>(-1 + i \sqrt{{<A>N</A>}}) / 2</M></Item>
  <Item>if</Item>
  <Item><M><A>N</A> \equiv -1 \pmod 4</M></Item>
</Row>
</Table>
So <M>\sqrt{{<A>N</A>}}</M> can be computed from <M>b_{<A>N</A>}</M>,
see&nbsp;<Ref Func="EB"/>.
<P/>
<Example><![CDATA[
gap> ER(3); EI(3);
-E(12)^7+E(12)^11
E(3)-E(3)^2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>EY, EX, <M>\ldots</M>, ES</Heading>
<Func Name="EY" Arg='N[, d]'/>
<Func Name="EX" Arg='N[, d]'/>
<Func Name="EW" Arg='N[, d]'/>
<Func Name="EV" Arg='N[, d]'/>
<Func Name="EU" Arg='N[, d]'/>
<Func Name="ET" Arg='N[, d]'/>
<Func Name="ES" Arg='N[, d]'/>

<Description>
<Index Key="s_N"><M>s_N</M> (irrational value)</Index>
<Index Key="t_N"><M>t_N</M> (irrational value)</Index>
<Index Key="u_N"><M>u_N</M> (irrational value)</Index>
<Index Key="v_N"><M>v_N</M> (irrational value)</Index>
<Index Key="w_N"><M>w_N</M> (irrational value)</Index>
<Index Key="x_N"><M>x_N</M> (irrational value)</Index>
<Index Key="y_N"><M>y_N</M> (irrational value)</Index>
For the given integer <A>N</A> <M>> 2</M>,
let <M><A>N</A>_k</M> denote the first integer
with multiplicative order exactly <M>k</M> modulo <A>N</A>,
chosen in the order of preference
<Display Mode="M">
1, -1, 2, -2, 3, -3, 4, -4, \ldots .
</Display>
<P/>
We define (with <M>z = \exp(2 \pi i/<A>N</A>)</M>)
<Table Align="lclcll">
<Row>
  <Item><C>EY(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>y_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n</M></Item>
  <Item><M>(n = <A>N</A>_2)</M></Item>
</Row>
<Row>
  <Item><C>EX(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>x_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n + z^{{n^2}}</M></Item>
  <Item><M>(n = <A>N</A>_3)</M></Item>
</Row>
<Row>
  <Item><C>EW</C>(<A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>w_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n + z^{{n^2}} + z^{{n^3}}</M></Item>
  <Item><M>(n = <A>N</A>_4)</M></Item>
</Row>
<Row>
  <Item><C>EV(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>v_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n + z^{{n^2}} + z^{{n^3}} + z^{{n^4}}</M></Item>
  <Item><M>(n = <A>N</A>_5)</M></Item>
</Row>
<Row>
  <Item><C>EU(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>u_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n + z^{{n^2}} + \ldots + z^{{n^5}}</M></Item>
  <Item><M>(n = <A>N</A>_6)</M></Item>
</Row>
<Row>
  <Item><C>ET(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>t_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n + z^{{n^2}} + \ldots + z^{{n^6}}</M></Item>
  <Item><M>(n = <A>N</A>_7)</M></Item>
</Row>
<Row>
  <Item><C>ES(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>s_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z + z^n + z^{{n^2}} + \ldots + z^{{n^7}}</M></Item>
  <Item><M>(n = <A>N</A>_8)</M></Item>
</Row>
</Table>
<P/>
For the two-argument versions of the functions,
see Section <Ref Func="NK"/>.
<P/>
<Example><![CDATA[
gap> EY(5);
E(5)+E(5)^4
gap> EW(16,3); EW(17,2);
0
E(17)+E(17)^4+E(17)^13+E(17)^16
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>EM, EL, <M>\ldots</M>, EJ</Heading>
<Func Name="EM" Arg='N[, d]'/>
<Func Name="EL" Arg='N[, d]'/>
<Func Name="EK" Arg='N[, d]'/>
<Func Name="EJ" Arg='N[, d]'/>

<Description>
Let <A>N</A> be an integer, <A>N</A> <M>> 2</M>.
We define (with <M>z = \exp(2 \pi i/<A>N</A>)</M>)
<Index Key="j_N"><M>j_N</M> (irrational value)</Index>
<Index Key="k_N"><M>k_N</M> (irrational value)</Index>
<Index Key="l_N"><M>l_N</M> (irrational value)</Index>
<Index Key="m_N"><M>m_N</M> (irrational value)</Index>
<Table Align="lclcll">
<Row>
  <Item><C>EM(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>m_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z - z^n</M></Item>
  <Item><M>(n = <A>N</A>_2)</M></Item>
</Row>
<Row>
  <Item><C>EL(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>l_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z - z^n + z^{{n^2}} - z^{{n^3}}</M></Item>
  <Item><M>(n = <A>N</A>_4)</M></Item>
</Row>
<Row>
  <Item><C>EK(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>k_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z - z^n + \ldots - z^{{n^5}}</M></Item>
  <Item><M>(n = <A>N</A>_6)</M></Item>
</Row>
<Row>
  <Item><C>EJ(</C><A>N</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>j_{<A>N</A>}</M></Item>
  <Item>=</Item>
  <Item><M>z - z^n + \ldots - z^{{n^7}}</M></Item>
  <Item><M>(n = <A>N</A>_8)</M></Item>
</Row>
</Table>
<P/>
For the two-argument versions of the functions,
see Section <Ref Func="NK"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="NK" Arg='N, k, d'/>

<Description>
Let <M><A>N</A>_{<A>k</A>}^{(<A>d</A>)}</M> be the <M>(<A>d</A>+1)</M>-th
integer with multiplicative order exactly <A>k</A> modulo <A>N</A>,
chosen in the order of preference defined in Section <Ref Subsect="EY"/>;
<Ref Func="NK"/> returns <M><A>N</A>_{<A>k</A>}^{(<A>d</A>)}</M>;
if there is no integer with the required multiplicative order,
<Ref Func="NK"/> returns <K>fail</K>.
<P/>
We write <M><A>N</A>_{<A>k</A>} = <A>N</A>_{<A>k</A>}^{(0)},
<A>N</A>_{<A>k</A>}^{\prime} = <A>N</A>_{<A>k</A>}^{(1)},
<A>N</A>_{<A>k</A>}^{\prime\prime} = <A>N</A>_{<A>k</A>}^{(2)}</M>
and so on.
<P/>
The algebraic numbers
<Display Mode="M">
y_{<A>N</A>}^{\prime} = y_{<A>N</A>}^{(1)},
y_{<A>N</A>}^{\prime\prime} = y_{<A>N</A>}^{(2)}, \ldots,
x_{<A>N</A>}^{\prime}, x_{<A>N</A>}^{\prime\prime}, \ldots,
j_{<A>N</A>}^{\prime}, j_{<A>N</A>}^{\prime\prime}, \ldots
</Display>
are obtained on replacing <M><A>N</A>_{<A>k</A>}</M> in the
definitions in the sections <Ref Subsect="EY"/> and <Ref Subsect="EM"/>
by <M><A>N</A>_{<A>k</A>}^{\prime},
<A>N</A>_{<A>k</A>}^{\prime\prime}, \ldots</M>;
they can be entered as
<P/>
<Table Align="lcl">
<Row>
  <Item><C>EY(</C><A>N</A>,<A>d</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>y_{<A>N</A>}^{(<A>d</A>)}</M></Item>
</Row>
<Row>
  <Item><C>EX(</C><A>N</A>,<A>d</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>x_{<A>N</A>}^{(<A>d</A>)}</M></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>\ldots</M></Item>
  <Item></Item>
</Row>
<Row>
  <Item><C>EJ(</C><A>N</A>,<A>d</A><C>)</C></Item>
  <Item>=</Item>
  <Item><M>j_{<A>N</A>}^{(<A>d</A>)}</M></Item>
</Row>
</Table>
</Description>
</ManSection>

<ManSection>
<Func Name="AtlasIrrationality" Arg='irratname'/>

<Description>
Let <A>irratname</A> be a string that describes an irrational value as
a linear combination in terms of the atomic irrationalities introduced in
the sections <Ref Subsect="EB"/>, <Ref Subsect="EI"/>,
<Ref Subsect="EY"/>, <Ref Subsect="EM"/>.
These irrational values are defined in
<Cite Key="CCN85" Where="Chapter 6, Section 10"/>, and the following
description is mainly copied from there.
If <M>q_N</M> is such a value (e.g. <M>y_{24}^{\prime\prime}</M>)
then linear combinations of algebraic conjugates of <M>q_N</M> are
abbreviated as in the following examples:
<P/>
<Table Align="lcl">
<Row>
  <Item><C>2qN+3&amp;5-4&amp;7+&amp;9</C></Item>
  <Item>means</Item>
  <Item><M>2 q_N + 3 q_N^{{*5}} - 4 q_N^{{*7}} + q_N^{{*9}}</M>
  </Item>
</Row>
<Row>
  <Item><C>4qN&amp;3&amp;5&amp;7-3&amp;4</C></Item>
  <Item>means</Item>
  <Item><M>4 (q_N + q_N^{{*3}} + q_N^{{*5}} + q_N^{{*7}})
  - 3 q_N^{{*11}}</M></Item>
</Row>
<Row>
  <Item><C>4qN*3&amp;5+&amp;7</C></Item>
  <Item>means</Item>
  <Item><M>4 (q_N^{{*3}} + q_N^{{*5}}) + q_N^{{*7}}</M></Item>
</Row>
</Table>
<P/>
To explain the <Q>ampersand</Q> syntax in general we remark that
<Q>&amp;k</Q> is interpreted as <M>q_N^{{*k}}</M>,
where <M>q_N</M> is the most recently named atomic irrationality,
and that the scope of any premultiplying coefficient is broken by a
<M>+</M> or <M>-</M> sign, but not by <M>\&amp;</M> or <M>*k</M>.
The algebraic conjugations indicated by the ampersands apply directly to
the <E>atomic</E> irrationality <M>q_N</M>, even when,
as in the last example,
<M>q_N</M> first appears with another conjugacy <M>*k</M>.
<P/>
<Example><![CDATA[
gap> AtlasIrrationality( "b7*3" );
E(7)^3+E(7)^5+E(7)^6
gap> AtlasIrrationality( "y'''24" );
E(24)-E(24)^19
gap> AtlasIrrationality( "-3y'''24*13&5" );
3*E(8)-3*E(8)^3
gap> AtlasIrrationality( "3y'''24*13-2&5" );
-3*E(24)-2*E(24)^11+2*E(24)^17+3*E(24)^19
gap> AtlasIrrationality( "3y'''24*13-&5" );
-3*E(24)-E(24)^11+E(24)^17+3*E(24)^19
gap> AtlasIrrationality( "3y'''24*13-4&5&7" );
-7*E(24)-4*E(24)^11+4*E(24)^17+7*E(24)^19
gap> AtlasIrrationality( "3y'''24&7" );
6*E(24)-6*E(24)^19
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Galois Conjugacy of Cyclotomics">
<Heading>Galois Conjugacy of Cyclotomics</Heading>

<ManSection>
<Oper Name="GaloisCyc" Arg='cyc, k' Label="for a cyclotomic"/>
<Oper Name="GaloisCyc" Arg='list, k' Label="for a list of cyclotomics"/>

<Description>
For a cyclotomic <A>cyc</A> and an integer <A>k</A>,
<Ref Oper="GaloisCyc" Label="for a cyclotomic"/> returns the cyclotomic
obtained by raising the roots of unity in the Zumbroich basis
representation of <A>cyc</A> to the <A>k</A>-th power.
If <A>k</A> is coprime to the integer <M>n</M>,
<C>GaloisCyc( ., <A>k</A> )</C> acts as a Galois automorphism
of the <M>n</M>-th cyclotomic field
(see&nbsp;<Ref Sect="Galois Groups of Abelian Number Fields"/>);
to get the Galois automorphisms themselves,
use <Ref Oper="GaloisGroup" Label="of field"/>.
<P/>
The <E>complex conjugate</E> of <A>cyc</A> is
<C>GaloisCyc( <A>cyc</A>, -1 )</C>,
which can also be computed using <Ref Func="ComplexConjugate"/>.
<P/>
For a list or matrix <A>list</A> of cyclotomics,
<Ref Oper="GaloisCyc" Label="for a list of cyclotomics"/> returns
the list obtained by applying
<Ref Oper="GaloisCyc" Label="for a cyclotomic"/> to the entries of
<A>list</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ComplexConjugate" Arg='z'/>
<Attr Name="RealPart" Arg='z'/>
<Attr Name="ImaginaryPart" Arg='z'/>

<Description>
For a cyclotomic number <A>z</A>,
<Ref Func="ComplexConjugate"/> returns
<C>GaloisCyc( <A>z</A>, -1 )</C>,
see&nbsp;<Ref Func="GaloisCyc" Label="for a cyclotomic"/>.
For a quaternion <M><A>z</A> = c_1 e + c_2 i + c_3 j + c_4 k</M>,
<Ref Func="ComplexConjugate"/> returns
<M>c_1 e - c_2 i - c_3 j - c_4 k</M>,
see&nbsp;<Ref Func="IsQuaternion"/>.
<P/>
When <Ref Func="ComplexConjugate"/> is called with a list then the result
is the list of return values of <Ref Func="ComplexConjugate"/>
for the list entries in the corresponding positions.
<P/>
When <Ref Func="ComplexConjugate"/> is defined for an object <A>z</A>
then <Ref Func="RealPart"/> and <Ref Func="ImaginaryPart"/> return
<C>(<A>z</A> + ComplexConjugate( <A>z</A> )) / 2</C> and
<C>(<A>z</A> - ComplexConjugate( <A>z</A> )) / 2 i</C>, respectively,
where <C>i</C> denotes the corresponding imaginary unit.
<P/>
<Example><![CDATA[
gap> GaloisCyc( E(5) + E(5)^4, 2 );
E(5)^2+E(5)^3
gap> GaloisCyc( E(5), -1 );           # the complex conjugate
E(5)^4
gap> GaloisCyc( E(5) + E(5)^4, -1 );  # this value is real
E(5)+E(5)^4
gap> GaloisCyc( E(15) + E(15)^4, 3 );
E(5)+E(5)^4
gap> ComplexConjugate( E(7) );
E(7)^6
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="StarCyc" Arg='cyc'/>

<Description>
If the cyclotomic <A>cyc</A> is an irrational element of a quadratic
extension of the rationals then <Ref Func="StarCyc"/> returns the unique
Galois conjugate of <A>cyc</A> that is different from <A>cyc</A>,
otherwise <K>fail</K> is returned.
In the first case, the return value is often called <A>cyc</A><M>*</M>
(see&nbsp;<Ref Sect="Printing Character Tables"/>).
<P/>
<Example><![CDATA[
gap> StarCyc( EB(5) ); StarCyc( E(5) );
E(5)^2+E(5)^3
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Quadratic" Arg='cyc'/>

<Description>
Let <A>cyc</A> be a cyclotomic integer that lies in a quadratic extension
field of the rationals.
Then we have <A>cyc</A><M> = (a + b \sqrt{{n}}) / d</M>,
for integers <M>a</M>, <M>b</M>, <M>n</M>, <M>d</M>,
such that <M>d</M> is either <M>1</M> or <M>2</M>.
In this case, <Ref Func="Quadratic"/> returns a record with the
components <C>a</C>, <C>b</C>, <C>root</C>, <C>d</C>, <C>ATLAS</C>,
and <C>display</C>;
the values of the first four are <M>a</M>, <M>b</M>, <M>n</M>,
and <M>d</M>,
the <C>ATLAS</C> value is a (not necessarily shortest) representation of
<A>cyc</A> in terms of the &ATLAS; irrationalities
<M>b_{{|n|}}</M>, <M>i_{{|n|}}</M>, <M>r_{{|n|}}</M>,
and the <C>display</C> value is a string that expresses <A>cyc</A> in
&GAP; notation, corresponding to the value of the <C>ATLAS</C> component.
<P/>
If <A>cyc</A> is not a cyclotomic integer or does not lie in a quadratic
extension field of the rationals then <K>fail</K> is returned.
<P/>
If the denominator <M>d</M> is <M>2</M> then necessarily <M>n</M> is
congruent to <M>1</M> modulo <M>4</M>,
and <M>r_n</M>, <M>i_n</M> are not possible;
we have <C><A>cyc</A> = x + y * EB( root )</C>
with <C>y = b</C>, <C>x = ( a + b ) / 2</C>.
<P/>
If <M>d = 1</M>, we have the possibilities
<M>i_{{|n|}}</M> for <M>n &lt; -1</M>,
<M>a + b * i</M> for <M>n = -1</M>, <M>a + b * r_n</M>
for <M>n &gt; 0</M>.
Furthermore if <M>n</M> is congruent to <M>1</M> modulo <M>4</M>,
also <A>cyc</A> <M>= (a+b) + 2 * b * b_{{|n|}}</M> is possible;
the shortest string of these is taken as the value for the component
<C>ATLAS</C>.
<P/>
<Example><![CDATA[
gap> Quadratic( EB(5) ); Quadratic( EB(27) );
rec( ATLAS := "b5", a := -1, b := 1, d := 2, 
  display := "(-1+Sqrt(5))/2", root := 5 )
rec( ATLAS := "1+3b3", a := -1, b := 3, d := 2, 
  display := "(-1+3*Sqrt(-3))/2", root := -3 )
gap> Quadratic(0); Quadratic( E(5) );
rec( ATLAS := "0", a := 0, b := 0, d := 1, display := "0", root := 1 )
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GaloisMat" Arg='mat'/>

<Description>
Let <A>mat</A> be a matrix of cyclotomics.
<Ref Func="GaloisMat"/> calculates the complete orbits under
the operation of the Galois group of the (irrational) entries of
<A>mat</A>,
and the permutations of rows corresponding to the generators of the
Galois group.
<P/>
If some rows of <A>mat</A> are identical,
only the first one is considered for the permutations,
and a warning will be printed.
<P/>
<Ref Func="GaloisMat"/> returns a record with the components <C>mat</C>,
<C>galoisfams</C>, and <C>generators</C>.
<P/>
<List>
<Mark><C>mat</C></Mark>
<Item>
   a list with initial segment being the rows of <A>mat</A>
   (<E>not</E> shallow copies of these rows);
   the list consists of full orbits under the action of the Galois
   group of the entries of <A>mat</A> defined above.
   The last rows in the list are those not contained in <A>mat</A> but
   must be added in order to complete the orbits;
   so if the orbits were already complete, <A>mat</A> and <C>mat</C> have
   identical rows.
</Item>
<Mark><C>galoisfams</C></Mark>
<Item>
   a list that has the same length as the <C>mat</C> component,
   its entries are either 1, 0, -1, or lists.
   <List>
   <Mark><C>galoisfams[i] = 1</C></Mark>
   <Item>
      means that <C>mat[i]</C> consists of rationals,
      i.e., <C>[ mat[i] ]</C> forms an orbit;
   </Item>
   <Mark><C>galoisfams[i] = -1</C></Mark>
   <Item>
      means that <C>mat[i]</C> contains unknowns
      (see Chapter&nbsp;<Ref Chap="Unknowns"/>);
      in this case <C>[ mat[i] ]</C> is regarded as an orbit, too,
      even if <C>mat[i]</C> contains irrational entries;
   </Item>
   <Mark><C>galoisfams[i] = </C><M>[ l_1, l_2 ]</M></Mark>
   <Item>
      (a list) means that <C>mat[i]</C> is the first element of its orbit
      in <C>mat</C>,
      <M>l_1</M> is the list of positions of rows that form the orbit,
      and <M>l_2</M> is the list of corresponding Galois automorphisms
      (as exponents, not as functions);
      so we have <C>mat</C><M>[ l_1[j] ][k] = </M>
      <C>GaloisCyc( mat</C><M>[i][k], l_2[j]</M><C> )</C>;
   </Item>
   <Mark><C>galoisfams[i] = 0</C></Mark>
   <Item>
      means that <C>mat[i]</C> is an element of a
      nontrivial orbit but not the first element of it.
   </Item>
   </List>
</Item>
<Mark><C>generators</C></Mark>
<Item>
   a list of permutations generating the permutation group
   corresponding to the action of the Galois group on the rows of
   <C>mat</C>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> GaloisMat( [ [ E(3), E(4) ] ] );
rec( galoisfams := [ [ [ 1, 2, 3, 4 ], [ 1, 7, 5, 11 ] ], 0, 0, 0 ], 
  generators := [ (1,2)(3,4), (1,3)(2,4) ], 
  mat := [ [ E(3), E(4) ], [ E(3), -E(4) ], [ E(3)^2, E(4) ], 
      [ E(3)^2, -E(4) ] ] )
gap> GaloisMat( [ [ 1, 1, 1 ], [ 1, E(3), E(3)^2 ] ] );
rec( galoisfams := [ 1, [ [ 2, 3 ], [ 1, 2 ] ], 0 ], 
  generators := [ (2,3) ], 
  mat := [ [ 1, 1, 1 ], [ 1, E(3), E(3)^2 ], [ 1, E(3)^2, E(3) ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RationalizedMat" Arg='mat'/>

<Description>
returns the list of rationalized rows of <A>mat</A>,
which must be a matrix of cyclotomics.
This is the set of sums over orbits under the action of the Galois group
of the entries of <A>mat</A> (see <Ref Func="GaloisMat"/>),
so the operation may be viewed as a kind of trace on the rows.
<P/>
Note that no two rows of <A>mat</A> should be equal.
<P/>
<Example><![CDATA[
gap> mat:= [ [ 1, 1, 1 ], [ 1, E(3), E(3)^2 ], [ 1, E(3)^2, E(3) ] ];;
gap> RationalizedMat( mat );
[ [ 1, 1, 1 ], [ 2, -1, -1 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Internally Represented Cyclotomics">
<Heading>Internally Represented Cyclotomics</Heading>

The implementation of an <E>internally represented cyclotomic</E> is based on
a list of length equal to its conductor.
This means that the internal representation of a cyclotomic does <E>not</E>
refer to the smallest number field but the smallest <E>cyclotomic</E> field
containing it.
The reason for this is the wish to reflect the natural embedding of two
cyclotomic fields into a larger one that contains both.
With such embeddings, it is easy to construct the sum or the product
of two arbitrary cyclotomics (in possibly different fields) as an element
of a cyclotomic field.
<P/>
The disadvantage of this approach is that the arithmetical operations
are quite expensive, so the use of internally represented cyclotomics
is not recommended for doing arithmetics over number fields, such as
calculations with matrices of cyclotomics.
But internally represented cyclotomics are good enough for dealing
with irrationalities in character tables
(see chapter&nbsp;<Ref Chap="Character Tables"/>).
<P/>
For the representation of cyclotomics one has to recall that the
<M>n</M>-th cyclotomic field <M>&QQ;(e_n)</M> is a vector space of dimension
<M>\varphi(n)</M> over the rationals where <M>\varphi</M> denotes Euler's
phi-function (see&nbsp;<Ref Func="Phi"/>).
<P/>
A special integral basis of cyclotomic fields is chosen that allows one to
easily convert arbitrary sums of roots of unity into the
basis, as well as to convert a cyclotomic represented w.r.t.&nbsp;the basis
into the smallest possible cyclotomic field.
This basis is accessible in &GAP;,
see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>
for more information and references.
<P/>
Note that the set of all <M>n</M>-th roots of unity is linearly dependent
for <M>n > 1</M>, so multiplication is <E>not</E> the multiplication
of the group ring <M>&QQ;\langle e_n \rangle</M>;
given a <M>&QQ;</M>-basis of <M>&QQ;(e_n)</M> the result of the multiplication
(computed as multiplication of polynomials in <M>e_n</M>,
using <M>(e_n)^n = 1</M>) will be converted to the basis.
<P/>
<Example><![CDATA[
gap> E(5) * E(5)^2; ( E(5) + E(5)^4 ) * E(5)^2;
E(5)^3
E(5)+E(5)^3
gap> ( E(5) + E(5)^4 ) * E(5);
-E(5)-E(5)^3-E(5)^4
]]></Example>
<P/>
An internally represented cyclotomic is always represented in the smallest
cyclotomic field it is contained in.
The internal coefficients list coincides with the external representation
returned by <Ref Func="ExtRepOfObj" Label="for a cyclotomic"/>.
<P/>
To avoid calculations becoming unintentionally very long, or consuming
very large amounts of memory,
there is a limit on the conductor of internally represented cyclotomics,
by default set to one million.
This can be raised (although not lowered) using
<Ref Func="SetCyclotomicsLimit"/> and
accessed using <Ref Func="GetCyclotomicsLimit"/>.
The maximum value of the limit is <M>2^{28}-1</M> on <M>32</M> bit systems,
and <M>2^{32}</M> on <M>64</M> bit systems.
So the maximal cyclotomic field implemented in &GAP; is not really
the field <M>&QQ;^{ab}</M>.
<P/>
It should be emphasized that one disadvantage of representing a cyclotomic in
the smallest <E>cyclotomic</E> field (and not in the smallest field) is that
arithmetic operations in a fixed small extension field of the rational
number field are comparatively expensive.
For example, take a prime integer <M>p</M> and suppose that we want to work
with a matrix group over the field <M>&QQ;(\sqrt{{p}})</M>.
Then each matrix entry could be described by two rational coefficients,
whereas the representation in the smallest cyclotomic field requires
<M>p-1</M> rational coefficients for each entry.
So it is worth thinking about using elements in a field constructed with
<Ref Func="AlgebraicExtension"/> when natural embeddings
of cyclotomic fields are not needed.

<!-- % show an example? -->
<ManSection>
<Func Name="SetCyclotomicsLimit" Arg="newlimit"/>
<Func Name="GetCyclotomicsLimit" Arg=""/>
<Description>
<Ref Func="GetCyclotomicsLimit"/> returns the current limit on
conductors of internally represented cyclotomic numbers
<P/>
<Ref Func="SetCyclotomicsLimit"/> can be called to increase the 
limit on conductors of internally represented cyclotomic numbers. Note that computing in
large cyclotomic fields using this representation can be both slow and memory-consuming, and
that other approaches may be better for some problems. See
<Ref Sect="Internally Represented Cyclotomics"/>.
</Description>
</ManSection>

</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<Chapter Label="Floats">
<Heading>Floats</Heading>

Starting with version 4.5, &GAP; has built-in support for
floating-point numbers in machine format, and allows package to
implement arbitrary-precision floating-point arithmetic in a uniform
manner. For now, one such package, <Package>Float</Package> exists,
and is based on the arbitrary-precision routines
in <Package>mpfr</Package>.

<P/> A word of caution: &GAP; deals primarily with algebraic objects,
which can be represented exactly in a computer. Numerical imprecision
means that floating-point numbers do not form a ring in the strict
&GAP; sense, because addition is in general not associative
(<C>(1.0e-100+1.0)-1.0</C> is not the same
as <C>1.0e-100+(1.0-1.0)</C>, in the default precision setting).

<P/> Most algorithms in &GAP; which require ring elements will
therefore not be applicable to floating-point elements. In some cases,
such a notion would not even make any sense (what is the greatest
common divisor of two floating-point numbers?)

<Section><Heading>A sample run</Heading>

Floating-point numbers can be input into &GAP; in the standard
floating-point notation:
<P/>
<Example><![CDATA[
gap> 3.14;
3.14
gap> last^2/6;
1.64327
gap> h := 6.62606896e-34;
6.62607e-34
gap> pi := 4*Atan(1.0);
3.14159
gap> hbar := h/(2*pi);
1.05457e-34
]]></Example>

<P/> Floating-point numbers can also be created using <C>Float</C>,
from strings or rational numbers; and can be converted back
using <C>String,Rat,Int</C>.

<P/> &GAP; allows rational and floating-point numbers to be mixed in
the elementary operations <C>+,-,*,/</C>. However, floating-point
numbers and rational numbers may not be compared. Conversions are
performed using the creator <C>Float</C>:
<P/>
<Example><![CDATA[
gap> Float("3.1416");
3.1416
gap> Float(355/113);
3.14159
gap> Rat(last);
355/113
gap> Rat(0.33333);
1/3
gap> Int(1.e10);
10000000000
gap> Int(1.e20);
100000000000000000000
gap> Int(1.e30);
1000000000000000019884624838656
]]></Example>
</Section>

<Section><Heading>Methods</Heading>

Floating-point numbers may be directly input, as in any usual
mathematical software or language; with the exception that every
floating-point number must contain a decimal
digit. Therefore <C>.1</C>, <C>.1e1</C>, <C>-.999</C> etc. are all valid
&GAP; inputs.
<P/>

Floating-point numbers so entered in &GAP; are stored as strings. They
are converted to floating-point when they are first used. This means that,
if the floating-point precision is increased, the constants are
reevaluated to fit the new format.
<P/>

Floating-point numbers may be followed by an underscore, as
in <C>1._</C>. This means that they are to be immediately converted to
the current floating-point format. The underscore may be followed by a
single letter, which specifies which format/precision to use. By
default, &GAP; has a single floating-point handler, with fixed (53
bits) precision, and its format specifier is <C>'l'</C> as
in <C>1._l</C>. Higher-precision floating-point computations is
available via external packages; <Package>float</Package> for example.
<P/>

A record, <Ref Var="FLOAT" Label="constants"/>,
contains all relevant constants for the
current floating-point format; see its documentation for details.
Typical fields are <C>FLOAT.MANT_DIG=53</C>, the
constant <C>FLOAT.VIEW_DIG=6</C> specifying the number of digits to
view, and <C>FLOAT.PI</C> for the constant <M>\pi</M>. The constants
have the same name as their C counterparts, except for the missing
initial <C>DBL_</C> or <C>M_</C>.
<P/>

Floating-point numbers may be created using the single function
<Ref Func="Float"/>, which accepts as arguments rational, string,
or floating-point numbers. Floating-point numbers may
also be created, in any floating-point representation, using
<Ref Func="NewFloat"/> as in <C>NewFloat(IsIEEE754FloatRep,355/113)</C>,
by supplying the category filter of the desired new floating-point number;
or using <Ref Func="MakeFloat"/> as in <C>NewFloat(1.0,355/113)</C>,
by supplying a sample floating-point number.
<P/>

Floating-point numbers may also be converted to other &GAP; formats
using the usual commands <Ref Oper="Int"/>, <Ref Oper="Rat"/>,
<Ref Oper="String"/>.
<P/>

Exact conversion to and from floating-point format may be done using
external representations. The "external representation" of a
floating-point number <C>x</C> is a pair <C>[m,e]</C> of integers,
such that <C>x=m*2^(-1+e-LogInt(AbsInt(m),2))</C>. Conversion to and from
external representation is performed as usual using
<Ref Oper="ExtRepOfObj"/> and <Ref Oper="ObjByExtRep"/>:
<Example><![CDATA[
gap> ExtRepOfObj(3.14);
[ 7070651414971679, 2 ]
gap> ObjByExtRep(IEEE754FloatsFamily,last);
3.14
]]></Example>
<P/>

Computations with floating-point numbers never raise any
error. Division by zero is allowed, and produces a signed
infinity. Illegal operations, such as <C>0./0.</C>,
produce <K>NaN</K>'s (not-a-number); this is the only floating-point
number <C>x</C> such that <C>not EqFloat(x+0.0,x)</C>.
<P/>

The IEEE754 standard requires <K>NaN</K> to be non-equal to itself. On
the other hand, &GAP; requires every object to be equal to itself. To
respect the IEEE754 standard, the function <Ref Oper="EqFloat"/>
should be used instead of <C>=</C>.
<P/>

The category a floating-point belongs to can be checked using the
filters <Ref Filt="IsFinite"/>, <Ref Filt="IsPInfinity"/>,
<Ref Filt="IsNInfinity"/>, <Ref Filt="IsXInfinity"/>,
<Ref Filt="IsNaN"/>.
<P/>

Comparisons between floating-point numbers and rationals are
explicitly forbidden. The rationale is that objects belonging to
different families should in general not be comparable in
&GAP;. Floating-point numbers are also approximations of real numbers,
and don't follow the same rules; consider for example, using the
default &GAP; implementation of floating-point numbers,
<Example><![CDATA[
gap> 1.0/3.0 = Float(1/3);
true
gap> (1.0/3.0)^5 = Float((1/3)^5);
false
]]></Example>
<P/>

<ManSection>
  <Heading>Mathematical operations</Heading>
  <Oper Name="Cos" Arg="x"/>
  <Oper Name="Sin" Arg="x"/>
  <Oper Name="SinCos" Arg="x"/>
  <Oper Name="Tan" Arg="x"/>
  <Oper Name="Sec" Arg="x"/>
  <Oper Name="Csc" Arg="x"/>
  <Oper Name="Cot" Arg="x"/>
  <Oper Name="Asin" Arg="x"/>
  <Oper Name="Acos" Arg="x"/>
  <Oper Name="Atan" Arg="x"/>
  <Oper Name="Atan2" Arg="y x"/>
  <Oper Name="Cosh" Arg="x"/>
  <Oper Name="Sinh" Arg="x"/>
  <Oper Name="Tanh" Arg="x"/>
  <Oper Name="Sech" Arg="x"/>
  <Oper Name="Csch" Arg="x"/>
  <Oper Name="Coth" Arg="x"/>
  <Oper Name="Asinh" Arg="x"/>
  <Oper Name="Acosh" Arg="x"/>
  <Oper Name="Atanh" Arg="x"/>
  <Oper Name="Log" Arg="x"/>
  <Oper Name="Log2" Arg="x"/>
  <Oper Name="Log10" Arg="x"/>
  <Oper Name="Log1p" Arg="x"/>
  <Oper Name="Exp" Arg="x"/>
  <Oper Name="Exp2" Arg="x"/>
  <Oper Name="Exp10" Arg="x"/>
  <Oper Name="Expm1" Arg="x"/>
  <Oper Name="Cuberoot" Arg="x"/>
  <Oper Name="Square" Arg="x"/>
  <Oper Name="Hypothenuse" Arg="x y"/>
  <Oper Name="Ceil" Arg="x"/>
  <Oper Name="Floor" Arg="x"/>
  <Oper Name="Round" Arg="x"/>
  <Oper Name="Trunc" Arg="x"/>
  <Oper Name="Frac" Arg="x"/>
  <Oper Name="SignFloat" Arg="x"/>
  <Oper Name="Argument" Arg="x" Label="for complex numbers" />
  <Oper Name="Erf" Arg="x"/>
  <Oper Name="Zeta" Arg="x"/>
  <Oper Name="Gamma" Arg="x"/>
  <Oper Name="ComplexI" Arg="x"/>
  <Description>
    Usual mathematical functions.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="EqFloat" Arg="x y"/>
  <Returns>Whether the floateans <A>x</A> and <A>y</A> are equal</Returns>
  <Description>
    This function compares two floating-point numbers, and returns
    <K>true</K> if they are equal, and <K>false</K> otherwise; with the
    exception that <K>NaN</K> is always considered to be different from
    itself.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="PrecisionFloat" Arg="x"/>
  <Returns>The precision of <A>x</A></Returns>
  <Description>
    This function returns the precision, counted in number of binary digits,
    of the floating-point number <A>x</A>.
  </Description>
</ManSection>

<ManSection>
  <Heading>Interval operations</Heading>
  <Oper Name="Sup" Arg="interval"/>
  <Oper Name="Inf" Arg="interval"/>
  <Oper Name="Mid" Arg="interval"/>
  <Oper Name="AbsoluteDiameter" Arg="interval"/>
  <Oper Name="RelativeDiameter" Arg="interval"/>
  <Oper Name="Overlaps" Arg="interval1 interval2"/>
  <Oper Name="IsDisjoint" Arg="interval1 interval2"/>
  <Oper Name="IncreaseInterval" Arg="interval delta"/>
  <Oper Name="BlowupInterval" Arg="interval ratio"/>
  <Oper Name="BisectInterval" Arg="interval"/>
  <Description>
    Most are self-explanatory.
    <C>BlowupInterval</C> returns an interval with same midpoint but 
    relative diameter increased by <A>ratio</A>; <C>IncreaseInterval</C>
    returns an interval with same midpoint but absolute diameter increased
    by <A>delta</A>; <C>BisectInterval</C> returns a list of two intervals
    whose union equals <A>interval</A>.
  </Description>  
</ManSection>

<ManSection>
  <Prop Name="IsPInfinity" Arg="x"/>
  <Prop Name="IsNInfinity" Arg="x"/>
  <Prop Name="IsXInfinity" Arg="x"/>
  <Prop Name="IsFinite" Arg="x" Label="float"/>
  <Prop Name="IsNaN" Arg="x"/>
  <Description>
    Returns <K>true</K> if the floating-point number <A>x</A> is
    respectively <M>+\infty</M>, <M>-\infty</M>, <M>\pm\infty</M>,
    finite, or `not a number', such as the result of <C>0.0/0.0</C>.
  </Description>
</ManSection>

<ManSection>
  <Var Name="FLOAT" Label="constants"/>
  <Description>
    This record contains useful floating-point constants: <List>
    <Mark>DECIMAL_DIG</Mark> <Item>Maximal number of useful digits;</Item>
    <Mark>DIG</Mark> <Item>Number of significant digits;</Item>
    <Mark>VIEW_DIG</Mark> <Item>Number of digits to print in short view;</Item>
    <Mark>EPSILON</Mark> <Item>Smallest number such that <M>1\neq1+\epsilon</M>;</Item>
    <Mark>MANT_DIG</Mark> <Item>Number of bits in the mantissa;</Item>
    <Mark>MAX</Mark> <Item>Maximal representable number;</Item>
    <Mark>MAX_10_EXP</Mark> <Item>Maximal decimal exponent;</Item>
    <Mark>MAX_EXP</Mark> <Item>Maximal binary exponent;</Item>
    <Mark>MIN</Mark> <Item>Minimal positive representable number;</Item>
    <Mark>MIN_10_EXP</Mark> <Item>Minimal decimal exponent;</Item>
    <Mark>MIN_EXP</Mark> <Item>Minimal exponent;</Item>
    <Mark>INFINITY</Mark> <Item>Positive infinity;</Item>
    <Mark>NINFINITY</Mark> <Item>Negative infinity;</Item>
    <Mark>NAN</Mark> <Item>Not-a-number,</Item>
    </List>
    as well as mathematical constants <C>E</C>, <C>LOG2E</C>, <C>LOG10E</C>,
    <C>LN2</C>, <C>LN10</C>, <C>PI</C>, <C>PI_2</C>, <C>PI_4</C>,
    <C>1_PI</C>, <C>2_PI</C>, <C>2_SQRTPI</C>, <C>SQRT2</C>, <C>SQRT1_2</C>.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="Float" Arg="obj"/>
  <Oper Name="NewFloat" Arg="filter, obj"/>
  <Oper Name="MakeFloat" Arg="sample obj, obj"/>
  <Returns>A new floating-point number, based on <A>obj</A></Returns>
  <Description>
    This function creates a new floating-point number.

    <P/> If <A>obj</A> is a rational number, the created number is created
    with sufficient precision so that the number can (usually) be converted
    back to the original number (see <Ref Oper="Rat" BookName="ref"/> and
    <Ref Oper="Rat"/>). For an integer, the precision, if unspecified, is
    chosen sufficient so that <C>Int(Float(obj))=obj</C> always holds, but
    at least 64 bits.

    <P/> <A>obj</A> may also be a string, which may be of the form
    <C>"3.14e0"</C> or <C>".314e1"</C> or <C>".314@1"</C> etc.

    <P/> An option may be passed to specify, it bits, a desired precision.
    The format is <C>Float("3.14":PrecisionFloat:=1000)</C> to create
    a 1000-bit approximation of <M>3.14</M>.

    <P/> In particular, if <A>obj</A> is already a floating-point number,
    then <C>Float(obj:PrecisionFloat:=prec)</C> creates a copy of
    <A>obj</A> with a new precision.
    prec
  </Description>
</ManSection>

<ManSection>
  <Oper Name="Rat" Arg="f" Label="for floats"/>
  <Returns>A rational approximation to <A>f</A></Returns>
  <Description>
    This command constructs a rational approximation to the
    floating-point number <A>f</A>. Of course, it is not guaranteed to
    return the original rational number <A>f</A> was created from, though
    it returns the most `reasonable' one given the precision of
    <A>f</A>.

    <P/> Two options control the precision of the rational approximation:
    In the form <C>Rat(f:maxdenom:=md,maxpartial:=mp)</C>, the rational
    returned is such that the denominator is at most <A>md</A> and the
    partials in its continued fraction expansion are at most <A>mp</A>.
    The default values are <C>maxpartial:=10000</C> and
    <C>maxdenom:=2^(precision/2)</C>.
  </Description>
</ManSection>

<ManSection>
  <Func Name="SetFloats" Arg="rec [bits] [install]"/>
  <Description>
    Installs a new interface to floating-point numbers in &GAP;, optionally
    with a desired precision <A>bits</A> in binary digits. The last
    optional argument <A>install</A> is a boolean value; if false, it
    only installs the eager handler and the precision for the floateans,
    without making them the default.
  </Description>
</ManSection>


</Section>

<Section><Heading>High-precision-specific methods</Heading>

&GAP; provides a mechanism for packages to implement new
floating-point numerical interfaces. The following describes that
mechanism, actual examples of packages are documented separately.
<P/>

A package must create a record with fields (all optional) <List>
<Mark>creator</Mark> <Item>a function converting strings to floating-point;</Item>
<Mark>eager</Mark> <Item>a character allowing immediate conversion
  to floating-point;</Item>
<Mark>objbyextrep</Mark> <Item>a function creating a floating-point
  number out of a list <C>[mantissa,exponent]</C>;</Item>
<Mark>filter</Mark> <Item>a filter for the new floating-point objects;</Item>
<Mark>constants</Mark> <Item>a record containing numerical constants,
  such as <C>MANT_DIG</C>, <C>MAX</C>, <C>MIN</C>, <C>NAN</C>.</Item>
</List>
<P/>

The package must install methods <C>Int</C>, <C>Rat</C>, <C>String</C>
for its objects, and
creators <C>NewFloat(filter,IsRat)</C>, <C>NewFloat(IsString)</C>.
<P/>

It must then install methods for all arithmetic and numerical
operations: <C>PLUS</C>, <C>Exp</C>, ...
<P/>

The user chooses that implementation by calling
<Ref Func="SetFloats"/> with the record as argument, and with an
optional second argument requesting a precision in binary digits.

</Section>

<Section><Heading>Complex arithmetic</Heading>

Complex arithmetic may be implemented in packages, and is present
in <Package>float</Package>. Complex numbers are treated as usual
numbers; they may be input with an extra "i" as in <C>-0.5+0.866i</C>.
<P/>

Methods should then be implemented for <C>Norm</C>, <C>RealPart</C>,
<C>ImaginaryPart</C>, <C>ComplexConjugate</C>, ...

</Section>

<Section><Heading>Interval-specific methods</Heading>

Interval arithmetic may also be implemented in packages. Intervals
are in fact efficient implementations of sets of real numbers. The
only non-trivial issue is how they should be compared. The standard
<C>EQ</C> tests if the intervals are equal; however, it is usually
more useful to know if intervals overlap, or are disjoint, or are
contained in each other. The methods provided by the package should
include <C>Sup,Inf,Mid,DiameterOfInterval,Overlaps,IsSubset,IsDisjoint</C>.
<P/>

Note the usual convention that intervals are compared as
in <M>[a,b]\le[c,d]</M> if and only if <M>a\le c</M> and <M>b\le
d</M>.
</Section>

</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  boolean.msk                 GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: boolean.msk,v 1.14 2002/04/15 10:02:27 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Booleans">
<Heading>Booleans</Heading>

<Index Subkey="boolean">type</Index>
<Index>logical</Index>

The two main <E>boolean</E> values are <K>true</K> and <K>false</K>.
They stand for the <E>logical</E> values of the same name.
They appear as values of the conditions in <K>if</K>-statements
and <K>while</K>-loops.
Booleans are also important as return values of <E>filters</E>
(see&nbsp;<Ref Sect="Filters"/>)
such as <Ref Prop="IsFinite"/> and <Ref Func="IsBool"/>.
Note that it is a convention that the name of a function that
returns <K>true</K> or <K>false</K> according to the outcome,
starts with <C>Is</C>.
<P/>
For technical reasons, also the value <K>fail</K>
(see&nbsp;<Ref Sect="Fail"/>) is regarded as a boolean.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsBool">
<Heading>IsBool (Filter)</Heading>

<ManSection>
<Filt Name="IsBool" Arg='obj' Type='Category'/>

<Description>
tests whether <A>obj</A> is <K>true</K>, <K>false</K> or <K>fail</K>.
<Example><![CDATA[
gap> IsBool( true );  IsBool( false );  IsBool( 17 );
true
true
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Fail">
<Heading>Fail (Variable)</Heading>

<ManSection>
<Var Name="fail"/>

<Description>
The value <K>fail</K> is used to indicate situations when an operation could
not be performed for the given arguments, either because of shortcomings of
the arguments or because of restrictions in the implementation or
computability.
So for example <Ref Func="Position"/> will return <K>fail</K>
if the point searched for is not in the list.
<P/>
<K>fail</K> is simply an object that is different from every other object
than itself.
<P/>
For technical reasons, <K>fail</K> is a boolean value.
But note that <K>fail</K> cannot be used to form boolean expressions with
<K>and</K>, <K>or</K>, and <K>not</K>
(see&nbsp;<Ref Sect="Operations for Booleans"/> below),
and <K>fail</K> cannot appear in boolean lists
(see Chapter&nbsp;<Ref Chap="Boolean Lists"/>).
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons of Booleans">
<Heading>Comparisons of Booleans</Heading>
<Index Subkey="of booleans">comparisons</Index>
<Subsection Label="Equality and inequality of Booleans">
<Heading>Equality and inequality of Booleans</Heading>
<Index Subkey="of booleans">equality</Index>
<Index Subkey="of booleans">inequality</Index>
<C><A>bool1</A> = <A>bool2</A></C>
<P/>
<Alt Only="LaTeX">\noindent</Alt>
<C><A>bool1</A> &lt;> <A>bool2</A></C>
<P/>
The equality operator <C>=</C> evaluates to <K>true</K>
if the two boolean values <A>bool1</A> and <A>bool2</A> are equal,
i.e., both are <K>true</K> or both are <K>false</K> or both <K>fail</K>,
and <K>false</K> otherwise.
The inequality operator <C>&lt;></C> evaluates to <K>true</K>
if the two boolean values <A>bool1</A>, <A>bool2</A> are different,
and <K>false</K> otherwise.
This operation is also called the <E>exclusive or</E>,
because its value is <K>true</K> if exactly one of <A>bool1</A> or
<A>bool2</A> is <K>true</K>.
<P/>
You can compare boolean values with objects of other types.
Of course they are never equal.
<P/>
<Example><![CDATA[
gap> true = false;
false
gap> false = (true = fail);
true
gap> true <> 17;
true
]]></Example>
</Subsection>

<Subsection Label="Ordering of Booleans">
<Heading>Ordering of Booleans</Heading>
<Index Subkey="booleans">ordering</Index>
<A>bool1</A> <C>&lt;</C> <A>bool2</A>
<P/>
The ordering of boolean values is defined by
<K>true</K> <C>&lt;</C> <K>false</K> <C>&lt;</C> <K>fail</K>.
For the comparison of booleans with other &GAP; objects,
see Section&nbsp;<Ref Sect="Comparisons"/>.
<P/>
<Example><![CDATA[
gap> true < false;  fail >= false;
true
true
]]></Example>
</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Booleans">
<Heading>Operations for Booleans</Heading>

<Index Subkey="for booleans">operations</Index>
<Index>logical operations</Index>

The following boolean operations are only applicable to <K>true</K> and
<K>false</K>.
<P/>

<Subsection Label="Logical disjunction">
<Heading>Logical disjunction</Heading>
<Index>Logical disjunction</Index>
<Index Key="or"><K>or</K></Index>
<A>bool1</A> <K>or</K> <A>bool2</A>
<P/>
The logical operator <K>or</K> evaluates to <K>true</K>
if at least one of the two boolean operands <A>bool1</A> and <A>bool2</A>
is <K>true</K>, and to <K>false</K> otherwise.
<P/>
<K>or</K> first evaluates <A>bool1</A>.
If the value is neither <K>true</K> nor <K>false</K> an error is signalled.
If the value is <K>true</K>, then <K>or</K> returns <K>true</K>
<E>without</E> evaluating <A>bool2</A>.
If the value is <K>false</K>, then <K>or</K> evaluates <A>bool2</A>.
Again, if the value is neither <K>true</K> nor <K>false</K>
an error is signalled.
Otherwise <K>or</K> returns the value of <A>bool2</A>.
This <E>short-circuited</E> evaluation is important if the value of
<A>bool1</A> is <K>true</K>
and evaluation of <A>bool2</A> would take much time or cause an error.
<P/>
<K>or</K> is associative, i.e., it is allowed to write
<A>b1</A> <K>or</K> <A>b2</A> <K>or</K> <A>b3</A>,
which is interpreted as (<A>b1</A> <K>or</K> <A>b2</A>) <K>or</K> <A>b3</A>.
<K>or</K> has the lowest precedence of the logical operators.
All logical operators have lower precedence than the comparison operators
<C>=</C>, <C>&lt;</C>, <K>in</K>, etc.
<P/>
<Example><![CDATA[
gap> true or false;
true
gap> false or false;
false
gap> i := -1;; l := [1,2,3];;
gap> if i <= 0 or l[i] = false then     # this does not cause an error,
>    Print("aha\n"); fi;                # because `l[i]' is not evaluated
aha
]]></Example>
</Subsection>

<Subsection Label="Logical conjunction">
<Heading>Logical conjunction</Heading>
<Index>Logical conjunction</Index>
<Index Key="and"><K>and</K></Index>
<A>bool1</A> <K>and</K> <A>bool2</A>
<P/>
<Index Key="and" Subkey="for filters"><K>and</K></Index>
<Alt Only="LaTeX">\noindent</Alt>
<A>fil1</A> <K>and</K> <A>fil2</A>
<P/>
The logical operator <K>and</K> evaluates to <K>true</K>
if both boolean operands <A>bool1</A>, <A>bool2</A> are <K>true</K>,
and to <K>false</K> otherwise.
<P/>
<K>and</K> first evaluates <A>bool1</A>.
If the value is neither <K>true</K> nor <K>false</K> an error is signalled.
If the value is <K>false</K>, then <K>and</K> returns <K>false</K>
<E>without</E> evaluating <A>bool2</A>.
If the value is <K>true</K>, then <K>and</K> evaluates <A>bool2</A>.
Again, if the value is neither <K>true</K> nor <K>false</K>
an error is signalled.
Otherwise <K>and</K> returns the value of <A>bool2</A>.
This <E>short-circuited</E> evaluation is important if the value of
<A>bool1</A> is <K>false</K> and evaluation of <A>bool2</A> would take much
time or cause an error.
<P/>
<K>and</K> is associative, i.e., it is allowed to write
<A>b1</A> <K>and</K> <A>b2</A> <K>and</K> <A>b3</A>,
which is interpreted as (<A>b1</A> <K>and</K> <A>b2</A>) <K>and</K> <A>b3</A>.
<K>and</K> has higher precedence than the logical <K>or</K> operator,
but lower than the unary logical <K>not</K> operator.
All logical operators have lower precedence than the comparison operators
<C>=</C>, <C>&lt;</C>, <K>in</K>, etc.
<P/>
<Example><![CDATA[
gap> true and false;
false
gap> true and true;
true
gap> false and 17;  # does not cause error, because 17 is never looked at
false
]]></Example>
<P/>
<K>and</K> can also be applied to filters.
It returns a filter that when applied to some argument <A>x</A>,
tests <A>fil1</A><M>(x)</M> <K>and</K> <A>fil2</A><M>(x)</M>.
<P/>
<Example><![CDATA[
gap> andfilt:= IsPosRat and IsInt;;
gap> andfilt( 17 );  andfilt( 1/2 );
true
false
]]></Example>
</Subsection>

<Subsection Label="Logical negation">
<Heading>Logical negation</Heading>
<Index>Logical negation</Index>
<Index Key="not"><K>not</K></Index>
<K>not</K> <A>bool</A>
<P/>
The logical operator <K>not</K> returns <K>true</K>
if the boolean value <A>bool</A> is <K>false</K>, and <K>true</K> otherwise.
An error is signalled if <A>bool</A> does not evaluate to <K>true</K> or
<K>false</K>.
<P/>
<K>not</K> has higher precedence than the other logical operators,
<K>or</K> and <K>and</K>.
All logical operators have lower precedence than the comparison operators
<C>=</C>, <C>&lt;</C>, <K>in</K>, etc.
<P/>
<Example><![CDATA[
gap> true and false;
false
gap> not true;
false
gap> not false;
true
]]></Example>
</Subsection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  lists.msk                   GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: lists.msk,v 1.58 2006/06/19 10:13:43 stefan Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Lists">
<Heading>Lists</Heading>

Lists are the most important way to treat objects together.
A <E>list</E> arranges objects in a definite order.
So each list implies a partial mapping from the integers to the elements
of the list.
I.e., there is a first element of a list, a second, a third, and so on.
Lists can occur in mutable or immutable form,
see&nbsp;<Ref Sect="Mutability and Copyability"/> for the concept of mutability,
and&nbsp;<Ref Sect="Duplication of Lists"/> for the case of lists.
<P/>
This chapter deals mainly with the aspect of lists in &GAP;
as <E>data structures</E>.
Chapter&nbsp;<Ref Chap="Collections"/> tells more about the <E>collection</E>
aspect of certain lists,
and more about lists as <E>arithmetic objects</E> can be found in the chapters
<Ref Chap="Row Vectors"/> and <Ref Chap="Matrices"/>.
<P/>
Lists are used to implement ranges (see&nbsp;<Ref Sect="Ranges"/>),
sets (see&nbsp;<Ref Sect="Sorted Lists and Sets"/>),<Index>Sets</Index>
strings (see&nbsp;<Ref Chap="Strings and Characters"/>),
row vectors (see&nbsp;<Ref Chap="Row Vectors"/>),
and matrices (see&nbsp;<Ref Chap="Matrices"/>);
Boolean lists (see&nbsp;<Ref Chap="Boolean Lists"/>) are a further
special kind of lists.
<P/>
Several operations for lists,
such as <Ref Func="Intersection" Label="for a list"/> and
<Ref Func="Random" Label="for a list or collection"/>,
will be described in Chapter&nbsp;<Ref Chap="Collections"/>,
in particular see&nbsp;<Ref Sect="Lists and Collections"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="List Categories">
<Heading>List Categories</Heading>

A list can be written by writing down the elements in order between
square brackets <C>[</C>, <C>]</C>, and separating them with commas <C>,</C>.
An <E>empty list</E>, i.e., a list with no elements, is written as <C>[]</C>.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3 ];              # a list with three elements
[ 1, 2, 3 ]
gap> [ [], [ 1 ], [ 1, 2 ] ];  # a list may contain other lists
[ [  ], [ 1 ], [ 1, 2 ] ]
]]></Example>
<P/>
Each list constructed this way is mutable
(see&nbsp;<Ref Sect="Mutability and Copyability"/>).

<ManSection>
<Filt Name="IsList" Arg='obj' Type='Category'/>

<Description>
tests whether <A>obj</A> is a list.
<P/>
<Example><![CDATA[
gap> IsList( [ 1, 3, 5, 7 ] );  IsList( 1 );
true
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsDenseList" Arg='obj' Type='Category'/>

<Description>
A list is <E>dense</E> if it has no holes, i.e., contains an element at
every position up to the length.
It is absolutely legal to have lists with holes.
They are created by leaving the entry between the commas empty.
Holes at the end of a list are ignored.
Lists with holes are sometimes convenient when the list represents
a mapping from a finite, but not consecutive,
subset of the positive integers.
<Log><![CDATA[
gap> IsDenseList( [ 1, 2, 3 ] );
true
gap> l := [ , 4, 9,, 25,, 49,,,, 121 ];;  IsDenseList( l );
false
gap> l[3];
9
gap> l[4];
List Element: <list>[4] must have an assigned value
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' after assigning a value to continue
brk> l[4] := 16;;  # assigning a value
brk> return;       # to escape the break-loop
16
gap> 
]]></Log>
<P/>
Observe that requesting the value of <C>l[4]</C>, which was not
assigned, caused the entry of a <K>break</K>-loop
(see Section&nbsp;<Ref Sect="Break Loops"/>).
After assigning a value and typing <C>return;</C>, &GAP; is finally
able to comply with our request (by responding with <C>16</C>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsHomogeneousList" Arg='obj' Type='Category'/>

<Description>
returns <K>true</K> if <A>obj</A> is a list and it is homogeneous,
and <K>false</K> otherwise.
<P/>
A <E>homogeneous</E> list is a dense list whose elements lie in the same
family (see&nbsp;<Ref Sect="Families"/>).
The empty list is homogeneous but not a collection
(see&nbsp;<Ref Chap="Collections"/>),
a nonempty homogeneous list is also a collection.
<!-- can we guarantee this? -->
<Example><![CDATA[
gap> IsHomogeneousList( [ 1, 2, 3 ] );  IsHomogeneousList( [] );
true
true
gap> IsHomogeneousList( [ 1, false, () ] );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsTable" Arg='obj' Type='Category'/>

<Description>
A <E>table</E> is a nonempty list of homogeneous lists which lie in the
same family.
Typical examples of tables are matrices
(see&nbsp;<Ref Chap="Matrices"/>).
<Example><![CDATA[
gap> IsTable( [ [ 1, 2 ], [ 3, 4 ] ] );    # in fact a matrix
true
gap> IsTable( [ [ 1 ], [ 2, 3 ] ] );       # not rectangular but a table
true
gap> IsTable( [ [ 1, 2 ], [ () , (1,2) ] ] );  # not homogeneous
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsRectangularTable" Arg='list'/>

<Description>
A list lies in <C>IsRectangularTable</C> when it is nonempty and its elements
are all homogeneous lists of the same family and the same length.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsConstantTimeAccessList" Arg='list' Type='Category'/>

<Description>
This category indicates whether the access to each element of the list
<A>list</A> will take roughly the same time.
This is implied for example by <C>IsList and IsInternalRep</C>,
so all strings, Boolean lists, ranges, and internally represented plain
lists are in this category.
<P/>
But also other enumerators (see&nbsp;<Ref Sect="Enumerators"/>) can lie
in this category if they guarantee constant time access to their elements.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Basic Operations for Lists">
<Heading>Basic Operations for Lists</Heading>

The basic operations for lists are element access
(see&nbsp;<Ref Sect="List Elements"/>),
assignment of elements to a list (see&nbsp;<Ref Sect="List Assignment"/>),
fetching the length of a list (see&nbsp;<Ref Func="Length"/>),
the test for a hole at a given position, and unbinding an element at a given
position (see&nbsp;<Ref Sect="IsBound and Unbind for Lists"/>).
<P/>
The term basic operation means that each other list operation can be
formulated in terms of the basic operations.
(But note that often a more efficient method than this one is implemented.)
<P/>
Any &GAP; object <A>list</A> in the category <Ref Func="IsList"/> is regarded
as a list, and if methods for the basic list operations are installed for
<A>list</A> then <A>list</A> can be used also for the other list operations.
<P/>
For internally represented lists, kernel methods are provided for the basic
list operations with positive integer indices.
For other lists or other indices, it is possible to install appropriate methods for these
operations.
This permits the implementation of lists that do not need to store all list
elements (see also&nbsp;<Ref Sect="Enumerators"/>);
for example, the elements might be described by an algorithm, such as the
elements list of a group.
For this reduction of space requirements, however, a price in access time
may have to be paid (see&nbsp;<Ref Func="ConstantTimeAccessList"/>).
<P/>
<Index Subkey="operation">list element</Index>
<Index Subkey="operation">list boundedness test</Index>
<Index Subkey="operation">list assignment</Index>
<Index Subkey="operation">list unbind</Index>
<ManSection>
<Oper Name="\[\]" Arg='list, ix'/>
<Oper Name="IsBound\[\]" Arg='list, ix'/>
<Oper Name="\[\]\:\=" Arg='list, pos, ix'/>
<Oper Name="Unbind\[\]" Arg='list, ix'/>

<Description>
These operations implement element access, test for element boundedness,
list element assignment, and removal of the element with index  <A>ix</A>.
<P/>
Note that the special characters <C>[</C>, <C>]</C>, <C>:</C>,
and <C>=</C> must be escaped with a backslash <C>\</C>
(see&nbsp;<Ref Sect="Symbols"/>);
so <Ref Oper="\[\]"/> denotes the operation for element access in a list,
whereas <C>[]</C> denotes an empty list.
(Maybe the variable names involving special characters look strange,
but nevertheless they are quite suggestive.)
<P/>
<C>\[\]( <A>list</A>, <A>ix</A> )</C> is equivalent to
<C><A>list</A>[ <A>ix</A> ]</C>,
which clearly will usually be preferred;
the former is useful mainly if one wants to access the operation itself,
for example if one wants to install a method for element access in a
special kind of lists.
<P/>
The syntax <C><A>list</A>[ <A>ix1</A>, <A>ix2</A>,.... <A>ixn</A>
]</C>, with two or more indices is treated as a shorthand for
<C><A>list</A>[[ <A>ix1</A>, <A>ix2</A>,.... <A>ixn</A>]]</C>

This is intended to provide a nicer syntax for accessing elements of
matrices and tensors.

<P/>
Similarly,
<Ref Oper="IsBound\[\]"/> is used explicitly mainly in method installations.
In other situations, one can simply call
<Ref Func="IsBound" Label="for a list index"/>,
which then delegates to <Ref Oper="IsBound\[\]"/>
if the first argument is a list,
and to <Ref Oper="IsBound\."/> if the first argument is a record.
<P/>
Analogous statements hold for <Ref Oper="\[\]\:\="/>
and <Ref Oper="Unbind\[\]"/>.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="List Elements">
<Heading>List Elements</Heading>

<Index Subkey="list elements">accessing</Index>
<Index Subkey="access">list element</Index>
<C><A>list</A>[ <A>ix</A> ]</C>
<P/>
The above construct evaluates to the element of the list
<A>list</A> with index <A>ix</A>.
For built-in list types and collections, indexing is done with origin 1,
i.e., the first element of the list is the element with index 1.
<Example><![CDATA[
gap> l := [ 2, 3, 5, 7, 11, 13 ];;  l[1];  l[2];  l[6];
2
3
13
]]></Example>
If <A>list</A> is not a built-in list, or <A>ix</A> does not evaluate to a
positive integer, method selection is invoked to try and find a way of
indexing <A>list</A> with index <A>ix</A>. If this fails, or the
selected method finds that
<C><A>list</A>[<A>ix</A>]</C> is unbound, an error is signalled.
<P/>
<Index>multiple indices</Index>
<C><A>list</A>[ <A>ix1</A>,<A>ix2</A>,...]</C> <P/> is a short-hand for <C><A>list</A>[[<A>ix1</A>,<A>ix2</A>,...]]</C>
<P/>

<Index>sublist</Index>
<Index Subkey="access">sublist</Index>
<C><A>list</A>{ <A>poss</A> }</C>
<P/>
The above construct evaluates to a new list <A>new</A> whose first element is
<C><A>list</A>[<A>poss</A>[1]]</C>,
whose second element is <C><A>list</A>[<A>poss</A>[2]]</C>, and so on.
However, it does not need to be sorted and may contain duplicate elements.
If for any <M>i</M>,
<C><A>list</A>[ <A>poss</A>[</C><M>i</M><C>] ]</C> is unbound,
an error is signalled.
<P/>
<Example><![CDATA[
gap> l := [ 2, 3, 5, 7, 11, 13, 17, 19 ];;
gap> l{[4..6]};  l{[1,7,1,8]};
[ 7, 11, 13 ]
[ 2, 17, 2, 19 ]
]]></Example>
<P/>
The result is a <E>new</E> list, that is not identical to any other list. The
elements of that list, however, are identical to the corresponding elements
of the left operand (see&nbsp;<Ref Sect="Identical Lists"/>).
<P/>
It is possible to nest such <E>sublist extractions</E>, as can be seen in the
example below.
<P/>
<Example><![CDATA[
gap> m := [ [1,2,3], [4,5,6], [7,8,9], [10,11,12] ];;  m{[1,2,3]}{[3,2]};
[ [ 3, 2 ], [ 6, 5 ], [ 9, 8 ] ]
gap> l := m{[1,2,3]};; l{[3,2]};
[ [ 7, 8, 9 ], [ 4, 5, 6 ] ]
]]></Example>
<P/>
Note the difference between the two examples.  The latter extracts
elements 1, 2, and 3 from <A>m</A> and then extracts the elements 3 and 2 from
<E>this list</E>.
The former extracts elements 1, 2, and 3 from <A>m</A> and then
extracts the elements 3 and 2 from <E>each of those element lists</E>.
<P/>
To be precise:
With each selector <C>[<A>pos</A>]</C> or <C>{<A>poss</A>}</C> we associate
a <E>level</E> that is defined as the number of selectors of the form
<C>{<A>poss</A>}</C> to its left in the same expression. For example
<P/>
<Listing><![CDATA[
    l[pos1]{poss2}{poss3}[pos4]{poss5}[pos6]
level   0      0      1     2      2     3
]]></Listing>
<P/>
Then  a selector <C><A>list</A>[<A>pos</A>]</C> of level <A>level</A> is
computed as <C>ListElement(<A>list</A>,<A>pos</A>,<A>level</A>)</C>,
where <C>ListElement</C> is defined as follows.
(Note that <C>ListElement</C> is <E>not</E> a &GAP; function.)
<P/>
<Log><![CDATA[
ListElement := function ( list, pos, level )
 if level = 0 then
  return list[pos];
 else
  return List( list, elm -> ListElement(elm,pos,level-1) );
 fi;
end;
]]></Log>
<P/>
and a selector <C><A>list</A>{<A>poss</A>}</C> of level <A>level</A> is
computed as <C>ListElements(<A>list</A>,<A>poss</A>,<A>level</A>)</C>,
where <C>ListElements</C> is defined as follows.
(Note that <C>ListElements</C> is <E>not</E> a &GAP; function.)
<P/>
<Log><![CDATA[
ListElements := function ( list, poss, level )
 if level = 0 then
  return list{poss};
  else
   return List( list, elm -> ListElements(elm,poss,level-1) );
  fi;
end;
]]></Log>
<P/>
<Index Subkey="operation">sublist</Index>
<ManSection>
<Oper Name="\{\}" Arg='list, poss'/>

<Description>
This operation implements <E>sublist access</E>.
For any list, the default method is to loop over the entries in the list
<A>poss</A>, and to delegate to the element access operation.
(For the somewhat strange variable name,
cf.&nbsp;<Ref Sect="Basic Operations for Lists"/>.)
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="List Assignment">
<Heading>List Assignment</Heading>

<Index Subkey="to a list">assignment</Index>
<Index Subkey="assignment">list element</Index>
<C><A>list</A>[ <A>ix</A> ] := <A>object</A>;</C>
<P/>
The list element assignment assigns the object <A>object</A>,
which can be of any type, to the list with index <A>ix</A>,
in the mutable (see&nbsp;<Ref Sect="Mutability and Copyability"/>) list
<A>list</A>.
That means that accessing the <A>ix</A>-th element of the list <A>list</A>
will return <A>object</A> after this assignment.
<P/>
<Example><![CDATA[
gap> l := [ 1, 2, 3 ];;
gap> l[1] := 3;; l;             # assign a new object
[ 3, 2, 3 ]
gap> l[2] := [ 4, 5, 6 ];; l;   # <object> may be of any type
[ 3, [ 4, 5, 6 ], 3 ]
gap> l[ l[1] ] := 10;; l;       # <index> may be an expression
[ 3, [ 4, 5, 6 ], 10 ]
]]></Example>
<P/>
If the index <A>ix</A> is an integer larger than the length of the list <A>list</A>
(see <Ref Func="Length"/>),
the list is automatically enlarged to make room for the new element.
Note that it is possible to generate lists with holes that way.
<P/>
<Example><![CDATA[
gap> l[4] := "another entry";; l;  # <list> is enlarged
[ 3, [ 4, 5, 6 ], 10, "another entry" ]
gap> l[ 10 ] := 1;; l;             # now <list> has a hole
[ 3, [ 4, 5, 6 ], 10, "another entry",,,,,, 1 ]
]]></Example>
<P/>
The  function <Ref Func="Add"/> should be used if you want to add an
element to the end of the list.
<P/>
Note that assigning to a list changes the list,
thus this list must be mutable
(see&nbsp;<Ref Sect="Mutability and Copyability"/>).
See&nbsp;<Ref Sect="Identical Lists"/> for subtleties of changing lists.
<P/>
If <A>list</A> does not evaluate to a list, <A>pos</A> does not evaluate to a
positive integer or <A>object</A> is a call to a function which does not
return a value (for example <C>Print</C>) an error is signalled.
<P/>
<Index Subkey="assignment">multiple indices</Index>
<C><A>list</A>[ <A>ix1</A>,<A>ix2</A>,...] := <A>obj</A></C>
<P/> is a short-hand for <C><A>list</A>[[<A>ix1</A>,<A>ix2</A>,...]]
:= <A>obj</A></C>.<P/>
<Index Subkey="assignment">sublist</Index>
<C><A>list</A>{ <A>poss</A> } := <A>objects</A>;</C>
<P/>
The sublist assignment assigns the object <C><A>objects</A>[1]</C>,
which can be of any type, to the list <A>list</A> at the position
<C><A>poss</A>[1]</C>, the object <C><A>objects</A>[2]</C> to
<C><A>list</A>[<A>poss</A>[2]]</C>, and so on. <A>poss</A> must be a dense
list of positive integers, it need, however, not be sorted and may
contain duplicate elements. <A>objects</A> must be a dense list and must have
the same length as <A>poss</A>.
<P/>
<Example><![CDATA[
gap> l := [ 2, 3, 5, 7, 11, 13, 17, 19 ];;
gap> l{[1..4]} := [10..13];; l;
[ 10, 11, 12, 13, 11, 13, 17, 19 ]
gap> l{[1,7,1,10]} := [ 1, 2, 3, 4 ];; l;
[ 3, 11, 12, 13, 11, 13, 2, 19,, 4 ]
]]></Example>
<P/>
The next example shows that it is possible to nest such sublist assignments.
<P/>
<Example><![CDATA[
gap> m := [ [1,2,3], [4,5,6], [7,8,9], [10,11,12] ];;
gap> m{[1,2,3]}{[3,2]} := [ [11,12], [13,14], [15,16] ];; m;
[ [ 1, 12, 11 ], [ 4, 14, 13 ], [ 7, 16, 15 ], [ 10, 11, 12 ] ]
]]></Example>
<P/>
The exact behaviour is defined in the same way as for list extractions
(see <Ref Sect="List Elements"/>).
Namely, with each selector <C>[<A>pos</A>]</C> or <C>{<A>poss</A>}</C>
we associate a <E>level</E> that is defined as the number of selectors
of the form <C>{<A>poss</A>}</C> to its left in the same expression.
For example
<P/>
<Log><![CDATA[
    l[pos1]{poss2}{poss3}[pos4]{poss5}[pos6]
level   0      0      1     1      1     2
]]></Log>
<P/>
Then a list assignment <C><A>list</A>[<A>pos</A>] := <A>vals</A>;</C> of
level <A>level</A> is computed as
<C>ListAssignment( <A>list</A>, <A>pos</A>, <A>vals</A>, <A>level</A> )</C>,
where <C>ListAssignment</C> is defined as follows.
(Note that <C>ListAssignment</C> is <E>not</E> a &GAP; function.)
<P/>
<Log><![CDATA[
ListAssignment := function ( list, pos, vals, level )
 local i;
 if level = 0 then
  list[pos] := vals;
 else
  for i in [1..Length(list)] do
   ListAssignment( list[i], pos, vals[i], level-1 );
  od;
 fi;
end;
]]></Log>
<P/>
and a list assignment <C><A>list</A>{<A>poss</A>} := <A>vals</A></C> of
level <A>level</A> is computed as
<C>ListAssignments( <A>list</A>, <A>poss</A>, <A>vals</A>, <A>level</A> )</C>,
where <C>ListAssignments</C> is defined as follows.
(Note that <C>ListAssignments</C> is <E>not</E> a &GAP; function.)
<P/>
<Log><![CDATA[
ListAssignments := function ( list, poss, vals, level )
 local i;
 if level = 0 then
  list{poss} := vals;
 else
  for i in [1..Length(list)] do
   ListAssignments( list[i], poss, vals[i], level-1 );
  od;
 fi;
end;
]]></Log>
<P/>
<Index Subkey="operation">sublist assignment</Index>
<ManSection>
<Oper Name="\{\}\:\=" Arg='list, poss, val'/>

<Description>
This operation implements sublist assignment.
For any list, the default method is to loop over the entries in the list
<A>poss</A>, and to delegate to the element assignment operation.
(For the somewhat strange variable name,
cf.&nbsp;<Ref Sect="Basic Operations for Lists"/>.)
</Description>
</ManSection>

<ManSection>
<Oper Name="Add" Arg='list, obj[, pos]'/>

<Description>
adds the element <A>obj</A> to the mutable list <A>list</A>.
The two argument version adds <A>obj</A> at the end of <A>list</A>,
i.e., it is equivalent to the assignment
<C><A>list</A>[ Length(<A>list</A>) + 1 ] := <A>obj</A></C>,
see&nbsp;<Ref Sect="List Assignment"/>.
<P/>
The three argument version adds <A>obj</A> in position <A>pos</A>,
moving all later elements of the list (if any) up by one position.
Any holes at or after position <A>pos</A> are also moved up by one
position, and new holes are created before <A>pos</A> if they are needed.
<P/>
Nothing is returned by <Ref Oper="Add"/>,
the function is only called for its side effect.
</Description>
</ManSection>

<ManSection>
<Oper Name="Remove" Arg='list[, pos]'/>

<Description>
removes an element from <A>list</A>.
The one argument form removes the last element.
The two argument form removes the element in position <A>pos</A>,
moving all subsequent elements down one position. Any holes after
position <A>pos</A> are also moved down by one position.
<P/>
The one argument form always returns the removed element.
In this case <A>list</A> must be non-empty.
<P/>
The two argument form returns the old value of <A>list</A>[<A>pos</A>]
if it was bound, and nothing if it was not.
Note that accessing or assigning the return value of this form of
the <Ref Oper="Remove"/> operation is only safe when you <E>know</E>
that there will be a  value, otherwise it will cause an error.
<P/>
<Example><![CDATA[
gap> l := [ 2, 3, 5 ];; Add( l, 7 ); l;
[ 2, 3, 5, 7 ]
gap> Add(l,4,2); l;
[ 2, 4, 3, 5, 7 ]
gap> Remove(l,2); l;
4
[ 2, 3, 5, 7 ]
gap> Remove(l); l;
7
[ 2, 3, 5 ]
gap> Remove(l,5); l;
[ 2, 3, 5 ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="CopyListEntries"
 Arg='fromlst, fromind, fromstep, tolst, toind, tostep, n'/>

<Description>
This function copies <A>n</A> elements from <A>fromlst</A>,
starting at position <A>fromind</A> and incrementing the position by
<A>fromstep</A> each time,
into <A>tolst</A> starting at position <A>toind</A>
and incrementing the position by <A>tostep</A> each time.
<A>fromlst</A> and <A>tolst</A> must be plain lists.
<A>fromstep</A> and/or <A>tostep</A> can be negative.
Unbound positions of <A>fromlst</A> are simply copied to <A>tolst</A>.
<P/>
<Ref Func="CopyListEntries"/> is used in methods for
the operations <Ref Func="Add"/> and <Ref Func="Remove"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Append" Arg='list1, list2'/>

<Description>
adds the elements of the list <A>list2</A> to the end of the mutable list
<A>list1</A>, see&nbsp;<Ref Sect="List Assignment"/>.
<A>list2</A> may contain holes, in which case the corresponding entries
in <A>list1</A> will be left unbound.
<Ref Oper="Append"/> returns nothing,
it is only called for its side effect.
<P/>
Note that <Ref Oper="Append"/> changes its first argument,
while <Ref Func="Concatenation" Label="for a list of lists"/> creates
a new list and leaves its arguments unchanged.
<P/>
<Example><![CDATA[
gap> l := [ 2, 3, 5 ];; Append( l, [ 7, 11, 13 ] ); l;
[ 2, 3, 5, 7, 11, 13 ]
gap> Append( l, [ 17,, 23 ] ); l;
[ 2, 3, 5, 7, 11, 13, 17,, 23 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="IsBound and Unbind for Lists">
<Heading>IsBound and Unbind for Lists</Heading>

<ManSection>
<Oper Name="IsBound" Arg='list[n]' Label="for a list index"/>
<Oper Name="IsBound" Arg='list[ix1,ix2,...]' Label="for multiple indices"/>

<Description>
<Ref Func="IsBound" Label="for a list index"/> returns <K>true</K>
if the list <A>list</A> has a element at index <A>n</A>,
and <K>false</K> otherwise.
<A>list</A> must evaluate to a list, otherwise an error is signalled.
<P/>
<Example><![CDATA[
gap> l := [ , 2, 3, , 5, , 7, , , , 11 ];;
gap> IsBound( l[7] );
true
gap> IsBound( l[4] );
false
gap> IsBound( l[101] );
false
]]></Example>

<C>IsBound(<A>list</A>[<A>ix1</A>,<A>ix2</A>,...]</C> is a short-hand for  
<C>IsBound(<A>list</A>[[<A>ix1</A>,<A>ix2</A>,...]]</C>   
</Description>
</ManSection>

<ManSection>
<Oper Name="Unbind" Arg='list[n]' Label="unbind a list entry"/>
<Oper Name="Unbind" Arg='list[ix1,ix2,...]' Label="for multiple indices"/>

<Description>
<Ref Func="Unbind" Label="unbind a list entry"/> deletes the element with index
<A>n</A> in the mutable list <A>list</A>.  That is, after
execution of <Ref Func="Unbind" Label="unbind a list entry"/>,
<A>list</A> no longer has an assigned value with index <A>n</A>.
Thus <Ref Func="Unbind" Label="unbind a list entry"/> can be used to
produce holes in a list.
Note that it is not an error to unbind a nonexistant list element.
<A>list</A> must evaluate to a list, otherwise an error is signalled.
<P/>
<Example><![CDATA[
gap> l := [ , 2, 3, 5, , 7, , , , 11 ];;
gap> Unbind( l[3] ); l;
[ , 2,, 5,, 7,,,, 11 ]
gap> Unbind( l[4] ); l;
[ , 2,,,, 7,,,, 11 ]
]]></Example>
<P/>
Note that <Ref Func="IsBound" Label="for a list index"/> and
<Ref Func="Unbind" Label="unbind a list entry"/> are special
in that they do not evaluate their argument,
otherwise <Ref Func="IsBound" Label="for a list index"/>
would always signal an error when it is supposed to return <K>false</K>
and there would be no way to tell
<Ref Func="Unbind" Label="unbind a list entry"/>
which component to remove.
<C>Unbind(<A>list</A>[<A>ix1</A>,<A>ix2</A>,...]</C> is a short-hand for  
<C>Unbind(<A>list</A>[[<A>ix1</A>,<A>ix2</A>,...]]</C>   
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Identical Lists">
<Heading>Identical Lists</Heading>

With the list assignment (see&nbsp;<Ref Sect="List Assignment"/>) it is
possible to change a mutable list.
This section describes the semantic consequences of this fact.
(See also&nbsp;<Ref Sect="Identical Objects"/>.)
<P/>
First we define what it means when we say that <Q>an object is changed</Q>.
You may think that in the following example the second assignment changes
the integer.
<P/>
<Log><![CDATA[
i := 3;
i := i + 1;
]]></Log>
<P/>
But in this example it is not the <E>integer</E> <C>3</C> which is changed,
by adding one to it.
Instead the <E>variable</E> <C>i</C> is changed by assigning the value of
<C>i+1</C>,
which happens to be <C>4</C>, to <C>i</C>.
The same thing happens in the example below.
<P/>
<Log><![CDATA[
l := [ 1, 2 ];
l := [ 1, 2, 3 ];
]]></Log>
<P/>
The second assignment does not change the first list, instead it assigns
a new list to the variable <C>l</C>.  On the other hand, in the following
example the list <E>is</E> changed by the second assignment.
<P/>
<Log><![CDATA[
l := [ 1, 2 ];
l[3] := 3;
]]></Log>
<P/>
To understand the difference, think of a variable as a name for an
object. The important point is that a list can have several names at the
same time.  An assignment <C><A>var</A>:= <A>list</A>;</C> means in this
interpretation that <A>var</A> is a name for the object <A>list</A>.
At the end of the following example <C>l2</C> still has the value
<C>[ 1, 2 ]</C> as this list has not been changed and nothing else has been
assigned to it.
<P/>
<Log><![CDATA[
l1 := [ 1, 2 ];
l2 := l1;
l1 := [ 1, 2, 3 ];
]]></Log>
<P/>
But after the following example the list for which <C>l2</C> is a name has
been changed and thus the value of <C>l2</C> is now <C>[ 1, 2, 3 ]</C>.
<P/>
<Log><![CDATA[
l1 := [ 1, 2 ];
l2 := l1;
l1[3] := 3;
]]></Log>
<P/>
We say that two lists are <E>identical</E> if changing one of them by a
list assignment also changes the other one.  This is slightly incorrect,
because if <E>two</E> lists are identical, there are actually only two names
for <E>one</E> list. However, the correct usage would be very awkward and
would only add to the confusion.  Note that two identical lists must be
equal, because there is only one list with two different names. Thus
identity is an equivalence relation that is a refinement of equality.
Identity of objects can be detected using <Ref Func="IsIdenticalObj"/>.
<P/>
Let us now consider under which circumstances two lists are identical.
<P/>
If you enter a list literal then the list denoted by this literal is a
new list that is not identical to any other list.
Thus in the following example <C>l1</C> and <C>l2</C> are not identical,
though they are equal of course.
<P/>
<Log><![CDATA[
l1 := [ 1, 2 ];
l2 := [ 1, 2 ];
]]></Log>
<P/>
Also in the following example, no lists in the list <C>l</C> are identical.
<P/>
<Log><![CDATA[
l := [];
for i in [1..10] do l[i] := [ 1, 2 ]; od;
]]></Log>
<P/>
If you assign a list to a variable no new list is created. Thus the list
value of the variable on the left hand side and the list on the right
hand side of the assignment are identical. So in the following example
<C>l1</C> and <C>l2</C> are identical lists.
<P/>
<Log><![CDATA[
l1 := [ 1, 2 ];
l2 := l1;
]]></Log>
<P/>
If you pass a list as an argument, the old list and the argument of the
function are identical. Also if you return a list from a function, the
old list and the value of the function call are identical. So in the
following example <C>l1</C> and <C>l2</C> are identical lists:
<P/>
<Log><![CDATA[
l1 := [ 1, 2 ];
f := function ( l ) return l; end;
l2 := f( l1 );
]]></Log>
<P/>
If you change a list it keeps its identity.  Thus if two lists are
identical and you change one of them, you also change the other, and they
are still identical afterwards. On the other hand, two lists that are
not identical will never become identical if you change one of them. So
in the following example both <C>l1</C> and <C>l2</C> are changed,
and are still identical.
<P/>
<Log><![CDATA[
l1 := [ 1, 2 ];
l2 := l1;
l1[1] := 2;
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Duplication of Lists">
<Heading>Duplication of Lists</Heading>

Here we describe the meaning of <Ref Func="ShallowCopy"/> and
<Ref Func="StructuralCopy"/> for lists.
For the general definition of these functions,
see&nbsp;<Ref Sect="Duplication of Objects"/>.
<P/>
<Index Key="ShallowCopy" Subkey="for lists"><C>ShallowCopy</C></Index>
The subobjects (see&nbsp;<Ref Func="ShallowCopy"/>) of a list are exactly
its elements.
<P/>
This means that for any list <A>list</A>,
<Ref Func="ShallowCopy"/> returns a mutable <E>new</E> list <A>new</A>
that is <E>not identical</E> to any other list
(see&nbsp;<Ref Sect="Identical Lists"/>),
and whose elements are identical to the elements of <A>list</A>.
<P/>
<Index Key="StructuralCopy" Subkey="for lists"><C>StructuralCopy</C></Index>
Analogously, for a <E>mutable</E> list <A>list</A>,
<Ref Func="StructuralCopy"/> returns a mutable <E>new</E> list <A>scp</A>
that is <E>not identical</E> to any other list,
and whose elements are structural copies (defined recursively)
of the elements of <A>list</A>;
an element of <A>scp</A> is mutable (and then a <E>new</E> list)
if and only if the corresponding element of <A>list</A> is mutable.
<P/>
In both cases, modifying the copy <A>new</A> resp.&nbsp;<A>scp</A> by
assignments (see&nbsp;<Ref Sect="List Assignment"/>) does not modify
the original object <A>list</A>.
<P/>
<Ref Func="ShallowCopy"/> basically executes the following code for lists.
<Log><![CDATA[
new := [];
for i in [ 1 .. Length( list ) ] do
  if IsBound( list[i] ) then
    new[i] := list[i];
  fi;
od;
]]></Log>
<P/>
<Example><![CDATA[
gap> list1 := [ [ 1, 2 ], [ 3, 4 ] ];;  list2 := ShallowCopy( list1 );;
gap> IsIdenticalObj( list1, list2 );
false
gap> IsIdenticalObj( list1[1], list2[1] );
true
gap> list2[1] := 0;;  list1;  list2;
[ [ 1, 2 ], [ 3, 4 ] ]
[ 0, [ 3, 4 ] ]
]]></Example>
<P/>
<Ref Func="StructuralCopy"/> basically executes the following code for lists.
<Log><![CDATA[
new := [];
for i in [ 1 .. Length( list ) ] do
  if IsBound( list[i] ) then
    new[i] := StructuralCopy( list[i] );
  fi;
od;
]]></Log>
<P/>
<Example><![CDATA[
gap> list1 := [ [ 1, 2 ], [ 3, 4 ] ];;  list2 := StructuralCopy( list1 );;
gap> IsIdenticalObj( list1, list2 );
false
gap> IsIdenticalObj( list1[1], list2[1] );
false
gap> list2[1][1] := 0;;  list1;  list2;
[ [ 1, 2 ], [ 3, 4 ] ]
[ [ 0, 2 ], [ 3, 4 ] ]
]]></Example>
<P/>
The above code is not entirely correct. If the object <A>list</A> contains a
mutable object twice this object is not copied twice,
as would happen with the above definition, but only once.
This means that the copy <A>new</A> and the object <A>list</A> have exactly
the same structure when viewed as a general graph.
<P/>
<Example><![CDATA[
gap> sub := [ 1, 2 ];; list1 := [ sub, sub ];;
gap> list2 := StructuralCopy( list1 );
[ [ 1, 2 ], [ 1, 2 ] ]
gap> list2[1][1] := 0;; list2;
[ [ 0, 2 ], [ 0, 2 ] ]
gap> list1;
[ [ 1, 2 ], [ 1, 2 ] ]
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Membership Test for Lists">
<Heading>Membership Test for Lists</Heading>

<ManSection>
<Oper Name="\in" Arg="obj, list" Label="element test for lists"/>

<Description>
<Index Key="in" Subkey="for lists"><K>in</K></Index>
<Index Subkey="for lists">element test</Index>
This function call or the infix variant
<A>obj</A>&nbsp;<K>in</K>&nbsp;<A>list</A>
tests whether there is a positive integer <M>i</M> such that
<A>list</A><M>[i] =</M> <A>obj</A> holds.
<P/>
If the list <A>list</A> knows that it is strictly sorted
(see&nbsp;<Ref Func="IsSSortedList"/>),
the membership test is much quicker, because a binary search can be used
instead of the linear search used for arbitrary lists,
see <Ref Meth="\in" Label="for strictly sorted lists"/>.
<P/>
<Example><![CDATA[
gap> 1 in [ 2, 2, 1, 3 ];  1 in [ 4, -1, 0, 3 ];
true
false
gap> s := SSortedList( [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32] );;
gap> 17 in s;  # uses binary search and only 4 comparisons
false
]]></Example>
<P/>
For finding the position of an element in a list,
see&nbsp;<Ref Sect="Finding Positions in Lists"/>.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Enlarging Internally Represented Lists">
<Heading>Enlarging Internally Represented Lists</Heading>

Section&nbsp;<Ref Sect="List Assignment"/> told you (among other things)
that it is possible to assign beyond the logical end of a mutable list,
automatically enlarging the list.
This section tells you how this is done for internally represented lists.
<P/>
It would be extremely wasteful to make all lists large enough so that
there is room for all assignments, because some lists may have more than
100000 elements, while most lists have less than 10 elements.
<P/>
On the other hand suppose every assignment beyond the end of a list would
be done by allocating new space for the list and copying all entries to
the new space. Then creating a list of 1000 elements by assigning them
in order, would take half a million copy operations and also create a lot
of garbage that the garbage collector would have to reclaim.
<P/>
So the following strategy is used.  If a list is created it is created
with exactly the correct size. If a  list is enlarged, because of an
assignment beyond  the end of the list,  it is enlarged  by at least
<C><A>length</A>/8 + 4</C> entries.
Therefore the next assignments beyond the end of the list do not need
to enlarge the list.
For example creating a list of 1000 elements by assigning them in order,
would now take only 32 enlargements.
<P/>
The result of this is of course that the <E>physical length</E> of a list
may be larger than the <E>logical length</E>,
which is usually called simply the length of the list.
Aside from the implications for the performance you need not be aware
of the physical length.
In fact all you can ever observe, for example by calling
<Ref Func="Length"/>, is the logical length.
<P/>
Suppose that <Ref Func="Length"/> would have to take the physical length
and then test how many entries at the end of a list are unassigned,
to compute the logical length of the list. That would take too much time.
In order to make <Ref Func="Length"/>, and other functions that need to know
the logical length, more efficient,
the length of a list is stored along with the list.
<P/>
For fine tuning code dealing with plain lists we provide the following 
two functions.
<P/>
<ManSection>
<Func Arg="len" Name="EmptyPlist"/>
<Returns>a plain list</Returns>
<Func Arg="l" Name="ShrinkAllocationPlist"/>
<Returns>nothing</Returns>
<Description>
The function <Ref Func="EmptyPlist"/> returns an empty plain list which
has enough memory allocated for <A>len</A> entries. This can be useful
for creating and filling a plain list with a known number of entries. 
<P/>
The function <Ref Func="ShrinkAllocationPlist"/> gives back to &GAP;'s
memory manager the physical memory which is allocated for the plain list
<A>l</A> but not needed by the current number of entries.
<P/>
Note that there are similar functions <Ref Func="EmptyString"/> and
<Ref Func="ShrinkAllocationString"/> for strings instead of plain lists.
<Example>
gap> l:=[]; for i in [1..160] do Add(l, i^2); od; 
[  ]
gap> m:=EmptyPlist(160); for i in [1..160] do Add(m, i^2); od;
[  ]
gap> # now l uses about 25% more memory than the equal list m
gap> ShrinkAllocationPlist(l);
gap> # now l and m use the same amount of memory
</Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons of Lists">
<Heading>Comparisons of Lists</Heading>

<Index Subkey="of lists">comparisons</Index>
<Index Subkey="comparison">list equal</Index>
<C><A>list1</A> = <A>list2</A></C>
<P/>
<C><A>list1</A> &lt;> <A>list2</A></C>
<P/>
Two lists <A>list1</A> and <A>list2</A> are equal if and only if for
every index <M>i</M>,
either both entries <A>list1</A><M>[i]</M> and <A>list2</A><M>[i]</M>
are unbound, or both are bound and are equal, i.e.,
<A>list1</A><M>[i] =</M> <A>list2</A><M>[i]</M> is <K>true</K>.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3 ] = [ 1, 2, 3 ];
true
gap> [ , 2, 3 ] = [ 1, 2, ];
false
gap> [ 1, 2, 3 ] = [ 3, 2, 1 ];
false
]]></Example>
<P/>
This definition will cause problems with lists which are their own entries.
Comparing two such lists for equality may lead to an infinite recursion in
the kernel if the list comparison has to compare the list entries which are
in fact the lists themselves,
and then &GAP; crashes.
<P/>
<Index Subkey="comparison">list smaller</Index>
<C><A>list1</A> &lt; <A>list2</A></C>
<P/>
<C><A>list1</A> &lt;= <A>list2</A></C>
<P/>
Lists are ordered <E>lexicographically</E>.
Unbound entries are smaller than any bound entry.
That implies the following behaviour.
Let <M>i</M> be the smallest positive integer <M>i</M> such that <A>list1</A>
and <A>list2</A> at position <M>i</M> differ,
i.e., either exactly one of <A>list1</A><M>[i]</M>, <A>list2</A><M>[i]</M>
is bound or both entries are bound and differ.
Then <A>list1</A> is less than <A>list2</A> if either
<A>list1</A><M>[i]</M> is unbound (and <A>list2</A><M>[i]</M> is not)
or both are bound and
<A>list1</A><M>[i]</M> &lt; <A>list2</A><M>[i]</M> is <K>true</K>.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3, 4 ] < [ 1, 2, 4, 8 ]; # <list1>[3] < <list2>[3]
true
gap> [ 1, 2, 3 ] < [ 1, 2, 3, 5 ];  # <list1>[4] is unbound and thus < 5
true
gap> [ 1, , 3, 4 ] < [ 1, -1, 3 ];  # <list1>[2] is unbound and thus < -1
true
]]></Example>
<P/>
Note that for comparing two lists with <C>&lt;</C> or <C>&lt;=</C>,
the (relevant) list elements must be comparable with <C>&lt;</C>,
which is usually <E>not</E> the case for objects in different families,
see&nbsp;<Ref Sect="Families"/>.
Also for the possibility to compare lists with other objects,
see&nbsp;<Ref Sect="Families"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic for Lists">
<Heading>Arithmetic for Lists</Heading>

<Index Subkey="for lists">operators</Index>

It is convenient to have arithmetic operations for lists,
in particular because in &GAP;
row vectors and matrices are special kinds of lists.
However, it is the wide variety of list objects because of which we
prescribe arithmetic operations <E>not for all</E> of them.
(Keep in mind that <Q>list</Q> means just an object in the category
<Ref Func="IsList"/>.)
<P/>
(Due to the intended generality and flexibility,
the definitions given in the following sections are quite technical.
But for not too complicated cases
such as matrices (see&nbsp;<Ref Sect="Operators for Matrices"/>)
and row vectors (see&nbsp;<Ref Sect="Operators for Row Vectors"/>)
whose entries aren't lists,
the resulting behaviour should be intuitive.)
<P/>
For example, we want to deal with matrices which can be added and
multiplied in the usual way, via the infix operators <C>+</C> and <C>*</C>;
and we want also Lie matrices, with the same additive behaviour but with
the multiplication defined by the Lie bracket.
Both kinds of matrices shall be lists, with the usual access to their rows,
with <Ref Func="Length"/> returning the number of rows etc.
<P/>
For the categories and attributes that control the arithmetic behaviour
of lists,
see&nbsp;<Ref Sect="Filters Controlling the Arithmetic Behaviour of Lists"/>.
<P/>
For the definition of return values of additive and multiplicative operations
whose arguments are lists in these filters,
see&nbsp;<Ref Sect="Additive Arithmetic for Lists"/> and
<Ref Sect="Multiplicative Arithmetic for Lists"/>, respectively.
It should be emphasized that these sections describe only what the return
values are, and not how they are computed.
<P/>
For the mutability status of the return values,
see&nbsp;<Ref Sect="Mutability Status and List Arithmetic"/>.
(Note that this is not dealt with in the sections about the result values.)
<P/>
Further details about the special cases of row vectors and matrices
can be found in&nbsp;<Ref Sect="Operators for Row Vectors"/> and
in&nbsp;<Ref Sect="Operators for Matrices"/>,
the compression status is dealt with
in&nbsp;<Ref Sect="Row Vectors over Finite Fields"/>
and&nbsp;<Ref Sect="Matrices over Finite Fields"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Filters Controlling the Arithmetic Behaviour of Lists">
<Heading>Filters Controlling the Arithmetic Behaviour of Lists</Heading>

The arithmetic behaviour of lists is controlled by their types.
The following categories and attributes are used for that.
<P/>
Note that we distinguish additive and multiplicative behaviour.
For example, Lie matrices have the usual additive behaviour but not the
usual multiplicative behaviour.

<ManSection>
<Filt Name="IsGeneralizedRowVector" Arg='list' Type='Category'/>

<Description>
For a list <A>list</A>, the value <K>true</K> for
<Ref Func="IsGeneralizedRowVector"/>
indicates that the additive arithmetic behaviour of <A>list</A> is
as defined in <Ref Sect="Additive Arithmetic for Lists"/>,
and that the attribute <Ref Func="NestingDepthA"/>
will return a nonzero value when called with <A>list</A>.
<P/>
<Example><![CDATA[
gap> IsList( "abc" ); IsGeneralizedRowVector( "abc" );
true
false
gap> liemat:= LieObject( [ [ 1, 2 ], [ 3, 4 ] ] );
LieObject( [ [ 1, 2 ], [ 3, 4 ] ] )
gap> IsGeneralizedRowVector( liemat );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMultiplicativeGeneralizedRowVector" Arg='list'
 Type='Category'/>

<Description>
For a list <A>list</A>, the value <K>true</K> for
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> indicates that the
multiplicative arithmetic behaviour of <A>list</A> is as defined
in <Ref Sect="Multiplicative Arithmetic for Lists"/>,
and that the attribute <Ref Func="NestingDepthM"/>
will return a nonzero value when called with <A>list</A>.
<P/>
<Example><![CDATA[
gap> IsMultiplicativeGeneralizedRowVector( liemat );
false
gap> bas:= CanonicalBasis( FullRowSpace( Rationals, 3 ) );
CanonicalBasis( ( Rationals^3 ) )
gap> IsMultiplicativeGeneralizedRowVector( bas );
true
]]></Example>
<P/>
Note that the filters <Ref Func="IsGeneralizedRowVector"/>,
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>
do <E>not</E> enable default methods for addition or multiplication
(cf.&nbsp;<Ref Func="IsListDefault"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsListDefault" Arg='list' Type='Category'/>

<Description>
For a list <A>list</A>, <Ref Func="IsListDefault"/> indicates that the
default methods for arithmetic operations of lists, such as pointwise
addition and multiplication as inner product or matrix product,
shall be applicable to <A>list</A>.
<P/>
<Ref Func="IsListDefault"/> implies <Ref Func="IsGeneralizedRowVector"/>
and <Ref Func="IsMultiplicativeGeneralizedRowVector"/>.
<P/>
All internally represented lists are in this category,
and also all lists in the representations <C>IsGF2VectorRep</C>,
<C>Is8BitVectorRep</C>, <C>IsGF2MatrixRep</C>, and
<C>Is8BitMatrixRep</C>
(see&nbsp;<Ref Sect="Row Vectors over Finite Fields"/> and
<Ref Sect="Matrices over Finite Fields"/>).
<!--  strings and blists:-->
<!--  It does not really make sense to have them in <C>IsGeneralizedRowVector</C>.-->
Note that the result of an arithmetic operation with lists in
<Ref Func="IsListDefault"/> will in general be an internally represented
list, so most <Q>wrapped list objects</Q> will not lie in
<Ref Func="IsListDefault"/>.
<P/>
<Example><![CDATA[
gap> v:= [ 1, 2 ];;  m:= [ v, 2*v ];;
gap> IsListDefault( v );  IsListDefault( m );
true
true
gap> IsListDefault( bas );  IsListDefault( liemat );
true
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NestingDepthA" Arg='obj'/>

<Description>
For a &GAP; object <A>obj</A>,
<Ref Func="NestingDepthA"/> returns the <E>additive nesting depth</E>
of <A>obj</A>.
This is defined recursively
as the integer <M>0</M> if <A>obj</A> is not in
<Ref Func="IsGeneralizedRowVector"/>,
as the integer <M>1</M> if <A>obj</A> is an empty list in
<Ref Func="IsGeneralizedRowVector"/>,
and as <M>1</M> plus the additive nesting depth of the first bound entry
in <A>obj</A> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="NestingDepthM" Arg='obj'/>

<Description>
For a &GAP; object <A>obj</A>,
<Ref Attr="NestingDepthM"/> returns the
<E>multiplicative nesting depth</E> of <A>obj</A>.
This is defined recursively as the
integer <M>0</M> if <A>obj</A> is not in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>,
as the integer <M>1</M> if <A>obj</A> is an empty list in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>,
and as <M>1</M> plus the multiplicative nesting depth of the first bound
entry in <A>obj</A> otherwise.
<Example><![CDATA[
gap> NestingDepthA( v );  NestingDepthM( v );
1
1
gap> NestingDepthA( m );  NestingDepthM( m );
2
2
gap> NestingDepthA( liemat );  NestingDepthM( liemat );
2
0
gap> l1:= [ [ 1, 2 ], 3 ];;  l2:= [ 1, [ 2, 3 ] ];;
gap> NestingDepthA( l1 );  NestingDepthM( l1 );
2
2
gap> NestingDepthA( l2 );  NestingDepthM( l2 );
1
1
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Additive Arithmetic for Lists">
<Heading>Additive Arithmetic for Lists</Heading>

In this general context, we define the results of additive operations
only in the following situations.
For unary operations (zero and additive inverse),
the unique argument must be in <Ref Func="IsGeneralizedRowVector"/>;
for binary operations (addition and subtraction),
at least one argument must be in <Ref Func="IsGeneralizedRowVector"/>,
and the other either is not a list or also in
<Ref Func="IsGeneralizedRowVector"/>.
<P/>
(For non-list &GAP; objects, defining the results of unary operations is not
an issue here,
and if at least one argument is a list not in
<Ref Func="IsGeneralizedRowVector"/>,
it shall be left to this argument whether the result in question is defined
and what it is.)

<Subsection Label="Zero for lists">
<Heading>Zero for lists</Heading>

The zero (see&nbsp;<Ref Func="Zero"/>) of a list <M>x</M> in
<Ref Func="IsGeneralizedRowVector"/>
is defined as the list whose entry at position <M>i</M> is the zero of
<M>x[i]</M> if this entry is bound, and is unbound otherwise.
<P/>
<Example><![CDATA[
gap> Zero( [ 1, 2, 3 ] );  Zero( [ [ 1, 2 ], 3 ] );  Zero( liemat );
[ 0, 0, 0 ]
[ [ 0, 0 ], 0 ]
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
]]></Example>

</Subsection>

<Subsection Label="AdditiveInverse for lists">
<Heading>AdditiveInverse for lists</Heading>

The additive inverse (see&nbsp;<Ref Func="AdditiveInverse"/>) of a list
<M>x</M> in <Ref Func="IsGeneralizedRowVector"/> is defined as the list
whose entry at position <M>i</M> is the additive inverse of <M>x[i]</M>
if this entry is bound, and is unbound otherwise.
<P/>
<Example><![CDATA[
gap> AdditiveInverse( [ 1, 2, 3 ] );  AdditiveInverse( [ [ 1, 2 ], 3 ] );
[ -1, -2, -3 ]
[ [ -1, -2 ], -3 ]
]]></Example>

</Subsection>

<Subsection Label="Addition of lists">
<Heading>Addition of lists</Heading>

<Index Subkey="list and non-list">addition</Index>
If <M>x</M> and <M>y</M> are in <Ref Func="IsGeneralizedRowVector"/>
and have the same additive nesting depth
(see&nbsp;<Ref Func="NestingDepthA"/>),
<!-- % By definition, this depth is nonzero. -->
the sum <M>x + y</M> is defined <E>pointwise</E>,
in the sense that the result is a list whose entry at position <M>i</M> is
<M>x[i] + y[i]</M> if these entries are bound,
is a shallow copy (see&nbsp;<Ref Func="ShallowCopy"/>) of <M>x[i]</M> or
<M>y[i]</M> if the other argument is not bound at position <M>i</M>,
and is unbound if both <M>x</M> and <M>y</M> are unbound at position <M>i</M>.
<P/>
If <M>x</M> is in <Ref Func="IsGeneralizedRowVector"/> and <M>y</M> is
in <Ref Func="IsGeneralizedRowVector"/> and has lower additive nesting depth,
or is neither a list nor a domain,
the sum <M>x + y</M> is defined as a list whose entry at position <M>i</M> is
<M>x[i] + y</M> if <M>x</M> is bound at position <M>i</M>,
and is unbound if not.
The equivalent holds in the reversed case,
where the order of the summands is kept,
as addition is not always commutative.
<P/>
<Example><![CDATA[
gap> 1 + [ 1, 2, 3 ];  [ 1, 2, 3 ] + [ 0, 2, 4 ];  [ 1, 2 ] + [ Z(2) ];
[ 2, 3, 4 ]
[ 1, 4, 7 ]
[ 0*Z(2), 2 ]
gap> l1:= [ 1, , 3, 4 ];;             l2:= [ , 2, 3, 4, 5 ];;
gap> l3:= [ [ 1, 2 ], , [ 5, 6 ] ];;  l4:= [ , [ 3, 4 ], [ 5, 6 ] ];;
gap> NestingDepthA( l1 );  NestingDepthA( l2 );
1
1
gap> NestingDepthA( l3 );  NestingDepthA( l4 );
2
2
gap> l1 + l2;
[ 1, 2, 6, 8, 5 ]
gap> l1 + l3;
[ [ 2, 2, 3, 4 ],, [ 6, 6, 3, 4 ] ]
gap> l2 + l4;
[ , [ 3, 6, 3, 4, 5 ], [ 5, 8, 3, 4, 5 ] ]
gap> l3 + l4;
[ [ 1, 2 ], [ 3, 4 ], [ 10, 12 ] ]
gap> l1 + [];
[ 1,, 3, 4 ]
]]></Example>

</Subsection>

<Subsection Label="Subtraction of lists">
<Heading>Subtraction of lists</Heading>

<Index Subkey="difference">list and non-list</Index>
For two &GAP; objects <M>x</M> and <M>y</M> of which one is in
<Ref Func="IsGeneralizedRowVector"/> and the other is also in
<Ref Func="IsGeneralizedRowVector"/>
or is neither a list nor a domain, <M>x - y</M> is defined as <M>x + (-y)</M>.
<P/>
<Example><![CDATA[
gap> l1 - l2;
[ 1, -2, 0, 0, -5 ]
gap> l1 - l3;
[ [ 0, -2, 3, 4 ],, [ -4, -6, 3, 4 ] ]
gap> l2 - l4;
[ , [ -3, -2, 3, 4, 5 ], [ -5, -4, 3, 4, 5 ] ]
gap> l3 - l4;
[ [ 1, 2 ], [ -3, -4 ], [ 0, 0 ] ]
gap> l1 - [];
[ 1,, 3, 4 ]
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Multiplicative Arithmetic for Lists">
<Heading>Multiplicative Arithmetic for Lists</Heading>

In this general context, we define the results of multiplicative operations
only in the following situations.
For unary operations (one and inverse), the unique argument must be in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>;
for binary operations (multiplication and division),
at least one argument must be in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>,
and the other either not a list or also in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>.
<P/>
(For non-list &GAP; objects, defining the results of unary operations is not
an issue here, and if at least one argument is a list not in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>,
it shall be left to this argument whether the result in question is defined
and what it is.)


<Subsection Label="One for lists">
<Heading>One for lists</Heading>

The one (see&nbsp;<Ref Func="One"/>) of a dense list <A>x</A> in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> such that <A>x</A> has
even multiplicative nesting depth and has the same length
as each of its rows is defined as the usual identity matrix
on the outer two levels,
that is, an identity matrix of the same dimensions, with diagonal entries
<C>One( <A>x</A>[1][1] )</C> and off-diagonal entries
<C>Zero( <A>x</A>[1][1] )</C>.
<P/>
<Example><![CDATA[
gap> One( [ [ 1, 2 ], [ 3, 4 ] ] );
[ [ 1, 0 ], [ 0, 1 ] ]
gap> One( [ [ [ [ 1 ] ], [ [ 2 ] ] ], [ [ [ 3 ] ], [ [ 4 ] ] ] ] );
[ [ [ [ 1 ] ], [ [ 0 ] ] ], [ [ [ 0 ] ], [ [ 1 ] ] ] ]
]]></Example>

</Subsection>

<Subsection Label="Inverse for lists">
<Heading>Inverse for lists</Heading>

The inverse (see&nbsp;<Ref Func="Inverse"/>) of an invertible square table
<A>x</A> in <Ref Func="IsMultiplicativeGeneralizedRowVector"/> whose entries
lie in a common field is defined as the usual inverse <M>y</M>, i.e.,
a square matrix over the same field such that <M><A>x</A> y</M> and
<M>y <A>x</A></M> is equal to <C>One( <A>x</A> )</C>.
<P/>
<Example><![CDATA[
gap> Inverse( [ [ 1, 2 ], [ 3, 4 ] ] );
[ [ -2, 1 ], [ 3/2, -1/2 ] ]
]]></Example>

</Subsection>

<Subsection Label="Multiplication of lists">
<Heading>Multiplication of lists</Heading>

<Index Subkey="product">list and non-list</Index>
There are three possible computations that might be triggered by a
multiplication involving a list in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>.
Namely, <M>x * y</M> might be
<List>
<Mark>(I)</Mark>
<Item>
    the inner product
    <M>x[1] * y[1] + x[2] * y[2] + \cdots + x[n] * y[n]</M>,
    where summands are omitted for which the entry in <M>x</M> or <M>y</M>
    is unbound
    (if this leaves no summand then the multiplication is an error),
    or
</Item>
<Mark>(L)</Mark>
<Item>
    the left scalar multiple, i.e., a list whose entry at position <M>i</M>
    is <M>x * y[i]</M> if <M>y</M> is bound at position <M>i</M>,
    and is unbound if not, or
</Item>
<Mark>(R)</Mark>
<Item>
    the right scalar multiple, i.e., a list whose entry at position <M>i</M>
    is <M>x[i] * y</M> if <M>x</M> is bound at position <M>i</M>,
    and is unbound if not.
</Item>
</List>
<P/>
Our aim is to generalize the basic arithmetic of simple row vectors and
matrices, so we first summarize the situations that shall be covered.
<P/>
<Table Align="c|ccc">
<Row>
  <Item> </Item>
  <Item>scl</Item>
  <Item>vec</Item>
  <Item>mat</Item>
</Row>
<HorLine/>
<Row>
  <Item>scl</Item>
  <Item> </Item>
  <Item>(L)</Item>
  <Item>(L)</Item>
</Row>
<Row>
  <Item>vec</Item>
  <Item>(R)</Item>
  <Item>(I)</Item>
  <Item>(I)</Item>
</Row>
<Row>
  <Item>mat</Item>
  <Item>(R)</Item>
  <Item>(R)</Item>
  <Item>(R)</Item>
</Row>
</Table>
<P/>
This means for example that the product of a scalar (scl) with a vector (vec)
or a matrix (mat) is computed according to (L).
Note that this is asymmetric.
<P/>
Now we can state the general multiplication rules.
<P/>
If exactly one argument is in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>
then we regard the other argument (which is then neither a list nor a domain)
as a scalar, and specify result (L) or (R), depending on ordering.
<P/>
In the remaining cases, both <M>x</M> and <M>y</M> are in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>,
and we distinguish the possibilities by their multiplicative nesting depths.
An argument with <E>odd</E> multiplicative nesting depth is regarded
as a vector,
and an argument with <E>even</E> multiplicative nesting depth is regarded
as a scalar or a matrix.
<P/>
So if both arguments have odd multiplicative nesting depth,
we specify result (I).
<P/>
If exactly one argument has odd nesting depth,
the other is treated as a scalar if it has lower multiplicative nesting
depth, and as a matrix otherwise.
In the former case, we specify result (L) or (R), depending on ordering;
in the latter case, we specify result (L) or (I), depending on ordering.
<P/>
We are left with the case that each argument has even multiplicative
nesting depth.
<!-- % By definition, this depth is nonzero. -->
If the two depths are equal, we treat the computation as a matrix product,
and specify result (R).
Otherwise, we treat the less deeply nested argument as a scalar and the other
as a matrix, and specify result (L) or (R), depending on ordering.
<P/>
<Example><![CDATA[
gap> [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ] * (1,4);
[ (1,4), (1,4)(2,3), (1,2,4), (1,2,3,4), (1,3,2,4), (1,3,4) ]
gap> [ 1, 2, , 4 ] * 2;
[ 2, 4,, 8 ]
gap> [ 1, 2, 3 ] * [ 1, 3, 5, 7 ];
22
gap> m:= [ [ 1, 2 ], 3 ];;  m * m;
[ [ 7, 8 ], [ [ 3, 6 ], 9 ] ]
gap> m * m = [ m[1] * m, m[2] * m ];
true
gap> n:= [ 1, [ 2, 3 ] ];;  n * n;
14
gap> n * n = n[1] * n[1] + n[2] * n[2];
true
]]></Example>

</Subsection>

<Subsection Label="Division of lists">
<Heading>Division of lists</Heading>

<Index Subkey="quotient">list and non-list</Index>
For two &GAP; objects <M>x</M> and <M>y</M> of which one is in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> and the other is also in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> or is neither a list
nor a domain, <M>x / y</M> is defined as <M>x * y^{{-1}}</M>.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3 ] / 2;  [ 1, 2 ] / [ [ 1, 2 ], [ 3, 4 ] ];
[ 1/2, 1, 3/2 ]
[ 1, 0 ]
]]></Example>

</Subsection>

<Subsection Label="mod for lists">
<Heading>mod for lists</Heading>

<Index Subkey="mod">list and non-list</Index>
<Index Subkey="lists">mod</Index>
If <A>x</A> and <A>y</A> are in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> and have the
same multiplicative nesting depth (see&nbsp;<Ref Func="NestingDepthM"/>),
<!-- % By definition, this depth is nonzero. -->
<C><A>x</A> mod <A>y</A></C> is defined <E>pointwise</E>,
in the sense that the result is a list whose entry at position <M>i</M> is
<C><A>x</A>[i] mod <A>y</A>[i]</C> if these entries are bound,
is a shallow copy (see&nbsp;<Ref Func="ShallowCopy"/>) of <M>x[i]</M> or
<M>y[i]</M> if the other argument is not bound at position <M>i</M>,
and is unbound if both <M>x</M> and <M>y</M> are unbound at position <M>i</M>.
<P/>
If <M>x</M> is in <Ref Func="IsMultiplicativeGeneralizedRowVector"/> and
<M>y</M> is in <Ref Func="IsMultiplicativeGeneralizedRowVector"/> and has
lower multiplicative nesting depth or is neither a list nor a domain,
<C><A>x</A> mod <A>y</A></C> is defined as a list whose entry at position
<M>i</M> is <C><A>x</A>[i] mod <A>y</A></C> if <A>x</A> is bound at position
<M>i</M>, and is unbound if not.
The equivalent holds in the reversed case,
where the order of the arguments is kept.
<P/>
<Example><![CDATA[
gap> 4711 mod [ 2, 3,, 5, 7 ];
[ 1, 1,, 1, 0 ]
gap> [ 2, 3, 4, 5, 6 ] mod 3;
[ 2, 0, 1, 2, 0 ]
gap> [ 10, 12, 14, 16 ] mod [ 3, 5, 7 ];
[ 1, 2, 0, 16 ]
]]></Example>

</Subsection>

<Subsection Label="Left quotients of lists">
<Heading>Left quotients of lists</Heading>

<Index Subkey="left quotient">list and non-list</Index>
For two &GAP; objects <M>x</M> and <M>y</M> of which one is in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> and the other is also in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/> or is neither a list nor
a domain,
<C>LeftQuotient( <A>x</A>, <A>y</A> )</C> is defined as <M>x^{{-1}} * y</M>.
<P/>
<Example><![CDATA[
gap> LeftQuotient( [ [ 1, 2 ], [ 3, 4 ] ], [ 1, 2 ] );
[ 0, 1/2 ]
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mutability Status and List Arithmetic">
<Heading>Mutability Status and List Arithmetic</Heading>

Many results of arithmetic operations, when applied to lists,
are again lists, and it is of interest whether their entries are mutable
or not (if applicable).
Note that the mutability status of the result itself is already defined
by the general rule for any result of an arithmetic operation, not
only for lists (see&nbsp;<Ref Sect="Mutability and Copyability"/>).
<P/>
However, we do <E>not</E> define exactly the mutability status for each
element on each level of a nested list returned by an arithmetic operation.
(Of course it would be possible to define this recursively,
but since the methods used are in general not recursive,
in particular for efficient multiplication of compressed matrices,
such a general definition would be a burden in these cases.)
Instead we consider,
for a list <M>x</M> in <Ref Func="IsGeneralizedRowVector"/>,
the sequence <M>x = x_1, x_2, \ldots x_n</M> where <M>x_{{i+1}}</M> is
the first bound entry in <M>x_i</M> if exists
(that is, if <M>x_i</M> is a nonempty list),
and <M>n</M> is the largest <M>i</M> such that <M>x_i</M> lies in
<Ref Func="IsGeneralizedRowVector"/>.
The <E>immutability level</E> of <M>x</M> is defined as infinity
if <M>x</M> is immutable,
and otherwise the number of <M>x_i</M> which are immutable.
(So the immutability level of a mutable empty list is <M>0</M>.)
<P/>
Thus a fully mutable matrix has immutability level <M>0</M>,
and a mutable matrix with immutable first row has immutability level <M>1</M>
(independent of the mutability of other rows).
<P/>
The immutability level of the result of any of the binary operations
discussed here is the minimum of the immutability levels of the arguments,
provided that objects of the required mutability status exist in &GAP;.
<!-- Note that this means to call <C>ShallowCopy</C> more often than
     necessary!
     Would it be possible to promise the mutability status for all entries
     only if the arguments are homogeneously mutable,
     as a refinement of the general mutability rule? -->
<P/>
Moreover, the results have a <Q>homogeneous</Q> mutability status,
that is, if the first bound entry at nesting depth <M>i</M> is immutable
(mutable)
then all entries at nesting depth <M>i</M> are immutable
(mutable, provided that a mutable version of this entry exists in &GAP;).
<P/>
Thus the sum of two mutable matrices whose first rows are mutable
is a matrix all of whose rows are mutable,
and the product of two matrices whose first rows are immutable
is a matrix all of whose rows are immutable,
independent of the mutability status of the other rows of the arguments.
<!-- Note that there are situations where this rule (and in fact already the
     general rule mentioned above) leads to counter-intuitive results. -->
<P/>
For example, the sum of a matrix (mutable or immutable, i.e.,
of immutability level one of <M>0</M>, <M>1</M>, or <M>2</M>) and a mutable
row vector (i.e., immutability level <M>0</M>) is a fully mutable matrix.
The product of two mutable row vectors of integers is an integer,
and since &GAP; does not support mutable integers, the result is immutable.
<P/>
For unary arithmetic operations, there are three operations available,
an attribute that returns an immutable result
(<Ref Func="Zero"/>, <Ref Func="AdditiveInverse"/>, <Ref Func="One"/>,
<Ref Func="Inverse"/>),
an operation that returns a result that is mutable
<!-- at least on the outer level, or shall more be guaranteed? -->
(<Ref Oper="ZeroOp"/>, <Ref Oper="AdditiveInverseOp"/>,
<Ref Oper="OneOp"/>, <Ref Oper="InverseOp"/>),
and an operation whose result has the same immutability level as the argument
(<Ref Func="ZeroSM"/>, <Ref Func="AdditiveInverseSM"/>,
<Ref Func="OneSM"/>, <Ref Func="InverseSM"/>).
The last kind of operations is equivalent to the corresponding infix
operations <C>0 * <A>list</A></C>, <C>- <A>list</A></C>,
<C><A>list</A>^0</C>, and <C><A>list</A>^-1</C>.
(This holds not only for lists,
see&nbsp;<Ref Sect="Mutability and Copyability"/>.)
<P/>
<Example><![CDATA[
gap> IsMutable( l1 );  IsMutable( 2 * Immutable( [ 1, 2, 3 ] ) );
true
false
gap> IsMutable( l2 );  IsMutable( l3 );
true
true
]]></Example>
<P/>
An example motivating the mutability rule is the use of syntactic constructs
such as <C><A>obj</A> * <A>list</A></C> and <C>- <A>list</A></C> as
an elegant and efficient way to
create mutable lists needed for further manipulations from mutable lists.
In particular one can construct a mutable zero vector of length <M>n</M>
by <C>0 * [ 1 .. </C><M>n</M><C> ]</C>.
The latter can be done also using <Ref Func="ListWithIdenticalEntries"/>.

<ManSection>
<Func Name="ListWithIdenticalEntries" Arg='n, obj'/>

<Description>
is a list <A>list</A> of length <A>n</A> that has the object <A>obj</A>
stored at each of the positions from <C>1</C> to <A>n</A>.
Note that all elements of <A>lists</A> are identical,
see&nbsp;<Ref Sect="Identical Lists"/>.
<P/>
<Example><![CDATA[
gap> ListWithIdenticalEntries( 10, 0 );
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finding Positions in Lists">
<Heading>Finding Positions in Lists</Heading>

<ManSection>
<Oper Name="Position" Arg='list, obj[, from]'/>

<Description>
returns the position of the first occurrence <A>obj</A> in <A>list</A>,
or <K>fail</K> if <A>obj</A> is not contained in <A>list</A>.
If a starting index <A>from</A> is given, it
returns the position of the first occurrence starting the search
<E>after</E> position <A>from</A>.
<P/>
Each call to the two argument version is translated into a call of the
three argument version, with third argument the integer zero <C>0</C>.
(Methods for the two argument version must be installed as methods for
the version with three arguments, the third being described by
<C>IsZeroCyc</C>.)
<P/>
<Example><![CDATA[
gap> Position( [ 2, 2, 1, 3 ], 1 );
3
gap> Position( [ 2, 1, 1, 3 ], 1 );
2
gap> Position( [ 2, 1, 1, 3 ], 1, 2 );
3
gap> Position( [ 2, 1, 1, 3 ], 1, 3 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Positions" Arg='list, obj'/>
<Oper Name="PositionsOp" Arg='list, obj'/>

<Description>
returns the positions of <E>all</E> occurrences of <A>obj</A> in
<A>list</A>.
<P/>
<Example><![CDATA[
gap> Positions([1,2,1,2,3,2,2],2);
[ 2, 4, 6, 7 ]
gap> Positions([1,2,1,2,3,2,2],4);
[  ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionCanonical" Arg='list, obj'/>

<Description>
returns the position of the canonical associate of <A>obj</A> in
<A>list</A>.
The definition of this associate depends on <A>list</A>.
For internally represented lists it is defined as the element itself
(and <Ref Oper="PositionCanonical"/> thus defaults to
<Ref Func="Position"/>,
but for example for certain enumerators
(see&nbsp;<Ref Sect="Enumerators"/>)
other canonical associates can be defined.
<P/>
For example <Ref Func="RightTransversal"/> defines the
canonical associate to be the element in the transversal defining the
same coset of a subgroup in a group.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;u:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap> rt:=RightTransversal(g,u);;AsList(rt);
[ (), (3,4), (2,3), (2,3,4), (2,4,3), (2,4) ]
gap> Position(rt,(1,2));
fail
gap> PositionCanonical(rt,(1,2));
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionNthOccurrence" Arg='list,obj,n'/>

<Description>
returns the position of the <A>n</A>-th occurrence of <A>obj</A> in
<A>list</A>
and returns <K>fail</K> if <A>obj</A> does not occur <A>n</A> times.
<P/>
<Example><![CDATA[
gap> PositionNthOccurrence([1,2,3,2,4,2,1],1,1);
1
gap> PositionNthOccurrence([1,2,3,2,4,2,1],1,2);
7
gap> PositionNthOccurrence([1,2,3,2,4,2,1],2,3);
6
gap> PositionNthOccurrence([1,2,3,2,4,2,1],2,4);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PositionSorted" Arg='list, elm[, func]'/>

<Description>
<Index Key="PositionSortedOp"><C>PositionSortedOp</C></Index>
Called with two arguments, <Ref Func="PositionSorted"/> returns
the position of the element <A>elm</A> in the sorted list <A>list</A>.
<P/>
Called with three arguments, <Ref Func="PositionSorted"/> returns
the position of the element <A>elm</A> in the list <A>list</A>,
which must be sorted with respect to <A>func</A>.
<A>func</A> must be a function of two arguments that returns <K>true</K>
if the first argument is less than the second argument,
and <K>false</K> otherwise.
<P/>
<Ref Func="PositionSorted"/> returns <A>pos</A> such that
<M><A>list</A>[<A>pos</A>-1] &lt; <A>elm</A></M> and
<M><A>elm</A> \leq <A>list</A>[<A>pos</A>]</M>.
That means, if <A>elm</A> appears once in <A>list</A>,
its position is returned.
If <A>elm</A> appears several times in <A>list</A>,
the position of the first occurrence is returned.
If <A>elm</A> is not an element of <A>list</A>,
the index where <A>elm</A> must be inserted to keep the list sorted
is returned.
<P/>
<Ref Func="PositionSorted"/> uses binary search,
whereas <Ref Func="Position"/> can in general
use only linear search, see the remark at the beginning
of&nbsp;<Ref Sect="Sorted Lists and Sets"/>.
For sorting lists, see&nbsp;<Ref Sect="Sorting Lists"/>,
for testing whether a list is sorted,
see&nbsp;<Ref Func="IsSortedList"/> and <Ref Func="IsSSortedList"/>.
<P/>
Specialized functions for certain kinds of lists must be installed 
as methods for the operation <C>PositionSortedOp</C>.
<P/>
<Example><![CDATA[
gap> PositionSorted( [1,4,5,5,6,7], 0 );
1
gap> PositionSorted( [1,4,5,5,6,7], 2 );
2
gap> PositionSorted( [1,4,5,5,6,7], 4 );
2
gap> PositionSorted( [1,4,5,5,6,7], 5 );
3
gap> PositionSorted( [1,4,5,5,6,7], 8 );
7
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PositionSet" Arg='list, obj[, func]'/>

<Description>
<Ref Func="PositionSet"/> is a slight variation of
<Ref Func="PositionSorted"/>.
The only difference to <Ref Func="PositionSorted"/> is that
<Ref Func="PositionSet"/> returns
<K>fail</K> if <A>obj</A> is not in <A>list</A>.
<P/>
<Example><![CDATA[
gap> PositionSet( [1,4,5,5,6,7], 0 );
fail
gap> PositionSet( [1,4,5,5,6,7], 2 );
fail
gap> PositionSet( [1,4,5,5,6,7], 4 );
2
gap> PositionSet( [1,4,5,5,6,7], 5 );
3
gap> PositionSet( [1,4,5,5,6,7], 8 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionProperty" Arg='list, func[, from]'/>

<Description>
returns the position of the first entry in the list <A>list</A>
for which the property tester function <A>func</A> returns <K>true</K>,
or <K>fail</K> if no such entry exists.
If a starting index <A>from</A> is given, it
returns the position of the first entry satisfying <A>func</A>,
starting the search <E>after</E> position <A>from</A>.
<P/>
<Example><![CDATA[
gap> PositionProperty( [10^7..10^8], IsPrime );
20
gap> PositionProperty( [10^5..10^6],
>        n -> not IsPrime(n) and IsPrimePowerInt(n) );
490
]]></Example>
<P/>
<Ref Func="First"/> allows you to extract the first element of a list
that satisfies a certain property.
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionsProperty" Arg='list, func'/>

<Description>
returns the list of all those positions in the dense list <A>list</A>
for which the property tester function <A>func</A> returns <K>true</K>.
<P/>
<Example><![CDATA[
gap> l:= [ -5 .. 5 ];;
gap> PositionsProperty( l, IsPosInt );
[ 7, 8, 9, 10, 11 ]
gap> PositionsProperty( l, IsPrimeInt );
[ 1, 3, 4, 8, 9, 11 ]
]]></Example>
<P/>
<Ref Func="PositionProperty"/> allows you to extract the position of the
first element in a list that satisfies a certain property.
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionBound" Arg='list'/>

<Description>
returns the first index for which an element is bound in the list
<A>list</A>.
For the empty list it returns <K>fail</K>.
<P/>
<Example><![CDATA[
gap> PositionBound([1,2,3]);
1
gap> PositionBound([,1,2,3]);
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionNot" Arg='list, val[, from]'/>

<Description>
For a list <A>list</A> and an object <A>val</A>,
<Ref Oper="PositionNot"/> returns the smallest
nonnegative integer <M>n</M> such that <M><A>list</A>[n]</M>
is either unbound or not equal to <A>val</A>.
If a starting index <A>from</A> is given, it
returns the first position with this property
starting the search <E>after</E> position <A>from</A>.
<P/>
<Example><![CDATA[
gap> l:= [ 1, 1, 2, 3, 2 ];;  PositionNot( l, 1 );
3
gap> PositionNot( l, 1, 4 );  PositionNot( l, 2, 4 );
5
6
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionNonZero" Arg='vec[, from]'/>

<Description>
For a row vector <A>vec</A>,
<Ref Oper="PositionNonZero"/> returns the position of the
first non-zero element of <A>vec</A>,
or <C>Length(</C> <A>vec</A> <C>)+1</C> if all entries of
<A>vec</A> are zero.
<P/>
If a starting index <A>from</A> is given,
it returns the position of the first occurrence starting the search
<E>after</E> position <A>from</A>.
<P/>
<Ref Oper="PositionNonZero"/> implements a special case of
<Ref Oper="PositionNot"/>.
Namely, the element to be avoided is the zero element,
and the list must be (at least) homogeneous
because otherwise the zero element cannot be specified implicitly.
<P/>
<Example><![CDATA[
gap> PositionNonZero( [ 1, 1, 2, 3, 2 ] );
1
gap> PositionNonZero( [ 2, 3, 4, 5 ] * Z(2) );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionSublist" Arg='list, sub[, from]'/>

<Description>
returns the smallest index in the list <A>list</A> at which a sublist
equal to <A>sub</A> starts.
If <A>sub</A> does not occur the operation returns <K>fail</K>.
The version with given <A>from</A> starts searching <E>after</E>
position <A>from</A>.
<P/>
To determine whether <A>sub</A> matches <A>list</A> at a particular
position, use <Ref Oper="IsMatchingSublist"/> instead.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties and Attributes for Lists">
<Heading>Properties and Attributes for Lists</Heading>

A list that contains mutable objects (like lists or records)
<E>cannot</E> store attribute values that depend on the values of its entries,
such as whether it is homogeneous, sorted, or strictly sorted,
as changes in any of its entries could change such property values,
like the following example shows.
<P/>
<Example><![CDATA[
gap> l:=[[1],[2]];
[ [ 1 ], [ 2 ] ]
gap> IsSSortedList(l);
true
gap> l[1][1]:=3;
3
gap> IsSSortedList(l);
false
]]></Example>
<P/>
For such lists these property values must be computed anew
each time the property is asked for.
For example, if <A>list</A> is a list of mutable row vectors then the call of
<Ref Func="Position"/> with <A>list</A> as first argument
cannot take advantage of the fact that <A>list</A> is in fact sorted.
One solution is to call explicitly <Ref Func="PositionSorted"/>
in such a situation, another solution is to replace <A>list</A> by an immutable
copy using <Ref Func="Immutable"/>.

<ManSection>
<Oper Name="IsMatchingSublist" Arg='list, sub[, at]'/>

<Description>
returns <K>true</K> if <A>sub</A> matches a sublist of <A>list</A> from
position <C>1</C> (or position <A>at</A>, in the case of three arguments),
or <K>false</K>, otherwise. 
If <A>sub</A> is empty <K>true</K> is returned.
If <A>list</A> is empty but <A>sub</A> is non-empty
<K>false</K> is returned.
<P/>
If you actually want to know whether there is an <A>at</A> for which
<C>IsMatchingSublist( <A>list</A>, <A>sub</A>, <A>at</A> )</C> is true,
use a construction like
<C>PositionSublist( <A>list</A>, <A>sub</A> ) &tlt;&tgt; fail</C> instead 
(see <Ref Oper="PositionSublist"/>); it's more efficient.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsDuplicateFree" Arg='obj'/>
<Prop Name="IsDuplicateFreeList" Arg='obj'/>

<Description>
<Ref Prop="IsDuplicateFree"/> returns <K>true</K> if <A>obj</A> is both a
list or collection, and it is duplicate free;
<Index>duplicate free</Index>
otherwise it returns <K>false</K>.
<Ref Prop="IsDuplicateFreeList"/> is a synonym for
<C>IsDuplicateFree and IsList</C>.
<P/>
A list is <E>duplicate free</E> if it is dense and does not contain equal
entries in different positions.
Every domain (see&nbsp;<Ref Sect="Domains"/>) is duplicate free.
<P/>
Note that  &GAP; cannot  compare arbitrary objects (by equality).
This can cause  that <Ref Func="IsDuplicateFree"/> runs  into an error,
if <A>obj</A> is a list with some non-comparable entries.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSortedList" Arg='obj'/>

<Description>
returns <K>true</K> if <A>obj</A> is a list and it is sorted,
<Index Subkey="sorted">list</Index> and <K>false</K> otherwise.
<P/>
A list <A>list</A> is <E>sorted</E> if it is dense
(see&nbsp;<Ref Func="IsDenseList"/>)
and satisfies the relation <M><A>list</A>[i] \leq <A>list</A>[j]</M>
whenever <M>i &lt; j</M>.
Note that a sorted list is not necessarily duplicate free
(see&nbsp;<Ref Func="IsDuplicateFree"/> and <Ref Func="IsSSortedList"/>).
<P/>
Many sorted lists are in fact homogeneous
(see&nbsp;<Ref Func="IsHomogeneousList"/>),
but also non-homogeneous lists may be sorted
(see&nbsp;<Ref Sect="Comparison Operations for Elements"/>).
<P/>
In sorted lists, membership test and computing of positions can be done
by binary search, see&nbsp;<Ref Sect="Sorted Lists and Sets"/>.
<P/>
Note that  &GAP; cannot  compare (by  less than)  arbitrary objects.
This can cause  that <Ref Func="IsSortedList"/> runs  into an error,
if <A>obj</A> is a list with some non-comparable entries.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSSortedList" Arg='obj'/>
<Prop Name="IsSet" Arg='obj'/>

<Description>
returns <K>true</K> if <A>obj</A> is a list and it is strictly sorted,
<Index>strictly sorted list</Index>
and <K>false</K> otherwise.
<Ref Prop="IsSSortedList"/> is short for <Q>is strictly sorted list</Q>;
<Ref Prop="IsSet"/> is just a synonym for <Ref Prop="IsSSortedList"/>.
<P/>
A list <A>list</A> is <E>strictly sorted</E> if it is sorted
(see&nbsp;<Ref Func="IsSortedList"/>)
and satisfies the relation <M><A>list</A>[i] &lt; <A>list</A>[j]</M>
whenever <M>i &lt; j</M>.
In particular, such lists are duplicate free
(see&nbsp;<Ref Func="IsDuplicateFree"/>).
<P/>
(Currently there is little special treatment of lists that are sorted
but not strictly sorted.
In particular, internally represented lists will <E>not</E> store
that they are sorted but not strictly sorted.)
<P/>
Note that  &GAP; cannot  compare (by  less than)  arbitrary objects.
This can cause  that <Ref Func="IsSSortedList"/> runs  into an error,
if <A>obj</A> is a list with some non-comparable entries.
</Description>
</ManSection>

<ManSection>
<Attr Name="Length" Arg='list'/>

<Description>
returns the <E>length</E> of the list <A>list</A>, which is defined to be
the index of the last bound entry in <A>list</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ConstantTimeAccessList" Arg='list'/>

<Description>
<Ref Attr="ConstantTimeAccessList"/> returns an immutable list containing
the same elements as the list <A>list</A> (which may have holes) in the
same order.
If <A>list</A> is already a constant time access list,
<Ref Attr="ConstantTimeAccessList"/> returns an immutable copy of
<A>list</A> directly.
Otherwise it puts all elements and holes of <A>list</A> into a new list
and makes that list immutable.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sorting Lists">
<Heading>Sorting Lists</Heading>


<ManSection>
<Oper Name="Sort" Arg='list[, func]'/>
<Oper Name="SortBy" Arg='list, func'/>

<Description>
<Ref Oper="Sort"/> sorts the list <A>list</A> in increasing order.
In the one argument form <Ref Oper="Sort"/> uses the operator <C>&lt;</C>
to compare the elements.
(If the list is not homogeneous it is the users responsibility to ensure
that <C>&lt;</C> is defined for all element pairs,
see&nbsp;<Ref Sect="Comparison Operations for Elements"/>)
In the two argument form <Ref Oper="Sort"/> uses the function <A>func</A>
to compare elements.
<A>func</A> must be a function taking two arguments that returns
<K>true</K> if the first is regarded as strictly smaller than the second,
and <K>false</K> otherwise.
<P/>
Note that, in cases where it is applicable, <Ref Oper="SortBy"/> is likely to be more
efficient.
<P/>
<Ref Oper="Sort"/> does not return anything,
it just changes the argument <A>list</A>.
Use <Ref Func="ShallowCopy"/> if you want to keep <A>list</A>.
Use <Ref Func="Reversed"/> if you want to get a new list that is
sorted in decreasing order.
<P/>
It is possible to sort lists that contain multiple elements which compare
equal.
It is not guaranteed that those elements keep their relative order,
i.e., <Ref Oper="Sort"/> is not stable.
<P/>
<Example><![CDATA[
gap> list := [ 5, 4, 6, 1, 7, 5 ];; Sort( list ); list;
[ 1, 4, 5, 5, 6, 7 ]
gap> list := [ [0,6], [1,2], [1,3], [1,5], [0,4], [3,4] ];;
gap> Sort( list, function(v,w) return v*v < w*w; end );
gap> list;  # sorted according to the Euclidean distance from [0,0]
[ [ 1, 2 ], [ 1, 3 ], [ 0, 4 ], [ 3, 4 ], [ 1, 5 ], [ 0, 6 ] ]
gap> list := [ [0,6], [1,3], [3,4], [1,5], [1,2], [0,4], ];;
gap> Sort( list, function(v,w) return v[1] < w[1]; end );
gap> # note the random order of the elements with equal first component:
gap> list;
[ [ 0, 6 ], [ 0, 4 ], [ 1, 3 ], [ 1, 5 ], [ 1, 2 ], [ 3, 4 ] ]
]]></Example>
<Ref Oper="SortBy"/> sorts the list <A>list</A> into an order such that
<C>func(list[i]) &lt;= func(list[i+1])</C> for all relevant
<A>i</A>. <A>func</A> must thus be a function on one argument which returns
values that can be compared.  Each <C>func(list[i])</C> is computed just
once and stored, making this more efficient than using the two-argument
version of <Ref Oper="Sort"/> in many cases.  
</Description>
</ManSection>

<ManSection>
<Oper Name="SortParallel" Arg='list1, list2[, func]'/>

<Description>
sorts the list <A>list1</A> in increasing order
just as <Ref Func="Sort"/> does.
In parallel it applies the same exchanges that are necessary to sort
<A>list1</A> to the list <A>list2</A>,
which must of course have at least as many elements as <A>list1</A> does.
<P/>
<Example><![CDATA[
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := [ 2, 3, 5, 7, 8, 9 ];;
gap> SortParallel( list1, list2 );
gap> list1;
[ 1, 4, 5, 5, 6, 7 ]
gap> list2;
[ 7, 3, 2, 9, 5, 8 ]
]]></Example>
<P/>
Note that <C>[ 7, 3, 2, 9, 5, 8 ]</C> or <C>[ 7, 3, 9, 2, 5, 8 ]</C>
are possible results.
</Description>
</ManSection>

<ManSection>
<Oper Name="Sortex" Arg='list[, func]'/>

<Description>
sorts the list <A>list</A> and returns a permutation
that can be applied to <A>list</A> to obtain the sorted list.
The one argument form sorts via the operator <C>&lt;</C>,
the two argument form sorts w.r.t. the function <A>func</A>.
(If the list is not homogeneous it is the user's responsibility to ensure
that <C>&lt;</C> is defined for all element pairs,
see&nbsp;<Ref Sect="Comparison Operations for Elements"/>)
<P/>
<Ref Func="Permuted"/> allows you to rearrange a list according to
a given permutation.
<P/>
<Example><![CDATA[
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := ShallowCopy( list1 );;
gap> perm := Sortex( list1 );
(1,3,5,6,4)
gap> list1;
[ 1, 4, 5, 5, 6, 7 ]
gap> Permuted( list2, perm );
[ 1, 4, 5, 5, 6, 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SortingPerm" Arg='list'/>

<Description>
<Ref Attr="SortingPerm"/> returns the same as <Ref Oper="Sortex"/>
but does <E>not</E> change the argument.
<P/>
<Example><![CDATA[
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := ShallowCopy( list1 );;
gap> perm := SortingPerm( list1 );
(1,3,5,6,4)
gap> list1;
[ 5, 4, 6, 1, 7, 5 ]
gap> Permuted( list2, perm );
[ 1, 4, 5, 5, 6, 7 ]
]]></Example>
</Description>
</ManSection>


The default methods for all of these sorting operations currently
use Shell sort as it has a comparable performance to Quicksort for lists of
length at most a few thousands, and has better worst-case behaviour.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sorted Lists and Sets">
<Heading>Sorted Lists and Sets</Heading>

<Index>sets</Index>
<Index>multisets</Index>

Searching objects in a list works much quicker if the list is known to be
sorted.
Currently &GAP; exploits the sortedness of a list automatically only if
the list is <E>strictly sorted</E>, which is indicated by the property
<Ref Func="IsSSortedList"/>.
<P/>
Remember that a list of <E>mutable</E> objects cannot store that it is
strictly sorted but has to test it anew whenever it is asked
whether it is sorted,
see the remark in&nbsp;<Ref Sect="Properties and Attributes for Lists"/>.
Therefore &GAP; cannot take advantage of the sortedness of a list if this
list has mutable entries.
Moreover, if a sorted list <A>list</A> with mutable elements is used
as an argument of a function that <E>expects</E> this argument to be sorted,
for example <Ref Func="UniteSet"/> or <Ref Func="RemoveSet"/>,
then it is checked whether <A>list</A> is in fact sorted;
this check can have the effect actually to slow down the computations,
compared to computations with sorted lists of immutable elements
or computations that do not involve functions that do automatically check
sortedness.
<P/>
Strictly sorted lists are used to represent <E>sets</E> in &GAP;.
More precisely, a strictly sorted list is called a <E>proper set</E>
in the following, in order to avoid confusion with domains
(see&nbsp;<Ref Sect="Domains"/>) which also represent sets.
<P/>
In short proper sets are represented by sorted lists without holes and
duplicates in &GAP;.
Note that we guarantee this representation, so  you may make use of
the fact that a set is represented by a sorted list in your functions.
<P/>
In some contexts (for example see&nbsp;<Ref Chap="Combinatorics"/>),
we also want to talk about multisets.
A <E>multiset</E> is like a set, except that an element may appear
several times in a multiset.
Such multisets are represented by sorted lists without holes
that may have duplicates.
<P/>
This section lists only those functions that are defined exclusively for
proper sets.
Set theoretic functions for general collections,
such as <Ref Func="Intersection" Label="for a list"/>
and <Ref Func="Union" Label="for a list"/>, 
are described in Chapter&nbsp;<Ref Chap="Collections"/>.
In particular, for the construction of proper sets,
see&nbsp;<Ref Func="SSortedList"/> and <Ref Func="AsSSortedList"/>.
For finding positions in sorted lists, see&nbsp;<Ref Func="PositionSorted"/>.
<P/>
There are nondestructive counterparts of the functions
<Ref Func="UniteSet"/>, <Ref Func="IntersectSet"/>, and
<Ref Func="SubtractSet"/> available for proper sets.
These are <C>UnionSet</C>, <C>IntersectionSet</C>, and
<Ref Oper="Difference"/>.
The former two are methods for the more general operations
<Ref Func="Union" Label="for a list"/>
and <Ref Func="Intersection" Label="for a list"/>,
the latter is itself an operation (see&nbsp;<Ref Oper="Difference"/>).
<P/>
The result of <C>IntersectionSet</C> and <C>UnionSet</C> is always a new list,
that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the first argument <A>set</A>.
If <A>set</A> is not a proper set it is not specified to which of a number
of equal elements in <A>set</A> the element in the result is identical
(see&nbsp;<Ref Sect="Identical Lists"/>).

The following functions, if not explicitly stated differently,
take two arguments, <A>set</A> and <A>obj</A>,
where <A>set</A> must be a proper set,
otherwise an error is signalled;
If the second argument <A>obj</A> is a list that is not a proper set
then <Ref Func="Set"/> is silently applied to it first.


<ManSection>
<Meth Name="\in" Arg="obj, list" Label="for strictly sorted lists"/>

<Description>
For a list <A>list</A> that stores that it is strictly sorted,
the test with <Ref Func="\in" Label="for strictly sorted lists"/>
whether the object <A>obj</A> is an entry of <A>list</A> uses binary search.
This test can be entered also with the infix notation
<A>obj</A> <K>in</K> <A>list</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsEqualSet" Arg='list1, list2'/>

<Description>
<Index Subkey="for set equality">test</Index>
tests whether <A>list1</A> and <A>list2</A> are equal
<E>when viewed as sets</E>, that is if every element of <A>list1</A> is
an element of <A>list2</A> and vice versa.
Either argument of <Ref Oper="IsEqualSet"/> may also be a list that is
not a proper set, in which case <Ref Func="Set"/> is applied to it first.
<P/>
If both lists are proper sets then they are of course equal if and only
if they are also equal as lists.
Thus <C>IsEqualSet( <A>list1</A>, <A>list2</A> )</C> is equivalent to
<C>Set( <A>list1</A>  ) = Set( <A>list2</A> )</C>
(see&nbsp;<Ref Func="Set"/>), but the former is more efficient.
<P/>
<Example><![CDATA[
gap> IsEqualSet( [2,3,5,7,11], [11,7,5,3,2] );
true
gap> IsEqualSet( [2,3,5,7,11], [2,3,5,7,11,13] );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsSubsetSet" Arg='list1, list2'/>

<Description>
tests whether every element of <A>list2</A> is contained in <A>list1</A>.
Either argument of <Ref Oper="IsSubsetSet"/> may also be a list
that is not a proper set,
in which case <Ref Func="Set"/> is applied to it first.
</Description>
</ManSection>

<ManSection>
<Oper Name="AddSet" Arg='set, obj'/>

<Description>
<Index Subkey="an element to a set">add</Index>
adds the element <A>obj</A> to the proper set <A>set</A>.
If <A>obj</A> is already contained in <A>set</A> then <A>set</A> is not
changed.
Otherwise <A>obj</A> is inserted at the correct position such that
<A>set</A> is again a proper set afterwards.
<P/>
Note that <A>obj</A> must be in the same family as each element of
<A>set</A>.
<Example><![CDATA[
gap> s := [2,3,7,11];;
gap> AddSet( s, 5 );  s;
[ 2, 3, 5, 7, 11 ]
gap> AddSet( s, 13 );  s;
[ 2, 3, 5, 7, 11, 13 ]
gap> AddSet( s, 3 );  s;
[ 2, 3, 5, 7, 11, 13 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RemoveSet" Arg='set, obj'/>

<Description>
<Index Subkey="an element from a set">remove</Index>
removes the element <A>obj</A> from the proper set <A>set</A>.
If <A>obj</A> is not contained in <A>set</A> then <A>set</A> is not
changed.
If <A>obj</A> is an element of <A>set</A> it is removed and all the
following elements in the list are moved one position forward.
<P/>
<Example><![CDATA[
gap> s := [ 2, 3, 4, 5, 6, 7 ];;
gap> RemoveSet( s, 6 ); s;
[ 2, 3, 4, 5, 7 ]
gap> RemoveSet( s, 10 ); s;
[ 2, 3, 4, 5, 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="UniteSet" Arg='set, list'/>

<Description>
<Index Subkey="of sets">union</Index>
unites the proper set <A>set</A> with <A>list</A>.
This is equivalent to adding all elements of <A>list</A> to <A>set</A>
(see&nbsp;<Ref Func="AddSet"/>).
<P/>
<Example><![CDATA[
gap> set := [ 2, 3, 5, 7, 11 ];;
gap> UniteSet( set, [ 4, 8, 9 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11 ]
gap> UniteSet( set, [ 16, 9, 25, 13, 16 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 25 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IntersectSet" Arg='set, list'/>

<Description>
<Index Subkey="of sets">intersection</Index>
intersects the proper set <A>set</A> with <A>list</A>.
This is equivalent to removing from <A>set</A> all elements of <A>set</A>
that are not contained in <A>list</A>.
<P/>
<Example><![CDATA[
gap> set := [ 2, 3, 4, 5, 7, 8, 9, 11, 13, 16 ];;
gap> IntersectSet( set, [ 3, 5, 7, 9, 11, 13, 15, 17 ] );  set;
[ 3, 5, 7, 9, 11, 13 ]
gap> IntersectSet( set, [ 9, 4, 6, 8 ] );  set;
[ 9 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SubtractSet" Arg='set, list'/>

<Description>
<Index Subkey="a set from another">subtract</Index>
subtracts <A>list</A> from the proper set <A>set</A>.
This is equivalent to removing from <A>set</A> all elements of
<A>list</A>.
<P/>
<Example><![CDATA[
gap> set := [ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];;
gap> SubtractSet( set, [ 6, 10 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11 ]
gap> SubtractSet( set, [ 9, 4, 6, 8 ] );  set;
[ 2, 3, 5, 7, 11 ]
]]></Example>
</Description>
</ManSection>


<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- % % (from the GAP 3.4 manual) -->
<!-- % </Section>
<Section Label="More about Sets">
<Heading>More about Sets</Heading> -->
<!-- %  -->
<!-- % In the previous section we defined a proper  set as a sorted list without -->
<!-- % holes or duplicates.  This representation is not  only nice to use, it is -->
<!-- % also a good internal representation supporting efficient algorithms.  For -->
<!-- % example the <K>in</K> operator can use binary instead of a linear search since -->
<!-- % a set is sorted.  For another example <Ref Func="Union"/> only has to merge the sets. -->
<!-- %  -->
<!-- % However, all  those set functions  also allow lists that are  not  proper -->
<!-- % sets,  silently making  a copy  of it and  converting this copy to a set. -->
<!-- % Suppose all the functions would have to test  their arguments every time, -->
<!-- % comparing  each element  with its  successor, to see if  they  are proper -->
<!-- % sets.  This would chew up most  of  the performance advantage again.  For -->
<!-- % example suppose <K>in</K> would have to run  over the whole list, to see if it -->
<!-- % is  a  proper set, so  it could  use the  binary search.   That  would be -->
<!-- % ridiculous. -->
<!-- %  -->
<!-- % To avoid this a  list that is  a proper set  may, but need  not, have  an -->
<!-- % internal flag set that tells  those functions that  this list is indeed a -->
<!-- % proper set.  Those functions do not have to check this argument then, and -->
<!-- % can use the more  efficient algorithms.  This  section tells  you  when a -->
<!-- % proper set obtains this flag,  so you can write your  functions in such a -->
<!-- % way that you make best use of the algorithms. -->
<!-- %  -->
<!-- % The results of <Ref Func="Set"/>, <Ref Func="Difference"/>, <Ref Func="Intersection"/>  and <Ref Func="Union"/> are known -->
<!-- % to be sets by construction, and thus have the flag set upon creation. -->
<!-- %  -->
<!-- % If an argument to <Ref Func="IsSet"/>, <Ref Func="IsEqualSet"/>, <Ref Func="IsSubset"/>, <Ref Func="Set"/>, <Ref Func="Difference"/>, -->
<!-- % <Ref Func="Intersection"/> or  <Ref Func="Union"/> is a proper  set, that does  not  yet have the -->
<!-- % flag set, those functions will notice that and set the flag for this set. -->
<!-- % Note that <K>in</K> will use linear search if the  right operand does not have -->
<!-- % the flag set, will therefore not detect  if it is  a proper set and will, -->
<!-- % unlike the functions above, never set the flag. -->
<!-- %  -->
<!-- % If you change a proper set, that does have this  flag set, by assignment, -->
<!-- % <C>Add</C>   or <C>Append</C> the  set  will generally lose  it  flag,  even if the -->
<!-- % change is such that the resulting list is still a proper set.  However if -->
<!-- % the set has more than 100 elements and the value assigned or added is not -->
<!-- % a list and not a record and the resulting list is still a proper set than -->
<!-- % it will keep  the flag.  Note that  changing a list  that is not a proper -->
<!-- % set will never set the flag, even if the resulting list  is a proper set. -->
<!-- % Such a set will obtain the flag only if it is passed to a set function. -->
<!-- %  -->
<!-- % Suppose you have built a proper set  in such a way that  it does not have -->
<!-- % the flag set, and that you now want  to perform lots of membership tests. -->
<!-- % Then you  should call <C>IsSet</C>  with that set   as an argument.   If it is -->
<!-- % indeed  a proper set  <C>IsSet</C> will set the flag,  and the subsequent <K>in</K> -->
<!-- % operations will use  the more efficient binary  search.  You can think of -->
<!-- % the call to <C>IsSet</C> as a hint to &GAP; that this list is a proper set. -->
<!-- %  -->
<!-- % There is no way you can set the flag for an ordinary  list  without going -->
<!-- % through the checking in <C>IsSet</C>.  The  internal  functions depend so much -->
<!-- % on the fact that a list with  this flag set  is indeed sorted and without -->
<!-- % holes and duplicates that the risk would be too high to allow setting the -->
<!-- % flag without such a check. -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Lists">
<Heading>Operations for Lists</Heading>

Several of the following functions expect the first argument to be either a
list or a collection (see&nbsp;<Ref Chap="Collections"/>),
with possibly slightly different meaning for lists and non-list collections.

<Index Subkey="of lists">concatenation</Index>
<ManSection>
<Func Name="Concatenation" Arg='list1, list2, ...'
 Label="for several lists"/>
<Func Name="Concatenation" Arg='list' Label="for a list of lists"/>

<Description>
In the first form <Ref Func="Concatenation" Label="for several lists"/>
returns the concatenation of the lists <A>list1</A>, <A>list2</A>, etc.
The <E>concatenation</E> is the list that begins with the elements of
<A>list1</A>, followed by the elements of <A>list2</A>, and so on.
Each list may also contain holes, in which case the concatenation also
contains holes at the corresponding positions.
<P/>
In the second form <A>list</A> must be a dense list of lists
<A>list1</A>, <A>list2</A>, etc.,
and <Ref Func="Concatenation" Label="for a list of lists"/> returns the
concatenation of those lists.
<P/>
The result is a new mutable list,
that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of <A>list1</A>, <A>list2</A>, etc.
(see&nbsp;<Ref Sect="Identical Lists"/>).
<P/>
Note that <Ref Func="Concatenation" Label="for several lists"/> creates
a new list and leaves its arguments unchanged,
while <Ref Func="Append"/> changes its first argument.
For computing the union of proper sets,
<Ref Func="Union" Label="for a list"/> can be used,
see also <Ref Sect="Sorted Lists and Sets"/>.
<P/>
<Example><![CDATA[
gap> Concatenation( [ 1, 2, 3 ], [ 4, 5 ] );
[ 1, 2, 3, 4, 5 ]
gap> Concatenation( [2,3,,5,,7], [11,,13,,,,17,,19] );
[ 2, 3,, 5,, 7, 11,, 13,,,, 17,, 19 ]
gap> Concatenation( [ [1,2,3], [2,3,4], [3,4,5] ] );
[ 1, 2, 3, 2, 3, 4, 3, 4, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Compacted" Arg='list'/>

<Description>
returns a new mutable list that contains the elements of <A>list</A>
in the same order but omitting the holes.
<P/>
<Example><![CDATA[
gap> l:=[,1,,,3,,,4,[5,,,6],7];;  Compacted( l );
[ 1, 3, 4, [ 5,,, 6 ], 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Collected" Arg='list'/>

<Description>
returns a new list <A>new</A> that contains for each element <A>elm</A>
of the list <A>list</A> a list of length two,
the first element of this is <A>elm</A> itself and the second element is
the number of times <A>elm</A> appears in <A>list</A>.
The order of those pairs in <A>new</A> corresponds to the ordering of
the elements elm, so that the result is sorted.
<P/>
For all pairs of elements in <A>list</A> the comparison via <C>&lt;</C>
must be defined.
<P/>
<Example><![CDATA[
gap> Factors( Factorial( 10 ) );
[ 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5, 7 ]
gap> Collected( last );
[ [ 2, 8 ], [ 3, 4 ], [ 5, 2 ], [ 7, 1 ] ]
gap> Collected( last );
[ [ [ 2, 8 ], 1 ], [ [ 3, 4 ], 1 ], [ [ 5, 2 ], 1 ], [ [ 7, 1 ], 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DuplicateFreeList" Arg='list'/>
<Oper Name="Unique" Arg='list'/>

<Description>
returns a new mutable list whose entries are the elements of the list
<A>list</A> with duplicates removed.
<Ref Oper="DuplicateFreeList"/> only uses the <C>=</C> comparison
and will not sort the result.
Therefore <Ref Oper="DuplicateFreeList"/> can be used even if the
elements of <A>list</A> do not lie in the same family.
Otherwise, if <A>list</A> contains objects that can be compared with
<Ref Func="\&lt;"/> then it is much more efficient to use 
<Ref Oper="Set"/> instead of <Ref Oper="DuplicateFreeList"/>.
<P/>
<Ref Oper="Unique"/> is a synonym for <Ref Oper="DuplicateFreeList"/>.
<P/>
<Example><![CDATA[
gap> l:=[1,Z(3),1,"abc",Group((1,2,3),(1,2)),Z(3),Group((1,2),(2,3))];;
gap> DuplicateFreeList( l );
[ 1, Z(3), "abc", Group([ (1,2,3), (1,2) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AsDuplicateFreeList" Arg='list'/>

<Description>
returns the same result as <Ref Func="DuplicateFreeList"/>,
except that the result is immutable.
</Description>
</ManSection>

<ManSection>
<Oper Name="Flat" Arg='list'/>

<Description>
returns the list of all elements that are contained in the list
<A>list</A> or its sublists.
That is, <Ref Oper="Flat"/> first makes a new empty list <A>new</A>.
Then it loops over the elements <A>elm</A> of <A>list</A>.
If <A>elm</A> is not a list it is added to <A>new</A>,
otherwise <Ref Oper="Flat"/> appends <C>Flat( <A>elm</A> )</C>
to <A>new</A>.
<P/>
<Example><![CDATA[
gap> Flat( [ 1, [ 2, 3 ], [ [ 1, 2 ], 3 ] ] );
[ 1, 2, 3, 1, 2, 3 ]
gap> Flat( [ ] );
[  ]
]]></Example>
<P/>
To reconstruct a matrix from the list obtained by applying
<Ref Func="Flat"/> to the matrix,
the sublist operator can be used, as follows.
<P/>
<Example><![CDATA[
gap> l:=[9..14];;w:=2;; # w is the length of each row
gap> sub:=[1..w];;List([1..Length(l)/w],i->l{(i-1)*w+sub});
[ [ 9, 10 ], [ 11, 12 ], [ 13, 14 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Reversed" Arg='list'/>

<Description>
returns a new mutable list, containing the elements of the dense list
<A>list</A> in reversed order.
<P/>
The argument list is unchanged.
The result list is a new list, that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the argument list (see&nbsp;<Ref Sect="Identical Lists"/>).
<P/>
<Ref Func="Reversed"/> implements a special case of list assignment,
which can also be formulated in terms of the <C>{}</C> operator
(see&nbsp;<Ref Sect="List Assignment"/>).
<P/>
<Example><![CDATA[
gap> Reversed( [ 1, 4, 9, 5, 6, 7 ] );
[ 7, 6, 5, 9, 4, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Shuffle" Arg='list'/>

<Description>
The argument <A>list</A> must be a dense mutable list. This operation 
permutes the entries of <A>list</A> randomly (in place), and returns 
<A>list</A>.
<Example>
gap> Reset(GlobalMersenneTwister, 12345);; # make manual tester happy
gap> l := [1..20];
[ 1 .. 20 ]
gap> m := Shuffle(ShallowCopy(l));
[ 15, 13, 3, 19, 8, 11, 14, 7, 16, 4, 17, 18, 5, 1, 10, 6, 2, 9, 12, 
  20 ]
gap> l;
[ 1 .. 20 ]
gap> Shuffle(l);;
gap> l;
[ 3, 4, 18, 13, 10, 7, 9, 8, 14, 17, 16, 6, 19, 12, 1, 11, 20, 2, 15, 
  5 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsLexicographicallyLess" Arg='list1, list2'/>

<Description>
Let <A>list1</A> and <A>list2</A> be two dense, but not necessarily
homogeneous lists
(see&nbsp;<Ref Func="IsDenseList"/>, <Ref Func="IsHomogeneousList"/>),
such that for each <M>i</M>, the entries in both lists at position
<M>i</M> can be compared via <C>&lt;</C>.
<Ref Func="IsLexicographicallyLess"/> returns <K>true</K> if <A>list1</A>
is smaller than <A>list2</A> w.r.t.&nbsp;lexicographical ordering,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Func Name="Apply" Arg='list, func'/>

<Description>
<Ref Func="Apply"/> applies the function <A>func</A> to every element
of the dense and mutable list <A>list</A>,
and replaces each element entry by the corresponding return value.
<P/>
<Ref Func="Apply"/> changes its argument.
The nondestructive counterpart of <Ref Func="Apply"/>
is <Ref Func="List" Label="for a collection"/>.
<P/>
<Example><![CDATA[
gap> l:= [ 1, 2, 3 ];;  Apply( l, i -> i^2 );  l;
[ 1, 4, 9 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Perform" Arg='list, func'/>

<Description>
<Ref Oper="Perform"/> applies the function <A>func</A> to every element
of the list <A>list</A>, discarding any return values.
It does not return a value.
<P/>
<Example><![CDATA[
gap> l := [1, 2, 3];; Perform(l, 
> function(x) if IsPrimeInt(x) then Print(x,"\n"); fi; end);
2
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PermListList" Arg='list1, list2'/>

<Description>
returns a permutation <M>p</M> of <C>[ 1 .. Length( <A>list1</A> ) ]</C>
such that <A>list1</A><M>[i</M><C>^</C><M>p] =</M> <A>list2</A><M>[i]</M>.
It returns <K>fail</K> if there is no such permutation.
<P/>
<Example><![CDATA[
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := [ 4, 1, 7, 5, 5, 6 ];;
gap> perm := PermListList(list1, list2);
(1,2,4)(3,5,6)
gap> Permuted( list2, perm );
[ 5, 4, 6, 1, 7, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Maximum</Heading>
<Func Name="Maximum" Arg='obj1, obj2 ...' Label="for various objects"/>
<Func Name="Maximum" Arg='list' Label="for a list"/>

<Description>
In the first form <Ref Func="Maximum" Label="for various objects"/>
returns the <E>maximum</E> of its arguments, i.e.,
one argument <A>obj</A> for which <M><A>obj</A> \geq <A>obj1</A></M>,
<M><A>obj</A> \geq <A>obj2</A></M> etc.
<P/>
In the second form <Ref Func="Maximum" Label="for a list"/> takes a
homogeneous list <A>list</A> and returns the maximum of the elements in
this list.
<P/>
<Example><![CDATA[
gap> Maximum( -123, 700, 123, 0, -1000 );
700
gap> Maximum( [ -123, 700, 123, 0, -1000 ] );
700
gap> # lists are compared elementwise:
gap> Maximum( [1,2], [0,15], [1,5], [2,-11] );  
[ 2, -11 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Minimum</Heading>
<Func Name="Minimum" Arg='obj1, obj2 ...' Label="for various objects"/>
<Func Name="Minimum" Arg='list' Label="for a list"/>

<Description>
In the first form <Ref Func="Minimum" Label="for various objects"/>
returns the <E>minimum</E> of its arguments, i.e.,
one argument <A>obj</A> for which <M><A>obj</A> \leq <A>obj1</A></M>,
<M><A>obj</A> \leq <A>obj2</A></M> etc.
<P/>
In the second form <Ref Func="Minimum" Label="for a list"/> takes a
homogeneous list <A>list</A> and returns the minimum of the elements in
this list.
<P/>
Note that for both <Ref Func="Maximum" Label="for various objects"/> and
<Ref Func="Minimum" Label="for various objects"/> the comparison of the
objects <A>obj1</A>, <A>obj2</A> etc.&nbsp;must be defined;
for that, usually they must lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
<P/>
<Example><![CDATA[
gap> Minimum( -123, 700, 123, 0, -1000 );
-1000
gap> Minimum( [ -123, 700, 123, 0, -1000 ] );
-1000
gap> Minimum( [ 1, 2 ], [ 0, 15 ], [ 1, 5 ], [ 2, -11 ] );
[ 0, 15 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>MaximumList and MinimumList</Heading>
<Oper Name="MaximumList" Arg='list [seed]'/>
<Oper Name="MinimumList" Arg='list [seed]'/>

<Description>
return the maximum resp.&nbsp;the minimum of the elements in the list
<A>list</A>.
They are the operations called by
<Ref Func="Maximum" Label="for various objects"/>
resp.&nbsp;<Ref Func="Minimum" Label="for various objects"/>.
Methods can be installed for special kinds of lists.
For example, there are special methods to compute the maximum
resp.&nbsp;the minimum of a range (see&nbsp;<Ref Sect="Ranges"/>).
<P/>
If a second argument <A>seed</A> is supplied, then the result is the
maximum resp.&nbsp;minimum of the union of <A>list</A> and <A>seed</A>.
In this manner, the operations may be applied to empty lists.
</Description>
</ManSection>

<ManSection>
<Heading>Cartesian</Heading>
<Func Name="Cartesian" Arg='list1, list2 ...'
 Label="for various objects"/>
<Func Name="Cartesian" Arg='list' Label="for a list"/>

<Description>
In the first form <Ref Func="Cartesian" Label="for various objects"/>
returns the cartesian product of the lists <A>list1</A>, <A>list2</A>,
etc.
<P/>
In the second form <A>list</A> must be a list of lists <A>list1</A>,
<A>list2</A>, etc.,
and <Ref Func="Cartesian" Label="for a list"/> returns the cartesian
product of those lists.
<P/>
The <E>cartesian product</E> is a list <A>cart</A> of lists <A>tup</A>,
such that the first element of <A>tup</A> is an element of <A>list1</A>,
the second element of <A>tup</A> is an element of <A>list2</A>,
and so on.
The total number of elements in <A>cart</A> is the product of the lengths
of the argument lists.
In particular <A>cart</A> is empty if and only if at least one of the
argument lists is empty.
Also <A>cart</A> contains duplicates if and only if no argument list is
empty and at least one contains duplicates.
<P/>
The last index runs fastest.
That means that the first element <A>tup1</A> of <A>cart</A> contains
the first element from <A>list1</A>, from <A>list2</A> and so on.
The second element <A>tup2</A> of <A>cart</A> contains the first element
from <A>list1</A>, the first from <A>list2</A>, an so on,
but the last element of <A>tup2</A> is the second element of the last
argument list.
This implies that <A>cart</A> is a proper set if and only if all argument
lists are proper sets (see&nbsp;<Ref Sect="Sorted Lists and Sets"/>).
<P/>
The function <Ref Func="Tuples"/> computes the  <A>k</A>-fold cartesian
product of a list.
<P/>
<Example><![CDATA[
gap> Cartesian( [1,2], [3,4], [5,6] );
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap> Cartesian( [1,2,2], [1,1,2] );
[ [ 1, 1 ], [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 1 ], [ 2, 2 ], 
  [ 2, 1 ], [ 2, 1 ], [ 2, 2 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>IteratorOfCartesianProduct</Heading>
<Func Name="IteratorOfCartesianProduct" Arg='list1, list2 ...'
 Label="for several lists"/>
<Func Name="IteratorOfCartesianProduct" Arg='list'
 Label="for a list of lists"/>

<Description>
In the first form
<Ref Func="IteratorOfCartesianProduct" Label="for several lists"/>
returns  an iterator (see&nbsp;<Ref Sect="Iterators"/>) of all elements
of the cartesian product
(see&nbsp;<Ref Func="Cartesian" Label="for a list"/>)
of the lists <A>list1</A>, <A>list2</A>, etc.
<P/>
In the second form <A>list</A> must be a list of lists
<A>list1</A>, <A>list2</A>, etc.,
and <Ref Func="IteratorOfCartesianProduct" Label="for a list of lists"/>
returns an iterator of the cartesian product of those lists.
<P/>
Resulting tuples will be returned in the lexicographic order.
Usage of iterators of cartesian products is recommended in the
case when the resulting cartesian product is big enough, so its
generating and storage will require essential amount of runtime
and memory. For smaller cartesian products it is faster to generate the
full set of tuples using <Ref Func="Cartesian" Label="for a list"/>
and then loop over its elements (with some minor overhead of needing
more memory).
</Description>
</ManSection>

<ManSection>
<Oper Name="Permuted" Arg='list,perm'/>

<Description>
returns a new list <A>new</A> that contains the elements of the
list <A>list</A> permuted according to the permutation <A>perm</A>.
That is <C><A>new</A>[<A>i</A>^<A>perm</A>] = <A>list</A>[<A>i</A>]</C>.
<P/>
<Ref Func="Sortex"/> allows you to compute a permutation that must
be applied to a list in order to get the sorted list.
<P/>
<Example><![CDATA[
gap> Permuted( [ 5, 4, 6, 1, 7, 5 ], (1,3,5,6,4) );
[ 1, 4, 5, 5, 6, 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="List" Arg='list[, func]' Label="for a list (and a function)"/>

<Description>
This function returns a new mutable list <C>new</C> of the same length 
as the list <A>list</A> (which may have holes). The entry <C>new[i]</C> 
is unbound if <C><A>list</A>[i]</C> is unbound. Otherwise 
<C>new[i] = <A>func</A>(<A>list</A>[i])</C>. If the argument <A>func</A> is
omitted, its default is <Ref Func="IdFunc"/>, so this function does the
same as <Ref Oper="ShallowCopy"/> (see also 
<Ref Sect="Duplication of Lists"/>).
<P/>
<Example><![CDATA[
gap> List( [1,2,3], i -> i^2 );
[ 1, 4, 9 ]
gap> List( [1..10], IsPrime );
[ false, true, true, false, true, false, true, false, false, false ]
gap> List([,1,,3,4], x-> x > 2);
[ , false,, true, true ]
]]></Example>
<P/>
(See also <Ref Func="List" Label="for a collection"/>.)
</Description>
</ManSection>

<ManSection>
<Func Name="Filtered" Arg='listorcoll, func'/>

<Description>
returns a new list that contains those elements of the list or collection
<A>listorcoll</A> (see&nbsp;<Ref Chap="Collections"/>), respectively,
for which the unary function <A>func</A> returns <K>true</K>.
<P/>
If the first argument is a list, the order of the elements in the result
is the same as the order of the corresponding elements of this list.
If an element for which <A>func</A> returns <K>true</K> appears several
times in the list it will also appear the same number of times
in the result.
The argument list may contain holes,
they are ignored by <Ref Func="Filtered"/>.
<P/>
For each element of <A>listorcoll</A>,
<A>func</A> must return either <K>true</K> or <K>false</K>,
otherwise an error is signalled.
<P/>
The result is a new list that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the argument list (see&nbsp;<Ref Sect="Identical Lists"/>).
<P/>
List assignment using the operator <Ref Func="\{\}"/>
(see&nbsp;<Ref Sect="List Assignment"/>) can be used to extract
elements of a list according to indices given in another list.
<P/>
<Example><![CDATA[
gap> Filtered( [1..20], IsPrime );
[ 2, 3, 5, 7, 11, 13, 17, 19 ]
gap> Filtered( [ 1, 3, 4, -4, 4, 7, 10, 6 ], IsPrimePowerInt );
[ 3, 4, 4, 7 ]
gap> Filtered( [ 1, 3, 4, -4, 4, 7, 10, 6 ],
>              n -> IsPrimePowerInt(n) and n mod 2 <> 0 );
[ 3, 7 ]
gap> Filtered( Group( (1,2), (1,2,3) ), x -> Order( x ) = 2 );
[ (2,3), (1,2), (1,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Number" Arg='listorcoll[, func]'/>

<Description>
Called with a list <A>listorcoll</A>, <Ref Func="Number"/> returns the
number of bound entries in this list.
For dense lists <Ref Func="Number"/>, <Ref Func="Length"/>,
and <Ref Func="Size"/> return the same value;
for lists with holes <Ref Func="Number"/> returns the number of bound
entries, <Ref Func="Length"/> returns the largest index of a bound entry,
and <Ref Func="Size"/> signals an error.
<P/>
Called with two arguments, a list or collection <A>listorcoll</A> and a
unary function <A>func</A>, <Ref Func="Number"/> returns the number of
elements of <A>listorcoll</A> for which <A>func</A> returns <K>true</K>.
If an element for which <A>func</A> returns <K>true</K> appears several
times in <A>listorcoll</A> it will also be counted the same number of
times.
<P/>
For each element of <A>listorcoll</A>,
<A>func</A> must return either <K>true</K> or <K>false</K>,
otherwise an error is signalled.
<P/>
<Ref Func="Filtered"/> allows you to extract the elements of a list
that have a certain property.
<P/>
<Example><![CDATA[
gap> Number( [ 2, 3, 5, 7 ] );
4
gap> Number( [, 2, 3,, 5,, 7,,,, 11 ] );
5
gap> Number( [1..20], IsPrime );
8
gap> Number( [ 1, 3, 4, -4, 4, 7, 10, 6 ], IsPrimePowerInt );
4
gap> Number( [ 1, 3, 4, -4, 4, 7, 10, 6 ],
>            n -> IsPrimePowerInt(n) and n mod 2 <> 0 );
2
gap> Number( Group( (1,2), (1,2,3) ), x -> Order( x ) = 2 );
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="First" Arg='list, func'/>

<Description>
<Ref Func="First"/> returns the first element of the list <A>list</A>
for which the unary function <A>func</A> returns <K>true</K>.
<A>list</A> may contain holes.
<A>func</A> must return either <K>true</K> or <K>false</K> for each
element of <A>list</A>, otherwise an error is signalled.
If <A>func</A> returns <K>false</K> for all elements of <A>list</A>
then <Ref Func="First"/> returns <K>fail</K>.
<P/>
<Ref Func="PositionProperty"/> allows you to find the
position of the first element in a list that satisfies a certain
property.
<P/>
<Example><![CDATA[
gap> First( [10^7..10^8], IsPrime );
10000019
gap> First( [10^5..10^6],
>      n -> not IsPrime(n) and IsPrimePowerInt(n) );
100489
gap> First( [ 1 .. 20 ], x -> x < 0 );
fail
gap> First( [ fail ], x -> x = fail );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ForAll" Arg='listorcoll, func'/>

<Description>
tests whether the unary function <A>func</A> returns <K>true</K>
for all elements in the list or collection <A>listorcoll</A>.
<P/>
<Example><![CDATA[
gap> ForAll( [1..20], IsPrime );
false
gap> ForAll( [2,3,4,5,8,9], IsPrimePowerInt );
true
gap> ForAll( [2..14], n -> IsPrimePowerInt(n) or n mod 2 = 0 );
true
gap> ForAll( Group( (1,2), (1,2,3) ), i -> SignPerm(i) = 1 );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ForAny" Arg='listorcoll, func'/>

<Description>
tests whether the unary function <A>func</A> returns <K>true</K>
for at least one element in the list or collection <A>listorcoll</A>.
<P/>
<Example><![CDATA[
gap> ForAny( [1..20], IsPrime );
true
gap> ForAny( [2,3,4,5,8,9], IsPrimePowerInt );
true
gap> ForAny( [2..14],
>    n -> IsPrimePowerInt(n) and n mod 5 = 0 and not IsPrime(n) );
false
gap> ForAny( Integers, i ->     i > 0
>                           and ForAll( [0,2..4], j -> IsPrime(i+j) ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Product" Arg='listorcoll[, func][, init]'/>

<Description>
Called with one argument, a dense list or collection <A>listorcoll</A>,
<Ref Func="Product"/> returns the product of the elements of
<A>listorcoll</A> (see&nbsp;<Ref Chap="Collections"/>).
<P/>
Called with a dense list or collection <A>listorcoll</A> and a function
<A>func</A>, which must be a function taking one argument,
<Ref Func="Product"/> applies the function <A>func</A>
to the elements of <A>listorcoll</A>, and returns the product of the
results.
In either case <Ref Func="Product"/> returns <C>1</C> if the first
argument is empty.
<P/>
The general rules for arithmetic operations apply
(see&nbsp;<Ref Sect="Mutability Status and List Arithmetic"/>),
so the result is immutable if and only if all summands are immutable.
<P/>
If <A>listorcoll</A> contains exactly one element then this element
(or its image under <A>func</A> if applicable) itself is returned,
not a shallow copy of this element.
<P/>
If an additional initial value <A>init</A> is given,
<Ref Func="Product"/> returns the product of <A>init</A> and the elements
of the first argument resp.&nbsp;of their images under the function
<A>func</A>.
This is useful for example if the first argument is empty and a different
identity than <C>1</C> is desired, in which case <A>init</A> is returned.
<P/>
<Example><![CDATA[
gap> Product( [ 2, 3, 5, 7, 11, 13, 17, 19 ] );
9699690
gap> Product( [1..10], x->x^2 );
13168189440000
gap> Product( [ (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) ] );
(1,4)(2,3)
gap> Product( GF(8) );
0*Z(2)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Sum" Arg='listorcoll[, func][, init]'/>

<Description>
Called with one argument, a dense list or collection <A>listorcoll</A>,
<Ref Func="Sum"/> returns the sum of the elements of <A>listorcoll</A>
(see&nbsp;<Ref Chap="Collections"/>).
<P/>
Called with a dense list or collection <A>listorcoll</A> and a function
<A>func</A>, which must be a function taking one argument,
<Ref Func="Sum"/> applies the function <A>func</A>
to the elements of <A>listorcoll</A>, and returns the sum of the results.
In either case <Ref Func="Sum"/> returns <C>0</C> if the first argument
is empty.
<P/>
The general rules for arithmetic operations apply
(see&nbsp;<Ref Sect="Mutability Status and List Arithmetic"/>),
so the result is immutable if and only if all summands are immutable.
<P/>
If <A>listorcoll</A> contains exactly one element then this element
(or its image under <A>func</A> if applicable) itself is returned,
not a shallow copy of this element.
<P/>
If an additional initial value <A>init</A> is given,
<Ref Func="Sum"/> returns the sum of <A>init</A> and the elements of the
first argument resp.&nbsp;of their images under the function <A>func</A>.
This is useful for example if the first argument is empty and a different
zero than <C>0</C> is desired, in which case <A>init</A> is returned.
<P/>
<Example><![CDATA[
gap> Sum( [ 2, 3, 5, 7, 11, 13, 17, 19 ] );
77
gap> Sum( [1..10], x->x^2 );
385
gap> Sum( [ [1,2], [3,4], [5,6] ] );
[ 9, 12 ]
gap> Sum( GF(8) );
0*Z(2)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Iterated" Arg='list, f'/>

<Description>
returns the result of the iterated application of the function
<A>f</A>, which must take two arguments,
to the elements of the list <A>list</A>.
More precisely, if <A>list</A> has length <M>n</M> then
<Ref Oper="Iterated"/> returns the result of the following application,
<M><A>f</A>( \ldots <A>f</A>( <A>f</A>( <A>list</A>[1], <A>list</A>[2] ),
<A>list</A>[3] ), \ldots, <A>list</A>[n] )</M>.
<P/>
<Example><![CDATA[
gap> Iterated( [ 126, 66, 105 ], Gcd );
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ListN" Arg='list1, list2, ..., listn, f'/>

<Description>
applies the <M>n</M>-argument function <A>f</A> to the lists.
That is, <Ref Func="ListN"/> returns the list whose <M>i</M>-th entry is
<M><A>f</A>(<A>list1</A>[i], <A>list2</A>[i], \ldots,
<A>listn</A>[i])</M>.
<P/>
<Example><![CDATA[
gap> ListN( [1,2], [3,4], \+ );
[ 4, 6 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Advanced List Manipulations">
<Heading>Advanced List Manipulations</Heading>

The following functions are generalizations of
<Ref Func="List" Label="for a collection"/>,
<Ref Func="Set"/>, <Ref Func="Sum"/>, and <Ref Func="Product"/>.

<ManSection>
<Oper Name="ListX" Arg='arg1, arg2, ... argn, func'/>

<Description>
<Ref Oper="ListX"/> returns a new list constructed from the arguments.
<P/>
Each of the arguments <A>arg1</A>, <A>arg2</A>, <M>\ldots</M> <A>argn</A>
must be one of the following:
<List>
<Mark>a list or collection</Mark>
<Item>
    this introduces a new for-loop in the sequence of nested
    for-loops and if-statements;
</Item>
<Mark>a function returning a list or collection</Mark>
<Item>
    this introduces a new for-loop in the sequence of nested
    for-loops and if-statements, where the loop-range depends on
    the values of the outer loop-variables; or
</Item>
<Mark>a function returning <K>true</K> or <K>false</K></Mark>
<Item>
    this introduces a new if-statement in the sequence of nested
    for-loops and if-statements.
</Item>
</List>
<P/>
The last argument <A>func</A> must be a function,
it is applied to the values of the loop-variables
and the results are collected.
<P/>
Thus <C>ListX( <A>list</A>, <A>func</A> )</C> is the same as
<C>List( <A>list</A>, <A>func</A> )</C>,
and <C>ListX( <A>list</A>, <A>func</A>, x -> x )</C> is the same as
<C>Filtered( <A>list</A>, <A>func</A> )</C>.
<P/>
As a more elaborate example, assume <A>arg1</A> is a list or collection,
<A>arg2</A> is a function returning <K>true</K> or <K>false</K>,
<A>arg3</A> is a function returning a list or collection, and
<A>arg4</A> is another function returning <K>true</K> or <K>false</K>,
then
<P/>
<C><A>result</A> := ListX( <A>arg1</A>, <A>arg2</A>, <A>arg3</A>,
<A>arg4</A>, <A>func</A> );</C>
<P/>
is equivalent to
<P/>
<Listing><![CDATA[
result := [];
for v1 in arg1 do
  if arg2( v1 ) then
    for v2 in arg3( v1 ) do
      if arg4( v1, v2 ) then
        Add( result, func( v1, v2 ) );
      fi;
    od;
  fi;
od;
]]></Listing>
<P/>
The following example shows how <Ref Func="ListX"/> can be used to
compute all pairs and all strictly sorted pairs of elements in a list.
<P/>
<Example><![CDATA[
gap> l:= [ 1, 2, 3, 4 ];;
gap> pair:= function( x, y ) return [ x, y ]; end;;
gap> ListX( l, l, pair );
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], 
  [ 2, 3 ], [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ], 
  [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ]
]]></Example>
<P/>
In the following example, <Ref Func="\&lt;"/> is the comparison
operation:
<P/>
<Example><![CDATA[
gap> ListX( l, l, \<, pair );
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SetX" Arg='arg1, arg2, ... func'/>

<Description>
The only difference between <Ref Oper="SetX"/> and <Ref Oper="ListX"/>
is that the result list of <Ref Oper="SetX"/> is strictly sorted.
</Description>
</ManSection>

<ManSection>
<Oper Name="SumX" Arg='arg1, arg2, ... func'/>

<Description>
<Ref Oper="SumX"/> returns the sum of the elements in the list obtained
by <Ref Oper="ListX"/> when this is called with the same arguments.
</Description>
</ManSection>

<ManSection>
<Oper Name="ProductX" Arg='arg1, arg2, ... func'/>

<Description>
<Ref Oper="ProductX"/> returns the product of the elements in the list
obtained by <Ref Oper="ListX"/> when this is called with the same
arguments.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Ranges">
<Heading>Ranges</Heading>

<Index>range</Index>
A <E>range</E> is a dense list of integers in arithmetic progression (or
degression).
This is a list of integers such that the difference between
consecutive elements is a nonzero constant.  Ranges can be abbreviated
with the syntactic construct
<P/>
<C>[ <A>first</A>, <A>second</A> .. <A>last</A> ]</C>
<P/>
or, if the difference between consecutive elements is 1, as
<P/>
<C>[ <A>first</A> .. <A>last</A> ]</C>.
<P/>
If <C><A>first</A> > <A>last</A></C>,
<C>[ <A>first</A> .. <A>last</A> ]</C> is the empty list,
which by definition is also a range;
also, if <C><A>second</A> > <A>first</A> > <A>last</A></C> or
<C><A>second</A> &lt; <A>first</A> &lt; <A>last</A></C>,
then <C>[ <A>first</A>, <A>second</A> .. <A>last</A> ]</C> is the empty list.
If <C><A>first</A> = <A>last</A></C>,
<C>[ <A>first</A>, <A>second</A> .. <A>last</A> ]</C> is a singleton list,
which is a range, too.
Note that <C><A>last</A> - <A>first</A></C> must be divisible by the
increment <C><A>second</A> - <A>first</A></C>,
otherwise an error is signalled.
<P/>
Currently, the integers <A>first</A>, <A>second</A> and <A>last</A>
and the length of a range must be small integers,
that is at least <M>-2^d</M> and at most <M>2^d - 1</M> 
with <M>d = 28</M> on 32-bit architectures
and <M>d = 60</M> on 64-bit architectures.
<P/>
Note also that a range is just a special case of a list.
Thus you can access elements in a range (see <Ref Sect="List Elements"/>),
test for membership etc.
You can even assign to such a range if it is mutable
(see&nbsp;<Ref Sect="List Assignment"/>).
Of course, unless you assign
<C><A>last</A> + <A>second</A> - <A>first</A></C> to the entry
<C><A>range</A>[ Length( <A>range</A> ) + 1 ]</C>,
the resulting list will no longer be a range.
<P/>
<Example><![CDATA[
gap> r := [10..20];
[ 10 .. 20 ]
gap> Length( r );
11
gap> r[3];
12
gap> 17 in r;
true
gap> r[12] := 25;; r;  # r is no longer a range
[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25 ]
gap> r := [1,3..17];
[ 1, 3 .. 17 ]
gap> Length( r );
9
gap> r[4];
7
gap> r := [0,-1..-9];
[ 0, -1 .. -9 ]
gap> r[5];
-4
gap> r := [ 1, 4 .. 32 ];
Error, Range: <last>-<first> (31) must be divisible by <inc> (3)
]]></Example>
<P/>
Most often ranges are used in connection with the <K>for</K>-loop
see&nbsp;<Ref Sect="For"/>).
Here the construct
<P/>
<C>for <A>var</A> in [ <A>first</A> .. <A>last</A> ] do <A>statements</A> od</C>
<P/>
replaces the
<P/>
<C>for <A>var</A> from <A>first</A> to <A>last</A> do <A>statements</A> od</C>
<P/>
which is more usual in other programming languages.
<P/>
<Example><![CDATA[
gap> s := [];; for i in [10..20] do Add( s, i^2 ); od; s;
[ 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400 ]
]]></Example>
<P/>
Note that a range with <C><A>last</A> >= <A>first</A></C>
is at the same time also a proper set
(see&nbsp;<Ref Sect="Sorted Lists and Sets"/>),
because it contains no holes or duplicates and is sorted,
and also a row vector (see&nbsp;<Ref Chap="Row Vectors"/>),
because it contains no holes and all elements are integers.
<P/>
<ManSection>
<Filt Name="IsRange" Arg='obj' Type='Category'/>

<Description>
tests if the object <A>obj</A> is a range, i.e. is a dense list of
integers that is also a range
(see&nbsp;<Ref Sect="Ranges"/> for a definition of <Q>range</Q>).
<!-- shouldn't this better be a property?-->
<Example><![CDATA[
gap> IsRange( [1,2,3] );  IsRange( [7,5,3,1] );
true
true
gap> IsRange( [1,2,4,5] );  IsRange( [1,,3,,5,,7] );
false
false
gap> IsRange( [] );  IsRange( [1] );
true
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ConvertToRangeRep" Arg='list'/>

<Description>
For some lists the &GAP; kernel knows that they are in fact ranges.
Those lists are represented internally in a compact way instead of the
ordinary way.
<P/>
If <A>list</A> is a range then <Ref Func="ConvertToRangeRep"/> changes
the representation of <A>list</A> to this compact representation.
<P/>
This is important since this representation needs only 12 bytes for
the entire range while the ordinary representation needs <M>4 length</M>
bytes.
<P/>
Note that a list that is represented in the ordinary way might still be a
range.
It is just that &GAP; does not know this.
The following rules tell you under which circumstances a range is
represented  in the compact way,
so you can write your program in such a way that you make best use of
this compact representation for ranges.
<P/>
Lists created by the syntactic construct
<C>[ <A>first</A>, <A>second</A>  .. <A>last</A> ]</C> are of course
known to be ranges and are represented in the compact way.
<P/>
If you call <Ref Func="ConvertToRangeRep"/> for a list represented the
ordinary way that is indeed a range,
the representation is changed from the ordinary to the compact
representation.
A call of <Ref Func="ConvertToRangeRep"/> for a list that is not a range
is ignored.
<P/>
If you change a mutable range that is represented in the compact way,
by assignment, <Ref Func="Add"/> or <Ref Func="Append"/>,
the range will be converted to the ordinary representation, even if the
change is such that the resulting list is still a proper range.
<P/>
Suppose you have built a proper range in such a way that it is
represented in the ordinary way and that you now want to convert it to
the compact representation to save space.
Then you should call <Ref Func="ConvertToRangeRep"/> with that list as an
argument.
You can think of the call to <Ref Func="ConvertToRangeRep"/> as a hint
to &GAP; that this list is a proper range.
<P/>
<Example><![CDATA[
gap> r:= [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
gap> ConvertToRangeRep( r );  r;
[ 1 .. 10 ]
gap> l:= [ 1, 2, 4, 5 ];;  ConvertToRangeRep( l );  l;
[ 1, 2, 4, 5 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Enumerators">
<Heading>Enumerators</Heading>

An <E>enumerator</E> is an immutable list that need not store its elements
explicitly but knows, from a set of basic data,
how to determine the <M>i</M>-th element and the position of a given object.
A typical example of this is a vector space over a finite field with <M>q</M>
elements, say, for which it is very easy to enumerate all elements
using <M>q</M>-adic expansions of integers.
<P/>
Using this enumeration can be even quicker than a binary search in a sorted
list of vectors, see <Ref Func="IsQuickPositionList"/>.
<P/>
On the one hand, element access to an enumerator may take more time than
element access to an internally represented list containing the same
elements.
On the other hand, an enumerator may save a vast amount of memory.
Take for example a permutation group of size a few millions.
Even for moderate degree it is unlikely that a list of all its elements
will fit into memory whereas it is no problem to construct an enumerator
from a stabilizer chain (see&nbsp;<Ref Sect="Stabilizer Chains"/>).
<P/>
There are situations where one only wants to loop over the elements of a
domain, without using the special facilities of an enumerator,
namely the particular order of elements and the possibility to find the
position of elements.
For such cases, &GAP; provides iterators (see&nbsp;<Ref Sect="Iterators"/>).
<P/>
The functions <Ref Func="Enumerator"/> and
<Ref Func="EnumeratorSorted"/> return enumerators of domains.
Most of the special implementations of enumerators in the &GAP; library
are based on the general interface that is provided by
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>;
one generic example is <Ref Func="EnumeratorByBasis"/>,
which can be used to get an enumerator of a finite dimensional free module.
<P/>
Also enumerators for non-domains can be implemented via
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>;
for a discussion,
see&nbsp;<Ref Sect="Example -- Constructing Enumerators"/>.

<ManSection>
<Filt Name="IsQuickPositionList" Arg='list'/>

<Description>
This filter indicates that a position test in <A>list</A> is quicker than
about 5 or 6 element comparisons for <Q>smaller</Q>.
If this is the case it can be beneficial to use <Ref Oper="Position"/>
in <A>list</A> and a bit list than ordered lists to represent subsets
of <A>list</A>.
</Description>
</ManSection>


</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  blist.msk                  GAP documentation             Martin Schönert -->
<!-- %% -->
<!-- %A  @(#)<M>Id: blist.msk,v 1.9 2002/04/15 10:02:27 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Boolean Lists">
<Heading>Boolean Lists</Heading>

This chapter describes boolean lists.
A <E>boolean list</E> is a list that has no holes and contains only
the boolean values <K>true</K> and <K>false</K>
(see Chapter&nbsp;<Ref Chap="Booleans"/>).
In function names we call boolean lists <E>blists</E> for brevity.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsBlist">
<Heading>IsBlist (Filter)</Heading>

<ManSection>
<Filt Name="IsBlist" Arg='obj' Type='Category'/>

<Description>
A boolean list (<Q>blist</Q>) is a list that has no holes and contains
only <K>true</K> and <K>false</K>.
Boolean lists can be represented in an efficient compact form, see 
<Ref Sect="More about Boolean Lists"/>  for details.
<P/>
<Example><![CDATA[
gap> IsBlist( [ true, true, false, false ] );
true
gap> IsBlist( [] );
true
gap> IsBlist( [false,,true] );  # has holes
false
gap> IsBlist( [1,1,0,0] );      # contains not only boolean values
false
gap> IsBlist( 17 );             # is not even a list
false
]]></Example>
<P/>
Boolean lists are lists and all operations for lists are therefore
applicable to boolean lists.
<P/>
Boolean lists can be used in various ways, but maybe the most important
application is their use for the description of <E>subsets</E> of finite
sets.
Suppose <M>set</M> is a finite set, represented as a list.
Then a subset <M>sub</M> of <M>set</M> is represented  by a boolean list
<M>blist</M> of the same length as <M>set</M> such that
<M>blist[i]</M> is <K>true</K>
if <M>set[i]</M> is in <M>sub</M>,
and <K>false</K> otherwise.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Boolean Lists Representing Subsets">
<Heading>Boolean Lists Representing Subsets</Heading>

<ManSection>
<Func Name="BlistList" Arg='list, sub'/>

<Description>
returns a new boolean list that describes the list <A>sub</A>
as a sublist of the dense list <A>list</A>.
That is <Ref Func="BlistList"/> returns a boolean list <M>blist</M> of
the same length as <A>list</A> such that <M>blist[i]</M>
is <K>true</K> if <A>list</A><M>[i]</M> is in <A>sub</A>
and <K>false</K> otherwise.
<P/>
<A>list</A> need not be a proper set
(see&nbsp;<Ref Sect="Sorted Lists and Sets"/>),
even though in this case <Ref Func="BlistList"/> is most efficient.
In particular <A>list</A> may contain duplicates.
<A>sub</A> need not be a proper sublist of <A>list</A>,
i.e., <A>sub</A> may contain elements that are not in <A>list</A>.
Those elements of course have no influence on the result of
<Ref Func="BlistList"/>.
<P/>
<Example><![CDATA[
gap> BlistList( [1..10], [2,3,5,7] );
[ false, true, true, false, true, false, true, false, false, false ]
gap> BlistList( [1,2,3,4,5,2,8,6,4,10], [4,8,9,16] );
[ false, false, false, true, false, false, true, false, true, false ]
]]></Example>
<P/>
See also&nbsp;<Ref Func="UniteBlistList"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ListBlist" Arg='list, blist'/>

<Description>
returns the sublist <M>sub</M> of the list <A>list</A>, which must have
no holes, represented by the boolean list <A>blist</A>, which must have
the same length as <A>list</A>.
<P/>
<M>sub</M> contains the element <A>list</A><M>[i]</M> if
<A>blist</A><M>[i]</M> is <K>true</K> and does not contain the
element if <A>blist</A><M>[i]</M> is <K>false</K>.
The order of the elements in <M>sub</M> is
the same as the order of the corresponding elements in <A>list</A>.
<P/>
<Example><![CDATA[
gap> ListBlist([1..8],[false,true,true,true,true,false,true,true]);
[ 2, 3, 4, 5, 7, 8 ]
gap> ListBlist( [1,2,3,4,5,2,8,6,4,10],
> [false,false,false,true,false,false,true,false,true,false] );
[ 4, 8, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SizeBlist" Arg='blist'/>

<Description>
returns the number of entries of the boolean list <A>blist</A> that are
<K>true</K>.
This is the size of the subset represented by the boolean list
<A>blist</A>.
<P/>
<Example><![CDATA[
gap> SizeBlist( [ false, true, false, true, false ] );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsSubsetBlist" Arg='blist1, blist2'/>

<Description>
returns <K>true</K> if the boolean list <A>blist2</A> is a subset of the
boolean list <A>blist1</A>, which must have equal length,
and <K>false</K> otherwise.
<A>blist2</A> is a subset of <A>blist1</A> if
<A>blist1</A><M>[i] =</M> <A>blist1</A><M>[i]</M> <K>or</K>
<A>blist2</A><M>[i]</M> for all <M>i</M>.
<P/>
<Example><![CDATA[
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> IsSubsetBlist( blist1, blist2 );
false
gap> blist2 := [ true, false, false, false ];;
gap> IsSubsetBlist( blist1, blist2 );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Set Operations via Boolean Lists">
<Heading>Set Operations via Boolean Lists</Heading>

<ManSection>
<Heading>UnionBlist</Heading>
<Func Name="UnionBlist" Arg='blist1,blist2[,...]'
 Label="for various boolean lists"/>
<Func Name="UnionBlist" Arg='list' Label="for a list"/>

<Description>
In the first form
<Ref Func="UnionBlist" Label="for various boolean lists"/> returns the
union of the boolean lists <A>blist1</A>, <A>blist2</A>, etc.,
which must have equal length.
The <E>union</E> is a new boolean list that contains at position <M>i</M>
the value <A>blist1</A><M>[i]</M> <K>or</K>
<A>blist2</A><M>[i]</M> <K>or</K> <M>\ldots</M>.
<P/>
The second form takes the union of all blists (which
as for the first form must have equal length) in the list <A>list</A>.
</Description>
</ManSection>

<ManSection>
<Heading>IntersectionBlist</Heading>
<Func Name="IntersectionBlist" Arg='blist1,blist2[,...]'
 Label="for various boolean lists"/>
<Func Name="IntersectionBlist" Arg='list' Label="for a list"/>

<Description>
In the first form
<Ref Func="IntersectionBlist" Label="for various boolean lists"/> returns
the intersection of the boolean lists <A>blist1</A>, <A>blist2</A>, etc.,
which must have equal length.
The <E>intersection</E> is a new blist that contains at position <M>i</M>
the value <A>blist1</A><M>[i]</M>
<K>and</K> <A>blist2</A><M>[i]</M> <K>and</K> <M>\ldots</M>.
<P/>
In the second form <A>list</A> must be a list of boolean lists
<A>blist1</A>, <A>blist2</A>, etc., which must have equal length,
and <Ref Func="IntersectionBlist" Label="for a list"/> returns the
intersection of those boolean lists.
</Description>
</ManSection>

<ManSection>
<Func Name="DifferenceBlist" Arg='blist1, blist2'/>

<Description>
returns the asymmetric set difference of the two
boolean lists <A>blist1</A> and <A>blist2</A>,
which must have equal length.
The <E>asymmetric set difference</E> is a new boolean list that contains
at position <M>i</M> the value
<A>blist1</A><M>[i]</M> <K>and</K> <K>not</K>
<A>blist2</A><M>[i]</M>.
<P/>
<Example><![CDATA[
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> UnionBlist( blist1, blist2 );
[ true, true, true, false ]
gap> IntersectionBlist( blist1, blist2 );
[ true, false, false, false ]
gap> DifferenceBlist( blist1, blist2 );
[ false, true, false, false ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Function that Modify Boolean Lists">
<Heading>Function that Modify Boolean Lists</Heading>

<ManSection>
<Func Name="UniteBlist" Arg='blist1, blist2'/>

<Description>
<Ref Func="UniteBlist"/> unites the boolean list <A>blist1</A> with the
boolean list <A>blist2</A>, which must have the same length.
This is equivalent to assigning
<A>blist1</A><M>[i] :=</M> <A>blist1</A><M>[i]</M> <K>or</K>
<A>blist2</A><M>[i]</M> for all <M>i</M>.
<P/>
<Ref Func="UniteBlist"/> returns nothing, it is only
called to change <A>blist1</A>.
<P/>
<Example><![CDATA[
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> UniteBlist( blist1, blist2 );
gap> blist1;
[ true, true, true, false ]
]]></Example>
<P/>
The function <Ref Func="UnionBlist" Label="for a list"/> is the
nondestructive counterpart to <Ref Func="UniteBlist"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="UniteBlistList" Arg='list, blist, sub'/>

<Description>
works like
<C>UniteBlist(<A>blist</A>,BlistList(<A>list</A>,<A>sub</A>))</C>.
As no intermediate blist is created, the performance is better than the
separate function calls.
</Description>
</ManSection>

<ManSection>
<Func Name="IntersectBlist" Arg='blist1, blist2'/>

<Description>
intersects the boolean list <A>blist1</A> with the boolean list
<A>blist2</A>, which must have the same length.
This is equivalent to assigning
<A>blist1</A><M>[i]:=</M> <A>blist1</A><M>[i]</M> <K>and</K>
<A>blist2</A><M>[i]</M> for all <M>i</M>.
<P/>
<Ref Func="IntersectBlist"/> returns nothing,
it is only called to change <A>blist1</A>.
<P/>
<Example><![CDATA[
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> IntersectBlist( blist1, blist2 );
gap> blist1;
[ true, false, false, false ]
]]></Example>
<P/>
The function <Ref Func="IntersectionBlist" Label="for a list"/> is the
nondestructive counterpart to <Ref Func="IntersectBlist"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="SubtractBlist" Arg='blist1, blist2'/>

<Description>
subtracts the boolean list <A>blist2</A> from the boolean list
<A>blist1</A>, which must have equal length.
This is equivalent to assigning
<A>blist1</A><M>[i]:=</M> <A>blist1</A><M>[i]</M> <K>and</K> <K>not</K>
<A>blist2</A><M>[i]</M>
for all <M>i</M>.
<P/>
<Ref Func="SubtractBlist"/> returns nothing, it is only called to change
<A>blist1</A>.
<P/>
<Example><![CDATA[
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> SubtractBlist( blist1, blist2 );
gap> blist1;
[ false, true, false, false ]
]]></Example>
<P/>
The function <Ref Func="DifferenceBlist"/> is the
nondestructive counterpart to <Ref Func="SubtractBlist"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="More about Boolean Lists">
<Heading>More about Boolean Lists</Heading>

We defined a boolean list as a list that has no holes and contains only
<K>true</K> and <K>false</K>.
There is a special internal representation for boolean lists that needs
only 1 bit for each entry.
This bit is set if the entry is <K>true</K> and reset if the entry is
<K>false</K>.
This representation is of course much more compact than the ordinary
representation of lists, which needs 32 or 64 bits per entry.
<P/>
<!-- %T Add a note about internal representation of plain lists (preferably in -->
<!-- %T the chapter <Q>Lists</Q>), -->
<!-- %T in order to allow a user to estimate the space needed for -->
<!-- %T computations with lists; -->
<!-- %T then add cross-references from and to the other available list -->
<!-- %T representations! -->
<P/>
Not every boolean list is represented in this compact representation. It
would be too much work to test every time a list is changed, whether this
list has become a boolean list.  This section tells you under which
circumstances a   boolean list is represented  in  the compact
representation, so you can write your functions in such a way that you make
best use of the compact representation.
<P/>
If a dense list containing only <K>true</K> and <K>false</K> is read, it
is stored in the compact representation. Furthermore,
the results of <Ref Func="BlistList"/>,
<Ref Func="UnionBlist" Label="for a list"/>,
<Ref Func="IntersectionBlist" Label="for a list"/>
and <Ref Func="DifferenceBlist"/> are known
to be boolean lists by construction, and thus
are represented in the compact representation upon creation.
<P/>
If an argument of <Ref Func="IsSubsetBlist"/>,
<Ref Func="ListBlist"/>, <Ref Func="UnionBlist" Label="for a list"/>,
<Ref Func="IntersectionBlist" Label="for a list"/>,
<Ref Func="DifferenceBlist"/>,
<Ref Func="UniteBlist"/>, <Ref Func="IntersectBlist"/> and
<Ref Func="SubtractBlist"/> is a list represented in the ordinary
representation, it is
tested to see if it is in fact a boolean list.
If it is not, an error is signalled. If it is,  the
representation of the list  is changed to  the compact representation.
<P/>
If you change a  boolean list that is  represented in  the compact
representation by assignment (see <Ref Sect="List Assignment"/>) or
<Ref Func="Add"/>
in such a way that the list remains a boolean list  it will remain
represented in the compact representation.  Note that changing a list
that is not represented in the compact representation, whether it is a
boolean list or not, in such a way that the resulting list becomes a
boolean list, will never change the representation of the list.

<ManSection>
<Filt Name="IsBlistRep" Arg='obj' Type='Representation'/>
<Func Name="ConvertToBlistRep"  Arg='blist' />
<Returns><K>true</K> or <K>false</K></Returns>
<Description>
The first function is a filter that returns <K>true</K> if 
the object <A>obj</A> is 
a boolean list in compact representation and <K>false</K> otherwise, 
see  <Ref Sect="More about Boolean Lists"/>.<P/>

The second function converts the object <A>blist</A> to a boolean list 
in compact representation and returns <K>true</K> if this is possible.
Otherwise <A>blist</A> is unchanged and <K>false</K> is returned.
<Example>
gap> l := [true, false, true];
[ true, false, true ]
gap> IsBlistRep(l);
true
gap> l := [true, false, 1]; 
[ true, false, 1 ]
gap> l[3] := false;
false
gap> IsBlistRep(l);
false
gap> ConvertToBlistRep(l);
true
</Example>
</Description>
</ManSection>


</Section>
</Chapter>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  vector.msk                  GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: vector.msk,v 1.23 2003/03/26 17:45:05 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Row Vectors">
<Heading>Row Vectors</Heading>

Just as in mathematics, a vector in &GAP; is any object which
supports appropriate addition and scalar multiplication operations
(see Chapter&nbsp;<Ref Chap="Vector Spaces"/>).
As in mathematics, an especially important class of vectors are those
represented by a list of coefficients with respect to some basis.
These correspond roughly to the &GAP; concept of <E>row vectors</E>.

<!-- %%  The basic design of the row vector support in &GAP; 4 is due to -->
<!-- %%  Martin Schönert. Frank Celler added the special support for -->
<!-- %%  vectors over the field of two elements; Steve Linton added special -->
<!-- %%  support for vectors over fields of sizes between 3 and 256; and Werner -->
<!-- %%  Nickel added special methods for vectors over large finite fields. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsRowVector">
<Heading>IsRowVector (Filter)</Heading>

<ManSection>
<Filt Name="IsRowVector" Arg='obj' Type='Category'/>

<Description>
A <E>row vector</E> is a vector (see&nbsp;<Ref Func="IsVector"/>)
that is also a homogeneous list of odd additive nesting depth
(see&nbsp;<Ref Sect="Filters Controlling the Arithmetic Behaviour of Lists"/>).
Typical examples are lists of integers and rationals,
lists of finite field elements of the same characteristic,
and lists of polynomials from a common polynomial ring.
Note that matrices are <E>not</E> regarded as row vectors, because they have
even additive nesting depth.
<P/>
The additive operations of the vector must thus be compatible with
that for lists, implying that the list entries are the
coefficients of the vector with respect to some basis.
<P/>
Note that not all row vectors admit a multiplication via <C>*</C>
(which is to be understood as a scalar product);
for example, class functions are row vectors but the product of two
class functions is defined in a different way.
For the installation of a scalar product of row vectors, the entries of
the vector must be ring elements; note that the default method expects
the row vectors to lie in <C>IsRingElementList</C>,
and this category may not be implied by <Ref Func="IsRingElement"/>
for all entries of the row vector
(see the comment in <Ref Func="IsVector"/>).
<P/>
Note that methods for special types of row vectors really must be
installed with the requirement <Ref Func="IsRowVector"/>,
since <Ref Func="IsVector"/> may lead to a rank of the method below
that of the default method for row vectors (see file <F>lib/vecmat.gi</F>).
<P/>
<Example><![CDATA[
gap> IsRowVector([1,2,3]);
true
]]></Example>
<P/>
Because row vectors are just a special case of lists, all operations
and functions for lists are applicable to row vectors as well (see
Chapter&nbsp;<Ref Chap="Lists"/>).
This especially includes accessing elements of a row vector
(see <Ref Sect="List Elements"/>), changing elements of a mutable row
vector (see <Ref Sect="List Assignment"/>),
and comparing row vectors (see <Ref Sect="Comparisons of Lists"/>).
<P/>
Note that, unless your algorithms specifically require you to be able
to change entries of your vectors, it is generally better and faster
to work with immutable row vectors.
See Section&nbsp;<Ref Sect="Mutability and Copyability"/> for more
details.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operators for Row Vectors">
<Heading>Operators for Row Vectors</Heading>

The rules for arithmetic operations involving row vectors are in fact
special cases of those for the arithmetic of lists,
as given in Section&nbsp;<Ref Sect="Arithmetic for Lists"/>
and the following sections,
here we reiterate that definition, in the language of vectors.
<P/>
Note that the additive behaviour sketched below is defined only for lists in
the category <Ref Func="IsGeneralizedRowVector"/>,
and the multiplicative behaviour is defined only for lists in the category
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>.
<P/>
<Index Subkey="vectors">addition</Index>
<C><A>vec1</A> + <A>vec2</A></C>
<P/>
returns the sum of the two row vectors <A>vec1</A> and <A>vec2</A>.
Probably the most usual situation is that <A>vec1</A> and <A>vec2</A> have
the same length and are defined over a common field;
in this case the sum is a new row vector over the same field where each entry
is the sum of the corresponding entries of the vectors.
<P/>
In more general situations, the sum of two row vectors need not be a row
vector, for example adding an integer vector <A>vec1</A> and a vector
<A>vec2</A> over a finite field yields the list of pointwise sums,
which will be a mixture of finite field elements and integers if <A>vec1</A>
is longer than <A>vec2</A>.
<P/>
<Index Subkey="vector and scalar">addition</Index>
<C><A>scalar</A> + <A>vec</A></C>
<P/>
<C><A>vec</A> + <A>scalar</A></C>
<P/>
returns the sum of the scalar <A>scalar</A> and the row vector <A>vec</A>.
Probably the most usual situation is that the elements of <A>vec</A> lie in a
common field with <A>scalar</A>;
in this case the sum is a new row vector over the same field where each entry
is the sum of the scalar and the corresponding entry of the vector.
<P/>
More general situations are for example the sum of an integer scalar and a
vector over a finite field, or the sum of a finite field element and an
integer vector.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3 ] + [ 1/2, 1/3, 1/4 ];
[ 3/2, 7/3, 13/4 ]
gap>  [ 1/2, 3/2, 1/2 ] + 1/2;
[ 1, 2, 1 ]
]]></Example>
<P/>
<Index Subkey="vectors">subtraction</Index>
<Index Subkey="scalar and vector">subtraction</Index>
<Index Subkey="vector and scalar">subtraction</Index>
<C><A>vec1</A> - <A>vec2</A></C>
<P/>
<C><A>scalar</A> - <A>vec</A></C>
<P/>
<C><A>vec</A> - <A>scalar</A></C>
<P/>
Subtracting a vector or scalar is defined as adding its additive inverse,
so the statements for the addition hold likewise.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3 ] - [ 1/2, 1/3, 1/4 ];
[ 1/2, 5/3, 11/4 ]
gap> [ 1/2, 3/2, 1/2 ] - 1/2;
[ 0, 1, 0 ]
]]></Example>
<P/>
<Index Subkey="scalar and vector">multiplication</Index>
<Index Subkey="vector and scalar">multiplication</Index>
<C><A>scalar</A> * <A>vec</A></C>
<P/>
<C><A>vec</A> * <A>scalar</A></C>
<P/>
returns the product of the scalar <A>scalar</A> and the row vector <A>vec</A>.
Probably the most usual situation is that the elements of <A>vec</A> lie in a
common field with <A>scalar</A>;
in this case the product is a new row vector over the same field where each
entry is the product of the scalar and the corresponding entry of the vector.
<P/>
More general situations are for example the product of an integer scalar and
a vector over a finite field,
or the product of a finite field element and an integer vector.
<P/>
<Example><![CDATA[
gap> [ 1/2, 3/2, 1/2 ] * 2;
[ 1, 3, 1 ]
]]></Example>
<P/>
<Index Subkey="vectors">multiplication</Index>
<C><A>vec1</A> * <A>vec2</A></C>
<P/>
returns the standard scalar product of <A>vec1</A> and <A>vec2</A>,
i.e., the sum of the products of the corresponding entries of the vectors.
Probably the most usual situation is that <A>vec1</A> and <A>vec2</A> have
the same length and are defined over a common field;
in this case the sum is an element of this field.
<P/>
More general situations are for example the inner product of an integer
vector and a vector over a finite field,
or the inner product of two row vectors of different lengths.
<P/>
<Example><![CDATA[
gap> [ 1, 2, 3 ] * [ 1/2, 1/3, 1/4 ];
23/12
]]></Example>
<P/>
For the mutability of results of arithmetic operations,
see&nbsp;<Ref Sect="Mutability and Copyability"/>.
<P/>
Further operations with vectors as operands are defined by the matrix
operations, see&nbsp;<Ref Sect="Operators for Matrices"/>.

<ManSection>
<Attr Name="NormedRowVector" Arg='v'/>

<Description>
returns a scalar multiple <C><A>w</A> = <A>c</A> * <A>v</A></C>
of the row vector <A>v</A>
with the property that the first nonzero entry of <A>w</A> is an identity
element in the sense of <Ref Func="IsOne"/>.
<P/>
<Example><![CDATA[
gap> NormedRowVector( [ 5, 2, 3 ] );
[ 1, 2/5, 3/5 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Row Vectors over Finite Fields">
<Heading>Row Vectors over Finite Fields</Heading>

&GAP; can use compact formats to store row vectors over fields of
order at most 256, based on those used by the Meat-Axe
<Cite Key="Rin93"/>. This format also permits extremely efficient vector
arithmetic. On the other hand element access and assignment is
significantly slower than for plain lists.
<P/>
The function
<Ref Func="ConvertToVectorRep" Label="for a list (and a field)"/> is used to
convert a list into a compressed vector, or to rewrite a compressed vector
over another field.
Note that this function is <E>much</E> faster when it is given a
field (or field size) as an argument, rather than having to scan the
vector and try to decide the field. Supplying the field can also
avoid errors and/or loss of performance, when one vector from some
collection happens to have all of its entries over a smaller field
than the <Q>natural</Q> field of the problem.

<ManSection>
<Heading>ConvertToVectorRep</Heading>
<Func Name="ConvertToVectorRep" Arg='list[, field]'
 Label="for a list (and a field)"/>
<Func Name="ConvertToVectorRep" Arg='list[, fieldsize]'
 Label="for a list (and a prime power)"/>
<Func Name="ConvertToVectorRepNC" Arg='list[, field]'
 Label="for a list (and a field)"/>
<Func Name="ConvertToVectorRepNC" Arg='list[, fieldsize]'
 Label="for a list (and a prime power)"/>

<Description>
Called with one argument <A>list</A>,
<Ref Func="ConvertToVectorRep" Label="for a list (and a field)"/>
converts <A>list</A> to an internal row vector representation
if possible.
<P/>
Called with a list <A>list</A> and a finite field <A>field</A>,
<Ref Func="ConvertToVectorRep" Label="for a list (and a field)"/>
converts <A>list</A> to an internal row vector representation appropriate
for a row vector over <A>field</A>.
<P/>
Instead of a <A>field</A> also its size <A>fieldsize</A> may be given.
<P/>
It is forbidden to call this function unless <A>list</A> is a plain
list or a row vector, <A>field</A> is a field, and all elements
of <A>list</A> lie in <A>field</A>.
Violation of this condition can lead to unpredictable behaviour or a
system crash.
(Setting the assertion level to at least 2 might catch some violations
before a crash, see&nbsp;<Ref Func="SetAssertionLevel"/>.)
<P/>
<A>list</A> may already be a compressed vector. In this case, if no
<A>field</A> or <A>fieldsize</A> is given, then nothing happens. If one is
given then the vector is rewritten as a compressed vector over the
given <A>field</A> unless it has the filter
<C>IsLockedRepresentationVector</C>, in which case it is not changed.
<P/>
The return value is the size of the field over which the vector
ends up written, if it is written in a compressed representation.
<P/>
In this example, we first create a row vector and then ask &GAP; to
rewrite it, first over <C>GF(2)</C> and then over <C>GF(4)</C>.
<P/>
<Example><![CDATA[
gap> v := [Z(2)^0,Z(2),Z(2),0*Z(2)];
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IsPlistRep", "IsInternalRep" ]
gap> ConvertToVectorRep(v);
2
gap> v;
<a GF2 vector of length 4>
gap> ConvertToVectorRep(v,4);
4
gap> v;
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IsDataObjectRep", "Is8BitVectorRep" ]
]]></Example>
<P/>
A vector in the special representation over <C>GF(2)</C> is always viewed
as <C>&lt;a GF2 vector of length ...></C>.
Over fields of orders 3 to 256, a vector of length 10 or less is viewed
as the list of its coefficients, but a longer one is abbreviated.
<P/>
Arithmetic operations (see&nbsp;<Ref Sect="Arithmetic for Lists"/> and
the following sections) preserve the compression status of row vectors in
the sense that if all arguments are compressed row vectors written over
the same field and the result is a row vector then also the result is a
compressed row vector written over this field.
</Description>
</ManSection>

<ManSection>
<Oper Name="NumberFFVector" Arg='vec, sz'/>

<Description>
returns an integer that gives the position of the finite field row vector
<A>vec</A> in the sorted list of all row vectors over the field with
<A>sz</A> elements in the same dimension as <A>vec</A>.
<Ref Func="NumberFFVector"/> returns <K>fail</K> if the vector cannot be
represented over the field with <A>sz</A> elements.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coefficient List Arithmetic">
<Heading>Coefficient List Arithmetic</Heading>

The following operations all perform arithmetic on row vectors.
given as homogeneous lists of the same length, containing
elements of a commutative ring.
<P/>
There are two reasons for using <Ref Func="AddRowVector"/>
in preference to arithmetic operators.
Firstly, the three argument form has no single-step equivalent.
Secondly <Ref Func="AddRowVector"/> changes its first argument in-place,
rather than allocating a new vector to hold the result,
and may thus produce less garbage.

<ManSection>
<Oper Name="AddRowVector" Arg='dst, src[, mul[, from, to]]'/>

<Description>
Adds the product of <A>src</A> and <A>mul</A> to <A>dst</A>,
changing <A>dst</A>.
If <A>from</A> and <A>to</A> are given then only the index range
<C>[ <A>from</A> .. <A>to</A> ]</C> is guaranteed to be affected.
Other indices <E>may</E> be affected, if it is more convenient to do so.
Even when <A>from</A> and <A>to</A> are given,
<A>dst</A> and <A>src</A> must be row vectors of the <E>same</E> length.
<P/>
If <A>mul</A> is not given either then this operation simply adds
<A>src</A> to <A>dst</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AddCoeffs" Arg='list1[, poss1], list2[, poss2[, mul]]'/>

<Description>
<Ref Func="AddCoeffs"/> adds the entries of
<A>list2</A><C>{</C><A>poss2</A><C>}</C>, multiplied by the scalar
<A>mul</A>, to <A>list1</A><C>{</C><A>poss1</A><C>}</C>.
Unbound entries in <A>list1</A> are assumed to be zero.
The position of the right-most non-zero element is returned.
<P/>
If the ranges <A>poss1</A> and <A>poss2</A> are not given,
they are assumed to span the whole vectors.
If the scalar <A>mul</A> is omitted, one is used as a default.
<P/>
Note that it is the responsibility of the caller to ensure that
<A>list2</A> has elements at position <A>poss2</A> and that the result
(in <A>list1</A>) will be a dense list.
<P/>
The function is free to remove trailing (right-most) zeros.
<Example><![CDATA[
gap> l:=[1,2,3,4];;m:=[5,6,7];;AddCoeffs(l,m);
4
gap> l;
[ 6, 8, 10, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="MultRowVector" Arg='list1, [poss1, list2, poss2, ]mul'/>

<Description>
The five argument version of this operation replaces
<A>list1</A><C>[</C><A>poss1</A><C>[</C><M>i</M><C>]]</C> by
<C><A>mul</A>*<A>list2</A>[<A>poss2</A>[</C><M>i</M><C>]]</C> for <M>i</M>
between <M>1</M> and <C>Length( <A>poss1</A> )</C>.
<P/>
The two-argument version simply multiplies each element of <A>list1</A>, 
in-place, by <A>mul</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="CoeffsMod" Arg='list1, [len1, ]modulus'/>

<Description>
returns the coefficient list obtained by reducing the entries in
<A>list1</A> modulo <A>modulus</A>.
After reducing it shrinks the list to remove trailing zeroes.
If the optional argument <A>len1</A> is used, it reduces
only first <A>len1</A> elements of the list. 
<Example><![CDATA[
gap> l:=[1,2,3,4];;CoeffsMod(l,2);
[ 1, 0, 1 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Shifting and Trimming Coefficient Lists">
<Heading>Shifting and Trimming Coefficient Lists</Heading>

The following functions change coefficient lists by shifting or
trimming.

<ManSection>
<Oper Name="LeftShiftRowVector" Arg='list, shift'/>

<Description>
changes <A>list</A> by assigning
<A>list</A><M>[i]</M><C>:= </C><A>list</A><M>[i+<A>shift</A>]</M>
and removing the last <A>shift</A> entries of the result.
</Description>
</ManSection>

<ManSection>
<Oper Name="RightShiftRowVector" Arg='list, shift, fill'/>

<Description>
changes <A>list</A> by assigning
<A>list</A><M>[i+<A>shift</A>]</M><C>:= </C><A>list</A><M>[i]</M>
and filling each of the <A>shift</A> first entries with <A>fill</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ShrinkRowVector" Arg='list'/>

<Description>
removes trailing zeroes from the list <A>list</A>.
<Example><![CDATA[
gap> l:=[1,0,0];;ShrinkRowVector(l);l;
[ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RemoveOuterCoeffs" Arg='list, coef'/>

<Description>
removes <A>coef</A> at the beginning and at the end of <A>list</A>
and returns the number of elements removed at the beginning.
<Example><![CDATA[
gap> l:=[1,1,2,1,2,1,1,2,1];; RemoveOuterCoeffs(l,1);
2
gap> l;
[ 2, 1, 2, 1, 1, 2 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Functions for Coding Theory">
<Heading>Functions for Coding Theory</Heading>

The following functions perform operations on finite fields vectors
considered as code words in a linear code.

<ManSection>
<Oper Name="WeightVecFFE" Arg='vec'/>

<Description>
returns the weight of the finite field vector <A>vec</A>, i.e. the number of
nonzero entries.
</Description>
</ManSection>

<ManSection>
<Oper Name="DistanceVecFFE" Arg='vec1,vec2'/>

<Description>
returns the distance between the two vectors <A>vec1</A> and <A>vec2</A>,
which must have the same length and whose elements must lie in a common
field.
The distance is the number of places where <A>vec1</A> and <A>vec2</A>
differ.
</Description>
</ManSection>

<ManSection>
<Oper Name="DistancesDistributionVecFFEsVecFFE" Arg='vecs, vec'/>

<Description>
returns the distances distribution of the vector <A>vec</A> to the
vectors in the list <A>vecs</A>.
All vectors must have the same length,
and all elements must lie in a common field.
The distances distribution is a list <M>d</M> of
length <C>Length(<A>vec</A>)+1</C>, such that the value <M>d[i]</M> is
the number of vectors in <A>vecs</A> that have distance <M>i+1</M> to
<A>vec</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="DistancesDistributionMatFFEVecFFE" Arg='mat, F, vec'/>

<Description>
returns the distances distribution of the vector <A>vec</A> to the
vectors in the vector space generated by the rows of the matrix
<A>mat</A> over the finite field <A>F</A>.
The length of the rows of <A>mat</A> and the length of <A>vec</A> must be
equal, and all entries must lie in <A>F</A>.
The rows of <A>mat</A> must be linearly independent.
The distances distribution is a list <M>d</M> of length
<C>Length(<A>vec</A>)+1</C>, such that the value <M>d[i]</M> is the
number of vectors in the vector space generated by the rows of <A>mat</A>
that have distance <M>i+1</M> to <A>vec</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AClosestVectorCombinationsMatFFEVecFFE"
 Arg='mat, f, vec, l, stop'/>
<Oper Name="AClosestVectorCombinationsMatFFEVecFFECoords"
 Arg='mat, f, vec, l, stop'/>

<Description>
These functions run through the <A>f</A>-linear combinations of the
vectors in the rows of the matrix <A>mat</A> that can be written as
linear combinations of exactly <A>l</A> rows (that is without using
zero as a coefficient). The length of the rows of <A>mat</A> and the
length of <A>vec</A> must be equal, and all elements must lie in the
field <A>f</A>.
The rows of <A>mat</A> must be linearly independent.
<Ref Func="AClosestVectorCombinationsMatFFEVecFFE"/> returns a vector
from these that is closest to the vector <A>vec</A>.
If it finds a vector of distance at most <A>stop</A>,
which must be a nonnegative integer, then it stops immediately
and returns this vector.
<P/>
<Ref Func="AClosestVectorCombinationsMatFFEVecFFECoords"/> returns a
length 2 list containing the same closest vector and also a vector
<A>v</A> with exactly <A>l</A> non-zero entries,
such that <A>v</A> times <A>mat</A> is the closest vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="CosetLeadersMatFFE" Arg='mat, f'/>

<Description>
returns a list of representatives of minimal weight for the cosets of a
code.
<A>mat</A> must be a <E>check matrix</E> for the code,
the code is defined over the finite field <A>f</A>.
All rows of <A>mat</A> must have the same length, and all elements must
lie in the field <A>f</A>.
The rows of <A>mat</A> must be linearly independent.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Vectors as coefficients of polynomials">
<Heading>Vectors as coefficients of polynomials</Heading>

A list of ring elements can be interpreted as a row vector or the list of
coefficients of a polynomial. There are a couple of functions that implement
arithmetic operations based on these interpretations. &GAP; contains proper
support for polynomials (see&nbsp;<Ref Chap="Polynomials and Rational Functions"/>), the
operations described in this section are on a lower level.
<P/>
The following operations all perform arithmetic on univariate
polynomials given by their coefficient lists. These lists can have
different lengths but must be dense homogeneous lists containing
elements of a commutative ring.
Not all input lists may be empty.
<P/>
In the following descriptions we will always assume that <A>list1</A> is
the coefficient list of the polynomial <A>pol1</A> and so forth.
If length parameter <A>leni</A> is not given, it is set to the length of
<A>listi</A> by default.

<ManSection>
<Func Name="ValuePol" Arg='coeff, x'/>

<Description>
Let <A>coeff</A> be the coefficients list of a univariate polynomial
<M>f</M>, and <A>x</A> a ring element.
Then <Ref Func="ValuePol"/> returns the value <M>f(<A>x</A>)</M>.
<P/>
The coefficient of <M><A>x</A>^i</M> is assumed to be stored
at position <M>i+1</M> in the coefficients list.
<Example><![CDATA[
gap> ValuePol([1,2,3],4);
57
]]></Example>
</Description>
</ManSection>


<!-- %\ Declaration{MultCoeffs} -->
<!-- %\ beginexample -->
<!-- %gap> a:=[];;l:=[1,2,3,4];;m:=[5,6,7];; -->
<!-- %gap> MultCoeffs(a,l,4,m,3); -->
<!-- %6 -->
<!-- %gap> a; -->
<!-- %[ 5, 16, 34, 52, 45, 28 ] -->
<!-- %\ endexample -->

<ManSection>
<Oper Name="ProductCoeffs" Arg='list1[, len1], list2[, len2]'/>

<Description>
Let <M>p1</M> (and <M>p2</M>) be polynomials given by the first
<A>len1</A> (<A>len2</A>) entries of the coefficient list <A>list2</A>
(<A>list2</A>).
If <A>len1</A> and <A>len2</A> are omitted,
they default to the lengths of <A>list1</A> and <A>list2</A>.
This operation returns the coefficient list of the product of <M>p1</M>
and <M>p2</M>.
<Example><![CDATA[
gap> l:=[1,2,3,4];;m:=[5,6,7];;ProductCoeffs(l,m);
[ 5, 16, 34, 52, 45, 28 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ReduceCoeffs" Arg='list1[, len1], list2[, len2]'/>

<Description>
Let <M>p1</M> (and <M>p2</M>) be polynomials given by the first
<A>len1</A> (<A>len2</A>) entries of the coefficient list <A>list1</A>
(<A>list2</A>).
If <A>len1</A> and <A>len2</A> are omitted,
they default to the lengths of <A>list1</A> and <A>list2</A>.
<Ref Func="ReduceCoeffs"/> changes <A>list1</A> to the coefficient list
of the remainder when dividing <A>p1</A> by <A>p2</A>.
This operation changes <A>list1</A> which therefore must be a mutable
list.
The operation returns the position of the last non-zero entry of the
result but is not guaranteed to remove trailing zeroes.
<Example><![CDATA[
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffs(l,m);
2
gap> l;
[ 64/49, -24/49, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ReduceCoeffsMod"
 Arg='list1[, len1], list2[, len2], modulus'/>

<Description>
Let <M>p1</M> (and <M>p2</M>) be polynomials given by the first
<A>len1</A> (<A>len2</A>) entries of the coefficient list <A>list1</A>
(<A>list2</A>).
If <A>len1</A> and <A>len2</A> are omitted,
they default to the lengths of <A>list1</A> and <A>list2</A>.
<Ref Func="ReduceCoeffsMod"/> changes <A>list1</A> to the
coefficient list of the remainder when dividing
<A>p1</A> by <A>p2</A> modulo <A>modulus</A>,
which must be a positive integer.
This operation changes <A>list1</A> which therefore must be a mutable
list.
The operations returns the position of the last non-zero entry of the
result but is not guaranteed to remove trailing zeroes.
<Example><![CDATA[
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffsMod(l,m,3);
1
gap> l;
[ 1, 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PowerModCoeffs" Arg='list1[, len1], exp, list2[, len2]'/>

<Description>
Let <M>p1</M> and <M>p2</M> be polynomials whose coefficients are given
by the first <A>len1</A> resp. <A>len2</A> entries of the lists
<A>list1</A> and <A>list2</A>, respectively.
If <A>len1</A> and <A>len2</A> are omitted, they default to the lengths
of <A>list1</A> and <A>list2</A>.
Let <A>exp</A> be a positive integer.
<Ref Func="PowerModCoeffs"/> returns the coefficient list of the
remainder when dividing the <A>exp</A>-th power of <M>p1</M> by
<M>p2</M>.
The coefficients are reduced already while powers are computed,
therefore avoiding an explosion in list length.
<Example><![CDATA[
gap> l:=[1,2,3,4];;m:=[5,6,7];;PowerModCoeffs(l,5,m);
[ -839462813696/678223072849, -7807439437824/678223072849 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ShiftedCoeffs" Arg='list, shift'/>

<Description>
produces a new coefficient list <C>new</C> obtained by the rule
<C>new[i+<A>shift</A>]:= <A>list</A>[i]</C>
and filling initial holes by the appropriate zero.
<Example><![CDATA[
gap> l:=[1,2,3];;ShiftedCoeffs(l,2);ShiftedCoeffs(l,-2);
[ 0, 0, 1, 2, 3 ]
[ 3 ]
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  matrix.msk                  GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: matrix.msk,v 1.42 2006/03/09 16:47:16 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Matrices">
<Heading>Matrices</Heading>

Matrices are represented in &GAP; by lists of row vectors
(see <Ref Chap="Row Vectors"/>) (for future changes to this
policy see Chapter <Ref Chap="Matrix objects"/>).
The vectors must all have the same length, and their elements must lie in
a common ring. However, since checking rectangularness can be expensive
functions and methods of operations for matrices often will not give an error
message for non-rectangular lists of lists &ndash;in such cases the result is
undefined.
<P/>
Because matrices are just a special case of lists, all operations and
functions for lists are applicable to matrices also (see chapter
<Ref Chap="Lists"/>).
This especially includes accessing elements of a matrix (see
<Ref Sect="List Elements"/>),
changing elements of a matrix (see <Ref Sect="List Assignment"/>),
and comparing matrices (see <Ref Sect="Comparisons of Lists"/>).
<P/>
Note that, since a matrix is a list of lists,
the behaviour of <Ref Oper="ShallowCopy"/>
for matrices is just a special case of <Ref Oper="ShallowCopy"/> for lists
(see&nbsp;<Ref Sect="Duplication of Lists"/>);
called with an immutable matrix <A>mat</A>,
<Ref Oper="ShallowCopy"/> returns a mutable matrix
whose rows are identical to the rows of <A>mat</A>.
In particular the rows are still immutable.
To get a matrix whose rows are mutable,
one can use <C>List( <A>mat</A>, ShallowCopy )</C>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:InfoMatrix">
<Heading>InfoMatrix (Info Class)</Heading>

<ManSection>
<InfoClass Name="InfoMatrix"/>

<Description>
The info class for matrix operations is <Ref InfoClass="InfoMatrix"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Categories of Matrices">
<Heading>Categories of Matrices</Heading>

<ManSection>
<Filt Name="IsMatrix" Arg='obj' Type='Category'/>

<Description>
A <E>matrix</E> is a list of lists of equal length whose entries lie in a
common ring.
<P/>
Note that matrices may have different multiplications,
besides the usual matrix product there is for example the Lie product.
So there are categories such as
<Ref Func="IsOrdinaryMatrix"/> and <Ref Func="IsLieMatrix"/>
that describe the matrix multiplication.
One can form the product of two matrices only if they support the same
multiplication.
<P/>
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];
[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]
gap> IsMatrix(mat);
true
]]></Example>
<P/>
Note also the filter <Ref Func="IsTable"/>
which may be more appropriate than <Ref Filt="IsMatrix"/>
for some purposes.
<P/>
Note that the empty list <C>[]</C> and more complex
<Q>empty</Q> structures such as <C>[[]]</C> are <E>not</E> matrices,
although special methods allow them be used in place of matrices in some
situations. See <Ref Func="EmptyMatrix"/> below.
<P/>
<Example><![CDATA[
gap> [[0]]*[[]];
[ [  ] ]
gap> IsMatrix([[]]);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsOrdinaryMatrix" Arg='obj' Type='Category'/>

<Description>
An <E>ordinary matrix</E> is a matrix whose multiplication is the ordinary
matrix multiplication.
<P/>
Each matrix in internal representation is in the category
<Ref Func="IsOrdinaryMatrix"/>,
and arithmetic operations with objects in <Ref Func="IsOrdinaryMatrix"/>
produce again matrices in <Ref Func="IsOrdinaryMatrix"/>.
<P/>
Note that we want that Lie matrices shall be matrices that behave in the
same way as ordinary matrices, except that they have a different
multiplication.
So we must distinguish the different matrix multiplications,
in order to be able to describe the applicability of multiplication,
and also in order to form a matrix of the appropriate type as the
sum, difference etc.&nbsp;of two matrices
which have the same multiplication.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLieMatrix" Arg='mat' Type='Category'/>

<Description>
A <E>Lie matrix</E> is a matrix whose multiplication is given by the
Lie bracket.
(Note that a matrix with ordinary matrix multiplication is in the
category <Ref Func="IsOrdinaryMatrix"/>.)
<P/>
Each matrix created by <Ref Func="LieObject"/> is in the category
<Ref Func="IsLieMatrix"/>,
and arithmetic operations with objects in <Ref Func="IsLieMatrix"/>
produce again matrices in <Ref Func="IsLieMatrix"/>.
<!--  We do not claim that every object in <Ref Func="IsLieMatrix"/>
      is also contained in <Ref Func="IsLieObject"/>,
      since the former describes the containment in a certain
      family and the latter describes a certain matrix multiplication;
      probably this distinction is unnecessary.  -->
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operators for Matrices">
<Heading>Operators for Matrices</Heading>

The rules for arithmetic operations involving matrices are in fact
special cases of those for the arithmetic of lists,
given in Section&nbsp;<Ref Sect="Arithmetic for Lists"/> and the following sections,
here we reiterate that definition, in the language of vectors and matrices.
<P/>
Note that the additive behaviour sketched below is defined only for lists in
the category <Ref Filt="IsGeneralizedRowVector"/>,
and the multiplicative behaviour is defined only for lists in the category
<Ref Filt="IsMultiplicativeGeneralizedRowVector"/>
(see&nbsp;<Ref Sect="Filters Controlling the Arithmetic Behaviour of Lists"/>).
<P/>
<Index Subkey="matrices">addition</Index>
<C><A>mat1</A> + <A>mat2</A></C>
<P/>
returns the sum of the two matrices <A>mat1</A> and <A>mat2</A>,
Probably the most usual situation is that <A>mat1</A> and <A>mat2</A> have the same
dimensions and are defined over a common field;
in this case the sum is a new matrix over the same field where each entry
is the sum of the corresponding entries of the matrices.
<P/>
In more general situations, the sum of two matrices need not be a matrix,
for example adding an integer matrix <A>mat1</A> and a matrix <A>mat2</A> over
a finite field yields the table of pointwise sums,
which will be a mixture of finite field elements and integers if <A>mat1</A> has
bigger dimensions than <A>mat2</A>.
<P/>
<Index Subkey="scalar and matrix">addition</Index>
<C><A>scalar</A> + <A>mat</A></C>
<P/>
<Index Subkey="matrix and scalar">addition</Index>
<C><A>mat</A> + <A>scalar</A></C>
<P/>
returns the sum of the scalar <A>scalar</A> and the matrix <A>mat</A>.
Probably the most usual situation is that the entries of <A>mat</A> lie in a
common field with <A>scalar</A>;
in this case the sum is a new matrix over the same field where each entry
is the sum of the scalar and the corresponding entry of the matrix.
<P/>
More general situations are for example the sum of an integer scalar and a
matrix over a finite field, or the sum of a finite field element and an
integer matrix.
<P/>
<Index Subkey="matrices">subtraction</Index>
<C><A>mat1</A> - <A>mat2</A></C>
<P/>
<Index Subkey="scalar and matrix">subtraction</Index>
<C><A>scalar</A> - <A>mat</A></C>
<P/>
<Index Subkey="matrix and scalar">subtraction</Index>
<C><A>mat</A> - <A>scalar</A></C>
<P/>
Subtracting a matrix or scalar is defined as adding its additive inverse,
so the statements for the addition hold likewise.
<P/>
<Index Subkey="scalar and matrix">multiplication</Index>
<C><A>scalar</A> * <A>mat</A></C>
<P/>
<Index Subkey="matrix and scalar">multiplication</Index>
<C><A>mat</A> * <A>scalar</A></C>
<P/>
returns the product of the scalar <A>scalar</A> and the matrix <A>mat</A>.
Probably the most usual situation is that the elements of <A>mat</A> lie in a
common field with <A>scalar</A>;
in this case the product is a new matrix over the same field where each
entry is the product of the scalar and the corresponding entry of the matrix.
<P/>
More general situations are for example the product of an integer scalar and
a matrix over a finite field,
or the product of a finite field element and an integer matrix.
<P/>
<Index Subkey="vector and matrix">multiplication</Index>
<C><A>vec</A> * <A>mat</A></C>
<P/>
returns the product of the row vector <A>vec</A> and the matrix <A>mat</A>.
Probably the most usual situation is that <A>vec</A> and <A>mat</A> have the same
lengths and are defined over a common field,
and that all rows of <A>mat</A> have the same length <M>m</M>, say;
in this case the product is a new row vector of length <M>m</M> over the same
field which is the sum of the scalar multiples of the rows of <A>mat</A> with the
corresponding entries of <A>vec</A>.
<P/>
More general situations are for example the product of an integer vector and
a matrix over a finite field,
or the product of a vector over a finite field and an integer matrix.
<P/>
<Index Subkey="matrix and vector">multiplication</Index>
<C><A>mat</A> * <A>vec</A></C>
<P/>
returns the product of the matrix <A>mat</A> and the row vector <A>vec</A>.
(This is the standard product of a matrix with a <E>column</E> vector.)
Probably the most usual situation is that the length of <A>vec</A> and of all rows
of <A>mat</A> are equal, and that the elements of <A>mat</A> and <A>vec</A> lie in a common
field;
in this case the product is a new row vector of the same length as <A>mat</A> and
over the same field which is the sum of the scalar multiples of the columns
of <A>mat</A> with the corresponding entries of <A>vec</A>.
<P/>
More general situations are for example the product of an integer matrix and
a vector over a finite field,
or the product of a matrix over a finite field and an integer vector.
<P/>
<Index Subkey="matrices">multiplication</Index>
<C><A>mat1</A> * <A>mat2</A></C>
<P/>
This form evaluates to the (Cauchy) product of the two matrices <A>mat1</A> and
<A>mat2</A>.
Probably the most usual situation is that the number of columns of <A>mat1</A>
equals the number of rows of <A>mat2</A>,
and that the elements of <A>mat</A> and <A>vec</A> lie in a common field;
if <A>mat1</A> is a matrix with <M>m</M> rows and <M>n</M> columns, say, and <A>mat2</A> is a
matrix with <M>n</M> rows and <M>o</M> columns, the result is a new matrix with <M>m</M>
rows and <M>o</M> columns.
The element in row <M>i</M> at position <M>j</M> of the product is the sum of
<M><A>mat1</A>[i][l] * <A>mat2</A>[l][j]</M>, with <M>l</M> running from <M>1</M> to <M>n</M>.
<P/>
<Index Subkey="matrix">inverse</Index>
<C>Inverse( <A>mat</A> )</C>
<P/>
returns the inverse of the matrix <A>mat</A>,
which must be an invertible square matrix.
If <A>mat</A> is not invertible then <K>fail</K> is returned.
<P/>
<Index Subkey="matrices">quotient</Index>
<C><A>mat1</A> / <A>mat2</A></C>
<P/>
<Index Subkey="scalar and matrix">quotient</Index>
<C><A>scalar</A> / <A>mat</A></C>
<P/>
<Index Subkey="matrix and scalar">quotient</Index>
<C><A>mat</A> / <A>scalar</A></C>
<P/>
<Index Subkey="vector and matrix">quotient</Index>
<C><A>vec</A> / <A>mat</A></C>
<P/>
In general, <C><A>left</A> / <A>right</A></C> is defined as <C><A>left</A> * <A>right</A>^-1</C>.
Thus in the above forms the right operand must always be invertible.
<P/>
<Index Subkey="matrix">power</Index>
<C><A>mat</A> ^ <A>int</A></C>
<P/>
<Index Subkey="matrix">conjugate</Index>
<C><A>mat1</A> ^ <A>mat2</A></C>
<P/>
<Index Subkey="vector under matrix">image</Index>
<C><A>vec</A> ^ <A>mat</A></C>
<P/>
Powering a square matrix <A>mat</A> by an integer <A>int</A> yields the <A>int</A>-th power
of <A>mat</A>; if <A>int</A> is negative then <A>mat</A> must be invertible,
if <A>int</A> is <C>0</C> then the result is the identity matrix <C>One( <A>mat</A> )</C>,
even if <A>mat</A> is not invertible.
<P/>
Powering a square matrix <A>mat1</A> by an invertible square matrix <A>mat2</A> of the
same dimensions yields the conjugate of <A>mat1</A> by <A>mat2</A>, i.e.,
the matrix <C><A>mat2</A>^-1 * <A>mat1</A> * <A>mat2</A></C>.
<P/>
Powering a row vector <A>vec</A> by a matrix <A>mat</A> is in every respect equivalent
to <C><A>vec</A> * <A>mat</A></C>.
This operations reflects the fact that matrices act naturally on row vectors
by multiplication from the right, and that the powering operator is &GAP;'s
standard for group actions.
<P/>
<Index Subkey="commutator">matrices</Index>
<C>Comm( <A>mat1</A>, <A>mat2</A> )</C>
<P/>
returns the commutator of the square invertible matrices <A>mat1</A> and <A>mat2</A>
of the same dimensions and over a common field,
which is the matrix <C><A>mat1</A>^-1 * <A>mat2</A>^-1 * <A>mat1</A> * <A>mat2</A></C>.
<P/>

The following cases are still special cases of the general list arithmetic
defined in&nbsp;<Ref Sect="Arithmetic for Lists"/>.
<P/>
<Index Subkey="scalar and matrix list">addition</Index>
<C><A>scalar</A> + <A>matlist</A></C>
<P/>
<Index Subkey="scalar and matrix list">addition</Index>
<C><A>matlist</A> + <A>scalar</A></C>
<P/>
<Index Subkey="scalar and matrix list">subtraction</Index>
<C><A>scalar</A> - <A>matlist</A></C>
<P/>
<Index Subkey="scalar and matrix list">subtraction</Index>
<C><A>matlist</A> - <A>scalar</A></C>
<P/>
<Index Subkey="scalar and matrix list">multiplication</Index>
<C><A>scalar</A> * <A>matlist</A></C>
<P/>
<Index Subkey="scalar and matrix list">multiplication</Index>
<C><A>matlist</A> * <A>scalar</A></C>
<P/>
<Index Subkey="scalar and matrix list">quotient</Index>
<C><A>matlist</A> / <A>scalar</A></C>
<P/>
A scalar <A>scalar</A> may also be added, subtracted, multiplied with, or
divided into a list <A>matlist</A> of matrices. The result is a new list
of matrices where each matrix is the result of performing the operation
with the corresponding matrix in <A>matlist</A>.
<P/>
<Index Subkey="matrix and matrix list">multiplication</Index>
<C><A>mat</A> * <A>matlist</A></C>
<P/>
<Index Subkey="matrix and matrix list">multiplication</Index>
<C><A>matlist</A> * <A>mat</A></C>
<P/>
A matrix <A>mat</A> may also be multiplied with a list <A>matlist</A> of matrices.
The result is a new list of matrices, where each entry is the product of
<A>mat</A> and the corresponding entry in <A>matlist</A>.
<P/>
<Index Subkey="matrix and matrix list">quotient</Index>
<C><A>matlist</A> / <A>mat</A></C>
<P/>
Dividing a list <A>matlist</A> of matrices by an invertible matrix <A>mat</A>
evaluates to <C><A>matlist</A> * <A>mat</A>^-1</C>.
<P/>
<Index Subkey="vector and matrix list">multiplication</Index>
<C><A>vec</A> * <A>matlist</A></C>
<P/>
returns the product of the vector <A>vec</A> and the list of matrices <A>mat</A>.
The lengths <A>l</A> of <A>vec</A> and <A>matlist</A> must be equal.
All matrices in <A>matlist</A> must have the same dimensions. The elements of
<A>vec</A> and the elements of the matrices in <A>matlist</A> must lie in a common
ring. The product is the sum over <C><A>vec</A>[<A>i</A>] * <A>matlist</A>[<A>i</A>]</C> with
<A>i</A> running from 1 to <A>l</A>.
<P/>

For the mutability of results of arithmetic operations,
see&nbsp;<Ref Sect="Mutability and Copyability"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties and Attributes of Matrices">
<Heading>Properties and Attributes of Matrices</Heading>

<ManSection>
<Attr Name="DimensionsMat" Arg='mat'/>

<Description>
is a list of length 2, the first being the number of rows, the second
being the number of columns of the matrix <A>mat</A>. If <A>mat</A> is
malformed, that is, it is not a <Ref Prop="IsRectangularTable"/>, 
returns <K>fail</K>.
<Example><![CDATA[
gap> DimensionsMat([[1,2,3],[4,5,6]]);
[ 2, 3 ]
gap> DimensionsMat([[1,2,3],[4,5]]);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DefaultFieldOfMatrix" Arg='mat'/>

<Description>
For a matrix <A>mat</A>, <Ref Attr="DefaultFieldOfMatrix"/> returns either a field
(not necessarily the smallest one) containing all entries of <A>mat</A>,
or <K>fail</K>.
<P/>
If <A>mat</A> is a matrix of finite field elements or a matrix of cyclotomics,
<Ref Attr="DefaultFieldOfMatrix"/> returns the default field generated by the matrix
entries (see&nbsp;<Ref Sect="Creating Finite Fields"/> and <Ref Sect="Operations for Cyclotomics"/>).
<Example><![CDATA[
gap> DefaultFieldOfMatrix([[Z(4),Z(8)]]);
GF(2^6)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TraceMat" Arg='mat'/>
<Func Name="Trace" Arg='mat' Label="of a matrix"/>

<Description>
The trace of a square matrix is the sum of its diagonal entries.
<Example><![CDATA[
gap> TraceMat([[1,2,3],[4,5,6],[7,8,9]]);
15
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DeterminantMat" Arg='mat'/>
<Attr Name="Determinant" Arg='mat'/>

<Description>
returns the determinant of the square matrix <A>mat</A>.
<P/>
These methods assume implicitly that <A>mat</A> is defined over an
integral domain whose quotient field is implemented in &GAP;. For
matrices defined over an arbitrary commutative ring with one 
see&nbsp;<Ref Func="DeterminantMatDivFree"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="DeterminantMatDestructive" Arg='mat'/>

<Description>
Does the same as <Ref Attr="DeterminantMat"/>, with the difference that it may
destroy its argument. The matrix <A>mat</A> must be mutable.
<Example><![CDATA[
gap> DeterminantMat([[1,2],[2,1]]);
-3
gap> mm:= [[1,2],[2,1]];;
gap> DeterminantMatDestructive( mm );
-3
gap> mm;
[ [ 1, 2 ], [ 0, -3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DeterminantMatDivFree" Arg='mat'/>

<Description>
returns the determinant of a square matrix <A>mat</A> over an arbitrary 
commutative ring with one using the division free method of 
Mahajan and Vinay <Cite Key="MV97"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsMonomialMatrix" Arg='mat'/>

<Description>
A matrix is monomial if  and only if it  has exactly one nonzero entry in
every row and every column.
<Example><![CDATA[
gap> IsMonomialMatrix([[0,1],[1,0]]);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsDiagonalMat" Arg='mat'/>

<Description>
returns true if mat has only zero entries off the main diagonal, false
otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsUpperTriangularMat" Arg='mat'/>

<Description>
returns true if mat has only zero entries below the main diagonal, false
otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsLowerTriangularMat" Arg='mat'/>

<Description>
returns true if mat has only zero entries below the main diagonal, false
otherwise.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Matrix Constructions">
<Heading>Matrix Constructions</Heading>

<ManSection>
<Func Name="IdentityMat" Arg='m [, R]'/>

<Description>
returns a (mutable) <A>m</A><M>\times</M><A>m</A> identity matrix over the ring given
by <A>R</A>. Here, <A>R</A> can be either a ring, or an element of a ring. By default,
an integer matrix is created.
<Example><![CDATA[
gap> IdentityMat(3);
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> IdentityMat(2,Integers mod 15);
[ [ ZmodnZObj( 1, 15 ), ZmodnZObj( 0, 15 ) ], 
  [ ZmodnZObj( 0, 15 ), ZmodnZObj( 1, 15 ) ] ]
gap> IdentityMat(2,Z(3));
[ [ Z(3)^0, 0*Z(3) ], [ 0*Z(3), Z(3)^0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NullMat" Arg='m, n [, R]'/>

<Description>
returns a (mutable) <A>m</A><M>\times</M><A>n</A> null matrix over the ring given by
by <A>R</A>. Here, <A>R</A> can be either a ring, or an element of a ring. By default,
an integer matrix is created.
<Example><![CDATA[
gap> NullMat(3,2);
[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ]
gap> NullMat(2,2,Integers mod 15);
[ [ ZmodnZObj( 0, 15 ), ZmodnZObj( 0, 15 ) ], 
  [ ZmodnZObj( 0, 15 ), ZmodnZObj( 0, 15 ) ] ]
gap> NullMat(3,2,Z(3));
[ [ 0*Z(3), 0*Z(3) ], [ 0*Z(3), 0*Z(3) ], [ 0*Z(3), 0*Z(3) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="EmptyMatrix" Arg='char'/>

<Description>
is an empty (ordinary) matrix in characteristic <A>char</A> that can be added
to or multiplied with empty lists (representing zero-dimensional row
vectors). It also acts (via the operation <Ref Oper="\^"/>) on empty lists.
<P/>
<!-- store in the family as an attribute?-->
<Example><![CDATA[
gap> EmptyMatrix(5);
EmptyMatrix( 5 )
gap> AsList(last);
[  ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DiagonalMat" Arg='vector'/>

<Description>
returns a diagonal matrix <A>mat</A> with the diagonal entries given by
<A>vector</A>.
<Example><![CDATA[
gap> DiagonalMat([1,2,3]);
[ [ 1, 0, 0 ], [ 0, 2, 0 ], [ 0, 0, 3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PermutationMat" Arg='perm, dim [, F ]'/>

<Description>
returns a matrix in dimension <A>dim</A> over the field given by <A>F</A> (i.e.
the smallest field containing the element <A>F</A> or <A>F</A> itself if it is a
field)  that
represents the permutation <A>perm</A> acting by permuting the basis vectors
as it permutes points.
<Example><![CDATA[
gap> PermutationMat((1,2,3),4,1);
[ [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TransposedMatImmutable" Arg='mat'/>
<Attr Name="TransposedMatAttr" Arg='mat'/>
<Attr Name="TransposedMat" Arg='mat'/>
<Oper Name="TransposedMatMutable" Arg='mat'/>
<Oper Name="TransposedMatOp" Arg='mat'/>

<Description>
These functions all return the transposed of the matrix <A>mat</A>, i.e.,
a matrix <A>trans</A> such that <C><A>trans</A>[<A>i</A>][<A>k</A>] = <A>mat</A>[<A>k</A>][<A>i</A>]</C> holds.
<P/>
They differ only w.r.t. the mutability of the result.
<P/>
<Ref Attr="TransposedMat"/> is an attribute and hence returns an immutable result.
<Ref Oper="TransposedMatMutable"/> is guaranteed to return a new <E>mutable</E> matrix.
<P/>
<Ref Attr="TransposedMatImmutable"/> and <Ref Attr="TransposedMatAttr"/> 
are synonyms of <Ref Attr="TransposedMat"/>,
and <Ref Oper="TransposedMatOp"/> is a synonym of <Ref Oper="TransposedMatMutable"/>,
in analogy to operations such as <Ref Func="Zero"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="TransposedMatDestructive" Arg='mat'/>

<Description>
If <A>mat</A> is a mutable matrix, then the transposed
is computed by swapping the entries in <A>mat</A>. In this way <A>mat</A> gets
changed. In all other cases the transposed is computed by <Ref Attr="TransposedMat"/>.
<Example><![CDATA[
gap> TransposedMat([[1,2,3],[4,5,6],[7,8,9]]);
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
gap> mm:= [[1,2,3],[4,5,6],[7,8,9]];;
gap> TransposedMatDestructive( mm );
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
gap> mm;
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="KroneckerProduct" Arg='mat1, mat2'/>

<Description>
The Kronecker product of two matrices is the matrix obtained when
replacing each entry <A>a</A> of <A>mat1</A> by the product <C><A>a</A>*<A>mat2</A></C> in one
matrix.
<Example><![CDATA[
gap> KroneckerProduct([[1,2]],[[5,7],[9,2]]);
[ [ 5, 7, 10, 14 ], [ 9, 2, 18, 4 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReflectionMat" Arg='coeffs[, conj][, root]'/>

<Description>
Let <A>coeffs</A> be a row vector.
<Ref Func="ReflectionMat"/> returns the matrix of the reflection in this
vector.
<P/>
More precisely, if <A>coeffs</A> is the coefficients list of a vector
<M>v</M> w.r.t. a basis <M>B</M> (see&nbsp;<Ref Func="Basis"/>), say,
then the returned matrix describes the
reflection in <M>v</M> w.r.t. <M>B</M> as a map on a row space,
with action from the right.
<P/>
The optional argument <A>root</A> is a root of unity that determines the
order of the reflection.
The default is a reflection of order 2.
For triflections one should choose a third root of unity etc.
(see&nbsp;<Ref Func="E"/>).
<P/>
<A>conj</A> is a function of one argument that conjugates a ring element.
The default is <Ref Attr="ComplexConjugate"/>.
<P/>
The matrix of the reflection in <M>v</M> is defined as
<Display Mode="M">
M = I_n +
  \overline{{v^{tr}}} \cdot (w-1) / ( v \overline{{v^{tr}}} ) \cdot v
</Display>
where <M>w</M> equals <A>root</A>,
<M>n</M> is the length of the coefficient list,
and <M>\overline{{\vphantom{x}}}</M> denotes the conjugation.
<P/>
So <M>v</M> is mapped to <M>w v</M>, with default <M>-v</M>,
and any vector <M>x</M> with the property
<M>x \overline{{v^{tr}}} = 0</M> is fixed by the reflection.
</Description>
</ManSection>

<ManSection>
<Func Name="PrintArray" Arg='array'/>

<Description>
pretty-prints the array <A>array</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Random Matrices">
<Heading>Random Matrices</Heading>

<ManSection>
<Func Name="RandomMat" Arg='m, n [, R]'/>

<Description>
<Ref Func="RandomMat"/> returns a new mutable random matrix with <A>m</A> rows and
<A>n</A> columns with elements taken from the ring <A>R</A>, which defaults
to <Ref Var="Integers"/>.
<Example><![CDATA[
gap> RandomMat(2,3,GF(3));
[ [ Z(3), Z(3), 0*Z(3) ], [ Z(3), Z(3)^0, Z(3) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RandomInvertibleMat" Arg='m [, R]'/>

<Description>
<Ref Func="RandomInvertibleMat"/> returns a new mutable invertible random
matrix with <A>m</A> rows and columns with elements taken from the ring
<A>R</A>, which defaults to <Ref Var="Integers"/>.
<Example><![CDATA[
gap> m := RandomInvertibleMat(4);
[ [ 1, -2, -1, 0 ], [ 1, 0, 1, -1 ], [ 0, 2, 0, 4 ], 
  [ -1, -3, 1, -4 ] ]
gap> m^-1;
[ [ 1/4, 1/2, -1/8, -1/4 ], [ -1/3, 0, -1/3, -1/3 ], 
  [ -1/12, 1/2, 13/24, 5/12 ], [ 1/6, 0, 5/12, 1/6 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RandomUnimodularMat" Arg='m'/>

<Description>
returns a new random mutable <A>m</A><M>\times</M><A>m</A> matrix with integer
entries that is invertible over the integers.
<Example><![CDATA[
gap> m := RandomUnimodularMat(3);
[ [ 1, 0, 0 ], [ 156, -39, -25 ], [ -100, 25, 16 ] ]
gap> m^-1;
[ [ 1, 0, 0 ], [ 4, 16, 25 ], [ 0, -25, -39 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Matrices Representing Linear Equations and the Gaussian Algorithm">
<Heading>Matrices Representing Linear Equations and the Gaussian Algorithm</Heading>

<Index>Gaussian algorithm</Index>
<ManSection>
<Attr Name="RankMat" Arg='mat'/>

<Description>
If <A>mat</A> is a matrix whose rows span a free module over the ring
generated by the matrix entries and their inverses
then <Ref Attr="RankMat"/> returns the dimension of this free module.
Otherwise <K>fail</K> is returned.
<P/>
Note that <Ref Attr="RankMat"/> may perform a Gaussian elimination.
For large rational matrices this may take very long,
because the entries may become very large.
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> RankMat(mat);
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TriangulizedMat" Arg='mat'/>
<Oper Name="RREF" Arg='mat'/>

<Description>
Computes an upper triangular form of the matrix <A>mat</A> via
the Gaussian Algorithm. It returns a immutable matrix in upper triangular form.
This is sometimes also  called <Q>Hermite normal form</Q> or <Q>Reduced Row Echelon
Form</Q>.
<C>RREF</C> is a synonym for <C>TriangulizedMat</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="TriangulizeMat" Arg='mat'/>

<Description>
Applies the Gaussian Algorithm to the mutable matrix
<A>mat</A> and changes <A>mat</A> such that it is in upper triangular normal
form (sometimes called <Q>Hermite normal form</Q> or <Q>Reduced Row Echelon
Form</Q>).
<Example><![CDATA[
gap> m:=TransposedMatMutable(mat);
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
gap> TriangulizeMat(m);m;
[ [ 1, 0, -1 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
gap> m:=TransposedMatMutable(mat);
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
gap> TriangulizedMat(m);m;
[ [ 1, 0, -1 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NullspaceMat" Arg='mat'/>
<Attr Name="TriangulizedNullspaceMat" Arg='mat'/>

<Description>
<Index Subkey="of a matrix">kernel</Index>
returns a list of row vectors that form a basis of the vector space of
solutions to the equation <C><A>vec</A>*<A>mat</A>=0</C>.
The result is an immutable matrix.
This basis is not guaranteed to be in any specific form.
<P/>
The variant <Ref Attr="TriangulizedNullspaceMat"/> returns a basis of the
nullspace in triangulized form as is often needed for algorithms.
</Description>
</ManSection>

<ManSection>
<Oper Name="NullspaceMatDestructive" Arg='mat'/>
<Oper Name="TriangulizedNullspaceMatDestructive" Arg='mat'/>

<Description>
This function does the same as <Ref Attr="NullspaceMat"/>.
However, the latter function makes a copy of <A>mat</A> to avoid having
to change it.
This function does not do that; it returns the nullspace and may destroy
<A>mat</A>;
this saves a lot of memory in case <A>mat</A> is big.
The matrix <A>mat</A> must be mutable.
<P/>
The variant <Ref Oper="TriangulizedNullspaceMatDestructive"/> returns a
basis of the nullspace in triangulized form.
It may destroy the matrix <A>mat</A>.
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> NullspaceMat(mat);
[ [ 1, -2, 1 ] ]
gap> mm:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> NullspaceMatDestructive( mm );
[ [ 1, -2, 1 ] ]
gap> mm;
[ [ 1, 2, 3 ], [ 0, -3, -6 ], [ 0, 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SolutionMat" Arg='mat, vec'/>

<Description>
returns a row vector <A>x</A> that is a solution of the equation <C><A>x</A> * <A>mat</A>
= <A>vec</A></C>. It returns <K>fail</K> if no such vector exists.
</Description>
</ManSection>

<ManSection>
<Oper Name="SolutionMatDestructive" Arg='mat, vec'/>

<Description>
Does the same as <C>SolutionMat( <A>mat</A>, <A>vec</A> )</C> except that
it may destroy the matrix <A>mat</A> and the vector <A>vec</A>.
The matrix <A>mat</A> must be mutable.
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> SolutionMat(mat,[3,5,7]);
[ 5/3, 1/3, 0 ]
gap> mm:= [[1,2,3],[4,5,6],[7,8,9]];;
gap> v:= [3,5,7];;
gap> SolutionMatDestructive( mm, v );
[ 5/3, 1/3, 0 ]
gap> mm;
[ [ 1, 2, 3 ], [ 0, -3, -6 ], [ 0, 0, 0 ] ]
gap> v;
[ 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BaseFixedSpace" Arg='mats'/>

<Description>
<Ref Func="BaseFixedSpace"/> returns a list of row vectors that form a base of the
vector space <M>V</M> such that <M>v M = v</M> for all <M>v</M> in <M>V</M> and all matrices
<M>M</M> in the list <A>mats</A>.  (This is the common eigenspace of all matrices
in <A>mats</A> for the eigenvalue 1.)
<Example><![CDATA[
gap> BaseFixedSpace([[[1,2],[0,1]]]);
[ [ 0, 1 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Eigenvectors and eigenvalues">
<Heading>Eigenvectors and eigenvalues</Heading>

<ManSection>
<Oper Name="GeneralisedEigenvalues" Arg='F, A'/>
<Oper Name="GeneralizedEigenvalues" Arg='F, A'/>

<Description>
The generalised eigenvalues of the matrix <A>A</A> over the field <A>F</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="GeneralisedEigenspaces" Arg='F, A'/>
<Oper Name="GeneralizedEigenspaces" Arg='F, A'/>

<Description>
The generalised eigenspaces of the matrix <A>A</A> over the field <A>F</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Eigenvalues" Arg='F, A'/>

<Description>
The eigenvalues of the matrix <A>A</A> over the field <A>F</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Eigenspaces" Arg='F, A'/>

<Description>
The eigenspaces of the matrix <A>A</A> over the field <A>F</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Eigenvectors" Arg='F, A'/>

<Description>
The eigenvectors of the matrix <A>A</A> over the field <A>F</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elementary Divisors">
<Heading>Elementary Divisors</Heading>

See also chapter <Ref Chap="Integral matrices and lattices"/>.

<ManSection>
<Oper Name="ElementaryDivisorsMat" Arg='[ring,] mat'/>
<Func Name="ElementaryDivisorsMatDestructive" Arg='ring,mat'/>

<Description>
returns a list of the elementary divisors, i.e., the
unique <M>d</M> with <M>d[i]</M> divides  <M>d[i+1]</M> and <A>mat</A> is  equivalent
to a diagonal matrix with the elements <M>d[i]</M> on the diagonal.
The operations are performed over the euclidean
ring <A>ring</A>, which must contain
all matrix entries. For compatibility reasons it can be omitted and
defaults to the <Ref Func="DefaultRing" Label="for ring elements"/> of the matrix entries.
<P/>
The function <Ref Func="ElementaryDivisorsMatDestructive"/> produces the same result
but in the process may destroy the contents of <A>mat</A>.
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> ElementaryDivisorsMat(mat);
[ 1, 3, 0 ]
gap> x:=Indeterminate(Rationals,"x");;
gap> mat:=mat*One(x)-x*mat^0;       
[ [ -x+1, 2, 3 ], [ 4, -x+5, 6 ], [ 7, 8, -x+9 ] ]
gap> ElementaryDivisorsMat(PolynomialRing(Rationals,1),mat);
[ 1, 1, x^3-15*x^2-18*x ]
gap> mat:=KroneckerProduct(CompanionMat((x-1)^2),
>                          CompanionMat((x^3-1)*(x-1)));;
gap> mat:=mat*One(x)-x*mat^0;
[ [ -x, 0, 0, 0, 0, 0, 0, 1 ], [ 0, -x, 0, 0, -1, 0, 0, -1 ], 
  [ 0, 0, -x, 0, 0, -1, 0, 0 ], [ 0, 0, 0, -x, 0, 0, -1, -1 ], 
  [ 0, 0, 0, -1, -x, 0, 0, -2 ], [ 1, 0, 0, 1, 2, -x, 0, 2 ], 
  [ 0, 1, 0, 0, 0, 2, -x, 0 ], [ 0, 0, 1, 1, 0, 0, 2, -x+2 ] ]
gap> ElementaryDivisorsMat(PolynomialRing(Rationals,1),mat);
[ 1, 1, 1, 1, 1, 1, x-1, x^7-x^6-2*x^4+2*x^3+x-1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ElementaryDivisorsTransformationsMat" Arg='[ring,] mat'/>
<Func Name="ElementaryDivisorsTransformationsMatDestructive" Arg='ring,mat'/>

<Description>
<C>ElementaryDivisorsTransformations</C>, in addition to the tasks done
by <C>ElementaryDivisorsMat</C>, also calculates transforming matrices.
It returns a record with components <C>normal</C> (a matrix <M>S</M>),
<C>rowtrans</C> (a matrix <M>P</M>),
and <C>coltrans</C> (a matrix <M>Q</M>) such that <M>P A Q = S</M>.
The operations are performed over the euclidean ring
<A>ring</A>, which must contain
all matrix entries. For compatibility reasons it can be omitted and
defaults to the <Ref Func="DefaultRing" Label="for ring elements"/> of the matrix entries.
<P/>
The function <Ref Func="ElementaryDivisorsTransformationsMatDestructive"/>
produces the same result
but in the process destroys the contents of <A>mat</A>.
<Example><![CDATA[
gap> mat:=KroneckerProduct(CompanionMat((x-1)^2),CompanionMat((x^3-1)*(x-1)));;
gap> mat:=mat*One(x)-x*mat^0;
[ [ -x, 0, 0, 0, 0, 0, 0, 1 ], [ 0, -x, 0, 0, -1, 0, 0, -1 ], 
  [ 0, 0, -x, 0, 0, -1, 0, 0 ], [ 0, 0, 0, -x, 0, 0, -1, -1 ], 
  [ 0, 0, 0, -1, -x, 0, 0, -2 ], [ 1, 0, 0, 1, 2, -x, 0, 2 ], 
  [ 0, 1, 0, 0, 0, 2, -x, 0 ], [ 0, 0, 1, 1, 0, 0, 2, -x+2 ] ]
gap> t:=ElementaryDivisorsTransformationsMat(PolynomialRing(Rationals,1),mat);
rec( coltrans := [ [ 0, 0, 0, 0, 0, 0, 1/6*x^2-7/9*x-1/18, -3*x^3-x^2-x-1 ], 
      [ 0, 0, 0, 0, 0, 0, -1/6*x^2+x-1, 3*x^3-3*x^2 ], 
      [ 0, 0, 0, 0, 0, 1, -1/18*x^4+1/3*x^3-1/3*x^2-1/9*x, x^5-x^4+2*x^2-2*x 
         ], [ 0, 0, 0, 0, -1, 0, -1/9*x^3+1/2*x^2+1/9*x, 2*x^4+x^3+x^2+2*x ],
      [ 0, -1, 0, 0, 0, 0, -2/9*x^2+19/18*x, 4*x^3+x^2+x ], 
      [ 0, 0, -1, 0, 0, -x, 1/18*x^5-1/3*x^4+1/3*x^3+1/9*x^2, 
          -x^6+x^5-2*x^3+2*x^2 ], 
      [ 0, 0, 0, -1, x, 0, 1/9*x^4-2/3*x^3+2/3*x^2+1/18*x, 
          -2*x^5+2*x^4-x^2+x ], 
      [ 1, 0, 0, 0, 0, 0, 1/6*x^3-7/9*x^2-1/18*x, -3*x^4-x^3-x^2-x ] ], 
  normal := [ [ 1, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0, 0, 0 ], 
      [ 0, 0, 0, 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0 ], 
      [ 0, 0, 0, 0, 0, 0, x-1, 0 ], 
      [ 0, 0, 0, 0, 0, 0, 0, x^7-x^6-2*x^4+2*x^3+x-1 ] ], 
  rowtrans := [ [ 1, 0, 0, 0, 0, 0, 0, 0 ], [ 1, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 1, 0, 0, 1, 0, 0, 0, 0 ], 
      [ -x+2, -x, 0, 0, 1, 0, 0, 0 ], 
      [ 2*x^2-4*x+2, 2*x^2-x, 0, 2, -2*x+1, 0, 0, 1 ], 
      [ 3*x^3-6*x^2+3*x, 3*x^3-2*x^2, 2, 3*x, -3*x^2+2*x, 0, 1, 2*x ], 
      [ 1/6*x^8-7/6*x^7+2*x^6-4/3*x^5+7/3*x^4-4*x^3+13/6*x^2-7/6*x+2, 
          1/6*x^8-17/18*x^7+13/18*x^6-5/18*x^5+35/18*x^4-31/18*x^3+1/9*x^2-x+\
2, 1/9*x^5-5/9*x^4+1/9*x^3-1/9*x^2+14/9*x-1/9, 
          1/6*x^6-5/6*x^5+1/6*x^4-1/6*x^3+11/6*x^2-1/6*x, 
          -1/6*x^7+17/18*x^6-13/18*x^5+5/18*x^4-35/18*x^3+31/18*x^2-1/9*x+1, 
          1, 1/18*x^5-5/18*x^4+1/18*x^3-1/18*x^2+23/18*x-1/18, 
          1/9*x^6-5/9*x^5+1/9*x^4-1/9*x^3+14/9*x^2-1/9*x ] ] )
gap> t.rowtrans*mat*t.coltrans;
[ [ 1, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, x-1, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, x^7-x^6-2*x^4+2*x^3+x-1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DiagonalizeMat" Arg='ring,mat'/>

<Description>
brings the mutable matrix <A>mat</A>, considered as a matrix over <A>ring</A>,
into diagonal form by elementary row and column operations.
<Example><![CDATA[
gap> m:=[[1,2],[2,1]];;
gap> DiagonalizeMat(Integers,m);m;
[ [ 1, 0 ], [ 0, 3 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Echelonized Matrices">
<Heading>Echelonized Matrices</Heading>

<ManSection>
<Attr Name="SemiEchelonMat" Arg='mat'/>

<Description>
A matrix over a field <M>F</M> is in semi-echelon form if the first nonzero
element in each row is the identity of <M>F</M>,
and all values exactly below these pivots are the zero of <M>F</M>.
<P/>
<Ref Attr="SemiEchelonMat"/> returns a record that contains information about
a semi-echelonized form of the matrix <A>mat</A>.
<P/>
The components of this record are
<P/>
<List>
<Mark><C>vectors</C></Mark>
<Item>
      list of row vectors, each with pivot element the identity of <M>F</M>,
</Item>
<Mark><C>heads</C></Mark>
<Item>
      list that contains at position <A>i</A>, if nonzero, the number of the
      row for that the pivot element is in column <A>i</A>.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Oper Name="SemiEchelonMatDestructive" Arg='mat'/>

<Description>
This does the same as <C>SemiEchelonMat( <A>mat</A> )</C>, except that it may
(and probably will) destroy the matrix <A>mat</A>.
<Example><![CDATA[
gap> mm:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> SemiEchelonMatDestructive( mm );
rec( heads := [ 1, 2, 0 ], vectors := [ [ 1, 2, 3 ], [ 0, 1, 2 ] ] )
gap> mm;
[ [ 1, 2, 3 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SemiEchelonMatTransformation" Arg='mat'/>

<Description>
does the same as <Ref Attr="SemiEchelonMat"/> but additionally stores the linear
transformation <M>T</M> performed on the matrix.
The additional components of the result are
<P/>
<List>
<Mark><C>coeffs</C></Mark>
<Item>
      a list of coefficients vectors of the <C>vectors</C> component,
      with respect to the rows of <A>mat</A>, that is, <C>coeffs * mat</C>
      is the <C>vectors</C> component.
</Item>
<Mark><C>relations</C></Mark>
<Item>
      a list of basis vectors for the (left) null space of <A>mat</A>.
</Item>
</List>
<Example><![CDATA[
gap> SemiEchelonMatTransformation([[1,2,3],[0,0,1]]);
rec( coeffs := [ [ 1, 0 ], [ 0, 1 ] ], heads := [ 1, 0, 2 ], 
  relations := [  ], vectors := [ [ 1, 2, 3 ], [ 0, 0, 1 ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SemiEchelonMats" Arg='mats'/>

<Description>
A list of matrices over a field <M>F</M> is in semi-echelon form if the
list of row vectors obtained on concatenating the rows of each matrix
is a semi-echelonized matrix (see <Ref Func="SemiEchelonMat"/>).
<P/>
<Ref Oper="SemiEchelonMats"/> returns a record that contains information about
a semi-echelonized form of the list <A>mats</A> of matrices.
<P/>
The components of this record are
<P/>
<List>
<Mark><C>vectors</C></Mark>
<Item>
      list of matrices, each with pivot element the identity of <M>F</M>,
</Item>
<Mark><C>heads</C></Mark>
<Item>
      matrix that contains at position [<A>i</A>,<A>j</A>], if nonzero,
      the number of the matrix that has the pivot element in
      this position
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Oper Name="SemiEchelonMatsDestructive" Arg='mats'/>

<Description>
Does the same as <C>SemiEchelonmats</C>, except that it may destroy
its argument. Therefore the argument must be a list of matrices
that re mutable.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Matrices as Basis of a Row Space">
<Heading>Matrices as Basis of a Row Space</Heading>

See also chapter <Ref Chap="Integral matrices and lattices"/>

<ManSection>
<Attr Name="BaseMat" Arg='mat'/>

<Description>
returns a basis for the row space generated by the rows of <A>mat</A> in the
form of an immutable matrix.
</Description>
</ManSection>

<ManSection>
<Oper Name="BaseMatDestructive" Arg='mat'/>

<Description>
Does the same as <Ref Attr="BaseMat"/>, with the difference that it may destroy
the matrix <A>mat</A>. The matrix <A>mat</A> must be mutable.
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> BaseMat(mat);
[ [ 1, 2, 3 ], [ 0, 1, 2 ] ]
gap> mm:= [[1,2,3],[4,5,6],[5,7,9]];;
gap> BaseMatDestructive( mm );
[ [ 1, 2, 3 ], [ 0, 1, 2 ] ]
gap> mm;
[ [ 1, 2, 3 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="BaseOrthogonalSpaceMat" Arg='mat'/>

<Description>
Let <M>V</M> be the row space generated  by the rows of  <A>mat</A> (over any field
that contains all  entries of <A>mat</A>).  <C>BaseOrthogonalSpaceMat( <A>mat</A>  )</C>
computes a base of the orthogonal space of <M>V</M>.
<P/>
The rows of <A>mat</A> need not be linearly independent.
<P/>
<!-- Note that this means to transpose twice ...-->
</Description>
</ManSection>

<ManSection>
<Oper Name="SumIntersectionMat" Arg='M1, M2'/>

<Description>
performs  Zassenhaus'  algorithm to compute  bases  for  the sum  and the
intersection of spaces generated by the rows of the matrices <A>M1</A>, <A>M2</A>.
<P/>
returns a list  of length 2,   at first position   a base of the sum,  at
second  position a  base   of the   intersection.   Both  bases  are   in
semi-echelon form (see&nbsp;<Ref Sect="Echelonized Matrices"/>).
<Example><![CDATA[
gap> SumIntersectionMat(mat,[[2,7,6],[5,9,4]]);
[ [ [ 1, 2, 3 ], [ 0, 1, 2 ], [ 0, 0, 1 ] ], [ [ 1, -3/4, -5/2 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BaseSteinitzVectors" Arg='bas, mat'/>

<Description>
find vectors extending mat to a basis spanning the span of <A>bas</A>.
Both <A>bas</A> and <A>mat</A> must be matrices of full (row) rank. It returns a
record with the following components:
<List>
<Mark><C>subspace</C></Mark>
<Item>
s a basis of the space spanned by <A>mat</A> in upper triangular
form with leading ones at all echelon steps and zeroes above these ones.
</Item>
<Mark><C>factorspace</C></Mark>
<Item>
is a list of extending vectors in upper triangular form.
</Item>
<Mark><C>factorzero</C></Mark>
<Item>
is a zero vector.
</Item>
<Mark><C>heads</C></Mark>
<Item>
is a list of integers which can be used to decompose vectors in
the basis vectors. The <A>i</A>th entry indicating the vector
that gives an echelon step at position <A>i</A>.
A negative number indicates an echelon step in the subspace, a positive
number an echelon step in the complement, the absolute value gives the
position of the vector in the lists <C>subspace</C> and <C>factorspace</C>.
</Item>
</List>
<Example><![CDATA[
gap> BaseSteinitzVectors(IdentityMat(3,1),[[11,13,15]]);
rec( factorspace := [ [ 0, 1, 15/13 ], [ 0, 0, 1 ] ], 
  factorzero := [ 0, 0, 0 ], heads := [ -1, 1, 2 ], 
  subspace := [ [ 1, 13/11, 15/11 ] ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Triangular Matrices">
<Heading>Triangular Matrices</Heading>

<ManSection>
<Oper Name="DiagonalOfMat" Arg='mat'/>

<Description>
returns the diagonal of the matrix <A>mat</A>. If <A>mat</A> is not a
square matrix, then the result has the same length as the rows of
<A>mat</A>, and is padded with zeros if <A>mat</A> has fewer rows than
columns.
<Example><![CDATA[
gap> DiagonalOfMat([[1,2,3],[4,5,6]]);
[ 1, 5, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="UpperSubdiagonal" Arg='mat, pos'/>

<Description>
returns a mutable list containing the entries of the <A>pos</A>th upper
subdiagonal of <A>mat</A>.
<Example><![CDATA[
gap> UpperSubdiagonal(mat,1);
[ 2, 6 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DepthOfUpperTriangularMatrix" Arg='mat'/>

<Description>
If <A>mat</A> is an upper triangular matrix this attribute returns the
index of the first nonzero diagonal.
<Example><![CDATA[
gap> DepthOfUpperTriangularMatrix([[0,1,2],[0,0,1],[0,0,0]]);
1
gap> DepthOfUpperTriangularMatrix([[0,0,2],[0,0,0],[0,0,0]]);
2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Matrices as Linear Mappings">
<Heading>Matrices as Linear Mappings</Heading>

<ManSection>
<Attr Name="CharacteristicPolynomial" Arg='[F, E, ]mat[, ind]'/>

<Description>
For a square matrix <A>mat</A>, <Ref Attr="CharacteristicPolynomial"/>
returns the <E>characteristic polynomial</E> of <A>mat</A>, that is, the
<Ref Oper="StandardAssociate"/> of the determinant of the matrix
<M><A>mat</A> - X \cdot I</M>, where <M>X</M> is an indeterminate and
<M>I</M> is the appropriate identity matrix.
<P/>
If fields <A>F</A> and <A>E</A> are given, then <A>F</A> must be a
subfield of <A>E</A>, and <A>mat</A> must have entries in <A>E</A>.
Then <Ref Oper="CharacteristicPolynomial"/> returns the characteristic
polynomial of the <A>F</A>-linear mapping induced by <A>mat</A> 
on the underlying <A>E</A>-vector space of <A>mat</A>. In this case, 
the characteristic polynomial is computed using <Ref Func="BlownUpMat"/>
for the field extension of <M>E/F</M> generated by the default field.
Thus, if <M>F = E</M>, the result is the same as for the one argument
version.
<P/>
The returned polynomials are expressed in the indeterminate number
<A>ind</A>.  If <A>ind</A> is not given, it defaults to <M>1</M>.
<P/>
<C>CharacteristicPolynomial(<A>F</A>, <A>E</A>, <A>mat</A>)</C> is a
multiple of the  minimal polynomial
<C>MinimalPolynomial(<A>F</A>, <A>mat</A>)</C>
(see&nbsp;<Ref Func="MinimalPolynomial"/>).
<P/>
Note that, up to &GAP; version 4.4.6,
<Ref Oper="CharacteristicPolynomial"/> only  allowed to specify one field
(corresponding to <A>F</A>) as an argument.
That usage has been disabled because its definition turned out to be 
ambiguous and may have lead to unexpected results. (To ensure
backward compatibility, it is still possible to use the old form 
if <A>F</A> contains the default field of the matrix,
see&nbsp;<Ref Func="DefaultFieldOfMatrix"/>,
but this feature will disappear in future versions of &GAP;.)
<Example><![CDATA[
gap> CharacteristicPolynomial( [ [ 1, 1 ], [ 0, 1 ] ] );
x^2-2*x+1
gap> mat := [[0,1],[E(4)-1,E(4)]];;
gap> CharacteristicPolynomial( mat );
x^2+(-E(4))*x+(1-E(4))
gap> CharacteristicPolynomial( Rationals, CF(4), mat );
x^4+3*x^2+2*x+2
gap> mat:= [ [ E(4), 1 ], [ 0, -E(4) ] ];;
gap> CharacteristicPolynomial( mat );
x^2+1
gap> CharacteristicPolynomial( Rationals, CF(4), mat );
x^4+2*x^2+1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="JordanDecomposition" Arg='mat'/>

<Description>
<C>JordanDecomposition( <A>mat </A> )</C> returns a list <C>[S,N]</C> such that
<C>S</C> is a semisimple matrix and <C>N</C> is nilpotent. Furthermore, <C>S</C>
and <C>N</C> commute and <C><A>mat</A>=S+N</C>.
<Example><![CDATA[
gap> mat:=[[1,2,3],[4,5,6],[7,8,9]];;
gap> JordanDecomposition(mat);
[ [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BlownUpMat" Arg='B, mat'/>

<Description>
Let <A>B</A> be a basis of a field extension <M>F / K</M>,
and <A>mat</A> a matrix whose entries are all in <M>F</M>.
(This is not checked.)
<Ref Func="BlownUpMat"/> returns a matrix over <M>K</M> that is obtained by replacing each
entry of <A>mat</A> by its regular representation w.r.t.&nbsp;<A>B</A>.
<P/>
More precisely,
regard <A>mat</A> as the matrix of a linear transformation on the row space
<M>F^n</M> w.r.t.&nbsp;the <M>F</M>-basis with vectors <M>(v_1, ldots, v_n)</M>, say,
and suppose that the basis <A>B</A> consists of the vectors
<M>(b_1,  \ldots, b_m)</M>;
then the returned matrix is the matrix of the linear transformation
on the row space <M>K^{mn}</M> w.r.t.&nbsp;the <M>K</M>-basis whose vectors are
<M>(b_1 v_1, \ldots b_m v_1, \ldots, b_m v_n)</M>.
<P/>
Note that the linear transformations act on <E>row</E> vectors, i.e.,
each row of the matrix is a concatenation of vectors of <A>B</A>-coefficients.
</Description>
</ManSection>

<ManSection>
<Func Name="BlownUpVector" Arg='B, vector'/>

<Description>
Let <A>B</A> be a basis of a field extension <M>F / K</M>,
and <A>vector</A> a row vector whose entries are all in <M>F</M>.
<Ref Func="BlownUpVector"/> returns a row vector over <M>K</M> that is obtained by
replacing each entry of <A>vector</A> by its coefficients w.r.t.&nbsp;<A>B</A>.
<P/>
So <Ref Func="BlownUpVector"/> and <Ref Func="BlownUpMat"/> are compatible
in the sense that for a matrix <A>mat</A> over <M>F</M>,
<C>BlownUpVector( <A>B</A>, <A>mat</A> * <A>vector</A> )</C>
is equal to
<C>BlownUpMat( <A>B</A>, <A>mat</A> ) * BlownUpVector( <A>B</A>, <A>vector</A> )</C>.
<Example><![CDATA[
gap> B:= Basis( CF(4), [ 1, E(4) ] );;
gap> mat:= [ [ 1, E(4) ], [ 0, 1 ] ];;  vec:= [ 1, E(4) ];;
gap> bmat:= BlownUpMat( B, mat );;  bvec:= BlownUpVector( B, vec );;
gap> Display( bmat );  bvec;
[ [   1,   0,   0,   1 ],
  [   0,   1,  -1,   0 ],
  [   0,   0,   1,   0 ],
  [   0,   0,   0,   1 ] ]
[ 1, 0, 0, 1 ]
gap> bvec * bmat = BlownUpVector( B, vec * mat );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CompanionMat" Arg='poly'/>

<Description>
computes a companion matrix of the polynomial <A>poly</A>. This matrix has
<A>poly</A> as its minimal polynomial.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Matrices over Finite Fields">
<Heading>Matrices over Finite Fields</Heading>

Just as for row vectors,
(see section <Ref Sect="Row Vectors over Finite Fields"/>),
&GAP; has a special representation for matrices over small finite fields.
<P/>
To be eligible to be represented in this way, each row of a matrix
must be able to be represented as a compact row vector of the same
length  over <E>the same</E> finite field.
<P/>
<Example><![CDATA[
gap> v := Z(2)*[1,0,0,1,1];
[ Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ]
gap> ConvertToVectorRep(v,2);
2
gap> v;
<a GF2 vector of length 5>
gap> m := [v];; ConvertToMatrixRep(m,GF(2));; m;
<a 1x5 matrix over GF2>
gap> m := [v,v];; ConvertToMatrixRep(m,GF(2));; m;
<a 2x5 matrix over GF2>
gap> m := [v,v,v];; ConvertToMatrixRep(m,GF(2));; m;
<a 3x5 matrix over GF2>
gap> v := Z(3)*[1..8];
[ Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0 ]
gap> ConvertToVectorRep(v);
3
gap> m := [v];; ConvertToMatrixRep(m,GF(3));; m;
[ [ Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0 ] ]
gap> RepresentationsOfObject(m);
[ "IsPositionalObjectRep", "Is8BitMatrixRep" ]
gap> m := [v,v,v,v];; ConvertToMatrixRep(m,GF(3));; m;
< mutable compressed matrix 4x8 over GF(3) >
]]></Example>
<P/>
All compressed matrices over GF(2) are viewed as 
<C>&lt;a <A>n</A>x<A>m</A> matrix over GF2></C>, 
while over fields GF(q) for q between 3 and 256, matrices
with 25 or more entries are viewed in this way, and smaller ones as
lists of lists.
<P/>
Matrices can be converted to this special representation via
the following functions.
<P/>
Note that the main advantage of this special representation of
matrices is in low dimensions, where various overheads can be
reduced. In higher dimensions, a list of compressed vectors will be
almost as fast. Note also that list access and assignment will be
somewhat slower for compressed matrices than for plain lists.
<P/>
In order to form a row of a compressed matrix a vector must accept
certain restrictions. Specifically, it cannot change its length or
change the field over which it is compressed. The main consequences of
this are: that only elements of the appropriate field can be assigned
to entries of the vector, and only to positions between 1 and the
original length; that the vector cannot be shared between two matrices
compressed over different fields.
<P/>
This is enforced by the filter <C>IsLockedRepresentationVector</C>.  When a
vector becomes part of a compressed matrix, this filter is set for it.
Assignment, <Ref Func="Unbind" Label="unbind a list entry"/>,  
<Ref Func="ConvertToVectorRep" Label="for a list (and a field)"/> and
<Ref Func="ConvertToMatrixRep" Label="for a list (and a field)"/>
are all prevented from altering a vector with this filter.
<P/>
<Example><![CDATA[
gap> v := [Z(2),Z(2)];; ConvertToVectorRep(v,GF(2));; v;
<a GF2 vector of length 2>
gap> m := [v,v]; 
[ <a GF2 vector of length 2>, <a GF2 vector of length 2> ]
gap> ConvertToMatrixRep(m,GF(2)); 
2
gap> m2 := [m[1], [Z(4),Z(4)]]; # now try and mix in some GF(4)
[ <a GF2 vector of length 2>, [ Z(2^2), Z(2^2) ] ]
gap> ConvertToMatrixRep(m2); # but m2[1] is locked
#I  ConvertToVectorRep: locked vector not converted to different field
fail
gap> m2 := [ShallowCopy(m[1]), [Z(4),Z(4)]]; # a fresh copy of row 1
[ <a GF2 vector of length 2>, [ Z(2^2), Z(2^2) ] ]
gap> ConvertToMatrixRep(m2); # now it works
4
gap> m2;
[ [ Z(2)^0, Z(2)^0 ], [ Z(2^2), Z(2^2) ] ]
gap> RepresentationsOfObject(m2);
[ "IsPositionalObjectRep", "Is8BitMatrixRep" ]
]]></Example>
<P/>
Arithmetic operations (see&nbsp;<Ref Sect="Arithmetic for Lists"/> and the following
sections) preserve the compression status of matrices in the sense that
if all arguments are compressed matrices written over the same field and
the result is a matrix then also the result is a compressed matrix
written over this field.
<P/>
There are also two operations that are only available for matrices
written over finite fields.

<ManSection>
<Func Name="ImmutableMatrix" Arg='field, matrix[, change]'/>

<Description>
returns an immutable matrix equal to <A>matrix</A> which is in the optimal
(concerning space and runtime) representation for matrices defined over
<A>field</A>. This means that matrices obtained by several calls of
<Ref Oper="ImmutableMatrix"/> for the same <A>field</A> are compatible
for fast arithmetic without need for field conversion.
<P/>
The input matrix <A>matrix</A> or its rows might change the
representation,
however the result of <Ref Oper="ImmutableMatrix"/> is not necessarily
<E>identical</E> to <A>matrix</A> if a conversion is not possible.
<P/>
If <A>change</A> is <K>true</K>, the rows of <A>matrix</A>
(or <A>matrix</A> itself) may be changed to become immutable;
otherwise they are copied first).
</Description>
</ManSection>

<ManSection>
<Func Name="ConvertToMatrixRep" Arg='list[, field]'
 Label="for a list (and a field)"/>
<Func Name="ConvertToMatrixRep" Arg='list[, fieldsize]'
 Label="for a list (and a prime power)"/>
<Func Name="ConvertToMatrixRepNC" Arg='list[, field]'
 Label="for a list (and a field)"/>
<Func Name="ConvertToMatrixRepNC" Arg='list[, fieldsize]'
 Label="for a list (and a prime power)"/>

<Description>

This function is more technical version of <Ref Func="ImmutableMatrix"/>,
which will never copy a matrix (or any rows of it) but may fail if it
encounters rows locked in the wrong representation, or various other
more technical problems. Most users should use <Ref Func="ImmutableMatrix"/>
instead. The NC versions of the function do less checking of the 
argument and may cause unpredictable results or crashes if given 
unsuitable arguments.

Called with one argument <A>list</A>,
<Ref Func="ConvertToMatrixRep" Label="for a list (and a field)"/>
converts <A>list</A> to an internal matrix representation
if possible.
<P/>
Called with a list <A>list</A> and a finite field <A>field</A>,
<Ref Func="ConvertToMatrixRep" Label="for a list (and a field)"/>
converts <A>list</A> to an internal matrix representation appropriate
for a matrix over <A>field</A>.
<P/>
Instead of a <A>field</A> also its size <A>fieldsize</A> may be given.
<P/>
It is forbidden to call this function unless all elements of <A>list</A>
are row vectors with entries in the field <A>field</A>.
Violation of this condition can lead to unpredictable behaviour or a
system crash.
(Setting the assertion level to at least 2 might catch some violations
before a crash, see&nbsp;<Ref Func="SetAssertionLevel"/>.)
<P/>
<A>list</A> may already be a compressed matrix. In this case, if no
<A>field</A> or <A>fieldsize</A> is given, then nothing happens.
<P/>
The return value is the size of the field over which the matrix
ends up written, if it is written in a compressed representation.
<P/>
</Description>
</ManSection>

<ManSection>
<Attr Name="ProjectiveOrder" Arg='mat'/>

<Description>
Returns an integer n and a finite field element e such that
<A>A</A>^n = eI.
<A>mat</A> must be a matrix defined over a finite field.
<Example><![CDATA[
gap> ProjectiveOrder([[1,4],[5,2]]*Z(11)^0);
[ 5, Z(11)^5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SimultaneousEigenvalues" Arg='matlist, expo'/>

<Description>
The matrices in <A>matlist</A> must be matrices over GF(<A>q</A>)
for some prime <A>q</A>.
Together, they must generate an abelian p-group of exponent <A>expo</A>.
Then the eigenvalues of <A>mat</A> in the splitting field
<C>GF(<A>q</A>^<A>r</A>)</C> for some <A>r</A> are powers of an element
<M>\xi</M> in the splitting field, which is of order <A>expo</A>.
<Ref Func="SimultaneousEigenvalues"/> returns a matrix of
integers mod <A>expo</A>, say <M>(a_{{i,j}})</M>, such that the power
<M>\xi^{{a_{{i,j}}}}</M> is an eigenvalue of the <A>i</A>-th matrix in
<A>matlist</A> and the eigenspaces of the different matrices to the
eigenvalues <M>\xi^{{a_{{i,j}}}}</M> for fixed <A>j</A> are equal.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Inverse and Nullspace of an Integer Matrix Modulo an Ideal">
<Heading>Inverse and Nullspace of an Integer Matrix Modulo an Ideal</Heading>

The following two operations deal with matrices over a ring,
but only care about the residues of their entries modulo some ring element.
In the case of the integers and a prime number <M>p</M>, say,
this is effectively computation in a matrix over the prime field
in characteristic <M>p</M>.

<ManSection>
<Oper Name="InverseMatMod" Arg='mat, obj'/>

<Description>
For a square matrix <A>mat</A>, <Ref Oper="InverseMatMod"/> returns a matrix <A>inv</A>
such that <C><A>inv</A> * <A>mat</A></C> is congruent to the identity matrix modulo
<A>obj</A>, if such a matrix exists, and <K>fail</K> otherwise.
<Example><![CDATA[
gap> mat:= [ [ 1, 2 ], [ 3, 4 ] ];;  inv:= InverseMatMod( mat, 5 );
[ [ 3, 1 ], [ 4, 2 ] ]
gap> mat * inv;
[ [ 11, 5 ], [ 25, 11 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NullspaceModQ" Arg='E, q'/>

<Description>
<A>E</A> must be a matrix of integers and <A>q</A> a prime power.
Then <Ref Func="NullspaceModQ"/> returns the set of all vectors of integers modulo
<A>q</A>, which solve the homogeneous equation system given by <A>E</A> modulo <A>q</A>.
<Example><![CDATA[
gap> mat:= [ [ 1, 3 ], [ 1, 2 ], [ 1, 1 ] ];;  NullspaceModQ( mat, 5 );
[ [ 0, 0, 0 ], [ 1, 3, 1 ], [ 2, 1, 2 ], [ 4, 2, 4 ], [ 3, 4, 3 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Special Multiplication Algorithms for Matrices over GF(2)">
<Heading>Special Multiplication Algorithms for Matrices over GF(2)</Heading>

When multiplying two compressed matrices <M>M</M> and <M>N</M> over GF(2) of dimensions
<M>a \times b</M> and <M>b \times c</M>, say,
where <M>a</M>, <M>b</M> and <M>c</M> are all
greater than or equal to 128, &GAP; by default uses a more
sophisticated matrix multiplication algorithm, in which linear
combinations of groups of 8 rows of <M>M</M> are remembered and re-used in
constructing various rows of the product. This is called level 8
grease. To optimise memory access patterns, these combinations are
stored for <M>(b+255)/256</M> sets of 8 rows at once. This number is called
the blocking level.
<P/>
These levels of grease and blocking are found experimentally to give
good performance across a range of processors and matrix sizes, but
other levels may do even better in some cases. You can control the
levels exactly using the functions below.
<P/>
We plan to include greased blocked matrix multiplication for other
finite fields, and greased blocked algorithms for inversion and other
matrix operations in a future release.
<P/>
<ManSection>
<Func Name="PROD_GF2MAT_GF2MAT_SIMPLE" Arg='m1, m2'/>

<Description>
This function performs the standard unblocked and ungreased matrix
multiplication for matrices of any size.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="PROD_GF2MAT_GF2MAT_ADVANCED" Arg='m1, m2, g, b'/>

<Description>
This function computes the product of <A>m1</A> and <A>m2</A>, which must be
compressed matrices over GF(2) of compatible dimensions, using level <A>g</A>
grease and level <A>b</A> blocking.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Block Matrices">
<Heading>Block Matrices</Heading>

Block matrices are a special representation of matrices which can save a
lot of memory if large matrices have a block structure with lots of zero
blocks. &GAP; uses the representation <C>IsBlockMatrixRep</C> 
to store block matrices.
<Index Key="IsBlockMatrixRep">IsBlockMatrixRep</Index>

<ManSection>
<Func Name="AsBlockMatrix" Arg='m, nrb, ncb'/>

<Description>
returns a block matrix with <A>nrb</A> row blocks and <A>ncb</A> column blocks
which is equal to the ordinary matrix <A>m</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="BlockMatrix" Arg='blocks, nrb, ncb[, rpb, cpb, zero]'/>

<Description>
<Ref Func="BlockMatrix"/> returns an immutable matrix in the sparse
representation <C>IsBlockMatrixRep</C>.
The nonzero blocks are described by the list <A>blocks</A> of triples
<M>[ <A>i</A>, <A>j</A>, M(i,j) ]</M> each consisting of a matrix
<M>M(i,j)</M> and its block coordinates in the block matrix to be
constructed.
All matrices <M>M(i,j)</M> must have the same dimensions.
As usual the first coordinate specifies the row and the second one
the column.
The resulting matrix has <A>nrb</A> row blocks and <A>ncb</A> column
blocks.
<P/>
If <A>blocks</A> is empty (i.e., if the matrix is a zero matrix) then
the dimensions of the blocks must be entered as <A>rpb</A> and
<A>cpb</A>, and the zero element as <A>zero</A>.
<P/>
Note that all blocks must be ordinary matrices
(see&nbsp;<Ref Func="IsOrdinaryMatrix"/>),
and also the block matrix is an ordinary matrix.
<Example><![CDATA[
gap> M := BlockMatrix([[1,1,[[1, 2],[ 3, 4]]],
>                      [1,2,[[9,10],[11,12]]],
>                      [2,2,[[5, 6],[ 7, 8]]]],2,2);
<block matrix of dimensions (2*2)x(2*2)>
gap> Display(M);
[ [   1,   2,   9,  10 ],
  [   3,   4,  11,  12 ],
  [   0,   0,   5,   6 ],
  [   0,   0,   7,   8 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MatrixByBlockMatrix" Arg='blockmat'/>

<Description>
returns a plain ordinary matrix that is equal to the block matrix
<A>blockmat</A>.
</Description>
</ManSection>


</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  matint.msk                  GAP documentation            Alexander Hulpke -->
<!-- %A                                                           Thomas Breuer -->
<!-- %A                                                           Rob Wainwright -->
<!-- %% -->
<!-- %A  @(#)<M>Id: matint.msk,v 1.19 2004/01/19 09:52:53 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Integral matrices and lattices">
<Heading>Integral matrices and lattices</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Linear equations over the integers and Integral Matrices">
<Heading>Linear equations over the integers and Integral Matrices</Heading>

<ManSection>
<Attr Name="NullspaceIntMat" Arg='mat'/>

<Description>
If <A>mat</A> is a matrix with integral entries, this function returns a
list of vectors that forms a basis of the integral nullspace of
<A>mat</A>, i.e., of those vectors in the nullspace of <A>mat</A> that
have integral entries.
<Example><![CDATA[
gap> mat:=[[1,2,7],[4,5,6],[7,8,9],[10,11,19],[5,7,12]];;
gap> NullspaceMat(mat);   
[ [ -7/4, 9/2, -15/4, 1, 0 ], [ -3/4, -3/2, 1/4, 0, 1 ] ]
gap> NullspaceIntMat(mat);                              
[ [ 1, 18, -9, 2, -6 ], [ 0, 24, -13, 3, -7 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SolutionIntMat" Arg='mat, vec'/>

<Description>
If <A>mat</A> is a matrix with integral entries and <A>vec</A> a vector
with integral entries, this function returns a vector <M>x</M> with
integer entries that is a solution of the equation
<M>x</M> <C>* <A>mat</A> = <A>vec</A></C>.
It returns <K>fail</K> if no such vector exists.
<Example><![CDATA[
gap> mat:=[[1,2,7],[4,5,6],[7,8,9],[10,11,19],[5,7,12]];;
gap> SolutionMat(mat,[95,115,182]);
[ 47/4, -17/2, 67/4, 0, 0 ]
gap> SolutionIntMat(mat,[95,115,182]);   
[ 2285, -5854, 4888, -1299, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SolutionNullspaceIntMat" Arg='mat,vec'/>

<Description>
This function returns a list of length two, its first entry being the
result of a call to <Ref Func="SolutionIntMat"/> with same arguments,
the second the result of <Ref Func="NullspaceIntMat"/> applied to the
matrix <A>mat</A>.
The calculation is performed faster than if two separate calls would be
used.
<Example><![CDATA[
gap> mat:=[[1,2,7],[4,5,6],[7,8,9],[10,11,19],[5,7,12]];;
gap> SolutionNullspaceIntMat(mat,[95,115,182]);
[ [ 2285, -5854, 4888, -1299, 0 ], 
  [ [ 1, 18, -9, 2, -6 ], [ 0, 24, -13, 3, -7 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="BaseIntMat" Arg='mat'/>

<Description>
If <A>mat</A> is a matrix with integral entries, this function returns a
list of vectors that forms a basis of the integral row space of <A>mat</A>, 
i.e. of the set of integral linear combinations of the rows of <A>mat</A>.
<Example><![CDATA[
gap> mat:=[[1,2,7],[4,5,6],[10,11,19]];;
gap> BaseIntMat(mat);                  
[ [ 1, 2, 7 ], [ 0, 3, 7 ], [ 0, 0, 15 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="BaseIntersectionIntMats" Arg='m,n'/>

<Description>
If <A>m</A> and <A>n</A> are matrices with integral entries,
this function returns a list of vectors that forms a basis of the
intersection of the integral row spaces of <A>m</A> and <A>n</A>.
<Example><![CDATA[
gap> nat:=[[5,7,2],[4,2,5],[7,1,4]];;
gap> BaseIntMat(nat);
[ [ 1, 1, 15 ], [ 0, 2, 55 ], [ 0, 0, 64 ] ]
gap> BaseIntersectionIntMats(mat,nat);
[ [ 1, 5, 509 ], [ 0, 6, 869 ], [ 0, 0, 960 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ComplementIntMat" Arg='full, sub'/>

<Description>
Let <A>full</A> be a list of integer vectors generating an integral row
module <M>M</M> and <A>sub</A> a list of vectors defining a submodule
<M>S</M> of <M>M</M>.
This function computes a free basis for <M>M</M> that extends <M>S</M>. 
I.e., if the dimension of <M>S</M> is <M>n</M> it
determines a basis
<M>B = \{ b_1, \ldots, b_m \}</M> for <M>M</M>,
as well as <M>n</M> integers <M>x_i</M> such that the <M>n</M> vectors
<M>s_i:= x_i \cdot b_i</M> form a basis for <M>S</M>.
<P/>
It returns a record with the following components:
<List>
<Mark><C>complement</C></Mark>
<Item>
   the vectors <M>b_{{n+1}}</M> up to <M>b_m</M>
   (they generate a complement to <M>S</M>).
</Item>
<Mark><C>sub</C></Mark>
<Item>
   the vectors <M>s_i</M> (a basis for <M>S</M>).
</Item>
<Mark><C>moduli</C></Mark>
<Item>
   the factors <M>x_i</M>.
</Item>
</List>
<Example><![CDATA[
gap> m:=IdentityMat(3);;
gap> n:=[[1,2,3],[4,5,6]];;
gap> ComplementIntMat(m,n);
rec( complement := [ [ 0, 0, 1 ] ], moduli := [ 1, 3 ], 
  sub := [ [ 1, 2, 3 ], [ 0, 3, 6 ] ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Normal Forms over the Integers">
<Heading>Normal Forms over the Integers</Heading>

This section describes the computation of the Hermite and Smith normal form
of integer matrices.
<P/>
The Hermite Normal Form (HNF) <M>H</M> of an integer matrix <M>A</M> is
a row equivalent upper triangular form such that all off-diagonal entries
are reduced modulo the diagonal entry of the column they are in.
There exists a unique unimodular matrix <M>Q</M> such that <M>Q A = H</M>. 
<P/>
The Smith Normal Form <M>S</M> of an integer matrix <M>A</M> is
the unique equivalent diagonal form with <M>S_i</M> dividing <M>S_j</M> for
<M>i &lt; j</M>.
There exist unimodular integer matrices <M>P, Q</M> such that <M>P A Q = S</M>.
<P/>
All routines described in this section build on the <Q>workhorse</Q> routine
<Ref Func="NormalFormIntMat"/>.

<ManSection>
<Oper Name="TriangulizedIntegerMat" Arg='mat'/>

<Description>
Computes an upper triangular form of a matrix with integer entries.
It returns a immutable matrix in upper triangular form.
</Description>
</ManSection>

<ManSection>
<Oper Name="TriangulizedIntegerMatTransform" Arg='mat'/>

<Description>
Computes an upper triangular form of a matrix with integer entries.
It returns a record with a component <C>normal</C> (an immutable matrix
in upper triangular form) and a component <C>rowtrans</C> that gives the
transformations done to the original matrix to bring it into upper
triangular form.
</Description>
</ManSection>

<ManSection>
<Oper Name="TriangulizeIntegerMat" Arg='mat'/>

<Description>
Changes <A>mat</A> to be in upper triangular form.
(The result is the same as that of <Ref Func="TriangulizedIntegerMat"/>,
but <A>mat</A> will be modified, thus using less memory.)
If <A>mat</A> is immutable an error will be triggered.
<Example><![CDATA[
gap> m:=[[1,15,28],[4,5,6],[7,8,9]];;
gap> TriangulizedIntegerMat(m);
[ [ 1, 15, 28 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ]
gap> n:=TriangulizedIntegerMatTransform(m);
rec( normal := [ [ 1, 15, 28 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ], 
  rank := 3, rowC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  rowQ := [ [ 1, 0, 0 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  rowtrans := [ [ 1, 0, 0 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  signdet := 1 )
gap> n.rowtrans*m=n.normal;
true
gap> TriangulizeIntegerMat(m); m;
[ [ 1, 15, 28 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="HermiteNormalFormIntegerMat" Arg='mat'/>

<Description>
This operation computes the Hermite normal form of a matrix <A>mat</A>
with integer entries. It returns a immutable matrix in HNF.
</Description>
</ManSection>

<ManSection>
<Oper Name="HermiteNormalFormIntegerMatTransform" Arg='mat'/>

<Description>
This operation computes the Hermite normal form of a matrix <A>mat</A>
with integer entries.
It returns a record with components <C>normal</C> (a matrix <M>H</M>) and
<C>rowtrans</C> (a matrix <M>Q</M>) such that <M>Q A = H</M>.
<Example><![CDATA[
gap> m:=[[1,15,28],[4,5,6],[7,8,9]];;
gap> HermiteNormalFormIntegerMat(m);          
[ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ]
gap> n:=HermiteNormalFormIntegerMatTransform(m);
rec( normal := [ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ], rank := 3, 
  rowC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  rowQ := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  rowtrans := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  signdet := 1 )
gap> n.rowtrans*m=n.normal;
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SmithNormalFormIntegerMat" Arg='mat'/>

<Description>
This operation computes the Smith normal form of a matrix <A>mat</A> with
integer entries. It returns a new immutable matrix in the Smith normal
form.
</Description>
</ManSection>

<ManSection>
<Oper Name="SmithNormalFormIntegerMatTransforms" Arg='mat'/>

<Description>
This operation computes the Smith normal form of a matrix <A>mat</A> with
integer entries.
It returns a record with components <C>normal</C> (a matrix <M>S</M>),
<C>rowtrans</C> (a matrix <M>P</M>),
and <C>coltrans</C> (a matrix <M>Q</M>) such that <M>P A Q = S</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="DiagonalizeIntMat" Arg='mat'/>

<Description>
This function changes <A>mat</A> to its SNF.
(The result is the same as
that of <Ref Func="SmithNormalFormIntegerMat"/>,
but <A>mat</A> will be modified, thus using less memory.)
If <A>mat</A> is immutable an error will be triggered.
<Example><![CDATA[
gap> m:=[[1,15,28],[4,5,6],[7,8,9]];;
gap> SmithNormalFormIntegerMat(m);          
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 3 ] ]
gap> n:=SmithNormalFormIntegerMatTransforms(m);  
rec( colC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  colQ := [ [ 1, 0, -1 ], [ 0, 1, -1 ], [ 0, 0, 1 ] ], 
  coltrans := [ [ 1, 0, -1 ], [ 0, 1, -1 ], [ 0, 0, 1 ] ], 
  normal := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 3 ] ], rank := 3, 
  rowC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  rowQ := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  rowtrans := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  signdet := 1 )
gap> n.rowtrans*m*n.coltrans=n.normal;
true
gap> DiagonalizeIntMat(m);m;
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="NormalFormIntMat" Arg='mat, options'/>

<Description>
This general operation for computation of various Normal Forms
is probably the most efficient.  
<P/>
Options bit values:
<List>
<Mark>0/1</Mark>
<Item>
 Triangular Form / Smith Normal Form.
</Item>
<Mark>2</Mark>
<Item>
   Reduce off diagonal entries.
</Item>
<Mark>4</Mark>
<Item>
   Row Transformations.
</Item>
<Mark>8</Mark>
<Item>
   Col Transformations.
</Item>
<Mark>16</Mark>
<Item>
   Destructive (the original matrix may be destroyed)
</Item>
</List>
<P/>
Compute a Triangular, Hermite or Smith form of the <M>n \times m</M> 
integer input matrix <M>A</M>.  Optionally, compute <M>n \times n</M> and 
<M>m \times m</M> unimodular transforming matrices <M>Q, P</M>
which satisfy  <M>Q A = H</M> or <M>Q A P = S</M>.
<!-- %The routines used are based on work by Arne Storjohann -->
<!-- %and were implemented in &GAP;&nbsp;4 by A.&nbsp;Storjohann and R.&nbsp;Wainwright. -->
<P/>
Note option is a value ranging from 0 to 15 but not all options make sense 
(e.g., reducing off diagonal entries with SNF option selected already).  
If an option makes no sense it is ignored.
<P/>
Returns a record with component <C>normal</C> containing the
computed normal form and optional components <C>rowtrans</C> 
and/or <C>coltrans</C> which hold the respective transformation matrix.
Also in the record are components holding the sign of the determinant, 
<C>signdet</C>, and the rank of the matrix, <C>rank</C>.
<Example><![CDATA[
gap> m:=[[1,15,28],[4,5,6],[7,8,9]];;
gap> NormalFormIntMat(m,0);  # Triangular, no transforms
rec( normal := [ [ 1, 15, 28 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ], 
  rank := 3, signdet := 1 )
gap> NormalFormIntMat(m,6);  # Hermite Normal Form with row transforms
rec( normal := [ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 0, 0, 3 ] ], rank := 3, 
  rowC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  rowQ := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  rowtrans := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  signdet := 1 )
gap> NormalFormIntMat(m,13); # Smith Normal Form with both transforms
rec( colC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  colQ := [ [ 1, 0, -1 ], [ 0, 1, -1 ], [ 0, 0, 1 ] ], 
  coltrans := [ [ 1, 0, -1 ], [ 0, 1, -1 ], [ 0, 0, 1 ] ], 
  normal := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 3 ] ], rank := 3, 
  rowC := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  rowQ := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  rowtrans := [ [ -2, 62, -35 ], [ 1, -30, 17 ], [ -3, 97, -55 ] ], 
  signdet := 1 )
gap> last.rowtrans*m*last.coltrans;
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AbelianInvariantsOfList" Arg='list'/>

<Description>
Given a list of nonnegative integers, this routine returns a sorted
list containing the prime power factors of the positive entries in the
original list, as well as all zeroes of the original list.
<Example><![CDATA[
gap> AbelianInvariantsOfList([4,6,2,0,12]);
[ 0, 2, 2, 3, 3, 4, 4 ]
]]></Example>
</Description>
</ManSection>


<!-- %\ Declaration{DiagonalizeIntMatNormDriven} -->
<!-- %\ Declaration{SNFNormDriven} -->
<!-- %\ Declaration{SNFofREF} -->
<!-- %\ Declaration{HNFNormDriven} -->
 
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Determinant of an integer matrix">
<Heading>Determinant of an integer matrix</Heading>

<ManSection>
<Oper Name="DeterminantIntMat" Arg='mat'/>

<Description>
<Index Subkey="integer matrix">determinant</Index>
Computes the determinant of an integer matrix using the  
same strategy as <Ref Func="NormalFormIntMat"/>.
This method is 
faster in general for matrices greater than <M>20 \times 20</M> but 
quite a lot slower for smaller matrices.  It therefore passes 
the work to the more general <Ref Func="DeterminantMat"/>
for these smaller matrices.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Decompositions">
<Heading>Decompositions</Heading>

<Index>decomposition matrix</Index>
<Index>DEC</Index>
For computing the decomposition of a vector of integers into the rows of
a matrix of integers, with integral coefficients,
one can use <M>p</M>-adic approximations, as follows.
<P/>
Let <M>A</M> be a square integral matrix, and <M>p</M> an odd prime.
The reduction of <M>A</M> modulo <M>p</M> is <M>\overline{A}</M>,
its entries are  chosen in the interval
<M>[ -(p-1)/2, (p-1)/2 ]</M>.
If <M>\overline{A}</M> is regular over the field with <M>p</M> elements,
we can form <M>A' = \overline{A}^{{-1}}</M>.
Now we consider the integral linear equation system <M>x A = b</M>,
i.e., we look for an integral solution <M>x</M>.
Define <M>b_0 = b</M>, and then iteratively compute
<Display Mode="M">
x_i = (b_i A') \bmod p,  b_{{i+1}} = (b_i - x_i A) / p,
  i = 0, 1, 2, \ldots .
</Display>
By induction, we get                                                     
<Display Mode="M">
p^{{i+1}} b_{{i+1}} + \left( \sum_{{j = 0}}^i p^j x_j \right) A = b.
</Display>
If there is an integral solution <M>x</M> then it is unique,
and there is an index <M>l</M> such that <M>b_{{l+1}}</M> is zero
and <M>x = \sum_{{j = 0}}^l p^j x_j</M>.               
<P/>
There are two useful generalizations of this idea.
First, <M>A</M> need not be square; it is only necessary that there is
a square regular matrix formed by a subset of columns of <M>A</M>.
Second, <M>A</M> does not need to be integral;
the entries may be cyclotomic integers as well,
in this case one can replace each column of <M>A</M> by the columns
formed by the coefficients w.r.t.&nbsp;an integral basis (which are
integers).
Note that this preprocessing must be performed compatibly for
<M>A</M> and <M>b</M>.
<P/>
&GAP; provides the following functions for this purpose
(see also&nbsp;<Ref Func="InverseMatMod"/>).

<ManSection>
<Func Name="Decomposition" Arg='A, B, depth'/>

<Description>
For a <M>m \times n</M> matrix <A>A</A> of cyclotomics that has rank
<M>m \leq n</M>, and a list <A>B</A> of cyclotomic vectors,
each of length <M>n</M>,
<Ref Func="Decomposition"/> tries to find integral solutions
of the linear equation systems <C><A>x</A> * <A>A</A> = <A>B</A>[i]</C>,
by computing the <M>p</M>-adic series of hypothetical solutions.
<P/>
<C>Decomposition( <A>A</A>, <A>B</A>, <A>depth</A> )</C>,
where <A>depth</A> is a nonnegative integer, computes for each vector
<C><A>B</A>[i]</C> the initial part
<M>\sum_{{k = 0}}^{<A>depth</A>} x_k p^k</M>,
with all <M>x_k</M> vectors of integers with entries bounded by
<M>\pm (p-1)/2</M>.
The prime <M>p</M> is set to 83 first; if the reduction of <A>A</A>
modulo <M>p</M> is singular, the next prime is chosen automatically.
<P/>
A list <A>X</A> is returned.
If the computed initial part for <C><A>x</A> * <A>A</A> = <A>B</A>[i]</C>
<E>is</E> a solution,
we have <C><A>X</A>[i] = <A>x</A></C>,
otherwise <C><A>X</A>[i] = fail</C>.
<P/>
If <A>depth</A> is not an integer then it must be the string
<C>"nonnegative"</C>.
<C>Decomposition( <A>A</A>, <A>B</A>, "nonnegative" )</C> assumes that
the solutions have only nonnegative entries,
and that the first column of <A>A</A> consists of positive integers.
This is satisfied, e.g., for the decomposition of ordinary characters
into Brauer characters.
In this case the necessary number <A>depth</A> of iterations can be
computed; the <C>i</C>-th entry of the returned list is <K>fail</K> if
there <E>exists</E> no nonnegative integral solution of the system
<C><A>x</A> * <A>A</A> = <A>B</A>[i]</C>, and it is the solution
otherwise.
<P/>
<E>Note</E> that the result is a list of <K>fail</K> if <A>A</A> has not
full rank,
even if there might be a unique integral solution for some equation
system.
</Description>
</ManSection>

<ManSection>
<Func Name="LinearIndependentColumns" Arg='mat'/>

<Description>
Called with a matrix <A>mat</A>, <C>LinearIndependentColumns</C> returns a maximal
list of column positions such that the restriction of <A>mat</A> to these
columns has the same rank as <A>mat</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="PadicCoefficients" Arg='A, Amodpinv, b, prime, depth'/>

<Description>
Let <A>A</A> be an integral matrix,
<A>prime</A> a prime integer,
<A>Amodpinv</A> an inverse of <A>A</A> modulo <A>prime</A>,
<A>b</A> an integral vector,
and <A>depth</A> a nonnegative integer.
<Ref Func="PadicCoefficients"/> returns the list
<M>[ x_0, x_1, \ldots, x_l, b_{{l+1}} ]</M>
describing the <A>prime</A>-adic approximation of <A>b</A> (see above),
where <M>l = <A>depth</A></M>
or <M>l</M> is minimal with the property that <M>b_{{l+1}} = 0</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="IntegralizedMat" Arg='A[, inforec]'/>

<Description>
<Ref Func="IntegralizedMat"/> returns, for a matrix <A>A</A> of
cyclotomics, a record <C>intmat</C> with components <C>mat</C> and
<C>inforec</C>.
Each family of algebraic conjugate columns of <A>A</A> is encoded in a
set of columns of the rational matrix <C>intmat.mat</C> by replacing
cyclotomics in <A>A</A> by their coefficients w.r.t.&nbsp;an integral
basis.
<C>intmat.inforec</C> is a record containing the information how to
encode the columns.
<P/>
If the only argument is <A>A</A>, the value of the component
<C>inforec</C> is computed that can be entered as second argument
<A>inforec</A> in a later call of <Ref Func="IntegralizedMat"/> with a
matrix <A>B</A> that shall be encoded compatibly with <A>A</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="DecompositionInt" Arg='A, B, depth'/>

<Description>
<Ref Func="DecompositionInt"/> does the same as
<Ref Func="Decomposition"/>,
except that <A>A</A> and <A>B</A> must be integral matrices,
and <A>depth</A> must be a nonnegative integer.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Lattice Reduction">
<Heading>Lattice Reduction</Heading>

<ManSection>
<Func Name="LLLReducedBasis"
 Arg='[L, ]vectors[, y][, "linearcomb"][, lllout]'/>

<Description>
<Index Subkey="for vectors">LLL algorithm</Index>
<Index>short vectors spanning a lattice</Index>
<Index>lattice base reduction</Index>
provides an implementation of the <E>LLL algorithm</E> by
Lenstra, Lenstra and Lovász (see&nbsp;<Cite Key="LLL82"/>,
<Cite Key="Poh87"/>).
The implementation follows the description
in&nbsp;<Cite Key="Coh93" Where="p. 94f."/>.
<P/>
<Ref Func="LLLReducedBasis"/> returns a record whose component
<C>basis</C> is a list of LLL reduced linearly independent vectors
spanning the same lattice as the list <A>vectors</A>.
<A>L</A> must be a lattice, with scalar product of the vectors <A>v</A>
and <A>w</A> given by
<C>ScalarProduct( <A>L</A>, <A>v</A>, <A>w</A> )</C>.
If no lattice is specified then the scalar product of vectors given by
<C>ScalarProduct( <A>v</A>, <A>w</A> )</C> is used.
<P/>
In the case of the option <C>"linearcomb"</C>, the result record contains
also the components <C>relations</C> and <C>transformation</C>,
with the following meaning.
<C>relations</C> is a basis of the relation space of <A>vectors</A>,
i.e., of vectors <A>x</A> such that <C><A>x</A> * <A>vectors</A></C> is
zero.
<C>transformation</C> gives the expression of the new lattice basis in
terms of the old, i.e.,
<C>transformation * <A>vectors</A></C> equals the <C>basis</C> component
of the result.
<P/>
Another optional argument is <A>y</A>, the <Q>sensitivity</Q> of the
algorithm, a rational number between <M>1/4</M> and <M>1</M>
(the default value is <M>3/4</M>).
<P/>
The optional argument <A>lllout</A> is a record with the components
<C>mue</C> and <C>B</C>, both lists of length <M>k</M>,
with the meaning that if <A>lllout</A> is present then the first <M>k</M>
vectors in <A>vectors</A> form an LLL reduced basis of the lattice they
generate,
and <C><A>lllout</A>.mue</C> and <C><A>lllout</A>.B</C> contain their
scalar products and norms used internally in the algorithm,
which are also present in the output of <Ref Func="LLLReducedBasis"/>.
So <A>lllout</A> can be used for <Q>incremental</Q> calls of
<Ref Func="LLLReducedBasis"/>.
<P/>
The function <Ref Func="LLLReducedGramMat"/>
computes an LLL reduced Gram matrix.
<P/>
<Example><![CDATA[
gap> vectors:= [ [ 9, 1, 0, -1, -1 ], [ 15, -1, 0, 0, 0 ],
>                [ 16, 0, 1, 1, 1 ], [ 20, 0, -1, 0, 0 ],
>                [ 25, 1, 1, 0, 0 ] ];;
gap> LLLReducedBasis( vectors, "linearcomb" );
rec( B := [ 5, 36/5, 12, 50/3 ], 
  basis := [ [ 1, 1, 1, 1, 1 ], [ 1, 1, -2, 1, 1 ], 
      [ -1, 3, -1, -1, -1 ], [ -3, 1, 0, 2, 2 ] ], 
  mue := [ [  ], [ 2/5 ], [ -1/5, 1/3 ], [ 2/5, 1/6, 1/6 ] ], 
  relations := [ [ -1, 0, -1, 0, 1 ] ], 
  transformation := [ [ 0, -1, 1, 0, 0 ], [ -1, -2, 0, 2, 0 ], 
      [ 1, -2, 0, 1, 0 ], [ -1, -2, 1, 1, 0 ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LLLReducedGramMat" Arg='G[, y]'/>

<Description>
<Index Subkey="for Gram matrices">LLL algorithm</Index>
<Index>lattice base reduction</Index>
<Ref Func="LLLReducedGramMat"/> provides an implementation of the
<E>LLL algorithm</E> by Lenstra, Lenstra and Lovász
(see&nbsp;<Cite Key="LLL82"/>,&nbsp;<Cite Key="Poh87"/>).
The implementation follows the description in
<Cite Key="Coh93" Where="p. 94f."/>.
<P/>
Let <A>G</A> the Gram matrix of the vectors
<M>(b_1, b_2, \ldots, b_n)</M>;
this means <A>G</A> is either a square symmetric matrix or lower
triangular matrix (only the entries in the lower triangular half are used
by the program).
<P/>
<Ref Func="LLLReducedGramMat"/> returns a record whose component
<C>remainder</C> is the Gram matrix of the LLL reduced basis
corresponding to <M>(b_1, b_2, \ldots, b_n)</M>.
If <A>G</A> is a lower triangular matrix then also the <C>remainder</C>
component of the result record is a lower triangular matrix.
<P/>
The result record contains also the components <C>relations</C> and
<C>transformation</C>, which have the following meaning.
<P/>
<C>relations</C> is a basis of the space of vectors
<M>(x_1, x_2, \ldots, x_n)</M>
such that <M>\sum_{{i = 1}}^n x_i b_i</M> is zero,
and <C>transformation</C> gives the expression of the new lattice basis
in terms of the old, i.e., <C>transformation</C> is the matrix <M>T</M>
such that <M>T \cdot <A>G</A> \cdot T^{tr}</M> is the <C>remainder</C>
component of the result.
<P/>
The optional argument <A>y</A> denotes the <Q>sensitivity</Q> of the
algorithm, it must be a rational number between <M>1/4</M> and <M>1</M>;
the default value is <M><A>y</A> = 3/4</M>.
<P/>
The function <Ref Func="LLLReducedBasis"/> computes an LLL reduced basis.
<P/>
<Example><![CDATA[
gap> g:= [ [ 4, 6, 5, 2, 2 ], [ 6, 13, 7, 4, 4 ],
>    [ 5, 7, 11, 2, 0 ], [ 2, 4, 2, 8, 4 ], [ 2, 4, 0, 4, 8 ] ];;
gap> LLLReducedGramMat( g );
rec( B := [ 4, 4, 75/16, 168/25, 32/7 ], 
  mue := [ [  ], [ 1/2 ], [ 1/4, -1/8 ], [ 1/2, 1/4, -2/25 ], 
      [ -1/4, 1/8, 37/75, 8/21 ] ], relations := [  ], 
  remainder := [ [ 4, 2, 1, 2, -1 ], [ 2, 5, 0, 2, 0 ], 
      [ 1, 0, 5, 0, 2 ], [ 2, 2, 0, 8, 2 ], [ -1, 0, 2, 2, 7 ] ], 
  transformation := [ [ 1, 0, 0, 0, 0 ], [ -1, 1, 0, 0, 0 ], 
      [ -1, 0, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], [ -2, 0, 1, 0, 1 ] ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Orthogonal Embeddings">
<Heading>Orthogonal Embeddings</Heading>

<ManSection>
<Func Name="OrthogonalEmbeddings" Arg='gram[, "positive"][, maxdim]'/>

<Description>
computes all possible orthogonal embeddings of a lattice given by its
Gram matrix <A>gram</A>, which must be a regular symmetric matrix of
integers.
In other words, all integral solutions <M>X</M> of the equation
<M>X^{tr} \cdot X = </M><A>gram</A>
are calculated.
The implementation follows the description in&nbsp;<Cite Key="Ple90"/>.
<P/>
Usually there are many solutions <M>X</M>
but all their rows belong to a small set of vectors,
so <Ref Func="OrthogonalEmbeddings"/> returns the solutions
encoded by a record with the following components.
<P/>
<List>
<Mark><C>vectors</C></Mark>
<Item>
   the list <M>L = [ x_1, x_2, \ldots, x_n ]</M> of vectors
   that may be rows of a solution, up to sign;
   these are exactly the vectors with the property
   <M>x_i \cdot </M><A>gram</A><M>^{{-1}} \cdot x_i^{tr} \leq 1</M>,
   see&nbsp;<Ref Func="ShortestVectors"/>,
</Item>
<Mark><C>norms</C></Mark>
<Item>
   the list of values
   <M>x_i \cdot </M><A>gram</A><M>^{{-1}} \cdot x_i^{tr}</M>,
   and
</Item>
<Mark><C>solutions</C></Mark>
<Item>
   a list <M>S</M> of index lists; the <M>i</M>-th solution matrix is
   <M>L</M><C>{ </C><M>S[i]</M><C> }</C>,
   so the dimension of the <A>i</A>-th solution is the length of
   <M>S[i]</M>, and we have
   <A>gram</A><M> = \sum_{{j \in S[i]}} x_j^{tr} \cdot x_j</M>,
</Item>
</List>
<P/>
The optional argument <C>"positive"</C> will cause
<Ref Func="OrthogonalEmbeddings"/>
to compute only vectors <M>x_i</M> with nonnegative entries.
In the context of characters this is allowed (and useful)
if <A>gram</A> is the matrix of scalar products of ordinary characters.
<P/>
When <Ref Func="OrthogonalEmbeddings"/> is called with the optional
argument <A>maxdim</A> (a positive integer),
only solutions up to dimension <A>maxdim</A> are computed;
this may accelerate the algorithm.
<P/>
<Example><![CDATA[
gap> b:= [ [ 3, -1, -1 ], [ -1, 3, -1 ], [ -1, -1, 3 ] ];;
gap> c:=OrthogonalEmbeddings( b );
rec( norms := [ 1, 1, 1, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2 ],
  solutions := [ [ 1, 2, 3 ], [ 1, 6, 6, 7, 7 ], [ 2, 5, 5, 8, 8 ],
      [ 3, 4, 4, 9, 9 ], [ 4, 5, 6, 7, 8, 9 ] ],
  vectors := [ [ -1, 1, 1 ], [ 1, -1, 1 ], [ -1, -1, 1 ],
      [ -1, 1, 0 ], [ -1, 0, 1 ], [ 1, 0, 0 ], [ 0, -1, 1 ],
      [ 0, 1, 0 ], [ 0, 0, 1 ] ] )
gap> c.vectors{ c.solutions[1] };
[ [ -1, 1, 1 ], [ 1, -1, 1 ], [ -1, -1, 1 ] ]
]]></Example>
<P/>
<A>gram</A> may be the matrix of scalar products of some virtual
characters.
From the characters and the embedding given by the matrix <M>X</M>,
<Ref Func="Decreased"/> may be able to compute irreducibles.
</Description>
</ManSection>

<ManSection>
<Func Name="ShortestVectors" Arg='G, m[, "positive"]'/>

<Description>
Let <A>G</A> be a regular matrix of a symmetric bilinear form,
and <A>m</A> a nonnegative integer.
<Ref Func="ShortestVectors"/> computes the vectors <M>x</M> that satisfy
<M>x \cdot <A>G</A> \cdot x^{tr} \leq <A>m</A></M>,
and returns a record describing these vectors.
The result record has the components
<List>
<Mark><C>vectors</C></Mark>
<Item>
   list of the nonzero vectors <M>x</M>, but only one of each pair
   <M>(x,-x)</M>,
</Item>
<Mark><C>norms</C></Mark>
<Item>
   list of norms of the vectors according to the Gram matrix <A>G</A>.
</Item>
</List>
If the optional argument <C>"positive"</C> is entered,
only those vectors <M>x</M> with nonnegative entries are computed.
<Example><![CDATA[
gap> g:= [ [ 2, 1, 1 ], [ 1, 2, 1 ], [ 1, 1, 2 ] ];;  
gap> ShortestVectors(g,4);
rec( norms := [ 4, 2, 2, 4, 2, 4, 2, 2, 2 ], 
  vectors := [ [ -1, 1, 1 ], [ 0, 0, 1 ], [ -1, 0, 1 ], [ 1, -1, 1 ], 
      [ 0, -1, 1 ], [ -1, -1, 1 ], [ 0, 1, 0 ], [ -1, 1, 0 ], 
      [ 1, 0, 0 ] ] )
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!--   matobj.xml               GAP documentation        Max Neunhoeffer  -->
<!--                                                                      -->
<!--   Copyright (C) 2011 The GAP Group                                   -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Chapter Label="Matrix objects">
<Heading>Vector and matrix objects</Heading>

This chapter is work in progress. It will eventually describe the new
interface to vector and matrix objects.
<P/>
Traditionally, vectors in &GAP; have been lists and matrices have been 
lists of lists (of equal length). Unfortunately, such lists cannot
store their type and so it is impossible to use the full advantages of
&GAP;'s method selection on them. This situation is unsustainable in the
long run since more special representations (compressed,
sparse, etc.) have already been and even more will be implemented. 
To eventually solve 
this problem, this chapter describes a new programming interface to
vectors and matrices.

<Section>
    <Heading>Fundamental ideas and rules</Heading>

The whole idea of this interface is that (row-) vectors and matrices must
be proper objects with a stored type (i.e. created by Objectify allowing
inheritance) to benefit from method selection. We therefore refer
to the new style vectors and matrices as <Q>vector objects</Q> and
<Q>matrix objects</Q> respectively. 
<P/>It should be possible to write
(efficient) code that is independent of the actual representation (in
the sense of &GAP;'s representation filters) and preserves it.
<P/>
This latter requirement makes it necessary to distinguish between
(at least) two classes of matrices:
<List>
<Item><Q>RowList</Q>-Matrices which behave basically like lists of rows,
      in particular are the rows individual &GAP; objects that can
      be shared between different matrix objects.</Item>
<Item><Q>Flat</Q> matrices which behave basically like one &GAP; object
      that cannot be split up further. In particular a row is only
      a part of a matrix and no GAP object in itself.</Item>
</List>
For various reasons these two classes have to be distinguished
already with respect to the definition of the operations for them.
<P/>
In particular vectors and matrices know their BaseDomain and their
dimensions. Note that the basic condition is that the elements of
vectors and matrices must either lie in the BaseDomain or naturally
embed in the sense that + and * and = automatically work with all elements
of the base domain (example: integers in polynomials over integers).
<P/>
Vectors are equal with respect to "=" if they have the same length
and the same entries. It is not necessary that they have the same
BaseDomain. Matrices are equal with respect to "=" if they have the
same dimensions and the same entries. It is possible that not for all
pairs of representations methods exist.
<P/>
It is not guaranteed that all rows of a matrix have the same vector type!
It is for example thinkable that a matrix stores some of its rows in a
sparse representation and some in a dense one!
However, it is guaranteed that the rows of matrices in the same 
representation are compatible in the sense that all vector operations
defined in this interface can be applied to them and that new matrices
in the same representation as the original matrix can be formed out of
them.
<P/>
Note that there is neither a default mapping from the set of matrix 
representations to the set of vector representations nor one in the 
reverse direction! There is nothing like an "associated" vector
representation to a matrix representation or vice versa.
<P/>
The way to write code that preserves the representation basically
works by using constructing operations that take template objects
to decide about the actual representation of the new object.
<P/>
Vectors do not have to be lists in the sense that they do not have
to support all list operations. The same holds for matrices. However,
RowList matrices behave nearly like lists of row vectors that insist
on being dense and containing only vectors of the same length and
with the same BaseDomain.
<P/>
There are some rules embedded in the comments to the following code.
They are marked with the word "Rule". FIXME: Collect all rules here.
<P/>


</Section>

<Section>
    <Heading>Categories of vectors and matrices</Heading>

</Section>

<Section>
    <Heading>Constructing vector and matrix objects</Heading>
</Section>

<Section>
    <Heading>Operations for row vector objects</Heading>

</Section>

<Section>
    <Heading>Operations for row list matrix objects</Heading>

</Section>

<Section>
    <Heading>Operations for flat matrix objects</Heading>

</Section>

</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  string.msk                  GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: string.msk,v 1.36 2006/08/16 10:21:03 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Strings and Characters">
<Heading>Strings and Characters</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsChar">
<Heading>IsChar and IsString</Heading>

<Index Subkey="strings">type</Index>
<Index>doublequotes</Index>
<Index>singlequotes</Index>

<ManSection>
<Filt Name="IsChar" Arg='obj' Type='Category'/>
<Filt Name="IsCharCollection" Arg='obj' Type='Category'/>

<Description>
A <E>character</E> is simply an object in &GAP; that represents an
arbitrary character from the character set of the operating system.
Character literals can be entered in &GAP; by enclosing the character
in <E>singlequotes</E> <C>'</C>.
<Example><![CDATA[
gap> x:= 'a';  IsChar( x );
'a'
true
gap> '*';
'*'
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsString" Arg='obj'/>

<Description>
A <E>string</E> is a dense list (see&nbsp;<Ref Func="IsList"/>,
<Ref Func="IsDenseList"/>) of characters (see&nbsp;<Ref Func="IsChar"/>);
thus strings are always homogeneous
(see&nbsp;<Ref Func="IsHomogeneousList"/>).
<P/>
A string literal can either be entered as the list of characters
or by writing the characters between <E>doublequotes</E> <C>"</C>.
&GAP; will always output strings in the latter format.
However, the input via the double quote syntax enables &GAP; to store
the string in an efficient compact internal representation.
See <Ref Func="IsStringRep"/> below for more details.
<P/>
Each character, in particular those which cannot be typed directly from
the keyboard, can also be typed in three digit octal notation.
And for some special characters (like the newline character) there is a
further possibility to type them,
see section <Ref Sect="Special Characters"/>.
<P/>
<Example><![CDATA[
gap> s1 := ['H','e','l','l','o',' ','w','o','r','l','d','.'];
"Hello world."
gap> IsString( s1 );
true
gap> s2 := "Hello world.";
"Hello world."
gap> s1 = s2;
true
gap> s3 := "";  # the empty string
""
gap> s3 = [];
true
gap> IsString( [] );
true
gap> IsString( "123" );  IsString( 123 );
true
false
gap> IsString( [ '1', '2', '3' ] );
true
gap> IsString( [ '1', '2', , '4' ] );  # strings must be dense
false
gap> IsString( [ '1', '2', 3 ] );  # strings must only contain characters
false
]]></Example>
</Description>
</ManSection>


<Subsection Label="subsect:strings as lists">
<Heading>Strings As Lists</Heading>

Note that a string is just a special case of a list.
So everything that is possible for lists (see&nbsp;<Ref Chap="Lists"/>)
is also possible for strings.
Thus you can access the characters in such a string
(see&nbsp;<Ref Sect="List Elements"/>),
test for membership (see&nbsp;<Ref Sect="Membership Test for Collections"/>),
ask for the length, concatenate strings
(see&nbsp;<Ref Func="Concatenation" Label="for several lists"/>),
form substrings etc.
You can even assign to a mutable string
(see&nbsp;<Ref Sect="List Assignment"/>).
Of course unless you assign a character in such a way that the list stays
dense,
the resulting list will no longer be a string.
<P/>
<Example><![CDATA[
gap> Length( s2 );
12
gap> s2[2];
'e'
gap> 'a' in s2;
false
gap> s2[2] := 'a';;  s2;
"Hallo world."
gap> s1{ [1..4] };
"Hell"
gap> Concatenation( s1{ [ 1 .. 6 ] }, s1{ [ 1 .. 4 ] } );
"Hello Hell"
]]></Example>

</Subsection>

<ManSection>
<Heading>Printing Strings</Heading>
<Meth Name="ViewObj" Arg="str" Label="for a string"/>
<Meth Name="PrintObj" Arg="str" Label="for a string"/>

<Description>
If a string is displayed by <Ref Func="View"/>,
for example as result of an evaluation (see&nbsp;<Ref Sect="Main Loop"/>),
or by <Ref Func="ViewObj"/> and <Ref Func="PrintObj"/>,
it is displayed with enclosing doublequotes.
(But note that there is an ambiguity for the empty string which is also an
empty list of arbitrary &GAP; objects;
it is only printed like a string if it was input as empty string or converted
to a string with <Ref Func="ConvertToStringRep"/>.)
<!--  no longer true since we consider UTF-8 standard, but support latinX
The difference between <Ref Func="ViewObj" Label="for a string"/> and
<Ref Func="PrintObj" Label="for a string"/> is that the latter prints
<E>all</E> non-printable and non-ASCII characters in three digit octal
notation, while  <Ref Func="ViewObj" Label="for a string"/> sends all
printable characters to the output stream.
-->
The output of <Ref Func="PrintObj" Label="for a string"/> can be read back
into &GAP;.
<P/>
Strings behave differently from other &GAP; objects with respect to
<Ref Func="Print"/>, <Ref Func="PrintTo"/>, or <Ref Func="AppendTo"/>.
These commands <E>interpret</E> a string in the sense that they essentially
send the characters of the string directly to the output stream/file.
(But depending on  the type of the stream and the presence of some special
characters used as hints for line breaks there may be sent some additional
newline (or backslash and newline) characters.
<!-- % XXX Should the characters \< and \> and their use with <C>Print</C> be documented? -->
<P/>
<Example><![CDATA[
gap> s4:= "abc\"def\nghi";;
gap> View( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> ViewObj( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> PrintObj( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> Print( s4 );  Print( "\n" );
abc"def
ghi
gap> s := "German uses strange characters: äöüß\n";
"German uses strange characters: äöüß\n"
gap> Print(s);
German uses strange characters: äöüß
gap> PrintObj(s);  Print( "\n" );
"German uses strange characters: \303\244\303\266\303\274\303\237\n"
]]></Example>
<P/>
<Log><![CDATA[
gap> s := "\007";
"\007"
gap> Print(s); # rings bell in many terminals
]]></Log>
<P/>
Note that only those line breaks are printed by <Ref Func="Print"/> that are
contained in the string
(<C>\n</C> characters, see&nbsp;<Ref Sect="Special Characters"/>),
as is shown in the example below.
<P/>
<Log><![CDATA[
gap> s1;
"Hello world."
gap> Print( s1 );
Hello world.gap> Print( s1, "\n" );
Hello world.
gap> Print( s1, "\nnext line\n" );
Hello world.
next line
]]></Log>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Special Characters">
<Heading>Special Characters</Heading>

<Index>escaped characters</Index>
<Index>special character sequences</Index>

There are a number of <E>special character sequences</E> that can be used
between the singlequotes of a character literal or between the
doublequotes of a string literal to specify characters. 
They consist of two characters.
The first is a backslash <C>\</C>. The second may be any character.
If it is an octal digit (from <C>0</C> to <C>7</C>) there must be two more
such digits. The meaning is given in the following list
<P/>
<List>
<Mark><C>\n</C></Mark>
<Item>
    <E>newline character</E>.
    This is the character that, at least on UNIX systems,
    separates lines in a text file.
    Printing of this character in a string has the effect of moving
    the cursor down one line and back to the beginning of the line.
</Item>
<Mark>
<Index><C>\"</C></Index>
<Index>doublequote character</Index>
<C>\"</C></Mark>
<Item>
    <E>doublequote character</E>.
    Inside a string a doublequote must be escaped by the backslash,
    because it is otherwise interpreted as end of the string.
</Item>
<Mark>
<Index><C>\'</C></Index>
<Index>singlequote character</Index>
<C>\'</C></Mark>
<Item>
    <E>singlequote character</E>.
    Inside a character a singlequote must escaped by the backslash,
    because it is otherwise interpreted as end of the character.
</Item>
<Mark>
<Index><C>\\</C></Index>
<Index>backslash character</Index>
<C>\\</C></Mark>
<Item>
    <E>backslash character</E>.
    Inside a string a backslash must be escaped by another backslash,
    because it is otherwise interpreted as first character of
    an escape sequence.
</Item>
<Mark>
<Index><C>\b</C></Index>
<Index>backspace character</Index>
<C>\b</C></Mark>
<Item>
    <E>backspace character</E>.
    Printing this character should have the effect of moving the cursor
    back one character.  Whether it works or not is system dependent
    and should not be relied upon.
</Item>
<Mark>
<Index><C>\r</C></Index>
<Index>carriage return character</Index>
<C>\r</C></Mark>
<Item>
    <E>carriage return character</E>.
    Printing this character should have the effect of moving the cursor
    back to the beginning of the same line.  Whether this works or not
    is again system dependent.
</Item>
<Mark>
<Index><C>\c</C></Index>
<Index>flush character</Index>
<C>\c</C></Mark>
<Item>
    <E>flush character</E>.
    This character is not printed.
    Its purpose is to flush the output queue.
    Usually &GAP; waits until it sees a <C>newline</C> before it prints a
    string.
    If you want to display a string that does not include this character
    use <C>\c</C>.
</Item>
<Mark>
<Index><C>\XYZ</C></Index>
<Index>octal character codes</Index>
<C>\XYZ</C></Mark>
<Item>
    with <C>X</C>, <C>Y</C>, <C>Z</C> three octal digits.
    This is translated to the character corresponding to the number
    <C>X * 64 + Y * 8 + Z modulo 256</C>.
    This can be used to specify and store arbitrary binary data as a string
    in &GAP;.
</Item>
<Mark>
<Index>escaping non-special characters</Index>
other</Mark>
<Item>
    For any other character the backslash is simply ignored.
</Item>
</List>
<P/>
Again, if the line is displayed as result of an evaluation,
those escape sequences are displayed in the same way that they are input. 
<P/>
Only  <Ref Func="Print"/>, <Ref Func="PrintTo"/>, or <Ref Func="AppendTo"/>
send the characters directly to the output stream.
<P/>
<Example><![CDATA[
gap> "This is one line.\nThis is another line.\n";
"This is one line.\nThis is another line.\n"
gap> Print( last );
This is one line.
This is another line.
]]></Example>
<P/>
Note in particular that it is not  allowed to enclose a <A>newline</A> inside
the string.
You can use the  special character sequence <C>\n</C> to write strings that
include <A>newline</A> characters.
If, however, an input string is too long to fit on a single line it is
possible to <E>continue</E> it over several lines.
In this case the last character of each input line, except the last line must
be a backslash.
Both backslash and <A>newline</A> are thrown away by &GAP; while reading the
string.
Note that the same continuation mechanism is available for identifiers and
integers, see&nbsp;<Ref Sect="Special Rules for Input Lines"/>.

The rules on escaping are ignored in a triple quoted string, see <Ref
Sect="Triple Quoted String"/>

</Section>

<Section Label="Triple Quoted String">
<Heading>Triple Quoted Strings</Heading>


Another method of entering strings in GAP is triple quoted strings.
Triple quoted strings ignore the rules on escaping given in <Ref
Sect="Special Characters"/>. Triple quoted strings begin an end with
three doublequotes. Inside the triple quotes no escaping is done,
and the string continues, including newlines, until three doublequotes
are found.
<P/>
<Example><![CDATA[
gap> """Print("\n")""";
"Print(\"\\n\")"
]]></Example>

Triple quoted strings are represented internally identically to all other
strings, they only provide an alternative method of giving strings to GAP.

Triple quoted strings still follow GAP's line editing rules 
(<Ref Sect="Special Rules for Input Lines"/>), which state that in normal
line editing mode, lines starting <C>gap> </C>, <C>> </C> or <C>brk> </C> will
have this beginning part removed.
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Internally Represented Strings">
<Heading>Internally Represented Strings</Heading>

<Index Subkey="to a string">convert</Index>
<ManSection>
<Filt Name="IsStringRep" Arg='obj' Type='Representation'/>

<Description>
<Ref Func="IsStringRep"/> is a special (internal) representation of dense
lists of characters.
Dense lists of characters can be converted into this representation
using <Ref Func="ConvertToStringRep"/>.
Note that calling <Ref Func="IsString"/> does <E>not</E> change the
representation.
</Description>
</ManSection>

<ManSection>
<Func Name="ConvertToStringRep" Arg='obj'/>

<Description>
If <A>obj</A> is a dense internally represented list of characters then
<Ref Func="ConvertToStringRep"/> changes the representation to
<Ref Func="IsStringRep"/>.
This is useful in particular for converting the empty list <C>[]</C>,
which usually is in <C>IsPlistRep</C>,
to <Ref Func="IsStringRep"/>.
If <A>obj</A> is not a string then <Ref Func="ConvertToStringRep"/>
signals an error.
</Description>
</ManSection>

<ManSection>
<Func Name="CopyToStringRep" Arg='obj'/>

<Description>
If <A>obj</A> is a dense internally represented list of characters then
<Ref Func="CopyToStringRep"/> copies <A>obj</A> to a new object with
representation 
<Ref Func="IsStringRep"/>.
If <A>obj</A> is not a string then <Ref Func="CopyToStringRep"/>
signals an error.
</Description>
</ManSection>

<ManSection>
<Func Name="IsEmptyString" Arg='str'/>

<Description>
<Ref Func="IsEmptyString"/> returns <K>true</K> if <A>str</A> is the
empty string in the representation <Ref Func="IsStringRep"/>,
and <K>false</K> otherwise.
Note that the empty list <C>[]</C> and the empty string <C>""</C> have
the same type, the recommended way to distinguish them is via
<Ref Func="IsEmptyString"/>.
For formatted printing, this distinction is sometimes necessary.
<!-- The type is the same because <C>IsStringRep</C> is not <E>set</E> in this type,-->
<!-- and <C>IsPlistRep</C> is <E>set</E>,-->
<!-- although <E>calling</E> <C>IsStringRep</C> for <C>[]</C> yields <K>false</K>,-->
<!-- and <E>calling</E> <C>IsPlistRep</C> for <C>""</C> yields <K>false</K>, too.-->
<!-- Why is <C>TNUM_OBJ_INT</C> used here,-->
<!-- calling <C>IsStringRep</C> would be enough, or?-->
<P/>
<Example><![CDATA[
gap> l:= [];;  IsString( l );  IsEmptyString( l );  IsEmpty( l );
true
false
true
gap> l;  ConvertToStringRep( l );  l;
[  ]
""
gap> IsEmptyString( l );  IsEmptyString( "" );  IsEmptyString( "abc" );
true
true
false
gap> ll:= [ 'a', 'b' ];  IsStringRep( ll );  ConvertToStringRep( ll );
"ab"
false
gap> ll;  IsStringRep( ll );
"ab"
true
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Arg="len" Name="EmptyString" />
<Returns>a string</Returns>
<Func Arg="str" Name="ShrinkAllocationString" />
<Returns>nothing</Returns>

<Description>
The function <Ref Func="EmptyString"/> returns an empty string in
internal representation which
has enough memory allocated for <A>len</A> characters. This can be useful
for creating and filling a string with a known number of entries. 
<P/>
The function <Ref Func="ShrinkAllocationString"/> gives back to &GAP;s
memory manager the physical memory which is allocated for the string
<A>str</A> in internal representation but not needed by its current 
number of characters.
<P/>
These functions are intended for saving some of &GAP;s memory in certain 
situations, see the explanations and the example for the analogeous
functions <Ref Func="EmptyPlist"/> and <Ref Func="ShrinkAllocationPlist"/> 
for plain lists.
</Description>
</ManSection>

<ManSection>
<Var Name="CharsFamily"/>

<Description>
Each character lies in the family <Ref Var="CharsFamily"/>,
each nonempty string lies in the collections family of this family.
Note the subtle differences between the empty list <C>[]</C> and the
empty string <C>""</C> when both are printed.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Recognizing Characters">
<Heading>Recognizing Characters</Heading>

<ManSection>
<Func Name="IsDigitChar" Arg='c'/>

<Description>
checks whether the character <A>c</A> is a digit,
i.e., occurs in the string <C>"0123456789"</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="IsLowerAlphaChar" Arg='c'/>

<Description>
checks whether the character <A>c</A> is a lowercase alphabet letter,
i.e., occurs in the string <C>"abcdefghijklmnopqrstuvwxyz"</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="IsUpperAlphaChar" Arg='c'/>

<Description>
checks whether the character <A>c</A> is an uppercase alphabet letter,
i.e., occurs in the string <C>"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="IsAlphaChar" Arg='c'/>

<Description>
checks whether the character <A>c</A> is either a lowercase or an
uppercase alphabet letter.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons of Strings">
<Heading>Comparisons of Strings</Heading>

<ManSection>
<Meth Name="\=" Arg='string1, string2' Label="for two strings"/>

<Description>
<Index Subkey="equality of">strings</Index>
<Index Subkey="inequality of">strings</Index>
The equality operator <C>=</C> returns <K>true</K> if the two strings
<A>string1</A> and <A>string2</A> are equal and <K>false</K> otherwise.
The inequality operator <C>&lt;></C> returns <K>true</K> if the two strings
<A>string1</A> and <A>string2</A> are not equal and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> "Hello world.\n" = "Hello world.\n";
true
gap> "Hello World.\n" = "Hello world.\n"; # comparison is case sensitive
false
gap> "Hello world." = "Hello world.\n";  # first string has no <newline>
false
gap> "Goodbye world.\n" = "Hello world.\n";
false
gap> [ 'a', 'b' ] = "ab";
true
]]></Example>
</Description>
</ManSection>


<ManSection>
<Meth Name="\&lt;" Arg='string1, string2' Label="for two strings"/>

<Description>
<Index Subkey="lexicographic ordering of">strings</Index>
The ordering of strings is lexicographically according to the order
implied by the underlying, system dependent, character set.
<P/>
<Example><![CDATA[
gap> "Hello world.\n" < "Hello world.\n";  # the strings are equal
false
gap> # in ASCII capitals range before small letters:
gap> "Hello World." < "Hello world.";
true
gap> "Hello world." < "Hello world.\n";  # prefixes are always smaller
true
gap> # G comes before H, in ASCII at least:
gap> "Goodbye world.\n" < "Hello world.\n";
true
]]></Example>
<P/>
Strings can be compared via <C>&lt;</C> with certain &GAP; objects that are
not strings, see&nbsp;<Ref Sect="Comparisons"/> for the details.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations to Produce or Manipulate Strings">
<Heading>Operations to Produce or Manipulate Strings</Heading>

For the possibility to print &GAP; objects to strings,
see&nbsp;<Ref Sect="String Streams"/>.

<ManSection>
<Oper Name="DisplayString" Arg='obj'/>

<Description>
Returns a string which could be used to 
display the object <A>obj</A> in a nice, formatted way which is easy to
read (but might be difficult for machines to understand).
The actual format used for this depends on the type of <A>obj</A>.
Each method should include a newline character as last character.
Note that no method for <Ref Oper="DisplayString"/> may delegate
to any of the operations <Ref Oper="Display"/>, <Ref Oper="ViewObj"/>
or <Ref Oper="PrintObj"/> to avoid circular delegations.
</Description>
</ManSection>


<ManSection>
<Var Name="DEFAULTDISPLAYSTRING"/>
<Description>
    This is the default value for <Ref Oper="DisplayString"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ViewString" Arg='obj'/>

<Description>
<Ref Oper="ViewString"/> returns a string which would be displayed 
by <Ref Oper="ViewObj"/> for an
object. Note that no method for <Ref Oper="ViewString"/> may 
delegate to any of
the operations <Ref Oper="Display"/>, <Ref Oper="ViewObj"/>,
<Ref Oper="DisplayString"/> or <Ref Oper="PrintObj"/> to avoid 
circular delegations.
</Description>
</ManSection>


<ManSection>
<Var Name="DEFAULTVIEWSTRING"/>
<Description>
    This is the default value for <Ref Oper="ViewString"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="PrintString" Arg='obj[, length]'/>

<Description>
<Ref Oper="PrintString"/> returns a representation of <A>obj</A>,
which may be an object of arbitrary type, as a string.
This string should approximate as closely as possible the character
sequence you see if you print <A>obj</A> using <Ref Oper="PrintObj"/>.
<P/>
If <A>length</A> is given it must be an integer.
The absolute value gives the minimal length of the result.
If the string representation of <A>obj</A> takes less than that many
characters it is filled with blanks.
If <A>length</A> is positive it is filled on the left,
if <A>length</A> is negative it is filled on the right.
<P/>
In the two argument case, the string returned is a new mutable
string (in particular not a part of any other object);
it can be modified safely,
and <Ref Func="MakeImmutable"/> may be safely applied to it.
<Example><![CDATA[
gap> PrintString(123);PrintString([1,2,3]);
"123"
"[ 1, 2, 3 ]"
]]></Example>
<Ref Oper="PrintString"/> is entitled to put in additional control 
characters <C>\&lt;</C> (ASCII 1) and <C>\&gt;</C> (ASCII 2) 
that allow proper line breaks. See <Ref Func="StripLineBreakCharacters"/>
for a function to get rid of these control characters.
</Description>
</ManSection>

<ManSection>
<Attr Name="String" Arg='obj[, length]'/>

<Description>
<Ref Attr="String"/> returns a representation of <A>obj</A>,
which may be an object of arbitrary type, as a string.
This string should approximate as closely as possible the character
sequence you see if you print <A>obj</A>.
<P/>
If <A>length</A> is given it must be an integer.
The absolute value gives the minimal length of the result.
If the string representation of <A>obj</A> takes less than that many
characters it is filled with blanks.
If <A>length</A> is positive it is filled on the left,
if <A>length</A> is negative it is filled on the right.
<P/>
In the two argument case, the string returned is a new mutable
string (in particular not a part of any other object);
it can be modified safely,
and <Ref Func="MakeImmutable"/> may be safely applied to it.
<Example><![CDATA[
gap> String(123);String([1,2,3]);
"123"
"[ 1, 2, 3 ]"
]]></Example>
<Ref Oper="String"/> must not put in additional control 
characters <C>\&lt;</C> (ASCII 1) and <C>\&gt;</C> (ASCII 2) 
that allow proper line breaks.
</Description>
</ManSection>


<ManSection>
<Func Name="StripLineBreakCharacters" Arg="st"/>

<Description>
This function takes a string <A>st</A> as an argument and removes all
control characters <C>\&lt;</C> (ASCII 1) and <C>\&gt;</C> (ASCII 2) 
which are used by
<Ref Oper="PrintString"/> and <Ref Oper="PrintObj"/> to ensure proper
line breaking. A new string with these characters removed is returned.
</Description>
</ManSection>


<ManSection>
<Func Name="HexStringInt" Arg='int'/>

<Description>
returns a string which represents the integer <A>int</A> with hexa-decimal
digits (using <C>A</C> to <C>F</C> as digits <C>10</C> to <C>15</C>).
The inverse translation can be achieved with <Ref Func="IntHexString"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="StringPP" Arg='int'/>

<Description>
returns a string representing the prime factor decomposition
of the integer <A>int</A>.
<Example><![CDATA[
gap> StringPP(40320);
"2^7*3^2*5*7"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="WordAlp" Arg='alpha, nr'/>

<Description>
returns a string that is the <A>nr</A>-th word over the alphabet list
<A>alpha</A>, w.r.t. word length and lexicographical order.
The empty word is <C>WordAlp( <A>alpha</A>, 0 )</C>.
<Example><![CDATA[
gap> List([0..5],i->WordAlp("abc",i));
[ "", "a", "b", "c", "aa", "ab" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LowercaseString" Arg='string'/>

<Description>
returns a lowercase version of the string <A>string</A>,
that is, a string in which each uppercase alphabet character is replaced
by the corresponding lowercase character.
<Example><![CDATA[
gap> LowercaseString("This Is UpperCase");
"this is uppercase"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SplitString" Arg='string, seps[, wspace]'/>

<Description>
This function accepts a string <A>string</A> and lists <A>seps</A> and,
optionally, <A>wspace</A> of characters.
Now <A>string</A> is split into substrings at each occurrence of a
character in <A>seps</A> or <A>wspace</A>.
The characters in <A>wspace</A> are interpreted as white space
characters.
Substrings of characters in <A>wspace</A> are treated as one white space
character and they are ignored at the beginning and end of a string.
<P/>
Both arguments <A>seps</A> and <A>wspace</A> can be single characters.
<P/>
Each string in the resulting list of substring does not contain any
characters in <A>seps</A> or <A>wspace</A>.
<P/>
A character that occurs both in <A>seps</A> and <A>wspace</A> is treated
as a white space character.
<P/>
A separator at the end of a string is interpreted as a terminator; in
this case, the separator does not produce a trailing empty string.
Also see&nbsp;<Ref Func="Chomp"/>.
<Example><![CDATA[
gap> SplitString( "substr1:substr2::substr4", ":" );
[ "substr1", "substr2", "", "substr4" ]
gap> SplitString( "a;b;c;d;", ";" );
[ "a", "b", "c", "d" ]
gap> SplitString( "/home//user//dir/", "", "/" );
[ "home", "user", "dir" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReplacedString" Arg='string, old, new'/>

<Description>
replaces occurrences of the string <A>old</A> in <A>string</A> by
<A>new</A>, starting from the left and always replacing the first
occurrence.
To avoid infinite recursion, characters which have been replaced already,
are not subject to renewed replacement.
<Example><![CDATA[
gap> ReplacedString("abacab","a","zl");
"zlbzlczlb"
gap> ReplacedString("ababa", "aba","c");
"cba"
gap> ReplacedString("abacab","a","ba");
"babbacbab"
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="NormalizeWhitespace" Arg='string'/>

<Description>
This function changes the string <A>string</A> in place.
The characters <C> </C> (space), <C>\n</C>, <C>\r</C> and <C>\t</C> are
considered as <E>white space</E>.
Leading and trailing white space characters in <A>string</A> are removed.
Sequences of white space characters between other characters are replaced by
a single space character.
<P/>
See <Ref Func="NormalizedWhitespace"/> for a non-destructive version.
<Example><![CDATA[ 
gap> s := "   x y \n\n\t\r  z\n   \n";
"   x y \n\n\t\r  z\n   \n"
gap> NormalizeWhitespace(s);
gap> s;
"x y z"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NormalizedWhitespace" Arg='str'/>

<Description>
This function returns a copy of string <A>str</A> to which
<Ref Func="NormalizeWhitespace"/> was applied.
</Description>
</ManSection>


<ManSection>
<Func Name="RemoveCharacters" Arg='string, chars'/>
<Description>
Both arguments must be strings. This function efficiently removes all 
characters given in <A>chars</A> from <A>string</A>.
<Example>
gap> s := "ab c\ndef\n\ng    h i .\n";
"ab c\ndef\n\ng    h i .\n"
gap> RemoveCharacters(s, " \n\t\r"); # remove all whitespace characters
gap> s;
"abcdefghi."
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name="JoinStringsWithSeparator" Arg='list[, sep]'/>

<Description>
joins <A>list</A> (a list of strings) after interpolating <A>sep</A>
(or <C>","</C> if the second argument is omitted) between each adjacent
pair of strings; <A>sep</A> should be a string.
<P/>
<Example><![CDATA[
gap> list := List([1..10], String);
[ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" ]
gap> JoinStringsWithSeparator(list);
"1,2,3,4,5,6,7,8,9,10"
gap> JoinStringsWithSeparator(["The", "quick", "brown", "fox"], " ");
"The quick brown fox"
gap> new:= JoinStringsWithSeparator(["a", "b", "c", "d"], ",\n    ");
"a,\n    b,\n    c,\n    d"
gap> Print("    ", new, "\n");
    a,
    b,
    c,
    d
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Chomp" Arg='str'/>
<Description>
Like the similarly named Perl function, <Ref Func="Chomp"/> removes a
trailing newline character (or carriage-return line-feed couplet) from a
string argument <A>str</A> if present and returns the result.
If <A>str</A> is not a string or does not have such trailing character(s)
it is returned unchanged.
This latter property means that <Ref Func="Chomp"/> is safe to use in
cases where one is manipulating the result of another function which
might sometimes return <K>fail</K>.
<P/>
<Example><![CDATA[
gap> Chomp("The quick brown fox jumps over the lazy dog.\n");
"The quick brown fox jumps over the lazy dog."
gap> Chomp("The quick brown fox jumps over the lazy dog.\r\n");
"The quick brown fox jumps over the lazy dog."
gap> Chomp("The quick brown fox jumps over the lazy dog.");
"The quick brown fox jumps over the lazy dog."
gap> Chomp(fail);
fail
gap> Chomp(32);
32
]]></Example>
<P/>
<E>Note:</E>
<Ref Func="Chomp"/> only removes a trailing newline character from
<A>str</A>.
If your string contains several newline characters and you really want to
split <A>str</A> into lines at the newline characters (and remove those
newline characters) then you should use <Ref Func="SplitString"/>, e.g.
<P/>
<Example><![CDATA[
gap> str := "The quick brown fox\njumps over the lazy dog.\n";
"The quick brown fox\njumps over the lazy dog.\n"
gap> SplitString(str, "", "\n");
[ "The quick brown fox", "jumps over the lazy dog." ]
gap> Chomp(str);
"The quick brown fox\njumps over the lazy dog."
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="StartsWith" Arg='string, prefix'/>
<Func Name="EndsWith" Arg='string, suffix'/>

<Description>
<Index>Prefix</Index>
<Index>Suffix</Index>
Determines whether a string starts or ends with another string.
</Description>
</ManSection>

        
The following two functions convert basic strings to lists of numbers and
vice versa. They are useful for examples of text encryption.
<ManSection>
<Func Name="NumbersString" Arg='s,m [,table]'/>

<Description>
<Ref Func="NumbersString"/> takes a string message <A>s</A> and 
returns a list of integers, each not exceeding the integer <A>m</A>
that encode the
message using  the scheme <M>A=11</M>, <M>B=12</M> and so on (and
converting lower case to upper case). 
If a list of characters is given in <A>table</A>,
it is used instead for encoding).
<Example><![CDATA[
gap> l:=NumbersString("Twas brillig and the slithy toves",1000000);
[ 303311, 291012, 281922, 221917, 101124, 141030, 181510, 292219, 
  301835, 103025, 321529 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="StringNumbers" Arg='l,m [,table]'/>

<Description>
<Ref Func="StringNumbers"/> takes a list <A>l</A> of integers that was
encoded using <Ref Func="NumbersString"/> and the size integer <A>m</A>, 
and returns a
message string, using  the scheme <M>A=11</M>, <M>B=12</M> and so on. 
If a list of characters is given in <A>table</A>,
it is used instead for decoding).
<Example><![CDATA[
gap> StringNumbers(l,1000000);
"TWAS BRILLIG AND THE SLITHY TOVES"
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Character Conversion">
<Heading>Character Conversion</Heading>

The following functions convert characters in their internal integer values
and vice versa. Note that the number corresponding to a particular character
might depend on the system used. While most systems use an extension of
ASCII, in particular character values outside the range <C>[ 32 .. 126 ]</C>
might differ between architectures.
<P/>

<ManSection>
<Func Name="IntChar" Arg='char'/>

<Description>
returns an integer value in the range <C>[ 0 .. 255 ]</C> that corresponds
to <A>char</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="CharInt" Arg='int'/>

<Description>
returns a character that corresponds to the integer value <A>int</A>,
which must be in the range <C>[ 0 .. 255 ]</C>.
<P/>
<Example><![CDATA[
gap> c:=CharInt(65);
'A'
gap> IntChar(c);
65
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="SIntChar" Arg='char'/>

<Description>
returns a signed integer value in the range <C>[ -128 .. 127 ]</C> that
corresponds to <A>char</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="CharSInt" Arg='int'/>

<Description>
returns a character which corresponds to the signed integer value <A>int</A>,
which must be in the range <C>[ -128 .. 127 ]</C>.
<P/>
The signed and unsigned integer functions behave the same for values in the
range <C>[ 0 .. 127 ]</C>.
<P/>
<Example><![CDATA[
gap> SIntChar(c);
65
gap> c:=CharSInt(-20);;
gap> SIntChar(c);
-20
gap> IntChar(c);
236
gap> SIntChar(CharInt(255));
-1
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations to Evaluate Strings">
<Heading>Operations to Evaluate Strings</Heading>

<ManSection>
<Attr Name="Int" Arg='str' Label="for strings"/>
<Attr Name="Rat" Arg='str' Label="for strings"/>
<Func Name="IntHexString" Arg='str'/>

<Description>
<Index Subkey="strings">evaluation</Index>
return either an integer (<Ref Func="Int" Label="for strings"/> and
<Ref Func="IntHexString"/>),
or a rational (<Ref Func="Rat" Label="for strings"/>) as represented by the
string <A>str</A>.
<Ref Func="Int" Label="for strings"/> returns <K>fail</K> if non-digit
characters occur in <A>str</A>.
For <Ref Func="Rat" Label="for strings"/>, the argument string may start with
the sign character <C>-</C>,
followed by either a sequence of digits or by two sequences of digits
that are separated by one of the characters <C>/</C> or <C>.</C>,
where the latter stands for a decimal dot.
(The methods only evaluate numbers but do <E>not</E> perform arithmetic!)
<P/>
<Ref Func="IntHexString"/> evaluates an integer written with hexa-decimal
digits.
Here the letters <C>a</C>-<C>f</C> or <C>A</C>-<C>F</C> are used as
<E>digits</E> <M>10</M> to <M>15</M>.
An error occurs when a wrong character is found in the string.
This function can be used (together with <Ref Func="HexStringInt"/>) for
efficiently storing and reading large integers from respectively into &GAP;.
Note that the translation between integers and their hexa-decimal
representation costs linear computation time in terms of the number of
digits, while translation from and into decimal representation needs
substantial computations.
If <A>str</A> is not in compact string representation then
<Ref Func="ConvertToStringRep"/> is applied to it as side effect.
<P/>
<Example><![CDATA[
gap> Int("12345")+1;
12346
gap> Int("123/45");
fail
gap> Int("1+2");
fail
gap> Int("-12");
-12
gap> Rat("123/45");
41/15
gap> Rat( "123.45" );
2469/20
gap> IntHexString("-abcdef0123456789");
-12379813738877118345
gap> HexStringInt(last);
"-ABCDEF0123456789"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Ordinal" Arg='n'/>

<Description>
returns the ordinal of the integer <A>n</A> as a string.
<Example><![CDATA[
gap> Ordinal(2);  Ordinal(21);  Ordinal(33);  Ordinal(-33);
"2nd"
"21st"
"33rd"
"-33rd"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="EvalString" Arg='expr'/>

<Description>
passes the string <A>expr</A> through an input text stream so that &GAP;
interprets it, and returns the result.
<P/>
<Example><![CDATA[
gap> a:=10;
10
gap> EvalString("a^2");
100
]]></Example>
<P/>
<Ref Func="EvalString"/> is intended for <E>single</E> expressions.
A sequence of commands may be interpreted by using the functions
<Ref Func="InputTextString"/> and
<Ref Func="ReadAsFunction" Label="for streams"/> together;
see <Ref Sect="Operations for Input Streams"/> for an example.
<P/>
If <Ref Func="EvalString"/> is used inside a function, then it doesn't
know about the local variables and the arguments of the function. 
A possible workaround is to define global variables in advance, and
then to assign the values of the local variables to the global ones,
like in the example below.
<P/>
<Example><![CDATA[
gap> global_a := 0;;
gap> global_b := 0;;
gap> example := function ( local_a )
>     local  local_b;
>     local_b := 5;
>     global_a := local_a;
>     global_b := local_b;
>     return EvalString( "global_a * global_b" );
> end;;
gap> example( 2 );
10
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CrcString" Arg='str'/>
<Returns>an integer</Returns>

<Description>
This function computes a cyclic redundancy check number from a string
<A>str</A>. See also <Ref Func="CrcFile"/>.
<Example>
gap> CrcString("GAP example string");
-50451670
</Example>
</Description>
</ManSection>



</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Calendar Arithmetic">
<Heading>Calendar Arithmetic</Heading>

All calendar functions use the Gregorian calendar.

<ManSection>
<Func Name="DaysInYear" Arg='year'/>

<Description>
returns the number of days in the year <A>year</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="DaysInMonth" Arg='month, year'/>

<Description>
returns the number of days in month number <A>month</A> of <A>year</A>,
and <K>fail</K> if <C>month</C> is not in the valid range.
<Example><![CDATA[
gap> DaysInYear(1998);
365
gap> DaysInMonth(3,1998);
31
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DMYDay" Arg='day'/>

<Description>
converts a number of days, starting 1-Jan-1970, to a list
<C>[ day, month, year ]</C> in Gregorian calendar counting.
</Description>
</ManSection>

<ManSection>
<Func Name="DayDMY" Arg='dmy'/>

<Description>
returns the number of days from 01-Jan-1970 to the day given by
<A>dmy</A>, which must be a list of the form
<C>[ day, month, year ]</C> in Gregorian calendar counting.
The result is <K>fail</K> on input outside valid ranges.
<P/>
Note that this makes not much sense for early dates like: before 1582
(no Gregorian calendar at all), or before 1753 in many English speaking
countries or before 1917 in Russia.
</Description>
</ManSection>

<ManSection>
<Func Name="WeekDay" Arg='date'/>

<Description>
returns the weekday of a day given by <A>date</A>, which can be a number
of days since 1-Jan-1970 or a list <C>[ day, month, year ]</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="StringDate" Arg='date'/>

<Description>
converts <A>date</A> to a readable string.
<A>date</A> can be a number of days since 1-Jan-1970 or a list
<C>[ day, month, year ]</C>.
<Example><![CDATA[
gap> DayDMY([1,1,1970]);DayDMY([2,1,1970]);
0
1
gap> DMYDay(12345);
[ 20, 10, 2003 ]
gap> WeekDay([11,3,1998]);
"Wed"
gap> StringDate([11,3,1998]);
"11-Mar-1998"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="HMSMSec" Arg='msec'/>

<Description>
converts a number <A>msec</A> of milliseconds into a list
<C>[ hour, min, sec, milli ]</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="SecHMSM" Arg='hmsm'/>

<Description>
is the reverse of <Ref Func="HMSMSec"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="StringTime" Arg='time'/>

<Description>
converts <A>time</A> (given as a number of milliseconds or a list
<C>[ hour, min, sec, milli ]</C>) to a readable string.
<Example><![CDATA[
gap> HMSMSec(Factorial(10));
[ 1, 0, 28, 800 ]
gap> SecHMSM([1,10,5,13]);
4205013
gap> StringTime([1,10,5,13]);
" 1:10:05.013"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SecondsDMYhms" Arg='DMYhms'/>

<Description>
returns the number of seconds from 01-Jan-1970, 00:00:00,
to the time given by <A>DMYhms</A>, which must be a list of the form
<C>[ day, month, year, hour, minute, second ]</C>.
The remarks on the Gregorian calendar in the section on
<Ref Func="DayDMY"/> apply here as well.
The last three arguments must lie in the appropriate ranges. 
</Description>
</ManSection>

<ManSection>
<Func Name="DMYhmsSeconds" Arg='secs'/>

<Description>
This is the inverse function to <Ref Func="SecondsDMYhms"/>.
<Example><![CDATA[
gap> SecondsDMYhms([ 9, 9, 2001, 1, 46, 40 ]);
1000000000
gap> DMYhmsSeconds(-1000000000);
[ 24, 4, 1938, 22, 13, 20 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Obtaining LaTeX Representations of Objects">
<Heading>Obtaining LaTeX Representations of Objects</Heading>
<Index Subkey="for GAP objects">LaTeX</Index>

For the purpose of generating &LaTeX; source code with &GAP; it is 
recommended to add new functions which will print the &LaTeX; source 
or return &LaTeX; strings for further processing.
<P/>

An alternative approach could be based on methods for the default &LaTeX; 
representation for each appropriate type of objects. However, there is
no clear notion of a default &LaTeX; code for any non-trivial mathematical
object; moreover, different output may be required in different contexts.
<P/>

While customisation of such an operation may require changes in a variety 
of methods that may be distributed all over the library, the user will 
have a clean overview of the whole process of &LaTeX; code generation if 
it is contained in a single function. Furthermore, there may be kinds of 
objects which are not detected by the method selection, or there may be 
a need in additional parameters specifying requirements for the output.
<P/>

This is why having a special purpose function for each particular case 
is more suitable. &GAP; provides several functions that produce &LaTeX; 
strings for those situations where this is nontrivial and reasonable. 
A useful example is <Ref Func="LaTeXStringDecompositionMatrix"/> from
the &GAP; library, others can be found entering <C>?LaTeX</C> at the 
&GAP; prompt. Package authors are encouraged to add an index entry 
<C>LaTeX</C> to the documentation of all &LaTeX; string producing functions.
This way, entering <C>?LaTeX</C> will give an overview of all documented 
functionality in this direction.
 
</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  dict.msk                  GAP documentation               Gene Cooperman -->
<!-- %A							         Scott Murray -->
<!-- %A	        					     Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: hash2.msk,v 1.9 2005/08/06 13:09:06 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 2000 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Dictionaries and General Hash Tables">
<Heading>Dictionaries and General Hash Tables</Heading>

People and computers spend a large amount of time with searching.
Dictionaries are an abstract data structure which facilitates searching for
objects. Depending on the kind of objects the implementation will use a
variety of possible internal storage methods that will aim to provide the
fastest possible access to objects. These internal methods include
<P/>
<List>
<Mark>Hash Tables</Mark>
<Item>
  for objects for which a hash function has been defined.
</Item>
<Mark>Direct Indexing</Mark>
<Item>
  if the domain is small and cheaply enumerable
</Item>
<Mark>Sorted Lists</Mark>
<Item>
  if a total order can be computed easily
</Item>
<Mark>Plain lists</Mark>
<Item>
  for objects for which nothing but an equality test is available.
</Item>
</List>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Using Dictionaries">
<Heading>Using Dictionaries</Heading>

The standard way to use dictionaries is to first create a dictionary (using
<Ref Func="NewDictionary"/>, and then to store objects (and associated information) in
it and look them up. 
<P/>
For the creation of objects the user has to make a few choices: Is the
dictionary only to be used to check whether objects are known already, or
whether associated information is to be stored with the objects. This second
case is called a <E>lookup dictionary</E> and is selected by the second parameter
of <Ref Func="NewDictionary"/>.
<P/>
The second choice is to indicate which kind of objects are to be stored. This
choice will decide the internal storage used. This kind of objects is
specified by the first parameter to <Ref Func="NewDictionary"/>, which is a <Q>sample</Q>
object. 
<P/>
In some cases however such a sample object is not specific enough. For
example when storing vectors over a finite field, it would not be clear
whether all vectors will be over a prime field or over a field extension.
Such an issue can be resolved by indicating in an (optional)  third
parameter to
<Ref Func="NewDictionary"/> a <E>domain</E> which has to be a collection that will
contain all objects to be used with this dictionary. (Such a domain may also
be used internally to decide that direct indexing can be used).
<P/>
The reason for this choice of giving two parameters is that in some cases no
suitable collection of objects has been defined in &GAP; - for example for
permutations there is no object representing the symmetric group on
infinitely many points.
<P/>
Once a dictionary has been created, it is possible to use
<Ref Oper="RepresentationsOfObject"/> to check which representation is used by &GAP;.
<P/>
In the following example, we create a dictionary to store permutations with
associated information.
<Example><![CDATA[
gap> d:=NewDictionary((1,2,3),true);;
gap> AddDictionary(d,(1,2),1);
gap> AddDictionary(d,(5,6),9);
gap> AddDictionary(d,(4,7),2);
gap> LookupDictionary(d,(5,6));
9
gap> LookupDictionary(d,(5,7));
fail
]]></Example>
A typical example of this use would be in an orbit algorithm. The dictionary
would be used to store the elements known in the orbit together with their
respective orbit positions.
<P/>
We observe that this dictionary is stored internally by a sorted list. On
the other hand, if we have an explicit, sorted element list, direct indexing
is to be used.
<Example><![CDATA[
gap> RepresentationsOfObject(d);
[ "IsComponentObjectRep", "IsDictionaryDefaultRep", 
  "IsListDictionary", "IsListLookupDictionary", "IsSortDictionary", 
  "IsSortLookupDictionary" ]
gap> d:=NewDictionary((1,2,3),true,Elements(SymmetricGroup(5)));;
gap> RepresentationsOfObject(d);
[ "IsComponentObjectRep", "IsDictionaryDefaultRep", 
  "IsPositionDictionary", "IsPositionDictionary" ]
]]></Example>
(Just indicating <C>SymmetricGroup(5)</C> as a third parameter would still keep
the first storage method, as indexing would be too expensive if no explicit
element list is known.)
<P/>
The same effect happens in the following example, in which we work with
vectors: Indicating only a vector only enables sorted index, as it cannot be
known whether all vectors will be defined over the prime field. On the other
hand, providing the vector space (and thus limiting the domain) enables
the use of hashing (which will be faster).
<Example><![CDATA[
gap> v:=GF(2)^7;;
gap> d:=NewDictionary(Zero(v),true);;                            
gap> RepresentationsOfObject(d);
[ "IsComponentObjectRep", "IsDictionaryDefaultRep", 
  "IsListDictionary", "IsListLookupDictionary", "IsSortDictionary", 
  "IsSortLookupDictionary" ]
gap> d:=NewDictionary(Zero(v),true,v);;
gap> RepresentationsOfObject(d);
[ "IsComponentObjectRep", "IsDictionaryDefaultRep", 
  "IsPositionDictionary", "IsPositionDictionary" ]
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Dictionaries">
<Heading>Dictionaries</Heading>

This section contains the formal declarations for dictionaries. For
information on how to use them, please refer to the previous
section&nbsp;<Ref Sect="Using Dictionaries"/>.

There are several ways how dictionaries are implemented: As lists, as
sorted lists, as hash tables or via binary lists. A user however will
just have to call <Ref Func="NewDictionary"/> and obtain a <Q>suitable</Q> dictionary
for the kind of objects she wants to create. It is possible however to
create hash tables (see&nbsp;<Ref Sect="General Hash Tables"/>)
and dictionaries using binary lists (see&nbsp;<Ref Func="DictionaryByPosition"/>).
<P/>

The use of two objects, <A>obj</A> and <A>objcoll</A> to parametrize the objects a
dictionary is able to store might look confusing. However there are
situations where either of them might be needed:
<P/>
The first situation is that of objects, for which no formal <Q>collection
object</Q> has been defined. A typical example here might be subspaces of
a vector space. &GAP; does not formally define a <Q>Grassmannian</Q> or
anything else to represent the multitude of all subspaces. So it is only
possible to give the dictionary a <Q>sample object</Q>.
<P/>
The other situation is that of an object which might represent quite
varied domains. The permutation <M>(1,10^6)</M> might be the nontrivial
element of a cyclic group of order 2, it might be a representative of
<M>S_{{10^6}}</M>.
In the first situation the best approach might be just to
have two entries for the two possible objects, in the second situation a
much more elaborate approach might be needed.
<P/>
An algorithm that creates a dictionary will usually know a priori, from what
domain all the objects will be, giving this domain permits to use a more
efficient dictionary.
<P/>
This is particularly true for vectors. From a single vector one cannot
decide whether a calculation will take place over the smallest field
containing all its entries or over a larger field.

<ManSection>
<Func Name="NewDictionary" Arg='obj,look[,objcoll]'/>

<Description>
creates a new dictionary for objects such as <A>obj</A>. If <A>objcoll</A> is
given the dictionary will be for objects only from this collection,
knowing this can improve the performance. If <A>objcoll</A> is given, <A>obj</A>
may be replaced by <K>false</K>, i.e. no sample object is needed.
<P/>
The function tries to find the right kind of dictionary for the basic
dictionary functions to be quick.
If <A>look</A> is <K>true</K>, the dictionary will be a lookup dictionary,
otherwise it is an ordinary dictionary.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Dictionaries via Binary Lists">
<Heading>Dictionaries via Binary Lists</Heading>

As there are situations where the approach via binary lists is explicitly
desired, such dictionaries can be created deliberately.

<ManSection>
<Func Name="DictionaryByPosition" Arg='list,lookup'/>

<Description>
creates a new (lookup) dictionary which uses
<Ref Oper="PositionCanonical"/> in <A>list</A> for indexing.
The dictionary will have an entry <A>dict</A><C>!.blist</C>
which is a bit list corresponding to <A>list</A> indicating the known
values.
If <A>look</A> is <K>true</K>,
the dictionary will be a lookup dictionary,
otherwise it is an ordinary dictionary.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsDictionary" Arg='obj' Type='Category'/>

<Description>
A dictionary is a growable collection of objects that permits to add
objects (with associated values) and to check whether an object is
already known.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLookupDictionary" Arg='obj' Type='Category'/>

<Description>
A <E>lookup dictionary</E> is a dictionary, which permits not only to check
whether an object is contained, but also to retrieve associated values,
using the operation <Ref Oper="LookupDictionary"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AddDictionary" Arg='dict,key[,val]'/>

<Description>
adds <A>key</A> to the dictionary <A>dict</A>, storing the associated
value <A>val</A> in case <A>dict</A> is a lookup dictionary. 
If <A>key</A> is not an object of the kind for
which the dictionary was specified, or if <A>key</A> is known already to
<A>dict</A>, the results are unpredictable.
</Description>
</ManSection>

<ManSection>
<Oper Name="KnowsDictionary" Arg='dict,key'/>

<Description>
checks, whether <A>key</A> is known to the dictionary <A>dict</A>,
and returns <K>true</K> or <K>false</K> accordingly.
<A>key</A> <E>must</E> be an object of the kind for
which the dictionary was specified, otherwise the results are
unpredictable.
</Description>
</ManSection>

<ManSection>
<Oper Name="LookupDictionary" Arg='dict,key'/>

<Description>
looks up <A>key</A> in the lookup dictionary <A>dict</A> and returns the
associated value.
If <A>key</A> is not known to the dictionary, <K>fail</K> is returned.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="General Hash Tables">
<Heading>General Hash Tables</Heading>

These sections describe some particularities for hash tables. These are
intended mainly for extending the implementation - programs requiring hash
functionality ought to use the dictionary interface described above.
<P/>
We hash by keys and also store a value.  Keys    
cannot be removed from the table, but the corresponding value can be 
changed.  Fast access to last hash index allows you to efficiently store 
more than one array of values &ndash;this facility should be used with care.
<P/>
This code works for any kind of object, provided you have a 
<Ref Oper="DenseIntKey"/> method to convert the key into a positive integer.  
This method should ideally be implemented efficiently in the core.
<P/>Note that, for efficiency, it is currently impossible to create a 
hash table with non-positive integers.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Hash keys">
<Heading>Hash keys</Heading>

The crucial step of hashing is to transform key objects into integers such
that equal objects produce the same integer.
<P/>
The actual function used will vary very much on the type of objects. However
&GAP; provides already key functions for some commonly encountered objects.

<ManSection>
<Oper Name="DenseIntKey" Arg='objcoll,obj'/>

<Description>
returns a function that can be used as hash key function for objects
such as <A>obj</A> in the collection <A>objcoll</A>.
Typically, <A>objcoll</A> will be a large domain.
If the domain is not available, it can be given as
<K>false</K> in which case the hash key function will be determined only
based on <A>obj</A>. (For a further discussion of these two arguments
see&nbsp;<Ref Func="NewDictionary"/>).
<P/>
The function returned by <Ref Oper="DenseIntKey"/> is guaranteed to give different
values for different objects.
If no suitable hash key function has been predefined, <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Oper Name="SparseIntKey" Arg='objcoll,obj'/>

<Description>
returns a function that can be used as hash key function for objects
such as <A>obj</A> in the collection <A>objcoll</A>.
In contrast to <Ref Oper="DenseIntKey"/>,
the function returned may return the same key value for different
objects.
If no suitable hash key function has been predefined,
<K>fail</K> is returned.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Dense hash tables">
<Heading>Dense hash tables</Heading>

Dense hash tables are used for hashing dense sets without collisions, 
in particular integers. 
Keys are stored as an unordered list and values as an 
array with holes. The position of a value is given by 
the function returned by <Ref Oper="DenseIntKey"/>,
and so <C>KeyIntDense</C> must be one-to-one.  

<ManSection>
<Func Name="DenseHashTable" Arg=''/>

<Description>
Construct an empty dense hash table.  This is the only correct way to
construct such a table.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sparse hash tables">
<Heading>Sparse hash tables</Heading>

Sparse hash tables are used for hashing sparse sets.  
Stores keys as an array with fail 
denoting an empty position, stores values as an array with holes.
Uses 
the result of calling <Ref Oper="SparseIntKey"/>) of the key.
<C>DefaultHashLength</C>
is the default starting hash table length; the table is doubled 
when it becomes half full.
<P/>
In sparse hash tables, the integer obtained from the hash key is then
transformed to an index position by taking it modulo the length of the hash
array.

<ManSection>
<Func Name="SparseHashTable" Arg='[intkeyfun]'/>

<Description>
Construct an empty sparse hash table.  This is the only correct way to
construct such a table.
If the argument <A>intkeyfun</A> is given, this function will be used to
obtain numbers for the keys passed to it.
</Description>
</ManSection>

<ManSection>
<Func Name="DoubleHashArraySize" Arg='hash'/>

<Description>
Double the size of the hash array and rehash all the entries.
This will also happen automatically when the hash array is half full.
</Description>
</ManSection>


</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  record.msk                  GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: record.msk,v 1.14 2002/10/01 15:03:08 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Records">
<Heading>Records</Heading>

<Index Subkey="records">type</Index>

<E>Records</E> are next to lists the most important way to collect objects
together. A record is a collection of <E>components</E>. Each component has
a unique <E>name</E>, which is an identifier that distinguishes this
component, and a <E>value</E>, which is an object of arbitrary type. We often
abbreviate <E>value of a component</E> to <E>element</E>. We also say that a
record <E>contains</E> its elements. You can access and change the elements
of a record using its name.
<P/>
Record literals are written by writing down the components in order between
<Q><C>rec(</C></Q> and <Q><C>)</C></Q>, and separating them by commas
<Q><C>,</C></Q>.
Each component consists of the name,
the assignment operator <Q><C>:=</C></Q>, and the value.
The <E>empty record</E>, i.e., the record with no components, is written as
<C>rec()</C>.
<P/>
<Example><![CDATA[
gap> rec( a := 1, b := "2" ); # a record with two components
rec( a := 1, b := "2" )
gap> rec( a := 1, b := rec( c := 2 ) ); # record may contain records
rec( a := 1, b := rec( c := 2 ) )
]]></Example>
<P/>
We may use the <Ref Func="Display"/> function to illustrate the hierarchy of
the record components.
<P/>
<Example><![CDATA[
gap> Display( last );
rec(
  a := 1,
  b := rec(
      c := 2 ) )
]]></Example>
<P/>
Records usually contain elements of various types, i.e., they are usually
not homogeneous like lists.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsRecord">
<Heading>IsRecord and RecNames</Heading>

<ManSection>
<Filt Name="IsRecord" Arg='obj' Type='Category'/>
<Filt Name="IsRecordCollection" Arg='obj' Type='Category'/>
<Filt Name="IsRecordCollColl" Arg='obj' Type='Category'/>

<Description>
<Index Subkey="for records">test</Index>
<Example><![CDATA[
gap> IsRecord( rec( a := 1, b := 2 ) );
true
gap> IsRecord( IsRecord );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RecNames" Arg='record'/>

<Description>
returns a list of strings corresponding to the names of the record
components of the record <A>record</A>.
<P/>
<Example><![CDATA[
gap> r := rec( a := 1, b := 2 );;
gap> Set(RecNames( r )); # 'Set' because ordering depends on GAP session
[ "a", "b" ]
]]></Example>
<P/>
Note that you cannot use the string result in the ordinary way to access
or change a record component.
You can use the <C><A>record</A>.(<A>name</A>)</C> construct for that,
see <Ref Sect="Accessing Record Elements"/> and
<Ref Sect="Record Assignment"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Accessing Record Elements">
<Heading>Accessing Record Elements</Heading>

<Index Subkey="record elements">accessing</Index>
<Index Subkey="component access">record</Index>
<C><A>r</A>.<A>name</A></C>
<P/>
The above construct evaluates to the value of the record component with
the name <A>name</A> in the record <A>r</A>. Note that the <A>name</A> is not
evaluated, i.e. it is taken literal.
<P/>
<Example><![CDATA[
gap> r := rec( a := 1, b := 2 );;
gap> r.a;
1
gap> r.b;
2
]]></Example>
<P/>
<Index Subkey="component variable">record</Index>
<C><A>r</A>.(<A>name</A>)</C>
<P/>
This construct is similar to the above construct. The difference is that
the second operand <A>name</A> is evaluated. It must evaluate to a string or
an integer otherwise an error is signalled. The construct then evaluates
to the element of the record <A>r</A> whose name is, as a string, equal to
<A>name</A>.
<P/>
<Example><![CDATA[
gap> old := rec( a := 1, b := 2 );;
gap> new := rec();
rec(  )
gap> for i in RecNames( old ) do
>  new.(i) := old.(i);
> od;
gap> Display( new );
rec(
  a := 1,
  b := 2 )
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Record Assignment">
<Heading>Record Assignment</Heading>

<Index Subkey="to a record">assignment</Index>
<Index Subkey="component assignment">record</Index>
<C><A>r</A>.<A>name</A> := <A>obj</A></C>
<P/>
The record assignment assigns the object <A>obj</A>,
which may be an object of arbitrary type,
to the record component with the name <A>name</A>,
which must be an identifier, of the record <A>r</A>.
That means that accessing the element with name <A>name</A> of the record
<A>r</A> will return <A>obj</A> after this assignment.
If the record <A>r</A> has no component with the name <A>name</A>,
the record is automatically extended to make room for the new component.
<P/>
<Example><![CDATA[
gap> r := rec( a := 1, b := 2 );;
gap> r.a := 10;;
gap> Display( r );
rec(
  a := 10,
  b := 2 )
gap> r.c := 3;;
gap> Display( r );
rec(
  a := 10,
  b := 2,
  c := 3 )
]]></Example>
<P/>
Note that assigning to a record changes the record.
<P/>
The function <Ref Func="IsBound" Label="for a record component"/>
can be used to test if a record has a component with a certain name,
the function <Ref Func="Unbind" Label="unbind a record component"/>
can be used to remove a component with a certain name again.
<P/>
<Example><![CDATA[
gap> IsBound(r.a);
true
gap> IsBound(r.d);
false
gap> Unbind(r.b);
gap> Display( r );
rec(
  a := 10,
  c := 3 )
]]></Example>
<P/>
<Index Subkey="component variable assignment">record</Index>
<C><A>r</A>.(<A>name</A>) := <A>obj</A></C>
<P/>
This construct is similar to the above construct. The difference is that
the second operand <A>name</A> is evaluated. It must evaluate to a string or
an integer otherwise an error is signalled. The construct then assigns
<A>obj</A> to the record component of the record <A>r</A> whose name is,
as a string, equal to <A>name</A>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Identical Records">
<Heading>Identical Records</Heading>

With the record assignment (see <Ref Sect="Record Assignment"/>)
it is possible to change a record.
This section describes the semantic consequences of this fact which are
essentially the same as for lists (see&nbsp;<Ref Sect="Identical Lists"/>).
<P/>
<Log><![CDATA[
r := rec( a := 1 );
r := rec( a := 1, b := 2 );
]]></Log>
<P/>
The second assignment does not change the first record, instead it
assigns a new record to the variable <C>r</C>. On the other hand, in the
following example the record is changed by the second assignment.
<P/>
<Log><![CDATA[
r := rec( a := 1 );
r.b := 2;
]]></Log>
<P/>
To understand the difference first think of a variable as a name for an
object. The important point is that a record can have several names at
the same time.
An assignment <C><A>var</A> := <A>r</A></C> means in this interpretation
that <A>var</A> is a name for the object <A>r</A>.
At the end of the following example <C>r2</C> still has the value
<C>rec( a := 1 )</C> as this record has not been changed and nothing else
has been assigned to <C>r2</C>.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
r2 := r1;
r1 := rec( a := 1, b := 2 );
]]></Log>
<P/>
But after the following example the record for which <C>r2</C> is a name has
been changed and thus the value of <C>r2</C> is now
<C>rec( a := 1, b := 2 )</C>.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
r2 := r1;
r1.b := 2;
]]></Log>
<P/>
We shall say that two records are <E>identical</E> if changing one of them by
a record assignment also changes the other one. This is slightly
incorrect, because if <E>two</E> records are identical, there are actually
only two names for <E>one</E> record. However, the correct usage would be
very awkward and would only add to the confusion.  Note that two
identical records must be equal, because there is only one records with
two different names. Thus identity is an equivalence relation that is a
refinement of equality.
<P/>
Let us now consider under which circumstances two records are identical.
<P/>
If you enter a record literal then the record denoted by this literal is
a new record that is not identical to any other record.
Thus in the following example <C>r1</C> and <C>r2</C> are not identical,
though they are equal of course.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
r2 := rec( a := 1 );
]]></Log>
<P/>
Also in the following example, no records in the list <C>l</C> are identical.
<P/>
<Log><![CDATA[
l := [];
for i in [1..10] do
  l[i] := rec( a := 1 );
od;
]]></Log>
<P/>
If you assign a record to a variable no new record is created. Thus the
record value of the variable on the left hand side and the record on the
right hand side of the assignment are identical. So in the following
example <C>r1</C> and <C>r2</C> are identical records.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
r2 := r1;
]]></Log>
<P/>
If you pass a record as argument, the old record and the argument of the
function are identical. Also if you return a record from a function, the
old record and the value of the function call are identical. So in the
following example <C>r1</C> and <C>r2</C> are identical records.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
f := function ( r ) return r; end;
r2 := f( r1 );
]]></Log>
<P/>
The functions <Ref Func="StructuralCopy"/> and <Ref Func="ShallowCopy"/>
accept a record and return a new record that is equal to the
old record but that is <E>not</E> identical to the old record.
The difference between <Ref Func="StructuralCopy"/> and
<Ref Func="ShallowCopy"/> is that in the case of
<Ref Func="ShallowCopy"/> the corresponding components of the new and the
old records will be identical,
whereas in the case of <Ref Func="StructuralCopy"/> they will only be equal.
So in the following example <C>r1</C> and <C>r2</C> are not identical records.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
r2 := ShallowCopy( r1 );
]]></Log>
<P/>
If you change a record it keeps its identity. Thus if two records are
identical and you change one of them, you also change the other, and they
are still identical afterwards. On the other hand, two records that are
not identical will never become identical if you change one of them. So
in the following example both <C>r1</C> and <C>r2</C> are changed,
and are still identical.
<P/>
<Log><![CDATA[
r1 := rec( a := 1 );
r2 := r1;
r1.b := 2;
]]></Log>
<P/>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons of Records">
<Heading>Comparisons of Records</Heading>

<Index Subkey="of records">equality</Index>
<Index Subkey="of records">inequality</Index>
<C><A>rec1</A> = <A>rec2</A></C>
<P/>
<C><A>rec1</A> &lt;> <A>rec2</A></C>
<P/>
Two records are considered equal, if for each component of one
record the other record has a component of the same name with an equal
value and vice versa.
<P/>
<Example><![CDATA[
gap> rec( a := 1, b := 2 ) = rec( b := 2, a := 1 );
true
gap> rec( a := 1, b := 2 ) = rec( a := 2, b := 1 );
false
gap> rec( a := 1 ) = rec( a := 1, b := 2 );
false
gap> rec( a := 1 ) = 1;
false
]]></Example>
<P/>
<Index Subkey="of records">ordering</Index>
<C><A>rec1</A> &lt; <A>rec2</A></C>
<P/>
<C><A>rec1</A> &lt;= <A>rec2</A></C>
<P/>
To compare records we imagine that the components of both records are
sorted according to their names (the sorting depends on the &GAP; session,
more precisely the order in which component names were first used).
Then the records are compared lexicographically with unbound elements
considered smaller than anything else.
Precisely one record <A>rec1</A> is considered less than another record
<A>rec2</A> if <A>rec2</A> has a component with name <A>name2</A> and either
<A>rec1</A> has no component with this name or
<C><A>rec1</A>.<A>name2</A> &lt; <A>rec2</A>.<A>name2</A></C>
and for each component of <A>rec1</A> with name
<C><A>name1</A> &lt; <A>name2</A></C> <A>rec2</A> has a
component with this name and
<C><A>rec1</A>.<A>name1</A> = <A>rec2</A>.<A>name1</A></C>.
<P/>
<Example><![CDATA[
gap> rec( axy := 1, bxy := 2 ) < rec( bxy := 2, axy := 1 ); # are equal
false
gap> rec( axy := 1 ) < rec( axy := 1, bxy := 2 ); # unbound is < 2
true
gap> # in new session the .axy components are compared first
gap> rec( axy := 1, bxy := 2 ) < rec( axy := 2, bxy := 0 ); # 1 < 2
true
gap> rec( axy := 1 ) < rec( axy := 0, bxy := 2 ); # 0 < 1
false
gap> rec( bxy := 1 ) < rec( bxy := 0, axy := 2 ); # unbound is < 2
true
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="IsBound and Unbind for Records">
<Heading>IsBound and Unbind for Records</Heading>

<ManSection>
<Oper Name="IsBound" Arg='r.name' Label="for a record component"/>

<Description>
<Ref Func="IsBound" Label="for a record component"/> returns <K>true</K>
if the record <A>r</A> has a component with the name <A>name</A>
(which must be an identifier) and <K>false</K> otherwise.
<A>r</A> must evaluate to a record, otherwise an error is signalled.
<P/>
<Example><![CDATA[
gap> r := rec( a := 1, b := 2 );;
gap> IsBound( r.a );
true
gap> IsBound( r.c );
false
]]></Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="Unbind" Arg='r.name' Label="unbind a record component"/>

<Description>
<Ref Func="Unbind" Label="unbind a record component"/> deletes the component
with the name <A>name</A> in the record <A>r</A>. That is, after
execution of <Ref Func="Unbind" Label="unbind a record component"/>,
<A>r</A> no longer has a record component with this name.
Note that it is not an error to unbind a nonexisting record component.
<A>r</A> must evaluate to a record, otherwise an error is signalled.
<P/>
<Example><![CDATA[
gap> r := rec( a := 1, b := 2 );;
gap> Unbind( r.a ); r;
rec( b := 2 )
gap> Unbind( r.c ); r;
rec( b := 2 )
]]></Example>
<P/>
Note that <Ref Func="IsBound" Label="for a record component"/> and
<Ref Func="Unbind" Label="unbind a record component"/> are special
in that they do not evaluate their argument,
otherwise <Ref Func="IsBound" Label="for a record component"/>
would always signal an error when it is supposed to return <K>false</K>
and there would be no way to tell
<Ref Func="Unbind" Label="unbind a record component"/>
which component to remove.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Record Access Operations">
<Heading>Record Access Operations</Heading>

Internally, record accesses are done using the operations listed in this
section. For the records implemented in the kernel, kernel methods are
provided for all these operations but otherwise it is possible to install
methods for these operations for any object. This
permits objects to simulate record behavior.
<P/>
To save memory, records do not store a list of all component names, but only
numbers identifying the components. There numbers are called <E>RNams</E>.
&GAP; keeps a global list of all RNams that are used and provides functions
to translate RNams to strings that give the component names and vice versa.

<ManSection>
<Func Name="NameRNam" Arg='nr'/>

<Description>
returns a string representing the component name corresponding to the RNam
<A>nr</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="RNamObj" Arg='str' Label="for a string"/>
<Func Name="RNamObj" Arg='int' Label="for a positive integer"/>

<Description>
returns a number (the RNam) corresponding to the string <A>str</A>. It is also
possible to pass a positive integer <A>int</A> in which case the decimal expansion of
<A>int</A> is used as a string.
<P/>
<Log><![CDATA[
gap> NameRNam(798);
"BravaisSupergroups"
gap> RNamObj("blubberflutsch");
2075
gap> NameRNam(last);
"blubberflutsch"
]]></Log>
<P/>
The correspondence between strings and RNams is not predetermined ab initio,
but RNams are assigned to component names dynamically on a
<Q>first come, first serve</Q> basis.
Therefore, depending on the version of the library you are using and on the
assignments done so far, the <E>same</E> component name may be represented
by <E>different</E> RNams in different &GAP; sessions.
</Description>
</ManSection>


<ManSection>
<Oper Name="\." Arg='obj, rnam'/>
<Oper Name="IsBound\." Arg='obj, rnam'/>
<Oper Name="\.\:\=" Arg='obj, rnam, val'/>
<Oper Name="Unbind\." Arg='obj, rnam'/>

<Description>
<Index Subkey="operation">record component</Index>
<Index Subkey="operation">record boundness test</Index>
<Index Subkey="operation">record assignment</Index>
<Index Subkey="operation">record unbind</Index>
These operations are called for record accesses to arbitrary objects.
If applicable methods are installed, they are called when the
object is accessed as a record.
<P/>
For records, the operations implement component access,
test for element boundness,
component assignment and removal of the component represented by the RNam
<A>rnam</A>.
<P/>
The component identifier <A>rnam</A> is always required to be in
<Ref Filt="IsPosInt"/>.
</Description>
</ManSection>

</Section>
</Chapter>




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  coll.msk                    GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: coll.msk,v 1.24 2006/08/29 13:38:17 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Collections">
<Heading>Collections</Heading>

A <E>collection</E> in &GAP; consists of elements in the same family
(see&nbsp;<Ref Sect="Families"/>).
The most important kinds of collections are <E>homogeneous lists</E>
(see&nbsp;<Ref Chap="Lists"/>)
and <E>domains</E> (see&nbsp;<Ref Chap="Domains"/>).
Note that a list is never a domain, and a domain is never a list.
A list is a collection if and only if it is nonempty and homogeneous.
<P/>
Basic operations for collections are <Ref Func="Size"/>
and <Ref Func="Enumerator"/>;
for <E>finite</E> collections,
<Ref Func="Enumerator"/> admits to delegate the other
operations for collections
(see&nbsp;<Ref Sect="Attributes and Properties for Collections"/>
and&nbsp;<Ref Sect="Operations for Collections"/>)
to functions for lists (see&nbsp;<Ref Chap="Lists"/>).
Obviously, special methods depending on the arguments are needed for
the computation of e.g.&nbsp;the intersection of two <E>infinite</E>
domains.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsCollection">
<Heading>IsCollection (Filter)</Heading>

<ManSection>
<Filt Name="IsCollection" Arg='obj' Type='Category'/>

<Description>
tests whether an object is a collection.
<P/>
Some of the functions for lists and collections are described in the
chapter about lists,
mainly in Section&nbsp;<Ref Sect="Operations for Lists"/>.
In the current chapter, we describe those functions for which the
<Q>collection aspect</Q> seems to be more important than the
<Q>list aspect</Q>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Collection Families">
<Heading>Collection Families</Heading>

<ManSection>
<Attr Name="CollectionsFamily" Arg='Fam'/>

<Description>
For a family <A>Fam</A>, <Ref Func="CollectionsFamily"/> returns the
family of all collections over <A>Fam</A>,
that is, of all dense lists and domains that consist of objects in
<A>Fam</A>.
<P/>
The <Ref Func="NewFamily"/> call in the standard method of
<Ref Func="CollectionsFamily"/> is executed with second argument
<Ref Func="IsCollection"/>,
since every object in the collections family must be a collection,
and with third argument the collections categories of the involved
categories in the implied filter of <A>Fam</A>.
<P/>
Note that families (see&nbsp;<Ref Sect="Families"/>)
are used to describe relations between objects.
Important such relations are that between an element <M>e</M> and each
collection of elements that lie in the same family as <M>e</M>,
and that between two collections whose elements lie in the same family.
Therefore, all collections of elements in the family <A>Fam</A> form the
new family <C>CollectionsFamily( <A>Fam</A> )</C>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsCollectionFamily" Arg='obj' Type='Category'/>

<Description>
is <K>true</K> if <A>Fam</A> is a family of collections,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="ElementsFamily" Arg='Fam'/>

<Description>
If <A>Fam</A> is a collections family
(see&nbsp;<Ref Func="IsCollectionFamily"/>)
then <Ref Func="ElementsFamily"/>
returns the family from which <A>Fam</A> was created
by <Ref Func="CollectionsFamily"/>.
The way a collections family is created, it always has its elements
family stored.
If <A>Fam</A> is not a collections family then an error is signalled.
<P/>
<Example><![CDATA[
gap> fam:= FamilyObj( (1,2) );;
gap> collfam:= CollectionsFamily( fam );;
gap> fam = collfam;  fam = ElementsFamily( collfam );
false
true
gap> collfam = FamilyObj( [ (1,2,3) ] );
true
gap> collfam = FamilyObj( Group( () ) );
true
gap> collfam = CollectionsFamily( collfam );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CategoryCollections" Arg='filter'/>

<Description>
Let <A>filter</A> be a filter that is <K>true</K> for all elements of a
family <A>Fam</A>, by the construction of <A>Fam</A>.
Then <Ref Func="CategoryCollections"/> returns the
<E>collections category</E> of <A>filter</A>.
This is a category that is <K>true</K> for all elements in
<C>CollectionsFamily( <A>Fam</A> )</C>.
<P/>
For example, the construction of
<Ref Var="PermutationsFamily"/> guarantees that
each of its elements lies in the filter
<Ref Func="IsPerm"/>,
and each collection of permutations (permutation group or dense list of
permutations) lies in the category <C>CategoryCollections( IsPerm )</C>.
<C>CategoryCollections( IsPerm )</C>.
Note that this works only if the collections category is created
<E>before</E> the collections family.
So it is necessary to construct interesting collections categories
immediately after the underlying category has been created.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Lists and Collections">
<Heading>Lists and Collections</Heading>

<Index>Sorted Lists as Collections</Index>
The following functions take a <E>list or collection</E> as argument,
and return a corresponding <E>list</E>.
They differ in whether or not the result is
mutable or immutable (see&nbsp;<Ref Sect="Mutability and Copyability"/>),
guaranteed to be sorted,
or guaranteed to admit list access in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>).

<ManSection>
<Filt Name="IsListOrCollection" Arg='obj' Type='Category'/>

<Description>
Several functions are defined for both lists and collections,
for example <Ref Func="Intersection" Label="for a list"/>,
<Ref Func="Iterator"/>,
and <Ref Func="Random" Label="for a list or collection"/>.
<Ref Func="IsListOrCollection"/> is a supercategory of
<Ref Func="IsList"/> and <Ref Func="IsCollection"/>
(that is, all lists and collections lie in this category),
which is used to describe the arguments of functions such as the ones
listed above.
</Description>
</ManSection>

<ManSection>
<Attr Name="Enumerator" Arg='listorcoll'/>

<Description>
<Ref Func="Enumerator"/> returns an immutable list <M>enum</M>.
If the argument is a list (which may contain holes),
then <C>Length( </C><M>enum</M><C> )</C> is the length of this list,
and <M>enum</M> contains the elements (and holes) of this list in the
same order.
If the argument is a collection that is not a list,
then <C>Length( </C><M>enum</M><C> )</C> is the number of different
elements of <A>C</A>,
and <M>enum</M> contains the different elements of the collection in an
unspecified order, which may change for repeated calls of
<Ref Func="Enumerator"/>.
<M>enum[pos]</M> may not execute in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <M>enum</M> in memory is as small as is feasible.
<P/>
For lists, the default method is <Ref Func="Immutable"/>.
For collections that are not lists, there is no default method.
</Description>
</ManSection>

<ManSection>
<Attr Name="EnumeratorSorted" Arg='listorcoll'/>

<Description>
<Ref Func="EnumeratorSorted"/> returns an immutable list <M>enum</M>.
The argument must be a collection or a list <A>listorcoll</A>
which may contain holes but whose elements lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
<C>Length( </C><M>enum</M><C> )</C> is the number of different elements
of the argument,
and <M>enum</M> contains the different elements in sorted order,
w.r.t.&nbsp;<C>&lt;</C>.
<M>enum[pos]</M> may not execute in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <M>enum</M> in memory is as small as is feasible.
<P/>
<Example><![CDATA[
gap> Enumerator( [ 1, 3,, 2 ] );
[ 1, 3,, 2 ]
gap> enum:= Enumerator( Rationals );;  elm:= enum[ 10^6 ];
-69/907
gap> Position( enum, elm );
1000000
gap> IsMutable( enum );  IsSortedList( enum );
false
false
gap> IsConstantTimeAccessList( enum );
false
gap> EnumeratorSorted( [ 1, 3,, 2 ] );
[ 1, 2, 3 ]
]]></Example>
</Description>
</ManSection>

<Heading>EnumeratorByFunctions</Heading>
<ManSection>
<Func Name="EnumeratorByFunctions" Arg='D, record'
 Label="for a domain and a record"/>
<Func Name="EnumeratorByFunctions" Arg='Fam, record'
 Label="for a family and a record"/>

<Description>
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>
returns an immutable, dense, and duplicate-free list <M>enum</M> for
which <Ref Func="IsBound" Label="for a list index"/>,
element access via <Ref Func="\[\]"/>,
<Ref Func="Length"/>, and <Ref Func="Position"/>
are computed via prescribed functions.
<P/>
Let <A>record</A> be a record with at least the following components.
<List>
<Mark><C>ElementNumber</C></Mark>
<Item>
    a function taking two arguments <A>enum</A> and <A>pos</A>,
    which returns <C><A>enum</A>[ <A>pos</A> ]</C>
    (see&nbsp;<Ref Sect="Basic Operations for Lists"/>);
    it can be assumed that the argument <A>pos</A> is a positive integer,
    but <A>pos</A> may be larger than the length of <A>enum</A>
    (in which case an error must be signalled);
    note that the result must be immutable since <A>enum</A> itself is
    immutable,
</Item>
<Mark><C>NumberElement</C></Mark>
<Item>
    a function taking two arguments <A>enum</A> and <A>elm</A>,
    which returns <C>Position( <A>enum</A>, <A>elm</A> )</C>
    (see&nbsp;<Ref Func="Position"/>);
    it cannot be assumed that <A>elm</A> is really contained in
    <A>enum</A> (and <K>fail</K> must be returned if not);
    note that for the three argument version of <Ref Func="Position"/>,
    the method that is available for duplicate-free lists suffices.
</Item>
</List>
<P/>
Further (data) components may be contained in <A>record</A>
which can be used by these function.
<P/>
If the first argument is a domain <A>D</A> then <A>enum</A> lists the
elements of <A>D</A> (in general <A>enum</A> is <E>not</E> sorted),
and methods for <Ref Attr="Length"/>,
<Ref Func="IsBound" Label="for a list index"/>,
and <Ref Func="PrintObj"/> may use <A>D</A>.
<!-- is this really true for Length?-->
<P/>
If one wants to describe the result without creating a domain then the
elements are given implicitly by the functions in <A>record</A>,
and the first argument must be a family <A>Fam</A> which will become the
family of <A>enum</A>;
if <A>enum</A> is not homogeneous then <A>Fam</A> must be
<C>ListsFamily</C>,
otherwise it must be the collections family of any element in <A>enum</A>.
In this case, additionally the following component in <A>record</A> is
needed.
<P/>
<List>
<Mark><C>Length</C></Mark>
<Item>
    a function taking the argument <A>enum</A>,
    which returns the length of <A>enum</A>
    (see&nbsp;<Ref Func="Length"/>).
</Item>
</List>
<P/>
The following components are optional; they are used if they are present
but default methods are installed for the case that they are missing.
<List>
<Mark><C>IsBound\[\]</C></Mark>
<Item>
    a function taking two arguments <A>enum</A> and <A>k</A>,
    which returns <C>IsBound( <A>enum</A>[ <A>k</A> ] )</C>
    (see&nbsp;<Ref Sect="Basic Operations for Lists"/>);
    if this component is missing then <Ref Func="Length"/> is used for
    computing the result,
</Item>
<Mark><C>Membership</C></Mark>
<Item>
    a function taking two arguments <A>elm</A> and <A>enum</A>,
    which returns <K>true</K> is <A>elm</A> is an element of <A>enum</A>,
    and <K>false</K> otherwise
    (see&nbsp;<Ref Sect="Basic Operations for Lists"/>);
    if this component is missing then <C>NumberElement</C> is used
    for computing the result,
</Item>
<Mark><C>AsList</C></Mark>
<Item>
    a function taking one argument <A>enum</A>, which returns a list with
    the property that the access to each of its elements will take
    roughly the same time
    (see&nbsp;<Ref Func="IsConstantTimeAccessList"/>);
    if this component is missing then
    <Ref Func="ConstantTimeAccessList"/> is used for computing the result,
</Item>
<Mark><C>ViewObj</C> and <C>PrintObj</C></Mark>
<Item>
    two functions that print what one wants to be printed when
    <C>View( <A>enum</A> )</C> or <C>Print( <A>enum</A> )</C> is called
    (see&nbsp;<Ref Sect="View and Print"/>),
    if the <C>ViewObj</C> component is missing then the <C>PrintObj</C>
    method is used as a default.
</Item>
</List>
<P/>
If the result is known to have additional properties such as being
strictly sorted (see&nbsp;<Ref Func="IsSSortedList"/>) then it can be
useful to set these properties after the construction of the enumerator,
before it is used for the first time.
And in the case that a new sorted enumerator of a domain is implemented
via <Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>,
and this construction is
installed as a method for the operation <Ref Func="Enumerator"/>,
then it should be installed also as a method for
<Ref Func="EnumeratorSorted"/>.
<P/>
Note that it is <E>not</E> checked that
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>
really returns a dense and duplicate-free list.
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>
does <E>not</E> make a shallow copy of <A>record</A>,
this record is changed in place,
see&nbsp;<Ref Sect="Creating Objects"/>.
<P/>
It would be easy to implement a slightly generalized setup for
enumerators that need not be duplicate-free (where the three argument
version of <Ref Func="Position"/> is supported),
but the resulting overhead for the methods seems not to be justified.
</Description>
</ManSection>

<ManSection>
<Func Name="List" Arg='C' Label="for a collection"/>

<Description>
For a collection <A>C</A> (see&nbsp;<Ref Chap="Collections"/>)
that is not a list, <Ref Func="List" Label="for a collection"/> returns
a new mutable list <A>new</A> such that <C>Length( <A>new</A> )</C>
is the number of different elements of <A>C</A>,
and <A>new</A> contains the different elements of <A>C</A> in an
unspecified order which may change for repeated calls.
<C><A>new</A>[<A>pos</A>]</C> executes in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <A>new</A> is proportional to its length.
The generic method for this case is
<C>ShallowCopy( Enumerator( <A>C</A> ) )</C>.
<!-- this is not reasonable since <C>ShallowCopy</C> need not guarantee to return-->
<!-- a constant time access list-->
<P/>
<Example><![CDATA[
gap> l:= List( Group( (1,2,3) ) );
[ (), (1,3,2), (1,2,3) ]
gap> IsMutable( l );  IsSortedList( l );  IsConstantTimeAccessList( l );
true
false
true
]]></Example>
<P/>
(See also <Ref Func="List" Label="for a list (and a function)"/>.)
</Description>
</ManSection>

<ManSection>
<Oper Name="SortedList" Arg='listorcoll'/>

<Description>
<Ref Func="SortedList"/> returns a new mutable and dense list <A>new</A>.
The argument must be a collection or list <A>listorcoll</A> which may
contain holes but whose elements lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
<C>Length( <A>new</A> )</C> is the number of elements of
<A>listorcoll</A>,
and <A>new</A> contains the elements in sorted order,
w.r.t.&nbsp;<C>&lt;=</C>.
<C><A>new</A>[<A>pos</A>]</C> executes in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <A>new</A> in memory is proportional to its length.
<P/>
<Example><![CDATA[
gap> l:= SortedList( Group( (1,2,3) ) );
[ (), (1,2,3), (1,3,2) ]
gap> IsMutable( l );  IsSortedList( l );  IsConstantTimeAccessList( l );
true
true
true
gap> SortedList( [ 1, 2, 1,, 3, 2 ] );
[ 1, 1, 2, 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SSortedList" Arg='listorcoll'/>
<Oper Name="Set" Arg='C'/>

<Description>
<Ref Func="SSortedList"/> (<Q>strictly sorted list</Q>) returns a new
dense, mutable, and duplicate free list <A>new</A>.
The argument must be a collection or list <A>listorcoll</A>
which may contain holes but whose elements lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
<C>Length( <A>new</A> )</C> is the number of different elements of
<A>listorcoll</A>,
and <A>new</A> contains the different elements in strictly sorted order,
w.r.t.&nbsp;<Ref Func="\&lt;"/>.
<C><A>new</A>[<A>pos</A>]</C> executes in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <A>new</A> in memory is proportional to its length.
<P/>
<Ref Func="Set"/> is simply a synonym for <Ref Func="SSortedList"/>.
<!-- <P/> -->
<!--  For collections that are not lists, the default method is-->
<!--  <C>ShallowCopy( EnumeratorSorted( <A>C</A> ) )</C>.-->
<P/>
<Example><![CDATA[
gap> l:= SSortedList( Group( (1,2,3) ) );
[ (), (1,2,3), (1,3,2) ]
gap> IsMutable( l );  IsSSortedList( l );  IsConstantTimeAccessList( l );
true
true
true
gap> SSortedList( [ 1, 2, 1,, 3, 2 ] );
[ 1, 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AsList" Arg='listorcoll'/>

<Description>
<Ref Func="AsList"/> returns a immutable list <A>imm</A>.
If the argument is a list (which may contain holes),
then <C>Length( <A>imm</A> )</C> is the <Ref Func="Length"/> value of
this list,
and <A>imm</A> contains the elements (and holes) of of the list
in the same order.
If the argument is a collection that is not a list,
then <C>Length( <A>imm</A> )</C> is the number of different elements
of this collection, and <A>imm</A> contains the different elements of
the collection in an unspecified order,
which may change for repeated calls of <Ref Func="AsList"/>.
<C><A>imm</A>[<A>pos</A>]</C> executes in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <A>imm</A> in memory is proportional to its length.
<P/>
If you expect to do many element tests in the resulting list, it might
be worth to use a sorted list instead, using <Ref Func="AsSSortedList"/>.
<!-- <P/> -->
<!--  For both lists and collections, the default method is-->
<!--  <C>ConstantTimeAccessList( Enumerator( <A>C</A> ) )</C>.-->
<P/>
<Example><![CDATA[
gap> l:= AsList( [ 1, 3, 3,, 2 ] );
[ 1, 3, 3,, 2 ]
gap> IsMutable( l );  IsSortedList( l );  IsConstantTimeAccessList( l );
false
false
true
gap> AsList( Group( (1,2,3), (1,2) ) );
[ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AsSortedList" Arg='listorcoll'/>

<Description>
<Ref Func="AsSortedList"/> returns a dense and immutable list <A>imm</A>.
The argument must be a collection or list <A>listorcoll</A>
which may contain holes but whose elements lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
<C>Length( <A>imm</A> )</C> is the number of elements of the argument,
and <A>imm</A> contains the elements in sorted order,
w.r.t.&nbsp;<C>&lt;=</C>.
<C><A>new</A>[<A>pos</A>]</C> executes in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <A>imm</A> in memory is proportional to its length.
<P/>
The only difference to the operation <Ref Func="SortedList"/>
is that <Ref Func="AsSortedList"/> returns an <E>immutable</E> list.
<P/>
<Example><![CDATA[
gap> l:= AsSortedList( [ 1, 3, 3,, 2 ] );
[ 1, 2, 3, 3 ]
gap> IsMutable( l );  IsSortedList( l );  IsConstantTimeAccessList( l );
false
true
true
gap> IsSSortedList( l );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AsSSortedList" Arg='listorcoll'/>
<Attr Name="AsSet" Arg='listorcoll'/>

<Description>
<Index Subkey="of a list or collection">elements</Index>
<Ref Func="AsSSortedList"/> (<Q>as strictly sorted list</Q>) returns
a dense, immutable, and duplicate free list <A>imm</A>.
The argument must be a collection or list <A>listorcoll</A>
which may contain holes but whose elements lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
<C>Length( <A>imm</A> )</C> is the number of different elements
of <A>listorcoll</A>,
and <A>imm</A> contains the different elements in strictly sorted order,
w.r.t.&nbsp;<Ref Func="\&lt;"/>.
<C><A>imm</A>[<A>pos</A>]</C> executes in constant time
(see&nbsp;<Ref Func="IsConstantTimeAccessList"/>),
and the size of <A>imm</A> in memory is proportional to its length.
<P/>
Because the comparisons required for sorting can be very expensive for
some kinds of objects, you should use <Ref Func="AsList"/> instead
if you do not require the result to be sorted.
<P/>
The only difference to the operation <Ref Func="SSortedList"/>
is that <Ref Attr="AsSSortedList"/> returns an <E>immutable</E> list.
<P/>
<Ref Attr="AsSet"/> is simply a synonym for <Ref Attr="AsSSortedList"/>.
<P/>
In general a function that returns a set of elements is free, in fact
encouraged, to return a domain instead of the proper set of its elements.
This allows one to keep a given structure, and moreover the
representation by a domain object is usually more space efficient.
<Ref Attr="AsSSortedList"/> must of course <E>not</E> do this,
its only purpose is to create the proper set of elements.
<!-- <P/> -->
<!--  For both lists and collections, the default method is-->
<!--  <C>ConstantTimeAccessList( EnumeratorSorted( <A>C</A> ) )</C>.-->
<P/>
<Example><![CDATA[
gap> l:= AsSSortedList( l );
[ 1, 2, 3 ]
gap> IsMutable( l );  IsSSortedList( l );  IsConstantTimeAccessList( l );
false
true
true
gap> AsSSortedList( Group( (1,2,3), (1,2) ) );
[ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Elements" Arg='C'/>

<Description>
<Ref Func="Elements"/> does the same as <Ref Func="AsSSortedList"/>,
that is, the return value is a strictly sorted list of the elements in
the list or collection <A>C</A>.
<P/>
<Ref Func="Elements"/> is only supported for backwards compatibility.
In many situations, the sortedness of the <Q>element list</Q> for a
collection is in fact not needed, and one can save a lot of time by
asking for a list that is <E>not</E> necessarily sorted,
using <Ref Func="AsList"/>.
If one is really interested in the strictly sorted list of elements in
<A>C</A> then one should use <Ref Func="AsSet"/> or
<Ref Func="AsSSortedList"/> instead.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties for Collections">
<Heading>Attributes and Properties for Collections</Heading>

<ManSection>
<Prop Name="IsEmpty" Arg='listorcoll'/>

<Description>
<Ref Func="IsEmpty"/> returns <K>true</K> if the collection or list
<A>listorcoll</A> is <E>empty</E> (that is it contains no elements),
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFinite" Arg='C'/>

<Description>
<Index Subkey="for a list or collection">finiteness test</Index>
<Ref Func="IsFinite"/> returns <K>true</K> if the collection <A>C</A>
is finite, and <K>false</K> otherwise.
<P/>
The default method for <Ref Func="IsFinite"/> checks the size
(see&nbsp;<Ref Func="Size"/>) of <A>C</A>.
<P/>
Methods for <Ref Func="IsFinite"/> may call <Ref Func="Size"/>,
but methods for <Ref Func="Size"/> must <E>not</E> call
<Ref Func="IsFinite"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsTrivial" Arg='C'/>

<Description>
<Ref Prop="IsTrivial"/> returns <K>true</K> if the collection <A>C</A>
consists of exactly one element.
<!--  1996/08/08 M.Schönert is this a sensible definition?-->
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNonTrivial" Arg='C'/>

<Description>
<Ref Func="IsNonTrivial"/> returns <K>true</K> if the collection <A>C</A>
is empty or consists of at least two elements
(see&nbsp;<Ref Func="IsTrivial"/>).
<P/>
<!-- I need this to distinguish trivial rings-with-one from fields!-->
<!-- (indication to introduce antifilters?)-->
<!--  1996/08/08 M.Schönert is this a sensible definition?-->
<Example><![CDATA[
gap> IsEmpty( [] ); IsEmpty( [ 1 .. 100 ] ); IsEmpty( Group( (1,2,3) ) );
true
false
false
gap> IsFinite( [ 1 .. 100 ] );  IsFinite( Integers );
true
false
gap> IsTrivial( Integers );  IsTrivial( Group( () ) );
false
true
gap> IsNonTrivial( Integers );  IsNonTrivial( Group( () ) );
true
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsWholeFamily" Arg='C'/>

<Description>
<Ref Prop="IsWholeFamily"/> returns <K>true</K> if the collection
<A>C</A> contains the whole family (see&nbsp;<Ref Sect="Families"/>)
of its elements.
<P/>
<Example><![CDATA[
gap> IsWholeFamily( Integers )
>    ;  # all rationals and cyclotomics lie in the family
false
gap> IsWholeFamily( Integers mod 3 )
>    ;  # all finite field elements in char. 3 lie in this family
false
gap> IsWholeFamily( Integers mod 4 );
true
gap> IsWholeFamily( FreeGroup( 2 ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Size" Arg='listorcoll'/>

<Description>
<Index Subkey="of a list or collection">size</Index>
<Index Subkey="of a list, collection or domain">order</Index>
<Ref Attr="Size"/> returns the size of the list or collection
<A>listorcoll</A>, which is either an integer or <Ref Var="infinity"/>.
If the argument is a list then the result is its length
(see&nbsp;<Ref Func="Length"/>).
<P/>
The default method for <Ref Attr="Size"/> checks the length of an
enumerator of <A>listorcoll</A>.
<P/>
Methods for <Ref Prop="IsFinite"/> may call <Ref Attr="Size"/>,
but methods for <Ref Attr="Size"/> must not call <Ref Prop="IsFinite"/>.
<P/>
<Example><![CDATA[
gap> Size( [1,2,3] );  Size( Group( () ) );  Size( Integers );
3
1
infinity
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Representative" Arg='C'/>

<Description>
<Ref Attr="Representative"/> returns a <E>representative</E>
of the collection <A>C</A>.
<P/>
Note that <Ref Attr="Representative"/> is free in choosing
a representative if there are several elements in <A>C</A>.
It is not even guaranteed that <Ref Attr="Representative"/> returns
the same representative if it is called several times for one collection.
The main difference between <Ref Attr="Representative"/> and
<Ref Func="Random" Label="for a list or collection"/>
is that <Ref Attr="Representative"/> is free
to choose a value that is cheap to compute,
while <Ref Func="Random" Label="for a list or collection"/>
must make an effort to randomly distribute its answers.
<P/>
If <A>C</A> is a domain then there are methods for
<Ref Attr="Representative"/> that try
to fetch an element from any known generator list of <A>C</A>,
see&nbsp;<Ref Chap="Domains and their Elements"/>.
Note that <Ref Attr="Representative"/> does not try to <E>compute</E>
generators of <A>C</A>,
thus <Ref Attr="Representative"/> may give up and signal an error
if <A>C</A> has no generators stored at all.
</Description>
</ManSection>

<ManSection>
<Attr Name="RepresentativeSmallest" Arg='C'/>

<Description>
<Index Subkey="of a list or collection">representative</Index>
returns the smallest element in the collection <A>C</A>, w.r.t.&nbsp;the
ordering <Ref Func="\&lt;"/>.
While the operation defaults to comparing all elements,
better methods are installed for some collections.
<P/>
<Example><![CDATA[
gap> Representative( Rationals );
0
gap> Representative( [ -1, -2 .. -100 ] );
-1
gap> RepresentativeSmallest( [ -1, -2 .. -100 ] );
-100
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Collections">
<Heading>Operations for Collections</Heading>

<ManSection>
<Oper Name="IsSubset" Arg='C1, C2'/>

<Description>
<Index Subkey="for collections">subset test</Index>
<Ref Oper="IsSubset"/> returns <K>true</K> if <A>C2</A>,
which must be a collection, is a <E>subset</E> of <A>C1</A>,
which also must be a collection, and <K>false</K> otherwise.
<P/>
<A>C2</A> is considered a subset of <A>C1</A> if and only if each element
of <A>C2</A> is also an element of <A>C1</A>.
That is <Ref Oper="IsSubset"/> behaves as if implemented as
<C>IsSubsetSet( AsSSortedList( <A>C1</A> ), AsSSortedList( <A>C2</A> ) )</C>,
except that it will also sometimes, but not always,
work for infinite collections,
and that it will usually work much faster than the above definition.
Either argument may also be a proper set
(see&nbsp;<Ref Sect="Sorted Lists and Sets"/>).
<P/>
<Example><![CDATA[
gap> IsSubset( Rationals, Integers );
true
gap> IsSubset( Integers, [ 1, 2, 3 ] );
true
gap> IsSubset( Group( (1,2,3,4) ), [ (1,2,3) ] );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Intersection</Heading>
<Func Name="Intersection" Arg='C1, C2 ...'
 Label="for various collections"/>
<Func Name="Intersection" Arg='list' Label="for a list"/>
<Oper Name="Intersection2" Arg='C1, C2'/>

<Description>
<Index Subkey="of collections">intersection</Index>
In the first form
<Ref Func="Intersection" Label="for various collections"/> returns the
intersection of the collections <A>C1</A>, <A>C2</A>, etc.
In the second form <A>list</A> must be a <E>nonempty</E> list of
collections and <Ref Func="Intersection" Label="for a list"/> returns
the intersection of those collections.
Each argument or element of <A>list</A> respectively may also be a
homogeneous list that is not a proper set,
in which case <Ref Func="Intersection" Label="for a list"/> silently
applies <Ref Func="Set"/> to it first.
<P/>
The result of <Ref Func="Intersection" Label="for a list"/> is the set
of elements that lie in every of the collections <A>C1</A>, <A>C2</A>,
etc.
If the result is a list then it is mutable and new, i.e., not identical
to any of <A>C1</A>, <A>C2</A>, etc.
<P/>
Methods can be installed for the operation <Ref Func="Intersection2"/>
that takes only two arguments.
<Ref Func="Intersection" Label="for a list"/> calls
<Ref Func="Intersection2"/>.
<P/>
Methods for <Ref Func="Intersection2"/> should try to maintain as much
structure as possible, for example the intersection of two permutation
groups is again a permutation group.
<P/>
<Example><![CDATA[
gap> # this is one of the rare cases where the intersection of two
gap> # infinite domains works ('CF' is a shorthand for 'CyclotomicField'):
gap> Intersection( CyclotomicField(9), CyclotomicField(12) );
CF(3)
gap> D12 := Group( (2,6)(3,5), (1,2)(3,6)(4,5) );;
gap> Intersection( D12, Group( (1,2), (1,2,3,4,5) ) );
Group([ (1,5)(2,4) ])
gap> Intersection( D12, [ (1,3)(4,6), (1,2)(3,4) ] )
>    ;  # note that the second argument is not a proper set
[ (1,3)(4,6) ]
gap> # although the result is mathematically a group it is returned as a
gap> # proper set because the second argument is not regarded as a group:
gap> Intersection( D12, [ (), (1,2)(3,4), (1,3)(4,6), (1,4)(5,6) ] );
[ (), (1,3)(4,6) ]
gap> Intersection( Group( () ), [1,2,3] );
[  ]
gap> Intersection( [2,4,6,8,10], [3,6,9,12,15], [5,10,15,20,25] )
>    ;  # two or more lists or collections as arguments are legal
[  ]
gap> Intersection( [ [1,2,4], [2,3,4], [1,3,4] ] )
>    ;  # or one list of lists or collections
[ 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Union</Heading>
<Func Name="Union" Arg='C1, C2 ...' Label="for various collections"/>
<Func Name="Union" Arg='list' Label="for a list"/>
<Oper Name="Union2" Arg='C1, C2'/>

<Description>
<Index Subkey="of collections">union</Index>
In the first form <Ref Func="Union" Label="for various collections"/>
returns the union of the collections <A>C1</A>, <A>C2</A>, etc.
In the second form <A>list</A> must be a list of collections
and <Ref Func="Union" Label="for a list"/> returns the union of those
collections.
Each argument or element of <A>list</A> respectively may also be a
homogeneous list that is not a proper set,
in which case <Ref Func="Union" Label="for a list"/> silently applies
<Ref Func="Set"/> to it first.
<P/>
The result of <Ref Func="Union" Label="for a list"/> is the set of
elements that lie in any of the collections <A>C1</A>, <A>C2</A>, etc.
If the result is a list then it is mutable and new, i.e., not identical
to any of <A>C1</A>, <A>C2</A>, etc.
<P/>
Methods can be installed for the operation <Ref Oper="Union2"/>
that takes only two arguments.
<Ref Func="Union" Label="for a list"/> calls <Ref Func="Union2"/>.
<P/>
<Example><![CDATA[
gap> Union( [ (1,2,3), (1,2,3,4) ], Group( (1,2,3), (1,2) ) );
[ (), (2,3), (1,2), (1,2,3), (1,2,3,4), (1,3,2), (1,3) ]
gap> Union( [2,4,6,8,10], [3,6,9,12,15], [5,10,15,20,25] )
>    ;  # two or more lists or collections as arguments are legal
[ 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 20, 25 ]
gap> Union( [ [1,2,4], [2,3,4], [1,3,4] ] )
>    ;  # or one list of lists or collections
[ 1, 2, 3, 4 ]
gap> Union( [ ] );
[  ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Difference" Arg='C1, C2'/>

<Description>
<Index Subkey="of collections">set difference</Index>
<Ref Func="Difference"/> returns the set difference of the collections
<A>C1</A> and <A>C2</A>.
Either argument may also be a homogeneous list that is not a proper set,
in which case <Ref Func="Difference"/> silently applies <Ref Func="Set"/>
to it first.
<P/>
The result of <Ref Func="Difference"/> is the set of elements that lie in
<A>C1</A> but not in <A>C2</A>.
Note that <A>C2</A> need not be a subset of <A>C1</A>.
The elements of <A>C2</A>, however, that are not elements of <A>C1</A>
play no role for the result.
If the result is a list then it is mutable and new, i.e., not identical
to <A>C1</A> or <A>C2</A>.
<P/>
<Example><![CDATA[
gap> Difference( [ (1,2,3), (1,2,3,4) ], Group( (1,2,3), (1,2) ) );
[ (1,2,3,4) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Membership Test for Collections">
<Heading>Membership Test for Collections</Heading>

<Index Key="in" Subkey="operation for testing membership">
<C>\in</C></Index>
<Index Key="in" Subkey="operation for"><K>in</K></Index>

<ManSection>
<Oper Name="\in" Arg='obj, C' Label="for a collection"/>

<Description>
returns <K>true</K> if the object <A>obj</A> lies in the collection <A>C</A>,
and <K>false</K> otherwise.
<P/>
The infix version of the command
<P/>
<A>obj</A> <K>in</K> <A>C</A>
<P/>
calls the operation <Ref Oper="\in" Label="for a collection"/>,
for which methods can be installed.
<P/>
<Example><![CDATA[
gap> 13 in Integers;  [ 1, 2 ] in Integers;
true
false
gap> g:= Group( (1,2) );;  (1,2) in g;  (1,2,3) in g;
true
false
]]></Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Random Elements">
<Heading>Random Elements</Heading>

The method used by &GAP; to obtain random elements may depend on the
type object.
<P/>
Most methods which produce random elements in &GAP; use a global random
number generator (see <Ref Var="GlobalMersenneTwister"/>).  
This random number generator is (deliberately) initialized to the same
values when &GAP; is started, so different runs of &GAP; with the same
input will always produce the same result, even if random calculations
are involved.
<P/>
See <Ref Oper="Reset"/> for a description of how to reset the
random number generator to a previous state.
<P/>

<!-- all outdated? (FL)
Many random methods in the library are eventually based on the function
<Ref Func="RandomList"/>.
As <Ref Func="RandomList"/> is restricted to lists of  <M>2^{28}</M>
elements, this may create problems for very large collections. Also note
that the method used by <Ref Func="RandomList"/> is intended to provide
a fast algorithm rather than to produce high quality randomness for
statistical purposes.
<P/>
If you implement your own
<Ref Func="Random" Label="for a list or collection"/> methods we recommend
that they initialize their seed to a defined value when they are loaded
to permit to reproduce calculations even if they involved random
elements.
-->

<ManSection>
<Oper Name="Random" Arg='listorcoll' Label="for a list or collection"/>
<Oper Name="Random" Arg='from, to' Label="for lower and upper bound"/>

<Description>
<!-- to get this on top of results for ?Random -->
<Index Key="Random"><Ref Func="Random" 
                         Label="for a list or collection"/></Index> 
<Ref Oper="Random" Label="for a list or collection"/> returns a
(pseudo-)random element of the list or collection <A>listorcoll</A>.
<P/>
As lists or ranges are restricted in length (<M>2^{28}-1</M> or 
<M>2^{60}-1</M> depending on your system), the second form returns a
random integer in the range <A>from</A> to <A>to</A> (inclusive) for
arbitrary integers <A>from</A> and <A>to</A>.
<P/>
The distribution of elements returned by
<Ref Oper="Random" Label="for a list or collection"/> depends
on the argument.
For a list the distribution is uniform (all elements are equally likely).
The same holds usually for finite collections that are
not lists.
For infinite collections some reasonable distribution is used.
<P/>
See the chapters of the various collections to find out
which distribution is being used.
<P/>
For some collections ensuring a reasonable distribution can be
difficult and require substantial runtime (for example for large
finite groups). If speed is more important than a guaranteed
distribution, 
the operation <Ref Func="PseudoRandom"/> should be used instead.
<P/>
Note that <Ref Oper="Random" Label="for a list or collection"/>
is of course <E>not</E> an attribute.
<P/>
<Example><![CDATA[
gap> Random([1..6]);
1
gap> Random(1, 2^100);
866227015645295902682304086250
gap> g:= Group( (1,2,3) );;  Random( g );  Random( g );
(1,3,2)
(1,2,3)
gap> Random(Rationals);
-2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PseudoRandom" Arg='listorcoll'/>

<Description>
<Ref Oper="PseudoRandom"/> returns a pseudo random element
of the list or collection <A>listorcoll</A>,
which can be roughly described as follows.
For a list, <Ref Oper="PseudoRandom"/> returns the same as
<Ref Oper="Random" Label="for a list or collection"/>.
For collections that are not lists,
the elements returned by <Ref Oper="PseudoRandom"/> are
<E>not</E> necessarily equally distributed,
even for finite collections;
the idea is that <Ref Oper="Random" Label="for a list or collection"/>
returns elements according to
a reasonable distribution, <Ref Oper="PseudoRandom"/> returns elements
that are cheap to compute but need not satisfy this strong condition, and
<Ref Attr="Representative"/> returns arbitrary elements,
probably the same element for each call.
</Description>
</ManSection>

<ManSection>
<Func Name="RandomList" Arg='list'/>

<Description>
<Index>random seed</Index>
For a dense list <A>list</A>,
<Ref Func="RandomList"/> returns a (pseudo-)random element with equal
distribution.
<P/>
This function uses the <Ref Var="GlobalMersenneTwister"/> to produce the
random elements (a source of high quality random numbers).
<P/>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Iterators">
<Heading>Iterators</Heading>

<ManSection>
<Oper Name="Iterator" Arg='listorcoll'/>
<Filt Name="IsStandardIterator" Arg='listorcoll'/>

<Description>
Iterators provide a possibility to loop over the elements of a
(countable) collection or list <A>listorcoll</A>, without repetition.
For many collections <M>C</M>,
an iterator of <M>C</M> need not store all elements of <M>C</M>,
for example it is possible to construct an iterator of some infinite
domains, such as the field of rational numbers.
<P/>
<Ref Func="Iterator"/> returns a mutable <E>iterator</E> <M>iter</M> for
its argument.
If this argument is a list (which may contain holes),
then <M>iter</M> iterates over the elements (but not the holes) of this
list in the same order (see&nbsp;<Ref Func="IteratorList"/> for details).
If this argument is a collection but not a list then <M>iter</M> iterates
over the elements of this collection in an unspecified order,
which may change for repeated calls of <Ref Func="Iterator"/>.
Because iterators returned by <Ref Func="Iterator"/> are mutable
(see&nbsp;<Ref Sect="Mutability and Copyability"/>),
each call of <Ref Func="Iterator"/> for the same argument returns a
<E>new</E> iterator.
Therefore <Ref Func="Iterator"/> is not an attribute
(see&nbsp;<Ref Sect="Attributes"/>).
<P/>
The only operations for iterators are <Ref Func="IsDoneIterator"/>,
<Ref Func="NextIterator"/>, and <Ref Func="ShallowCopy"/>.
In particular, it is only possible to access the next element of the
iterator with <Ref Func="NextIterator"/> if there is one,
and this can be checked with <Ref Func="IsDoneIterator"/>
For an iterator <M>iter</M>, <Ref Func="ShallowCopy"/> returns a
mutable iterator <M>new</M> that iterates over the remaining elements
independent of <M>iter</M>;
the results of <Ref Func="IsDoneIterator"/> for <M>iter</M> and
<M>new</M> are equal,
and if <M>iter</M> is mutable then also the results of
<Ref Func="NextIterator"/> for <M>iter</M> and <M>new</M> are equal;
note that <C>=</C> is not defined for iterators,
so the equality of two iterators cannot be checked with <C>=</C>.
<P/>
When <Ref Func="Iterator"/> is called for a <E>mutable</E> collection
<M>C</M> then it is not defined whether <M>iter</M> respects changes to
<M>C</M> occurring after the construction of <M>iter</M>,
except if the documentation explicitly promises a certain behaviour.
The latter is the case if the argument is a mutable list
(see&nbsp;<Ref Func="IteratorList"/> for subtleties in this case).
<P/>
It is possible to have <K>for</K>-loops run over mutable iterators
instead of lists.
<P/>
In some situations, one can construct iterators with a special
succession of elements,
see&nbsp;<Ref Func="IteratorByBasis"/> for the possibility to loop over
the elements of a vector space w.r.t.&nbsp;a given basis.
<!-- (also for perm. groups, w.r.t. a given stabilizer chain?)-->
<P/>
For lists, <Ref Func="Iterator"/> is implemented by
<Ref Func="IteratorList"/>.
For collections <M>C</M> that are not lists, the default method is
<C>IteratorList( Enumerator( </C><M>C</M><C> ) )</C>.
Better methods depending on <M>C</M> should be provided if possible.
<P/>
For random access to the elements of a (possibly infinite) collection,
<E>enumerators</E> are used.
See&nbsp;<Ref Sect="Enumerators"/> for the facility to compute a list
from <M>C</M>, which provides a (partial) mapping from <M>C</M> to the
positive integers.
<P/>
The filter <Ref Filt="IsStandardIterator"/> means that the iterator is
implemented as a component object and has components <C>IsDoneIterator</C>
and <C>NextIterator</C> which are bound to the methods of the operations of
the same name for this iterator. 
<!-- (This is used to avoid overhead when looping over such iterators.) -->
<!--  We wanted to admit an iterator as first argument of <C>Filtered</C>,-->
<!--  <C>First</C>, <C>ForAll</C>, <C>ForAny</C>, <C>Number</C>.-->
<!--  This is not yet implemented.-->
<!--  (Note that the iterator is changed in the call,-->
<!--  so the meaning of the operations would be slightly abused,-->
<!--  or we must define that these operations first make a shallow copy.)-->
<!--  (Additionally, the unspecified order of the elements makes it-->
<!--  difficult to define what <C>First</C> and <C>Filtered</C> means for an iterator.)-->
<Example><![CDATA[
gap> iter:= Iterator( GF(5) );
<iterator>
gap> l:= [];;
gap> for i in iter do Add( l, i ); od; l;
[ 0*Z(5), Z(5)^0, Z(5), Z(5)^2, Z(5)^3 ]
gap> iter:= Iterator( [ 1, 2, 3, 4 ] );;  l:= [];;
gap> for i in iter do
>      new:= ShallowCopy( iter );
>      for j in new do Add( l, j ); od;
>    od; l;
[ 2, 3, 4, 3, 4, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IteratorSorted" Arg='listorcoll'/>

<Description>
<Ref Func="IteratorSorted"/> returns a mutable iterator.
The argument must be a collection or a list that is not
necessarily dense but whose elements lie in the same family
(see&nbsp;<Ref Sect="Families"/>).
It loops over the different elements in sorted order.
<P/>
For a collection <M>C</M> that is not a list, the generic method is
<C>IteratorList( EnumeratorSorted( </C><A>C</A><C> ) )</C>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsIterator" Arg='obj' Type='Category'/>

<Description>
Every iterator lies in the category <C>IsIterator</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsDoneIterator" Arg='iter'/>

<Description>
If <A>iter</A> is an iterator for the list or collection <M>C</M> then
<C>IsDoneIterator( <A>iter</A> )</C> is <K>true</K> if all elements of
<M>C</M> have been returned already by <C>NextIterator( <A>iter</A> )</C>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="NextIterator" Arg='iter'/>

<Description>
Let <A>iter</A> be a mutable iterator for the list or collection <M>C</M>.
If <C>IsDoneIterator( <A>iter</A> )</C> is <K>false</K> then
<Ref Func="NextIterator"/> is applicable to <A>iter</A>,
and the result is the next element of <M>C</M>,
according to the succession defined by <A>iter</A>.
<P/>
If <C>IsDoneIterator( <A>iter</A> )</C> is <K>true</K> then it is not
defined what happens when <Ref Func="NextIterator"/> is called for
<A>iter</A>;
that is, it may happen that an error is signalled or that something
meaningless is returned, or even that &GAP; crashes.
<P/>
<Example><![CDATA[
gap> iter:= Iterator( [ 1, 2, 3, 4 ] );
<iterator>
gap> sum:= 0;;
gap> while not IsDoneIterator( iter ) do
>      sum:= sum + NextIterator( iter );
>    od;
gap> IsDoneIterator( iter ); sum;
true
10
gap> ir:= Iterator( Rationals );;
gap> l:= [];; for i in [1..20] do Add( l, NextIterator( ir ) ); od; l;
[ 0, 1, -1, 1/2, 2, -1/2, -2, 1/3, 2/3, 3/2, 3, -1/3, -2/3, -3/2, -3, 
  1/4, 3/4, 4/3, 4, -1/4 ]
gap> for i in ir do
>      if DenominatorRat( i ) > 10 then break; fi;
>    od;
gap> i;
1/11
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IteratorList" Arg='list'/>

<Description>
<Ref Func="IteratorList"/> returns a new iterator that allows iteration
over the elements of the list <A>list</A> (which may have holes)
in the same order.
<P/>
If <A>list</A> is mutable then it is in principle possible to change
<A>list</A> after the call of <Ref Func="IteratorList"/>.
In this case all changes concerning positions that have not yet been
reached in the iteration will also affect the iterator.
For example, if <A>list</A> is enlarged then the iterator will iterate
also over the new elements at the end of the changed list.
<P/>
<E>Note</E> that changes of <A>list</A> will also affect all
shallow copies of <A>list</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="TrivialIterator" Arg='elm'/>

<Description>
is a mutable iterator for the collection <C>[ <A>elm</A> ]</C> that
consists of exactly one element <A>elm</A>
(see&nbsp;<Ref Func="IsTrivial"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="IteratorByFunctions" Arg='record'/>

<Description>
<Ref Func="IteratorByFunctions"/> returns a (mutable) iterator
<A>iter</A> for which <Ref Func="NextIterator"/>,
<Ref Func="IsDoneIterator"/>,
and <Ref Func="ShallowCopy"/>
are computed via prescribed functions.
<P/>
Let <A>record</A> be a record with at least the following components.
<List>
<Mark><C>NextIterator</C></Mark>
<Item>
    a function taking one argument <A>iter</A>,
    which returns the next element of <A>iter</A>
    (see&nbsp;<Ref Func="NextIterator"/>);
    for that, the components of <A>iter</A> are changed,
</Item>
<Mark><C>IsDoneIterator</C></Mark>
<Item>
    a function taking one argument <A>iter</A>,
    which returns the <Ref Func="IsDoneIterator"/> value of <A>iter</A>,
</Item>
<Mark><C>ShallowCopy</C></Mark>
<Item>
    a function taking one argument <A>iter</A>,
    which returns a record for which <Ref Func="IteratorByFunctions"/>
    can be called in order to create a new iterator that is independent
    of <A>iter</A> but behaves like <A>iter</A> w.r.t. the operations
    <Ref Func="NextIterator"/> and <Ref Func="IsDoneIterator"/>.
</Item>
<Mark><C>ViewObj</C> and <C>PrintObj</C></Mark>
<Item>
    two functions that print what one wants to be printed when
    <C>View( <A>iter</A> )</C> or <C>Print( <A>item</A> )</C> is called
    (see&nbsp;<Ref Sect="View and Print"/>),
    if the <C>ViewObj</C> component is missing then the <C>PrintObj</C>
    method is used as a default.
</Item>
</List>
Further (data) components may be contained in <A>record</A> which can be
used by these function.
<P/>
<Ref Func="IteratorByFunctions"/> does <E>not</E> make a shallow copy of
<A>record</A>, this record is changed in place
(see Section &nbsp;<Ref Sect="Creating Objects"/>).
<P/>
Iterators constructed with <Ref Func="IteratorByFunctions"/> are in the
filter <Ref Filt="IsStandardIterator"/>.
</Description>
</ManSection>


</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  domain.msk                   GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: domain.msk,v 1.29 2002/04/15 10:02:28 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Domains and their Elements">
<Heading>Domains and their Elements</Heading>

<E>Domain</E> is &GAP;'s name for structured sets.
The ring of Gaussian integers <M>&ZZ;[\sqrt{{-1}}]</M> is an example of a
domain,
the group <M>D_{12}</M> of symmetries of a regular hexahedron is another.
<P/>
The &GAP; library predefines some domains.
For example the ring of Gaussian integers is predefined as
<Ref Var="GaussianIntegers"/> (see&nbsp;<Ref Chap="Gaussians"/>)
and the field of rationals is predefined as <Ref Var="Rationals"/>
(see&nbsp;<Ref Chap="Rational Numbers"/>).
Most domains are constructed by functions,
which are called <E>domain constructors</E>
(see&nbsp;<Ref Sect="Constructing Domains"/>).
For example the group <M>D_{12}</M> is constructed by the construction
<C>Group( (1,2,3,4,5,6), (2,6)(3,5) )</C>
(see&nbsp;<Ref Func="Group" Label="for several generators"/>)
and the finite field with 16 elements is constructed by
<C>GaloisField( 16 )</C>
(see&nbsp;<Ref Func="GaloisField" Label="for field size"/>).
<P/>
The first place where you need domains in &GAP; is the obvious one.
Sometimes you simply want to deal with a domain.
For example if you want to compute the size of the group <M>D_{12}</M>,
you had better be able to represent this group in a way that the
<Ref Func="Size"/> function can understand.
<P/>
The second place where you need domains in &GAP; is when you want to
be able to specify that an operation or computation takes place in a
certain domain.
For example suppose you want to factor 10 in the ring of Gaussian
integers.
Saying <C>Factors( 10 )</C> will not do, because this will return the
factorization <C>[ 2, 5 ]</C> in the ring of integers.
To allow operations and computations to happen in a specific domain,
<Ref Func="Factors"/>, and many other functions as well,
accept this domain as optional first argument.
Thus <C>Factors( GaussianIntegers, 10 )</C> yields the desired result
<C>[ 1+E(4), 1-E(4), 2+E(4), 2-E(4) ]</C>.
(The imaginary unit <M>\sqrt{{-1}}</M> is written as <C>E(4)</C>
in &GAP;, see <Ref Func="E"/>.)

<P/>
An introduction to the most important facts about domains is given
in Chapter&nbsp;<Ref Chap="Domains" BookName="tut"/>.
<P/>
There are only few <E>operations</E> especially for domains
(see&nbsp;<Ref Sect="Operations for Domains"/>),
operations such as <Ref Func="Intersection" Label="for a list"/>
and <Ref Func="Random" Label="for a list or collection"/>
are defined for the more
general situation of collections (see Chapter&nbsp;<Ref Chap="Collections"/>).

<!-- %%  The fundamental suport for domains in &GAP; was designed and implemented by -->
<!-- %%  Thomas Breuer. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operational Structure of Domains">
<Heading>Operational Structure of Domains</Heading>

Domains have an <E>operational structure</E>,
that is, a collection of operations under which the domain is closed.
For example, a group is closed under multiplication,
taking the zeroth power of elements, and taking inverses of elements.
The operational structure may be empty,
examples of domains without additional structure are
the underlying relations of general mappings
(see&nbsp;<Ref Sect="Properties and Attributes of (General) Mappings"/>).
<P/>
The operations under which a domain is closed are a subset of
the operations that the elements of a domain admit.
It is possible that the elements admit more operations.
For example, matrices can be multiplied and added.
But addition plays no role in a group of matrices,
and multiplication plays no role in a vector space of matrices.
In particular, a matrix group is not closed under addition.
<P/>
Note that the elements of a domain exist independently of this domain,
usually they existed already before the domain was created.
So it makes sense to say that a domain is <E>generated</E> by some elements
with respect to certain operations.
<P/>
Of course, different sets of operations yield different notions of
generation.
For example, the group generated by some matrices is different from
the ring generated by these matrices, and these two will in general be
different from the vector space generated by the same matrices,
over a suitable field.
<P/>
The other way round,
the same set of elements may be obtained by generation w.r.t.&nbsp;different
notions of generation.
For example, one can get the group generated by two elements <M>g</M> and <M>h</M>
also as the monoid generated by the elements <M>g</M>, <M>g^{{-1}}</M>,
<M>h</M>, <M>h^{{-1}}</M>;
if both <M>g</M> and <M>h</M> have finite order then of course the group generated
by <M>g</M> and <M>h</M> coincides with the monoid generated by <M>g</M> and <M>h</M>.
<P/>
Additionally to the operational structure,
a domain can have properties.
For example, the multiplication of a group is associative,
and the multiplication in a field is commutative.
<P/>
Note that associativity and commutativity depend on the set of
elements for which one considers the multiplication,
i.e., it depends on the domain.
For example, the multiplication in a full matrix ring over a field
is not commutative, whereas its restriction to the set of diagonal
matrices is commutative.
<P/>
One important difference between the operational structure and the
properties of a domain is that the operational structure is fixed when
the domain is constructed, whereas properties can be discovered later.
For example, take a domain whose operational structure is given by
closure under multiplication.
If it is discovered that the inverses of all its elements
also do (by chance) lie in this domain,
being closed under taking inverses is <E>not</E> added to the operational
structure.
But a domain with operational structure of multiplication,
taking the identity, and taking inverses
will be treated as a group as soon as the multiplication is found out to
be associative for this domain.
<P/>
The operational structures available in &GAP; form a hierarchy,
which is explicitly formulated in terms of domain categories,
see&nbsp;<Ref Sect="Domain Categories"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Equality and Comparison of Domains">
<Heading>Equality and Comparison of Domains</Heading>

<E>Equality</E> and <E>comparison</E> of domains are defined as follows.
<P/>
Two domains are considered <E>equal</E> if and only if the sets of their
elements as computed by <Ref Attr="AsSSortedList"/>) are equal.
Thus, in general <C>=</C> behaves as if each domain operand were replaced
by its set of elements.
Except that <C>=</C> will also sometimes, but not always,
work for infinite domains, for which of course &GAP; cannot compute
the set of elements.
Note that this implies that domains with different algebraic structure
may well be equal.
As a special case of this, either operand of <C>=</C> may also be a
proper set (see&nbsp;<Ref Sect="Sorted Lists and Sets"/>),
i.e., a sorted list without holes or duplicates
(see <Ref Attr="AsSSortedList"/>),
and <C>=</C> will return <K>true</K> if and only if this proper set is
equal to the set of elements of the argument that is a domain.
<P/>
<!-- #T These statements imply that <C>&lt;</C> and <C>=</C> -->
<!-- #T comparisons of <E>elements</E> in a domain are always -->
<!-- #T defined.  Do we really want to guarantee this? -->
<E>No</E> general <E>ordering</E> of arbitrary domains via <C>&lt;</C>
is defined in &GAP;&nbsp;4.
This is because a well-defined <C>&lt;</C> for domains or, more general,
for collections, would have to be compatible with <C>=</C> and would need
to be transitive and antisymmetric in order to be used to form ordered
sets.
In particular, <C>&lt;</C> would have to be independent of the algebraic
structure of its arguments because this holds for <C>=</C>,
and thus there would be hardly a situation where one could implement
an efficient comparison method.
(Note that in the case that two domains are comparable with <C>&lt;</C>,
the result is in general <E>not</E> compatible with the set theoretical
subset relation, which can be decided with <Ref Oper="IsSubset"/>.)


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Domains">
<Heading>Constructing Domains</Heading>

For several operational structures (see&nbsp;<Ref Sect="Operational Structure of Domains"/>),
&GAP; provides functions to construct domains with this structure
(note that such functions do not exist for all operational structures).
For example, <Ref Func="Group" Label="for several generators"/>
returns groups, <Ref Func="VectorSpace"/> returns vector spaces etc.:
<P/>
<Index Key="Struct"><A>Struct</A></Index>
<C><A>Struct</A>( <A>arg1</A>, <A>arg2</A>, ... )</C>
<P/>
The syntax of these functions may vary, dependent on the structure in question.
Usually a domain is constructed as the closure of some elements under the
given operations, that is, the domain is given by its <E>generators</E>.
For example, a group can be constructed from a list of generating
permutations or matrices or whatever is admissible as group elements,
and a vector space over a given field <M>F</M> can be constructed from <M>F</M> and
a list of appropriate vectors.
<P/>
The idea of generation and generators in &GAP; is that the domain
returned by a function such as <C>Group</C>, <C>Algebra</C>, or <C>FreeLeftModule</C>
<E>contains</E> the given generators.
This implies that the generators of a group must know how they are
multiplied and inverted,
the generators of a module must know how they are added and how scalar
multiplication works, and so on.
Thus one cannot use for example permutations as generators of a vector
space.
<P/>
The function <A>Struct</A> first checks whether the arguments admit
the construction of a domain with the desired structure.
This is done by calling the operation
<P/>
<C>IsGeneratorsOf<A>Struct</A>( [<A>info</A>, ]<A>gens</A> )</C>
<P/>
<Index Key="IsGeneratorsOfStruct"><C>IsGeneratorsOf<A>Struct</A></C></Index>
<P/>
where <A>arglist</A> is the list of given generators and <A>info</A> an argument
of <A>Struct</A>, for example the field of scalars in the case that a
vector space shall be constructed.
If the check failed then <A>Struct</A> returns <K>fail</K>,
otherwise it returns the result of <C><A>Struct</A>ByGenerators</C> (see below).
(So if one wants to omit the check then one should call
<C><A>Struct</A>ByGenerators</C> directly.)
<P/>
<Index Key="GeneratorsOfStruct"><C>GeneratorsOf<A>Struct</A></C></Index>
<C>GeneratorsOf<A>Struct</A>( <A>D</A>)</C>
<P/>
For a domain <A>D</A> with operational structure corresponding to <A>Struct</A>,
the attribute <C>GeneratorsOf<A>Struct</A></C> returns a list of corresponding
generators of <A>D</A>.
If these generators were not yet stored in <A>D</A> then <A>D</A> must know <E>some</E>
generators if <C>GeneratorsOf<A>Struct</A></C> shall have a chance to compute the
desired result;
for example, monoid generators of a group can be computed from known
group generators (and vice versa).
Note that several notions of generation may be meaningful for a given
domain, so it makes no sense to ask for <Q>the generators of a domain</Q>.
Further note that the generators may depend on other information about <A>D</A>.
For example the generators of a vector space depend on the underlying field
of scalars; the vector space generators of a vector space over the field
with four elements need not generate the same vector space when this is
viewed as a space over the field with two elements.
<P/>
<Index Key="StructByGenerators"><C><A>Struct</A>ByGenerators</C></Index>
<C><A>Struct</A>ByGenerators( [<A>info</A>, ]<A>gens</A> )</C>
<P/>
Domain construction from generators <A>gens</A> is implemented by operations
<C><A>Struct</A>ByGenerators</C>,
which are called by the simple functions <A>Struct</A>;
methods can be installed only for the operations.
Note that additional information <A>info</A> may be necessary
to construct the domain;
for example, a vector space needs the underlying field of scalars
in addition to the list of vector space generators.
The <C>GeneratorsOf<A>Struct</A></C> value of the returned domain need <E>not</E>
be equal to <A>gens</A>.
But if a domain <A>D</A> is printed as <C><A>Struct</A>([<A>a</A>, <A>b</A>, ...])</C> and if
there is an attribute <C>GeneratorsOf<A>Struct</A></C> then the list
<C>GeneratorsOf<A>Struct</A>( <A>D</A> )</C> is guaranteed to be equal to
<C>[ <A>a</A>, <A>b</A>, ... ]</C>.
<P/>
<Index Key="StructWithGenerators"><C><A>Struct</A>WithGenerators</C></Index>
<C><A>Struct</A>WithGenerators( [<A>info</A>, ]<A>gens</A> )</C>
<P/>
The only difference between <C><A>Struct</A>ByGenerators</C> and
<C><A>Struct</A>WithGenerators</C> is that the latter guarantees that the
<C>GeneratorsOf<A>Struct</A></C> value of the result is equal to the given
generators <A>gens</A>.
<P/>
<Index Key="ClosureStruct"><C>Closure<A>Struct</A></C></Index>
<C>Closure<A>Struct</A>( <A>D</A>, <A>obj</A> )</C>
<P/>
For constructing a domain as the closure of a given domain with an
element or another domain, one can use the operation <C>Closure<A>Struct</A></C>.
It returns the smallest domain with operational structure corresponding to
<A>Struct</A> that contains <A>D</A> as a subset and <A>obj</A> as an element.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changing the Structure">
<Heading>Changing the Structure</Heading>

The same set of elements can have different operational structures.
For example, it may happen that a monoid <M>M</M> does in fact contain
the inverses of all of its elements;
if <M>M</M> has not been constructed as a group (see&nbsp;<Ref Sect="Domain Categories"/>)
then it is reasonable to ask for the group that is equal to <M>M</M>.
<P/>
<Index Key="AsStruct"><C>As<A>Struct</A></C></Index>
<C>As<A>Struct</A>( [<A>info</A>, ]<A>D</A> )</C>
<P/>
If <A>D</A> is a domain that is closed under the operational structure
given by <A>Struct</A> then <C>As<A>Struct</A></C> returns a domain <A>E</A> that consists
of the same elements (that is, <C><A>D</A> = <A>E</A></C>) and that has this
operational structure (that is, <C>Is<A>Struct</A>( <A>E</A> )</C> is <K>true</K>);
if <A>D</A> is not closed under the structure given by <A>Struct</A> then
<C>As<A>Struct</A></C> returns <K>fail</K>.
<P/>
If additional information besides generators are necessary to define <A>D</A>
then the argument <A>info</A> describes the value of this information for the
desired domain.
For example, if we want to view <A>D</A> as a vector space over the field
with two elements then we may call <C>AsVectorSpace( GF(2), <A>D</A> )</C>;
this allows us to change the underlying field of scalars,
for example if <A>D</A> is a vector space over the field with four elements.
Again, if <A>D</A> is not equal to a domain with the desired structure and
additional information then <K>fail</K> is returned.
<P/>
In the case that no additional information <A>info</A> is related to the
structure given by <A>Struct</A>,
the operation <C>As<A>Struct</A></C> is in fact an attribute (see&nbsp;<Ref Sect="Attributes"/>).
<P/>
See the index of the &GAP; Reference Manual for an overview of the available
<C>As<A>Struct</A></C> functions.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changing the Representation">
<Heading>Changing the Representation</Heading>

Often it is useful to answer questions about a domain via computations in
a different but isomorphic domain.
In the sense that this approach keeps the structure and changes the
underlying set of elements, it can be viewed as a counterpart of keeping the
set of elements and changing its structure
(see&nbsp;<Ref Sect="Changing the Structure"/>).
<P/>
One reason for doing so can be that computations with the elements in the
given domain are not very efficient.
For example, if one is given a solvable matrix group
(see Chapter&nbsp;<Ref Chap="Matrix Groups"/>)
then one can compute an isomorphism to a
polycyclicly presented group <M>G</M>,
say (see Chapter&nbsp;<Ref Chap="Polycyclic Groups"/>);
the multiplication of two matrices &ndash;which is essentially determined by
the dimension of the matrices&ndash; is much more expensive than the
multiplication of two elements in <M>G</M>
&ndash;which is essentially determined by the composition length of <M>G</M>.
<P/>
<Index Key="IsomorphismRepStruct"><C>Isomorphism<A>Rep</A><A>Struct</A></C></Index>
<C>Isomorphism<A>Rep</A><A>Struct</A>( <A>D</A> )</C>
<P/>
If <A>D</A> is a domain that is closed under the operational structure
given by <A>Struct</A> then <C>Isomorphism<A>Rep</A><A>Struct</A></C> returns
a mapping <A>hom</A>
from <A>D</A> to a domain <M>E</M> having structure given by <A>Struct</A>,
such that <A>hom</A> respects the structure <A>Struct</A>
and <A>Rep</A> describes the representation of the elements in <M>E</M>.
If no domain <M>E</M> with the required properties exists then <K>fail</K> is
returned.
<P/>
For example, <Ref Func="IsomorphismPermGroup"/> takes a
group as its argument and returns a group homomorphism
(see&nbsp;<Ref Chap="Group Homomorphisms"/>) onto an isomorphic permutation group
(see Chapter&nbsp;<Ref Chap="Permutation Groups"/>) provided the original
group is finite;
for infinite groups, <Ref Func="IsomorphismPermGroup"/> returns <K>fail</K>.
Similarly, <Ref Func="IsomorphismPcGroup"/> returns a group
homomorphism from its argument to a polycyclicly presented group
(see&nbsp;<Ref Chap="Pc Groups"/>) if the argument is polycyclic,
and <K>fail</K> otherwise.
<P/>
See the index of the &GAP; Reference Manual for an overview of the available
<C>Isomorphism<A>Rep</A><A>Struct</A></C> functions.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Domain Categories">
<Heading>Domain Categories</Heading>

As mentioned in&nbsp;<Ref Sect="Operational Structure of Domains"/>,
the operational structure of a domain is fixed when the domain is
constructed.
For example, if <A>D</A> was constructed by
<Ref Func="Monoid" Label="for various generators"/>
then <A>D</A> is in general not regarded as a group in &GAP;,
even if <A>D</A> is in fact closed under taking inverses.
In this case, <Ref Func="IsGroup"/> returns <K>false</K> for <A>D</A>.
The operational structure determines which operations are applicable for
a domain, so for example <Ref Func="SylowSubgroup"/> is not defined for
<A>D</A> and therefore will signal an error.
<P/>
<Index Key="IsStruct"><C>Is<A>Struct</A></C></Index>
<C>Is<A>Struct</A>( <A>D</A> )</C>
<P/>
The functions <C>Is<A>Struct</A></C> implement the tests whether a domain
<A>D</A> has the respective operational structure (upon construction).
<C>Is<A>Struct</A></C> is a filter (see&nbsp;<Ref Chap="Types of Objects"/>)
that involves certain categories (see&nbsp;<Ref Sect="Categories"/>)
and usually also certain properties (see&nbsp;<Ref Sect="Properties"/>).
For example, <Ref Func="IsGroup"/> is equivalent to
<C>IsMagmaWithInverses and IsAssociative</C>,
the first being a category and the second being a property.
<P/>
Implications between domain categories describe the hierarchy of
operational structures available in &GAP;.
Here are some typical examples.
<P/>
<List>
<Item>
    <Ref Func="IsDomain"/> is implied by each domain category,
</Item>
<Item>
    <Ref Func="IsMagma"/> is implied by each category that describes the
    closure under multiplication <C>*</C>,
</Item>
<Item>
    <Ref Func="IsAdditiveMagma"/> is implied by each category that describes
    the closure under addition <C>+</C>,
</Item>
<Item>
    <Ref Func="IsMagmaWithOne"/> implies <Ref Func="IsMagma"/>;
    a <E>magma-with-one</E> is a magma such that each element
    (and thus also the magma itself) can be asked for its zeroth power,
</Item>
<Item>
    <Ref Func="IsMagmaWithInverses"/> implies <Ref Func="IsMagmaWithOne"/>;
    a <E>magma-with-inverses</E> is a magma such that each element
    can be asked for its inverse;
    important special cases are <E>groups</E>,
    which in addition are associative,
</Item>
<Item>
    a <E>ring</E> is a magma that is also an additive group,
</Item>
<Item>
    a <E>ring-with-one</E> is a ring that is also a magma-with-one,
</Item>
<Item>
    a <E>division ring</E> is a ring-with-one that is also closed under taking
    inverses of nonzero elements,
</Item>
<Item>
    a <E>field</E> is a commutative division ring.
</Item>
</List>
<P/>
Each operational structure <A>Struct</A> has associated with it 
a domain category <C>Is<A>Struct</A></C>,
and operations <C><A>Struct</A>ByGenerators</C> for constructing a domain
from generators,
<C>GeneratorsOf<A>Struct</A></C> for storing and accessing generators
w.r.t.&nbsp;this structure,
<C>Closure<A>Struct</A></C> for forming the closure,
and <C>As<A>Struct</A></C> for getting a domain with the desired structure
from one with weaker operational structure and for testing whether a given
domain can be regarded as a domain with <A>Struct</A>.
<P/>
The functions applicable to domains with the various structures
are described in the corresponding chapters of the Reference Manual.
For example, functions for rings, fields, groups, and vector spaces
are described in Chapters&nbsp;<Ref Chap="Rings"/>,
<Ref Chap="Fields and Division Rings"/>,
<Ref Chap="Groups"/>, and <Ref Chap="Vector Spaces"/>, respectively.
More general functions for arbitrary collections can be found in
Chapter&nbsp;<Ref Chap="Collections"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Parents">
<Heading>Parents</Heading>

<ManSection>
<Func Name="Parent" Arg='D'/>
<Oper Name="SetParent" Arg='D, P'/>
<Func Name="HasParent" Arg='D'/>

<Description>
It is possible to assign to a domain <A>D</A> one other domain <A>P</A>
containing <A>D</A> as a subset,
in order to exploit this subset relation between <A>D</A> and <A>P</A>.
Note that <A>P</A> need not have the same operational structure as <A>D</A>,
for example <A>P</A> may be a magma and <A>D</A> a field.
<P/>
The assignment is done by calling <Ref Func="SetParent"/>,
and <A>P</A> is called the <E>parent</E> of <A>D</A>.
If <A>D</A> has already a parent,
calls to <Ref Func="SetParent"/> will be ignored.
<P/>
If <A>D</A> has a parent <A>P</A>
&ndash;this can be checked with <Ref Func="HasParent"/>&ndash;
then <A>P</A> can be used to gain information about <A>D</A>.
First, the call of <Ref Func="SetParent"/> causes
<Ref Func="UseSubsetRelation"/> to be called.
Second, for a domain <A>D</A> with parent,
information relative to the parent can be stored in <A>D</A>;
for example, there is an attribute <C>NormalizerInParent</C> for storing
<C>Normalizer( <A>P</A>, <A>D</A> )</C> in the case that <A>D</A> is a
group.
(More about such parent dependent attributes can be found in
<Ref Sect="In Parent Attributes"/>.)
<!-- better make this part of the Reference Manual?-->
Note that because of this relative information,
one cannot change the parent;
that is, one can set the parent only once,
subsequent calls to <Ref Func="SetParent"/> for the same domain <A>D</A>
are ignored.
<!-- better raise a warning/error?-->
Further note that contrary to <Ref Func="UseSubsetRelation"/>,
also knowledge about the parent <A>P</A> might be used
that is discovered after the <Ref Func="SetParent"/> call.
<P/>
A stored parent can be accessed using <Ref Func="Parent"/>.
If <A>D</A> has no parent then <Ref Func="Parent"/> returns <A>D</A>
itself, and <Ref Func="HasParent"/> will return <K>false</K>
also after a call to <Ref Func="Parent"/>.
So <Ref Func="Parent"/> is <E>not</E> an attribute,
the underlying attribute to store the parent is <C>ParentAttr</C>.
<!-- add a cross-ref. to section about attributes -->
<P/>
Certain functions that return domains with parent already set,
for example <Ref Func="Subgroup"/>,
are described in Section&nbsp;<Ref Sect="Constructing Subdomains"/>.
Whenever a function has this property,
the &GAP; Reference Manual states this explicitly.
Note that these functions <E>do not guarantee</E> a certain parent,
for example <Ref Func="DerivedSubgroup"/> for a perfect
group <M>G</M> may return <M>G</M> itself, and if <M>G</M> had already a
parent then this is not replaced by <M>G</M>.
As a rule of thumb, &GAP; avoids to set a domain as its own parent,
which is consistent with the behaviour of <Ref Func="Parent"/>,
at least until a parent is set explicitly with <Ref Func="SetParent"/>.
<P/>
<Example><![CDATA[
gap> g:= Group( (1,2,3), (1,2) );; h:= Group( (1,2) );;
gap> HasParent( g );  HasParent( h );
false
false
gap> SetParent( h, g );
gap> Parent( g );  Parent( h );
Group([ (1,2,3), (1,2) ])
Group([ (1,2,3), (1,2) ])
gap> HasParent( g );  HasParent( h );
false
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Subdomains">
<Heading>Constructing Subdomains</Heading>

<Index>Subdomains</Index>
For many domains <A>D</A>, there are functions that construct certain subsets <A>S</A>
of <A>D</A> as domains with parent (see&nbsp;<Ref Sect="Parents"/>) already set to <A>D</A>.
For example, if <A>G</A> is a group that contains the elements in the list <A>gens</A>
then <C>Subgroup( <A>G</A>, <A>gens</A> )</C> returns a group <A>S</A> that is generated by the
elements in <A>gens</A> and with <C>Parent( <A>S</A> ) = <A>G</A></C>.
<P/>
<Index Key="Substruct"><C>Sub<A>struct</A></C></Index>
<C>Sub<A>struct</A>( <A>D</A>, <A>gens</A> )</C>
<P/>
More general, if <A>D</A> is a domain whose algebraic structure is given by the
function <A>Struct</A> (for example <C>Group</C>, <C>Algebra</C>, <C>Field</C>)
then the function <C>Sub<A>struct</A></C> (for example <C>Subgroup</C>, <C>Subalgebra</C>,
<C>Subfield</C>) returns domains with structure <A>Struct</A> and parent set to
the first argument.
<P/>
<Index Key="SubstructNC"><C>Sub<A>struct</A>NC</C></Index>
<C>Sub<A>struct</A>NC( <A>D</A>, <A>gens</A> )</C>
<P/>
Each function <C>Sub<A>struct</A></C> checks that the <A>Struct</A> generated by
<A>gens</A> is in fact a subset of <A>D</A>.
If one wants to omit this check then one can call <C>Sub<A>struct</A>NC</C> instead;
the suffix <C>NC</C> stands for <Q>no  check</Q>.
<P/>
<Index Key="AsSubstruct"><C>AsSub<A>struct</A></C></Index>
<C>AsSub<A>struct</A>( <A>D</A>, <A>S</A> )</C>
<P/>
first constructs <C>As<A>Struct</A>( [<A>info</A>, ]<A>S</A> )</C>,
where <A>info</A> depends on <A>D</A> and <A>S</A>,
and then sets the parent (see&nbsp;<Ref Sect="Parents"/>) of this new domain to <A>D</A>.
<P/>
<Index Key="IsSubstruct"><C>IsSub<A>struct</A></C></Index>
<C>IsSub<A>struct</A>( <A>D</A>, <A>S</A> )</C>
<P/>
There is no real need for functions that check whether a domain <A>S</A> is a
<C>Sub<A>struct</A></C> of a domain <A>D</A>,
since this is equivalent to the checks whether <A>S</A> is a <A>Struct</A> and <A>S</A>
is a subset of <A>D</A>.
Note that in many cases, only the subset relation is what one really wants
to check, and that appropriate methods for the operation
<Ref Func="IsSubset"/> are available for many special situations,
such as the test whether a group is contained in another group,
where only generators need to be checked.
<P/>
If a function <C>IsSub<A>struct</A></C> is available in &GAP; then it is implemented
as first a call to <C>Is<A>Struct</A></C> for the second argument and then a call to
<Ref Func="IsSubset"/> for the two arguments.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Domains">
<Heading>Operations for Domains</Heading>

For the meaning of the attributes <Ref Attr="Characteristic"/>,
<Ref Attr="One"/>, <Ref Attr="Zero"/>
in the case of a domain argument,
see&nbsp;<Ref Sect="Attributes and Properties of Elements"/>.

<ManSection>
<Filt Name="IsGeneralizedDomain" Arg='obj' Type='Category'/>
<Filt Name="IsDomain" Arg='obj' Type='Category'/>

<Description>
For some purposes, it is useful to deal with objects that are similar to
domains but that are not collections in the sense of &GAP;
because their elements may lie in different families;
such objects are called <E>generalized domains</E>.
An instance of generalized domains are <Q>operation domains</Q>,
for example any <M>G</M>-set for a permutation group <M>G</M>
consisting of some union of points, sets of points, sets of sets of
points etc., under a suitable action.
<P/>
<Ref Func="IsDomain"/> is a synonym for
<C>IsGeneralizedDomain and IsCollection</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfDomain" Arg='D'/>

<Description>
For a domain <A>D</A>, <Ref Func="GeneratorsOfDomain"/> returns a list
containing all elements of <A>D</A>, perhaps with repetitions.
Note that if the domain <A>D</A> shall be generated by a list of some
elements w.r.t.&nbsp;the empty operational structure
(see&nbsp;<Ref Sect="Operational Structure of Domains"/>),
the only possible choice of elements is to take all elements of <A>D</A>.
See&nbsp;<Ref Sect="Constructing Domains"/> and
<Ref Sect="Changing the Structure"/> for concepts
of other notions of generation.
<P/>
For many domains that have <E>natural generators by construction</E>
(for example, the natural generators of a free group of rank two 
are the two generators stored as value of the attribute 
<Ref Attr="GeneratorsOfGroup"/>, and the natural generators of 
a free associative algebra are those generators stored as value of 
the attribute <Ref Attr="GeneratorsOfAlgebra"/>), each <E>natural</E> 
generator can be accessed using the <C>.</C> operator. For a domain
<A>D</A>, <C><A>D</A>.i</C> returns the <M>i</M>-th generator if 
<M>i</M> is a positive integer, and if <C>name</C> is the name of a 
generator of <A>D</A> then <C><A>D</A>.name</C> returns this generator. 
</Description>
</ManSection>

<ManSection>
<Func Name="Domain" Arg='[Fam, ]generators'/>
<Oper Name="DomainByGenerators" Arg='Fam, generators'/>

<Description>
<Ref Func="Domain"/> returns the domain consisting of the elements
in the homogeneous list <A>generators</A>.
If <A>generators</A> is empty then a family <A>Fam</A> must be entered
as the first argument, and the returned (empty) domain lies in the
collections family of <A>Fam</A>.
<P/>
<Ref Func="DomainByGenerators"/> is the operation called by
<Ref Func="Domain"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties of Elements">
<Heading>Attributes and Properties of Elements</Heading>

The following attributes and properties for elements and domains
correspond to the operational structure.

<ManSection>
<Attr Name="Characteristic" Arg='obj'/>

<Description>
<Ref Attr="Characteristic"/> returns the <E>characteristic</E> of
<A>obj</A>.
<P/>
If <A>obj</A> is a family, all of whose elements lie in
<Ref Filt="IsAdditiveElementWithZero"/> then its characteristic
is the least positive integer <M>n</M>, if any, such that
<C>IsZero(n*x)</C> is <K>true</K> for all <C>x</C> in the
family <A>obj</A>, otherwise it is <M>0</M>.
<P/>
If <A>obj</A> is a collections family of a family <M>g</M> which
has a characteristic, then the characteristic of <A>obj</A> is
the same as the characteristic of <M>g</M>.
<P/>
For other families <A>obj</A> the characteristic is not defined
and <K>fail</K> will be returned.
<P/>
For any object <A>obj</A> which is in the filter
<Ref Filt="IsAdditiveElementWithZero"/> or in the filter
<Ref Filt="IsAdditiveMagmaWithZero"/> the characteristic of
<A>obj</A> is the same as the characteristic of its family
if that is defined and undefined otherwise.
<P/>
For all other objects <A>obj</A> the characteristic is undefined
and may return <K>fail</K> or a <Q>no method found</Q> error.
</Description>
</ManSection>

<ManSection>
<Attr Name="OneImmutable" Arg='obj'/>
<Attr Name="OneAttr" Arg='obj'/>
<Attr Name="One" Arg='obj'/>
<Attr Name="Identity" Arg='obj'/>
<Oper Name="OneMutable" Arg='obj'/>
<Oper Name="OneOp" Arg='obj'/>
<Oper Name="OneSameMutability" Arg='obj'/>
<Oper Name="OneSM" Arg='obj'/>

<Description>
<Ref Attr="OneImmutable"/>, <Ref Oper="OneMutable"/>,
and <Ref Oper="OneSameMutability"/> return the multiplicative neutral
element of the multiplicative element <A>obj</A>.
<P/>
They differ only w.r.t. the mutability of the result.
<Ref Attr="OneImmutable"/> is an attribute and hence returns an immutable
result.
<Ref Oper="OneMutable"/> is guaranteed to return a new <E>mutable</E>
object whenever a mutable version of the required element exists in &GAP;
(see&nbsp;<Ref Func="IsCopyable"/>).
<Ref Oper="OneSameMutability"/> returns a result that is mutable if
<A>obj</A> is mutable
and if a mutable version of the required element exists in &GAP;;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<P/>
If <A>obj</A> is a multiplicative element then
<C>OneSameMutability( <A>obj</A> )</C>
is equivalent to <C><A>obj</A>^0</C>.
<P/>
<Ref Attr="OneAttr"/>, <Ref Attr="One"/> and <Ref Attr="Identity"/> are
synonyms of <C>OneImmutable</C>.
<Ref Oper="OneSM"/> is a synonym of <Ref Oper="OneSameMutability"/>.
<Ref Oper="OneOp"/> is a synonym of <Ref Oper="OneMutable"/>.
<P/>
If <A>obj</A> is a domain or a family then <Ref Attr="One"/> is defined
as the identity element of all elements in <A>obj</A>, 
provided that all these elements have the same identity.
For example, the family of all cyclotomics has the identity element
<C>1</C>,
but a collections family (see&nbsp;<Ref Func="CollectionsFamily"/>)
may contain matrices of all dimensions and then it cannot have a unique
identity element.
Note that <Ref Oper="One"/> is applicable to a domain only if it is a
magma-with-one (see&nbsp;<Ref Func="IsMagmaWithOne"/>);
use <Ref Func="MultiplicativeNeutralElement"/> otherwise.
<P/>
The identity of an object need not be distinct from its zero,
so for example a ring consisting of a single element can be regarded as a
ring-with-one (see&nbsp;<Ref Chap="Rings"/>).
This is particularly useful in the case of finitely presented algebras,
where any factor of a free algebra-with-one is again an algebra-with-one,
no matter whether or not it is a zero algebra.
<P/>
The default method of <Ref Attr="One"/> for multiplicative elements calls
<Ref Oper="OneMutable"/> (note that methods for <Ref Oper="OneMutable"/>
must <E>not</E> delegate to <Ref Attr="One"/>);
so other methods to compute identity elements need to be installed only
for <Ref Oper="OneOp"/> and (in the case of copyable objects)
<Ref Oper="OneSameMutability"/>.
<P/>
For domains, <Ref Attr="One"/> may call <Ref Attr="Representative"/>,
but <Ref Attr="Representative"/> is allowed to fetch the identity of a
domain <A>D</A> only if <C>HasOne( <A>D</A> )</C> is <K>true</K>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ZeroImmutable" Arg='obj'/>
<Attr Name="ZeroAttr" Arg='obj'/>
<Attr Name="Zero" Arg='obj'/>
<Oper Name="ZeroMutable" Arg='obj'/>
<Oper Name="ZeroOp" Arg='obj'/>
<Oper Name="ZeroSameMutability" Arg='obj'/>
<Oper Name="ZeroSM" Arg='obj'/>

<Description>
<Ref Func="ZeroImmutable"/>, <Ref Func="ZeroMutable"/>,
and <Ref Func="ZeroSameMutability"/> all
return the additive neutral element of the additive element <A>obj</A>.
<P/>
They differ only w.r.t. the mutability of the result.
<Ref Func="ZeroImmutable"/> is an attribute and hence returns an
immutable result.
<Ref Func="ZeroMutable"/> is guaranteed to return a new <E>mutable</E>
object whenever a mutable version of the required element exists in &GAP;
(see&nbsp;<Ref Func="IsCopyable"/>).
<Ref Func="ZeroSameMutability"/> returns a result that is mutable if
<A>obj</A> is mutable and if a mutable version of the required element
exists in &GAP;;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<P/>
<C>ZeroSameMutability( <A>obj</A> )</C> is equivalent to
<C>0 * <A>obj</A></C>.
<P/>
<Ref Attr="ZeroAttr"/> and <Ref Func="Zero"/> are synonyms of
<Ref Func="ZeroImmutable"/>.
<Ref Func="ZeroSM"/> is a synonym of <Ref Func="ZeroSameMutability"/>.
<Ref Func="ZeroOp"/> is a synonym of <Ref Func="ZeroMutable"/>.
<P/>
If <A>obj</A> is a domain or a family then <Ref Func="Zero"/> is defined
as the zero element of all elements in <A>obj</A>,
provided that all these elements have the same zero.
For example, the family of all cyclotomics has the zero element <C>0</C>,
but a collections family (see&nbsp;<Ref Func="CollectionsFamily"/>) may
contain matrices of all dimensions and then it cannot have a unique
zero element.
Note that <Ref Func="Zero"/> is applicable to a domain only if it is an
additive magma-with-zero
(see&nbsp;<Ref Func="IsAdditiveMagmaWithZero"/>);
use <Ref Func="AdditiveNeutralElement"/> otherwise.
<P/>
The default method of <Ref Func="Zero"/> for additive elements calls
<Ref Func="ZeroMutable"/>
(note that methods for <Ref Func="ZeroMutable"/> must <E>not</E> delegate
to <Ref Func="Zero"/>);
so other methods to compute zero elements need to be installed only for
<Ref Func="ZeroMutable"/> and (in the case of copyable objects)
<Ref Func="ZeroSameMutability"/>.
<P/>
For domains, <Ref Func="Zero"/> may call <Ref Attr="Representative"/>,
but <Ref Attr="Representative"/> is allowed to fetch the zero of a domain
<A>D</A> only if <C>HasZero( <A>D</A> )</C> is <K>true</K>.
</Description>
</ManSection>

<ManSection>
<Oper Name="MultiplicativeZeroOp" Arg='elt'/>
<Returns>A multiplicative zero element.</Returns>
<Description>
for an element <A>elt</A> in the category 
<Ref Func="IsMultiplicativeElementWithZero"/>,
<C>MultiplicativeZeroOp</C> 
returns the element <M>z</M> in the family <M>F</M> of <A>elt</A>
with the property that <M>z * m = z = m * z</M> holds for all
<M>m \in F</M>, if such an element can be determined.
<P/>

Families of elements in the category
<Ref Func="IsMultiplicativeElementWithZero"/>
often arise from adjoining a new zero to an existing magma. 
See&nbsp;<Ref Attr="InjectionZeroMagma"/> or 
<Ref Func="MagmaWithZeroAdjoined"/> for details.
<Example><![CDATA[
gap> G:=AlternatingGroup(5);;
gap> x:=Representative(MagmaWithZeroAdjoined(G));
<group with 0 adjoined elt: ()>
gap> MultiplicativeZeroOp(x);
<group with 0 adjoined elt: 0>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsOne" Arg='elm'/>

<Description>
is <K>true</K> if <C><A>elm</A> = One( <A>elm</A> )</C>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsZero" Arg='elm'/>

<Description>
is <K>true</K> if <C><A>elm</A> = Zero( <A>elm</A> )</C>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsIdempotent" Arg='elt'/>

<Description>
returns <K>true</K> iff <A>elt</A> is its own square. 
(Even if <Ref Func="IsZero"/> returns <K>true</K> for <A>elt</A>.)
</Description>
</ManSection>

<ManSection>
<Attr Name="InverseImmutable" Arg='elm'/>
<Attr Name="InverseAttr" Arg='elm'/>
<Attr Name="Inverse" Arg='elm'/>
<Oper Name="InverseMutable" Arg='elm'/>
<Oper Name="InverseOp" Arg='elm'/>
<Oper Name="InverseSameMutability" Arg='elm'/>
<Oper Name="InverseSM" Arg='elm'/>

<Description>
<Ref Attr="InverseImmutable"/>, <Ref Oper="InverseMutable"/>, and
<Ref Oper="InverseSameMutability"/>
all return the multiplicative inverse of an element <A>elm</A>,
that is, an element <A>inv</A> such that
<C><A>elm</A> * <A>inv</A> = <A>inv</A> * <A>elm</A>
 = One( <A>elm</A> )</C> holds;
if <A>elm</A> is not invertible then <K>fail</K>
(see&nbsp;<Ref Sect="Fail"/>) is returned.
<P/>
Note that the above definition implies that a (general) mapping
is invertible in the sense of <Ref Attr="Inverse"/> only if its source
equals its range
(see&nbsp;<Ref Sect="Technical Matters Concerning General Mappings"/>).
For a bijective mapping <M>f</M> whose source and range differ,
<Ref Func="InverseGeneralMapping"/> can be used
to construct a mapping <M>g</M> with the property
that <M>f</M> <C>*</C> <M>g</M> is the identity mapping on the source of
<M>f</M> and <M>g</M> <C>*</C> <M>f</M> is the identity mapping on the
range of <M>f</M>.
<P/>
The operations differ only w.r.t. the mutability of the result.
<Ref Attr="InverseImmutable"/> is an attribute and hence returns an
immutable result.
<Ref Oper="InverseMutable"/> is guaranteed to return a new <E>mutable</E>
object whenever a mutable version of the required element exists in &GAP;.
<Ref Oper="InverseSameMutability"/> returns a result that is mutable if
<A>elm</A> is mutable and if a mutable version of the required element
exists in &GAP;;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<P/>
<C>InverseSameMutability( <A>elm</A> )</C> is equivalent to
<C><A>elm</A>^-1</C>.
<P/>
<Ref Attr="InverseAttr"/> and <Ref Attr="Inverse"/> are synonyms of
<Ref Attr="InverseImmutable"/>.
<Ref Oper="InverseSM"/> is a synonym of
<Ref Oper="InverseSameMutability"/>.
<Ref Oper="InverseOp"/> is a synonym of <Ref Oper="InverseMutable"/>.
<P/>
The default method of <Ref Attr="InverseImmutable"/> calls
<Ref Oper="InverseMutable"/> (note that methods
for <Ref Oper="InverseMutable"/> must <E>not</E> delegate to
<Ref Attr="InverseImmutable"/>);
other methods to compute inverses need to be installed only for
<Ref Oper="InverseMutable"/> and (in the case of copyable objects)
<Ref Oper="InverseSameMutability"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="AdditiveInverseImmutable" Arg='elm'/>
<Attr Name="AdditiveInverseAttr" Arg='elm'/>
<Attr Name="AdditiveInverse" Arg='elm'/>
<Oper Name="AdditiveInverseMutable" Arg='elm'/>
<Oper Name="AdditiveInverseOp" Arg='elm'/>
<Oper Name="AdditiveInverseSameMutability" Arg='elm'/>
<Oper Name="AdditiveInverseSM" Arg='elm'/>

<Description>
<Ref Attr="AdditiveInverseImmutable"/>,
<Ref Oper="AdditiveInverseMutable"/>, and 
<Ref Oper="AdditiveInverseSameMutability"/> all return the
additive inverse of <A>elm</A>.
<P/>
They differ only w.r.t. the mutability of the result.
<Ref Attr="AdditiveInverseImmutable"/> is an attribute and hence returns
an immutable result.
<Ref Oper="AdditiveInverseMutable"/> is guaranteed to return a new
<E>mutable</E> object whenever a mutable version of the required element
exists in &GAP; (see&nbsp;<Ref Func="IsCopyable"/>).
<Ref Oper="AdditiveInverseSameMutability"/> returns a result that is
mutable if <A>elm</A> is mutable and if a mutable version of the required
element exists in &GAP;;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<P/>
<C>AdditiveInverseSameMutability( <A>elm</A> )</C> is equivalent to
<C>-<A>elm</A></C>.
<P/>
<Ref Attr="AdditiveInverseAttr"/> and <Ref Attr="AdditiveInverse"/> are
synonyms of <Ref Attr="AdditiveInverseImmutable"/>.
<Ref Oper="AdditiveInverseSM"/> is a synonym of
<Ref Oper="AdditiveInverseSameMutability"/>.
<Ref Oper="AdditiveInverseOp"/> is a synonym of
<Ref Oper="AdditiveInverseMutable"/>.
<P/>
The default method of <Ref Attr="AdditiveInverse"/> calls
<Ref Oper="AdditiveInverseMutable"/>
(note that methods for <Ref Oper="AdditiveInverseMutable"/>
must <E>not</E> delegate to <Ref Attr="AdditiveInverse"/>);
so other methods to compute additive inverses need to be installed only
for <Ref Oper="AdditiveInverseMutable"/> and (in the case of copyable
objects) <Ref Oper="AdditiveInverseSameMutability"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="Order" Arg='elm'/>

<Description>
is the multiplicative order of <A>elm</A>.
This is the smallest positive integer <M>n</M> such that
<A>elm</A> <C>^</C> <M>n</M> <C>= One( <A>elm</A> )</C>
if such an integer exists. If the order is
infinite, <Ref Attr="Order"/> may return the value <Ref Var="infinity"/>,
but it also might run into an infinite loop trying to test the order.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison Operations for Elements">
<Heading>Comparison Operations for Elements</Heading>

Binary comparison operations have been introduced already in
<Ref Sect="Comparisons"/>.
The underlying operations for which methods can be installed are the
following.


<ManSection>
<Heading>\= and \&lt;</Heading>
<Oper Name="\=" Arg='left-expr, right-expr'/>
<Oper Name="\&lt;" Arg='left-expr, right-expr'/>

<Description>
<Index Subkey="operation">equality</Index>
<Index Subkey="operation">comparison</Index>
Note that the comparisons via <C>&lt;></C>, <C>&lt;=</C>, <C>></C>,
and <C>>=</C>
are delegated to the operations <Ref Oper="\="/> and <Ref Oper="\&lt;"/>.
<P/>
In general, objects in <E>different</E> families cannot be compared with
<Ref Oper="\&lt;"/>.
For the reason and for exceptions from this rule,
see&nbsp;<Ref Sect="Comparisons"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="CanEasilyCompareElements" Arg='obj'/>
<Func Name="CanEasilyCompareElementsFamily" Arg='fam'/>
<Prop Name="CanEasilySortElements" Arg='obj'/>
<Func Name="CanEasilySortElementsFamily" Arg='fam'/>

<Description>
For some objects a <Q>normal form</Q> is hard to compute
and thus equality of elements of a domain might be expensive to test.
Therefore &GAP; provides a (slightly technical) property with which an
algorithm can test whether an efficient equality test is available
for elements of a certain kind.
<P/>
<Ref Func="CanEasilyCompareElements"/> indicates whether the elements in
the family <A>fam</A> of <A>obj</A> can be easily compared with
<Ref Func="\="/>.
<P/>
The default method for this property is to ask the family of <A>obj</A>,
the default method for the family is to return <K>false</K>.
<P/>
The ability to compare elements may depend on the successful computation
of certain information. (For example for finitely presented groups it
might depend on the knowledge of a faithful permutation representation.)
This information might change over time and thus it might not be a good
idea to store a value <K>false</K> too early in a family. Instead the
function <Ref Func="CanEasilyCompareElementsFamily"/> should be called
for the family of <A>obj</A> which returns <K>false</K> if the value of
<Ref Func="CanEasilyCompareElements"/> is not known for the family
without computing it. (This is in fact what the above mentioned family
dispatch does.)
<P/>
If a family knows ab initio that it can compare elements this property
should be set as implied filter <E>and</E> filter for the family
(the 3rd and 4th argument of <Ref Func="NewFamily"/>
respectively).
This guarantees that code which directly asks the family gets a right
answer.
<P/>
The property <Ref Func="CanEasilySortElements"/> and the function
<Ref Func="CanEasilySortElementsFamily"/> behave exactly in the same way,
except that they indicate that objects can be compared via
<Ref Func="\&lt;"/>.
This property implies <Ref Func="CanEasilyCompareElements"/>,
as the ordering must be total.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Operations for Elements">
<Heading>Arithmetic Operations for Elements</Heading>

<E>Binary</E> arithmetic operations have been introduced already in
<Ref Sect="Arithmetic Operators"/>.
The underlying operations for which methods can be installed are the
following.

<ManSection>
<Heading>\+, \*, \/, \^, \mod</Heading>
<Oper Name="\+" Arg='left-expr, right-expr'/>
<Oper Name="\*" Arg='left-expr, right-expr'/>
<Oper Name="\/" Arg='left-expr, right-expr'/>
<Oper Name="\^" Arg='left-expr, right-expr'/>
<Oper Name="\mod" Arg='left-expr, right-expr'/>

<Description>
<Index Subkey="operation">addition</Index>
<Index Subkey="operation">multiplication</Index>
<Index Subkey="operation">division</Index>
<Index Subkey="operation">exponentiation</Index>
<Index Subkey="operation">remainder</Index>
For details about special methods for <Ref Oper="\*"/>, 
<Ref Oper="\/"/>, <Ref Oper="\^"/> and <Ref Oper="\mod"/>, 
consult the appropriate index entries for them.
<!-- % (no Declaration available for them?) -->
</Description>
</ManSection>


<ManSection>
<Oper Name="LeftQuotient" Arg='elm1, elm2'/>

<Description>
returns the product <C><A>elm1</A>^(-1) * <A>elm2</A></C>.
For some types of objects (for example permutations) this product can be
evaluated more efficiently than by first inverting <A>elm1</A>
and then forming the product with <A>elm2</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Comm" Arg='elm1, elm2'/>

<Description>
returns the <E>commutator</E> of <A>elm1</A> and <A>elm2</A>.
The commutator is defined as the product
<M><A>elm1</A>^{{-1}} * <A>elm2</A>^{{-1}} * <A>elm1</A> * <A>elm2</A></M>.
<P/>
<Example><![CDATA[
gap> a:= (1,3)(4,6);; b:= (1,6,5,4,3,2);;
gap> Comm( a, b );
(1,5,3)(2,6,4)
gap> LeftQuotient( a, b );
(1,2)(3,6)(4,5)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LieBracket" Arg='elm1, elm2'/>

<Description>
returns the element
<C><A>elm1</A> * <A>elm2</A> - <A>elm2</A> * <A>elm1</A></C>.
<P/>
The addition <Ref Oper="\+"/> is assumed to be associative
but <E>not</E> assumed to be commutative
(see&nbsp;<Ref Func="IsAdditivelyCommutative"/>).
The multiplication <Ref Oper="\*"/> is <E>not</E> assumed to be
commutative or associative
(see&nbsp;<Ref Func="IsCommutative"/>, <Ref Func="IsAssociative"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="Sqrt" Arg='obj'/>

<Description>
<Ref Oper="Sqrt"/> returns a square root of <A>obj</A>, that is,
an object <M>x</M> with the property that <M>x \cdot x = <A>obj</A></M>
holds.
If such an <M>x</M> is not unique then the choice of <M>x</M> depends
on the type of <A>obj</A>.
For example, <Ref Func="ER"/> is the <Ref Oper="Sqrt"/> method for
rationals (see&nbsp;<Ref Func="IsRat"/>).
</Description>
</ManSection>


<!-- % missing facts about the others ... -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Relations Between Domains">
<Heading>Relations Between Domains</Heading>

Domains are often constructed relative to other domains.
The probably most usual case is to form a <E>subset</E> of a domain,
for example the intersection
(see&nbsp;<Ref Func="Intersection" Label="for a list"/>) of two domains,
or a Sylow subgroup of a given group (see&nbsp;<Ref Func="SylowSubgroup"/>).
<P/>
In such a situation, the new domain can gain knowledge by exploiting that
several attributes are maintained under taking subsets.
For example, the intersection of an arbitrary domain with a finite domain
is clearly finite, a Sylow subgroup of an abelian group is abelian, too,
and so on.
<P/>
Since usually the new domain has access to the knowledge of the old domain(s)
only when it is created (see&nbsp;<Ref Sect="Constructing Subdomains"/> for the exception),
this is the right moment to take advantage of the subset relation,
using <Ref Func="UseSubsetRelation"/>.
<P/>
Analogous relations occur when a <E>factor structure</E> is created from a
domain and a subset (see <Ref Func="UseFactorRelation"/>),
and when a domain <E>isomorphic</E> to a given one is created
(see <Ref Func="UseIsomorphismRelation"/>).
<P/>
The functions <Ref Func="InstallSubsetMaintenance"/>,
<Ref Func="InstallIsomorphismMaintenance"/>, and
<Ref Func="InstallFactorMaintenance"/> are used to tell &GAP;
under what conditions an attribute is maintained under taking subsets,
or forming factor structures or isomorphic domains.
This is used only when a new attribute is created,
see&nbsp;<Ref Sect="Creating Attributes and Properties"/>.
For the attributes already available,
such as <Ref Func="IsFinite"/> and <Ref Func="IsCommutative"/>,
the maintenances are already notified.

<ManSection>
<Oper Name="UseSubsetRelation" Arg='super, sub'/>

<Description>
Methods for this operation transfer possibly useful information from the
domain <A>super</A> to its subset <A>sub</A>, and vice versa.
<P/>
<Ref Oper="UseSubsetRelation"/> is designed to be called automatically
whenever substructures of domains are constructed.
So the methods must be <E>cheap</E>, and the requirements should be as
sharp as possible!
<P/>
To achieve that <E>all</E> applicable methods are executed, all methods for
this operation except the default method must end with <C>TryNextMethod()</C>.
This default method deals with the information that is available by
the calls of <Ref Func="InstallSubsetMaintenance"/> in the &GAP; library.
<P/>
<Example><![CDATA[
gap> g:= Group( (1,2), (3,4), (5,6) );; h:= Group( (1,2), (3,4) );;
gap> IsAbelian( g );  HasIsAbelian( h );
true
false
gap> UseSubsetRelation( g, h );;  HasIsAbelian( h );  IsAbelian( h );
true
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="UseFactorRelation" Arg='numer, denom, factor'/>

<Description>
Methods for this operation transfer possibly useful information from the
domain <A>numer</A> or its subset <A>denom</A> to the domain
<A>factor</A> that is isomorphic to the factor of <A>numer</A> by
<A>denom</A>, and vice versa.
<A>denom</A> may be <K>fail</K>, for example if <A>factor</A> is just
known to be a factor of <A>numer</A> but <A>denom</A> is not available as
a &GAP; object;
in this case those factor relations are used that are installed without
special requirements for <A>denom</A>.
<P/>
<Ref Oper="UseFactorRelation"/> is designed to be called automatically
whenever factor structures of domains are constructed.
So the methods must be <E>cheap</E>, and the requirements should be as
sharp as possible!
<P/>
To achieve that <E>all</E> applicable methods are executed, all methods
for this operation except the default method must end with a call to
<Ref Func="TryNextMethod"/>.
This default method deals with the information that is available by
the calls of <Ref Func="InstallFactorMaintenance"/> in the &GAP; library.
<P/>
<Example><![CDATA[
gap> g:= Group( (1,2,3,4), (1,2) );; h:= Group( (1,2,3), (1,2) );;
gap> IsSolvableGroup( g );  HasIsSolvableGroup( h );
true
false
gap> UseFactorRelation(g, Subgroup( g, [ (1,2)(3,4), (1,3)(2,4) ] ), h);;
gap> HasIsSolvableGroup( h );  IsSolvableGroup( h );
true
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="UseIsomorphismRelation" Arg='old, new'/>

<Description>
Methods for this operation transfer possibly useful information from the
domain <A>old</A> to the isomorphic domain <A>new</A>.
<P/>
<Ref Oper="UseIsomorphismRelation"/> is designed to be called
automatically whenever isomorphic structures of domains are constructed.
So the methods must be <E>cheap</E>, and the requirements should be as
sharp as possible!
<P/>
To achieve that <E>all</E> applicable methods are executed, all methods
for this operation except the default method must end with a call to
<Ref Func="TryNextMethod"/>.
This default method deals with the information that is available by
the calls of <Ref Func="InstallIsomorphismMaintenance"/> in the &GAP;
library.
<P/>
<Example><![CDATA[
gap> g:= Group( (1,2) );;  h:= Group( [ [ -1 ] ] );;
gap> Size( g );  HasSize( h );
2
false
gap> UseIsomorphismRelation( g, h );;  HasSize( h );  Size( h );
true
2
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="InstallSubsetMaintenance" Arg='opr, super_req, sub_req'/>

<Description>
<A>opr</A> must be a property or an attribute.
The call of <Ref Func="InstallSubsetMaintenance"/> has the effect that
for a domain <M>D</M> in the filter <A>super_req</A>,
and a domain <M>S</M> in the filter <A>sub_req</A>,
the call <C>UseSubsetRelation</C><M>( D, S )</M>
(see&nbsp;<Ref Func="UseSubsetRelation"/>)
sets a known value of <A>opr</A> for <M>D</M> as value of <A>opr</A> also
for <M>S</M>.
A typical example for which <Ref Func="InstallSubsetMaintenance"/> is
applied is given by <A>opr</A> <C>= IsFinite</C>,
<A>super_req</A> <C>= IsCollection and IsFinite</C>,
and <A>sub_req</A> <C>= IsCollection</C>.
<P/>
If <A>opr</A> is a property and the filter <A>super_req</A> lies in the
filter <A>opr</A> then we can use also the following inverse implication.
If <M>D</M> is in the filter whose intersection with <A>opr</A> is
<A>super_req</A> and if <M>S</M> is in the filter <A>sub_req</A>,
<M>S</M> is a subset of <M>D</M>, and the value of <A>opr</A> for
<M>S</M> is <K>false</K> then the value of <A>opr</A> for <M>D</M> is
also <K>false</K>.
<!-- This is implemented only for the case <A>super_req</A> = <A>opr</A>
     and <A>sub_req</A>.-->
</Description>
</ManSection>

<ManSection>
<Func Name="InstallFactorMaintenance"
 Arg='opr, numer_req, denom_req, factor_req'/>

<Description>
<A>opr</A> must be a property or an attribute.
The call of <Ref Func="InstallFactorMaintenance"/> has the effect that
for collections <M>N</M>, <M>D</M>, <M>F</M> in the filters
<A>numer_req</A>, <A>denom_req</A>, and <A>factor_req</A>, respectively,
the call <C>UseFactorRelation</C><M>( N, D, F )</M>
(see&nbsp;<Ref Func="UseFactorRelation"/>)
sets a known value of <A>opr</A> for <M>N</M> as value of <A>opr</A> also
for <M>F</M>.
A typical example for which <Ref Func="InstallFactorMaintenance"/> is
applied is given by <A>opr</A> <C>= IsFinite</C>,
<A>numer_req</A> <C>= IsCollection and IsFinite</C>,
<A>denom_req</A> <C>= IsCollection</C>,
and <A>factor_req</A> <C>= IsCollection</C>.
<P/>
For the other direction, if <A>numer_req</A> involves the filter
<A>opr</A> then a known <K>false</K> value of <A>opr</A> for <M>F</M>
implies a <K>false</K> value for <M>D</M> provided that <M>D</M> lies in
the filter obtained from <A>numer_req</A> by removing <A>opr</A>.
<P/>
Note that an implication of a factor relation holds in particular for the
case of isomorphisms.
So one need <E>not</E> install an isomorphism maintained method when
a factor maintained method is already installed.
For example, <Ref Func="UseIsomorphismRelation"/>
will transfer a known <Ref Prop="IsFinite"/> value because of the
installed factor maintained method.
</Description>
</ManSection>

<ManSection>
<Func Name="InstallIsomorphismMaintenance" Arg='opr, old_req, new_req'/>

<Description>
<A>opr</A> must be a property or an attribute.
The call of <Ref Func="InstallIsomorphismMaintenance"/> has the effect
that for a domain <M>D</M> in the filter <A>old_req</A>,
and a domain <M>E</M> in the filter <A>new_req</A>,
the call <C>UseIsomorphismRelation</C><M>( D, E )</M>
(see&nbsp;<Ref Func="UseIsomorphismRelation"/>)
sets a known value of <A>opr</A> for <M>D</M> as value of <A>opr</A> also
for <M>E</M>.
A typical example for which <Ref Func="InstallIsomorphismMaintenance"/>
is applied is given by <A>opr</A> <C>= Size</C>,
<A>old_req</A> <C>= IsCollection</C>,
and <A>new_req</A> <C>= IsCollection</C>.
<!-- Up to now, there are no dependencies between the maintenances-->
<!-- (contrary to the case of subset maintenances),-->
<!-- so we do not take care of the succession.-->
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Useful Categories of Elements">
<Heading>Useful Categories of Elements</Heading>

This section and the following one are rather technical,
and may be interesting only for those &GAP; users who want to implement
new kinds of elements.
<P/>
It deals with certain categories of elements that are useful mainly for the
design of elements, from the viewpoint that one wants to form certain domains
of these elements.
For example, a domain closed under multiplication <C>*</C> (a so-called magma,
see Chapter&nbsp;<Ref Chap="Magmas"/>) makes sense only if its elements can be multiplied,
and the latter is indicated by the category
<Ref Func="IsMultiplicativeElement"/> for each element.
Again note that the underlying idea is that a domain is regarded as
<E>generated</E> by given elements, and that these elements carry information
about the desired domain.
For general information on categories and their hierarchies,
see&nbsp;<Ref Sect="Categories"/>.
<P/>
More special categories of this kind are described in the contexts where
they arise,
they are <Ref Func="IsRowVector"/>,
<Ref Func="IsMatrix"/>,
<Ref Func="IsOrdinaryMatrix"/>,
and <Ref Func="IsLieMatrix"/>.
<P/>
<ManSection>
<Filt Name="IsExtAElement" Arg='obj' Type='Category'/>

<Description>
An <E>external additive element</E> is an object that can be added via
<C>+</C> with other elements
(not necessarily in the same family, see&nbsp;<Ref Sect="Families"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearAdditiveElement" Arg='obj' Type='Category'/>

<Description>
A <E>near-additive element</E> is an object that can be added via
<C>+</C> with elements in its family (see&nbsp;<Ref Sect="Families"/>);
this addition is not necessarily commutative.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditiveElement" Arg='obj' Type='Category'/>

<Description>
An <E>additive element</E> is an object that can be added via <C>+</C>
with elements in its family (see&nbsp;<Ref Sect="Families"/>);
this addition is commutative.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearAdditiveElementWithZero" Arg='obj' Type='Category'/>

<Description>
A <E>near-additive element-with-zero</E> is an object that can be added
via <C>+</C> with elements in its family
(see&nbsp;<Ref Sect="Families"/>),
and that is an admissible argument for the operation <Ref Func="Zero"/>;
this addition is not necessarily commutative.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditiveElementWithZero" Arg='obj' Type='Category'/>

<Description>
An <E>additive element-with-zero</E> is an object that can be added
via <C>+</C> with elements in its family
(see&nbsp;<Ref Sect="Families"/>),
and that is an admissible argument for the operation <Ref Func="Zero"/>;
this addition is commutative.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearAdditiveElementWithInverse" Arg='obj' Type='Category'/>

<Description>
A <E>near-additive element-with-inverse</E> is an object that can be
added via <C>+</C> with elements in its family
(see&nbsp;<Ref Sect="Families"/>),
and that is an admissible argument for the operations <Ref Func="Zero"/>
and <Ref Func="AdditiveInverse"/>;
this addition is not necessarily commutative.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditiveElementWithInverse" Arg='obj' Type='Category'/>

<Description>
An <E>additive element-with-inverse</E> is an object that can be
added via <C>+</C> with elements in its family
(see&nbsp;<Ref Sect="Families"/>),
and that is an admissible argument for the operations <Ref Func="Zero"/>
and <Ref Func="AdditiveInverse"/>;
this addition is commutative.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsExtLElement" Arg='obj' Type='Category'/>

<Description>
An <E>external left element</E> is an object that can be multiplied
from the left, via <C>*</C>, with other elements
(not necessarily in the same family, see&nbsp;<Ref Sect="Families"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsExtRElement" Arg='obj' Type='Category'/>

<Description>
An <E>external right element</E> is an object that can be multiplied
from the right, via <C>*</C>, with other elements
(not necessarily in the same family, see&nbsp;<Ref Sect="Families"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMultiplicativeElement" Arg='obj' Type='Category'/>

<Description>
A <E>multiplicative element</E> is an object that can be multiplied via
<C>*</C> with elements in its family (see&nbsp;<Ref Sect="Families"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMultiplicativeElementWithOne" Arg='obj' Type='Category'/>

<Description>
A <E>multiplicative element-with-one</E> is an object that can be
multiplied via <C>*</C> with elements in its family
(see&nbsp;<Ref Sect="Families"/>),
and that is an admissible argument for the operation <Ref Func="One"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMultiplicativeElementWithZero" Arg='elt' Type='Category'/>
<Returns><K>true</K> or <K>false</K>.</Returns>
<Description>
This is the category of elements in a family which can be the operands of 
<C>*</C> (multiplication) and the operation 
<Ref Attr="MultiplicativeZero"/>.
<Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 1, 1, 1 ] ));;
gap> M:=MagmaWithZeroAdjoined(S);
<<commutative transformation semigroup of degree 3 with 1 generator>
  with 0 adjoined>
gap> x:=Representative(M);
<semigroup with 0 adjoined elt: Transformation( [ 1, 1, 1 ] )>
gap> IsMultiplicativeElementWithZero(x);
true
gap> MultiplicativeZeroOp(x);
<semigroup with 0 adjoined elt: 0>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMultiplicativeElementWithInverse" Arg='obj'
 Type='Category'/>

<Description>
A <E>multiplicative element-with-inverse</E> is an object that can be
multiplied via <C>*</C> with elements in its family
(see&nbsp;<Ref Sect="Families"/>),
and that is an admissible argument for the operations <Ref Func="One"/>
and <Ref Func="Inverse"/>. (Note the word <Q>admissible</Q>: an
object in this category does not necessarily have an inverse,
<Ref Func="Inverse"/> may return <K>fail</K>.)
</Description>
</ManSection>

<ManSection>
<Filt Name="IsVector" Arg='obj' Type='Category'/>

<Description>
A <E>vector</E> is an additive-element-with-inverse that can be
multiplied from the left and right with other objects
(not necessarily of the same type).
Examples are cyclotomics, finite field elements,
and of course row vectors (see below).
<P/>
Note that not all lists of ring elements are regarded as vectors,
for example lists of matrices are not vectors.
This is because although the category
<Ref Func="IsAdditiveElementWithInverse"/> is
implied by the meet of its collections category and <Ref Func="IsList"/>,
the family of a list entry may not imply
<Ref Func="IsAdditiveElementWithInverse"/> for all its elements.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearRingElement" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsNearRingElement"/> is just a synonym for the meet of
<Ref Func="IsNearAdditiveElementWithInverse"/> and
<Ref Func="IsMultiplicativeElement"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRingElement" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsRingElement"/> is just a synonym for the meet of
<Ref Func="IsAdditiveElementWithInverse"/> and
<Ref Func="IsMultiplicativeElement"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearRingElementWithOne" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsNearRingElementWithOne"/> is just a synonym for the meet of
<Ref Func="IsNearAdditiveElementWithInverse"/> and
<Ref Func="IsMultiplicativeElementWithOne"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRingElementWithOne" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsRingElementWithOne"/> is just a synonym for the meet of
<Ref Func="IsAdditiveElementWithInverse"/> and
<Ref Func="IsMultiplicativeElementWithOne"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearRingElementWithInverse" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsNearRingElementWithInverse"/> is just a synonym for the meet of
<Ref Func="IsNearAdditiveElementWithInverse"/> and
<Ref Func="IsMultiplicativeElementWithInverse"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRingElementWithInverse" Arg='obj' Type='Category'/>
<Filt Name="IsScalar" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsRingElementWithInverse"/> and <Ref Func="IsScalar"/>
are just synonyms for the meet of
<Ref Func="IsAdditiveElementWithInverse"/> and
<Ref Func="IsMultiplicativeElementWithInverse"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Useful Categories for all Elements of a Family">
<Heading>Useful Categories for all Elements of a Family</Heading>

The following categories of elements are to be understood mainly as
categories for all objects in a family,
they are usually used as third argument of <C>NewFamily</C>
(see&nbsp;<Ref Sect="Creating Families"/>).
The purpose of each of the following categories is then to guarantee that
each collection of its elements automatically lies in its collections
category (see&nbsp;<Ref Func="CategoryCollections"/>).
<P/>
For example, the multiplication of permutations is associative,
and it is stored in the family of permutations that each permutation lies
in <Ref Func="IsAssociativeElement"/>.
As a consequence, each magma consisting of permutations
(more precisely: each collection that lies in the family
<C>CollectionsFamily( PermutationsFamily )</C>,
see&nbsp;<Ref Func="CollectionsFamily"/>)
automatically lies in <C>CategoryCollections( IsAssociativeElement )</C>.
A magma in this category is always known to be associative, via a logical
implication (see&nbsp;<Ref Sect="Logical Implications"/>).
<P/>
Similarly, if a family knows that all its elements are in the categories
<Ref Func="IsJacobianElement"/> and <Ref Func="IsZeroSquaredElement"/>,
then each algebra of these elements is automatically known to be a
Lie algebra (see Chapter&nbsp;<Ref Chap="Algebras"/>).

<ManSection>
<Filt Name="IsAssociativeElement" Arg='obj' Type='Category'/>
<Filt Name="IsAssociativeElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsAssociativeElementCollColl" Arg='obj' Type='Category'/>

<Description>
An element <A>obj</A> in the category <Ref Func="IsAssociativeElement"/>
knows that the multiplication of any elements in the family of <A>obj</A>
is associative.
For example, all permutations lie in this category, as well as those
ordinary matrices (see&nbsp;<Ref Func="IsOrdinaryMatrix"/>)
whose entries are also in <Ref Func="IsAssociativeElement"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditivelyCommutativeElement" Arg='obj' Type='Category'/>
<Filt Name="IsAdditivelyCommutativeElementCollection" Arg='obj'
 Type='Category'/>
<Filt Name="IsAdditivelyCommutativeElementCollColl" Arg='obj'
 Type='Category'/>
<Filt Name="IsAdditivelyCommutativeElementFamily" Arg='obj'
 Type='Category'/>

<Description>
An element <A>obj</A> in the category
<Ref Func="IsAdditivelyCommutativeElement"/> knows
that the addition of any elements in the family of <A>obj</A>
is commutative.
For example, each finite field element and each rational number lies in
this category.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsCommutativeElement" Arg='obj' Type='Category'/>
<Filt Name="IsCommutativeElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsCommutativeElementCollColl" Arg='obj' Type='Category'/>

<Description>
An element <A>obj</A> in the category <Ref Func="IsCommutativeElement"/>
knows that the multiplication of any elements in the family of <A>obj</A>
is commutative.
For example, each finite field element and each rational number lies in
this category.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFiniteOrderElement" Arg='obj' Type='Category'/>
<Filt Name="IsFiniteOrderElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsFiniteOrderElementCollColl" Arg='obj' Type='Category'/>

<Description>
An element <A>obj</A> in the category <Ref Func="IsFiniteOrderElement"/>
knows that it has finite multiplicative order.
For example, each finite field element and each permutation lies in
this category.
However the value may be <K>false</K> even if <A>obj</A> has finite
order, but if this was not known when <A>obj</A> was constructed.
<P/>
Although it is legal to set this filter for any object with finite order,
this is really useful only in the case that all elements of a family are
known to have finite order.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsJacobianElement" Arg='obj' Type='Category'/>
<Filt Name="IsJacobianElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsJacobianElementCollColl" Arg='obj' Type='Category'/>
<Filt Name="IsRestrictedJacobianElement" Arg='obj' Type='Category'/>
<Filt Name="IsRestrictedJacobianElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsRestrictedJacobianElementCollColl" Arg='obj' Type='Category'/>

<Description>
An element <A>obj</A> in the category <Ref Func="IsJacobianElement"/>
knows that the multiplication of any elements in the family <M>F</M>
of <A>obj</A> satisfies the Jacobi identity, that is,
<M>x * y * z + z * x * y + y * z * x</M> is zero
for all <M>x</M>, <M>y</M>, <M>z</M> in <M>F</M>.
<P/>
For example, each Lie matrix (see&nbsp;<Ref Func="IsLieMatrix"/>)
lies in this category.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsZeroSquaredElement" Arg='obj' Type='Category'/>
<Filt Name="IsZeroSquaredElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsZeroSquaredElementCollColl" Arg='obj' Type='Category'/>

<Description>
An element <A>obj</A> in the category <Ref Func="IsZeroSquaredElement"/>
knows that <C><A>obj</A>^2 = Zero( <A>obj</A> )</C>.
For example, each Lie matrix (see&nbsp;<Ref Func="IsLieMatrix"/>)
lies in this category.
<P/>
Although it is legal to set this filter for any zero squared object,
this is really useful only in the case that all elements of a family are
known to have square zero.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  mapping.msk                  GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: mapping.msk,v 1.20 2002/04/15 10:02:30 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Mappings">
<Heading>Mappings</Heading>

<Index Subkey="as in mathematics">functions</Index>
<Index>relations</Index>
A <E>mapping</E> in &GAP; is what is called a <Q>function</Q> in mathematics.
&GAP; also implements <E>generalized mappings</E> in which one element might
have several images, these can be imagined as subsets of the cartesian
product and are often called <Q>relations</Q>.
<P/>
Most operations are declared for general mappings and therefore this manual
often  refers to <Q>(general) mappings</Q>, unless you deliberately need the
generalization you can ignore the <Q>general</Q> bit and just read
it as <Q>mappings</Q>.
<P/>
A <E>general mapping</E> <M>F</M> in &GAP; is described by
its source <M>S</M>, its range <M>R</M>, and a subset <M>Rel</M> of the
direct product <M>S \times R</M>,
which is called the underlying relation of <M>F</M>.
<M>S</M>, <M>R</M>, and <M>Rel</M> are generalized domains
(see <Ref Chap="Domains"/>).
The corresponding attributes for general mappings are
<Ref Func="Source"/>, <Ref Func="Range" Label="of a general mapping"/>,
and <Ref Func="UnderlyingRelation"/>.
<!-- what about the family predicates if the source/range is not a -->
<!-- collection? -->
<P/>
Note that general mappings themselves are <E>not</E> domains.
One reason for this is that two general mappings with same underlying
relation are regarded as equal only if also the sources are equal and
the ranges are equal.
Other, more technical, reasons are that general mappings and domains
have different basic operations, and that general mappings are
arithmetic objects
(see&nbsp;<Ref Sect="Arithmetic Operations for General Mappings"/>);
both should not apply to domains.
<P/>
Each element of an underlying relation of a general mapping lies in the
category of direct product elements
(see&nbsp;<Ref Func="IsDirectProductElement"/>).
<P/>
For each <M>s \in S</M>, the set <M>\{ r \in R | (s,r) \in Rel \}</M>
is called the set of <E>images</E> of <M>s</M>.
Analogously, for <M>r \in R</M>,
the set <M>\{ s \in S | (s,r) \in Rel \}</M>
is called the set of <E>preimages</E> of <M>r</M>.
<P/>
The <E>ordering</E> of general mappings via <C>&lt;</C> is defined
by the ordering of source, range, and underlying relation.
Specifically, if the source and range domains of <A>map1</A> and
<A>map2</A> are the same, then one considers  the union of the preimages
of <A>map1</A> and <A>map2</A> as a strictly ordered set.
The smaller of <A>map1</A> and <A>map2</A> is the one whose image is
smaller on the  first point of this sequence where they differ.

<P/>
For mappings which preserve an algebraic structure a <E>kernel</E> is
defined.
Depending on the structure preserved the operation to compute this kernel is
called differently,
see Section&nbsp;<Ref Sect="Mappings which are Compatible with Algebraic Structures"/>.
<P/>
Some technical details of general mappings are described in
section&nbsp;<Ref Sect="General Mappings"/>.

<!-- %%  The general support for mappings is due to Thomas Breuer. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsDirectProductElement">
<Heading>IsDirectProductElement (Filter)</Heading>

<ManSection>
<Filt Name="IsDirectProductElement" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsDirectProductElement"/> is a subcategory of the meet of
<Ref Func="IsDenseList"/>,
<Ref Func="IsMultiplicativeElementWithInverse"/>,
<Ref Func="IsAdditiveElementWithInverse"/>,
and <Ref Func="IsCopyable"/>,
where the arithmetic operations (addition, zero, additive inverse,
multiplication, powering, one, inverse) are defined componentwise.
<P/>
Note that each of these operations will cause an error message if
its result for at least one component cannot be formed.
<P/>
For an object in the filter <Ref Func="IsDirectProductElement"/>,
<Ref Func="ShallowCopy"/> returns a mutable plain list with the same
entries.
The sum and the product of a direct product element and a list in
<Ref Func="IsListDefault"/> is the list of sums and products,
respectively.
The sum and the product of a direct product element and a non-list
is the direct product element of componentwise sums and products,
respectively.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Mappings">
<Heading>Creating Mappings</Heading>

<ManSection>
<Func Name="GeneralMappingByElements" Arg='S, R, elms'/>

<Description>
is the general mapping with source <A>S</A> and range <A>R</A>,
and with underlying relation consisting of the collection <A>elms</A>
of direct product elements.
</Description>
</ManSection>

<ManSection>
<Heading>MappingByFunction</Heading>
<Func Name="MappingByFunction" Arg='S, R, fun[, invfun]'
 Label="by function (and inverse function) between two domains"/>
<Func Name="MappingByFunction" Arg='S, R, fun, false, prefun'
 Label="by function and function that computes one preimage"/>

<Description>
<Ref Func="MappingByFunction" Label="by function (and inverse function) between two domains"/>
returns a mapping <C>map</C> with source
<A>S</A> and range <A>R</A>,
such that each element <M>s</M> of <A>S</A> is mapped to the element
<A>fun</A><M>( s )</M>, where <A>fun</A> is a &GAP; function.
<P/>
If the argument <A>invfun</A> is bound then <C>map</C> is a bijection
between <A>S</A> and <A>R</A>, and the preimage of each element <M>r</M>
of <A>R</A> is given by <A>invfun</A><M>( r )</M>,
where <A>invfun</A> is a &GAP;  function.
<P/>
If five arguments are given and the fourth argument is <K>false</K> then
the &GAP; function <A>prefun</A> can be used to compute a single preimage
also if <C>map</C> is not bijective.
<!-- what is <A>prefun</A> expected to return for <A>r</A> outside the image of <A>map</A>-->
<!-- if <A>map</A> is not surjective?-->
<!-- or must <A>map</A> be surjective in this case?-->
<P/>
The mapping returned by
<Ref Func="MappingByFunction" Label="by function (and inverse function) between two domains"/> lies in the
filter <Ref Func="IsNonSPGeneralMapping"/>,
see&nbsp;<Ref Sect="Technical Matters Concerning General Mappings"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="InverseGeneralMapping" Arg='map'/>

<Description>
The <E>inverse general mapping</E> of a general mapping <A>map</A> is
the general mapping whose underlying relation
(see&nbsp;<Ref Func="UnderlyingRelation"/>) contains a pair <M>(r,s)</M>
if and only if the underlying relation of <A>map</A> contains the pair
<M>(s,r)</M>.
<P/>
See the introduction to Chapter&nbsp;<Ref Chap="Mappings"/>
for the subtleties concerning the difference between
<Ref Func="InverseGeneralMapping"/> and <Ref Func="Inverse"/>.
<P/>
Note that the inverse general mapping of a mapping <A>map</A> is
in general only a general mapping.
If <A>map</A> knows to be bijective its inverse general mapping will know
to be a mapping.
In this case also <C>Inverse( <A>map</A> )</C> works.
</Description>
</ManSection>

<ManSection>
<Func Name="CompositionMapping" Arg='map1, map2, ...'/>

<Description>
<Ref Func="CompositionMapping"/> allows one to compose arbitrarily many
general mappings,
and delegates each step to <Ref Func="CompositionMapping2"/>.
<P/>
Additionally, the properties <Ref Func="IsInjective"/> and
<Ref Func="IsSingleValued"/> are maintained;
if the source of the <M>i+1</M>-th general mapping is identical to
the range of the <M>i</M>-th general mapping,
also <Ref Func="IsTotal"/> and <Ref Func="IsSurjective"/> are maintained.
(So one should not call <Ref Func="CompositionMapping2"/> directly
if one wants to maintain these properties.)
<P/>
Depending on the types of <A>map1</A> and <A>map2</A>,
the returned mapping might be constructed completely new (for example by
giving domain generators and their images, this is for example the case
if both mappings preserve the same algebraic structures and &GAP; can
decompose elements of the source of <A>map2</A> into generators) or as an
(iterated) composition
(see&nbsp;<Ref Func="IsCompositionMappingRep"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="CompositionMapping2" Arg='map2, map1'/>
<Func Name="CompositionMapping2General" Arg='map2, map1'/>

<Description>
<Ref Func="CompositionMapping2"/> returns the composition of <A>map2</A>
and <A>map1</A>,
this is the general mapping that maps an element first under <A>map1</A>,
and then maps the images under <A>map2</A>.
<P/>
(Note the reverse ordering of arguments in the composition via
the multiplication <Ref Func="\*"/>.
<P/>
<Ref Func="CompositionMapping2General"/> is the method that forms a
composite mapping with two constituent mappings.
(This is used in some algorithms.)
</Description>
</ManSection>

<ManSection>
<Filt Name="IsCompositionMappingRep" Arg='map' Type='Representation'/>

<Description>
Mappings in this representation are stored as composition of two
mappings, (pre)images of elements are computed in a two-step process.
The constituent mappings of the composition can be obtained via
<Ref Func="ConstituentsCompositionMapping"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ConstituentsCompositionMapping" Arg='map'/>

<Description>
If <A>map</A> is stored in the representation
<Ref Func="IsCompositionMappingRep"/> as composition of two mappings
<A>map1</A> and <A>map2</A>, this function returns the
two constituent mappings in a list <C>[ <A>map1</A>, <A>map2</A> ]</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ZeroMapping" Arg='S, R'/>

<Description>
A zero mapping is a total general mapping that maps each element of its
source to the zero element of its range.
<P/>
(Each mapping with empty source is a zero mapping.)
</Description>
</ManSection>

<ManSection>
<Attr Name="IdentityMapping" Arg='D'/>

<Description>
is the bijective mapping with source and range equal to the collection
<A>D</A>, which maps each element of <A>D</A> to itself.
</Description>
</ManSection>

<ManSection>
<Heading>Embedding</Heading>
<Oper Name="Embedding" Arg='S, T' Label="for two domains"/>
<Oper Name="Embedding" Arg='S, i'
 Label="for a domain and a positive integer"/>

<Description>
returns the embedding of the domain <A>S</A> in the domain <A>T</A>,
or in the second form, some domain indexed by the positive integer
<A>i</A>.
The precise natures of the various methods are described elsewhere:
for Lie algebras, see <Ref Func="LieFamily"/>; for group  products,
see&nbsp;<Ref Sect="Embeddings and Projections for Group Products"/>
for a general description, or for examples
see&nbsp;<Ref Sect="Direct Products"/> for direct products,
<Ref Sect="Semidirect Products"/> for semidirect products,
or&nbsp;<Ref Sect="Wreath Products"/> for wreath products; or for
magma rings
see&nbsp;<Ref Sect="Natural Embeddings related to Magma Rings"/>.
</Description>
</ManSection>

<ManSection>
<Heading>Projection</Heading>
<Oper Name="Projection" Arg='S, T' Label="for two domains"/>
<Oper Name="Projection" Arg='S, i'
 Label="for a domain and a positive integer"/>
<Oper Name="Projection" Arg='S' Label="for a domain"/>

<Description>
returns the projection of the domain <A>S</A> onto the domain <A>T</A>,
or in the second form, some domain indexed by the positive integer
<A>i</A>,
or in the third form some natural quotient domain of <A>S</A>.
Various methods are defined for group products;
see&nbsp;<Ref Sect="Embeddings and Projections for Group Products"/> for
a general description,
or for examples see&nbsp;<Ref Sect="Direct Products"/> for direct
products, <Ref Sect="Semidirect Products"/> for semidirect products,
<Ref Sect="Subdirect Products"/> for subdirect products,
or&nbsp;<Ref Sect="Wreath Products"/> for wreath products.
</Description>
</ManSection>

<ManSection>
<Oper Name="RestrictedMapping" Arg='map, subdom'/>

<Description>
If <A>subdom</A> is a subdomain of the source of the general mapping
<A>map</A>,
this operation returns the restriction of <A>map</A> to <A>subdom</A>.
<!--  The general concept of restricted general mappings still missing.-->
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties and Attributes of (General) Mappings">
<Heading>Properties and Attributes of (General) Mappings</Heading>

<ManSection>
<Prop Name="IsTotal" Arg='map'/>

<Description>
is <K>true</K> if each element in the source <M>S</M>
of the general mapping <A>map</A> has images, i.e.,
<M>s^{<A>map</A>} \neq \emptyset</M> for all <M>s \in S</M>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSingleValued" Arg='map'/>

<Description>
is <K>true</K> if each element in the source <M>S</M>
of the general mapping <A>map</A> has at most one image, i.e.,
<M>|s^{<A>map</A>}| \leq 1</M> for all <M>s \in S</M>,
and <K>false</K> otherwise.
<P/>
Equivalently, <C>IsSingleValued( <A>map</A> )</C> is <K>true</K>
if and only if the preimages of different elements in <M>R</M> are
disjoint.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsMapping" Arg='map'/>

<Description>
A <E>mapping</E> <A>map</A> is a general mapping that assigns to each
element <C>elm</C> of its source a unique element
<C>Image( <A>map</A>, elm )</C> of its range.
<P/>
Equivalently, the general mapping <A>map</A> is a mapping if and only if
it is total and single-valued
(see&nbsp;<Ref Func="IsTotal"/>, <Ref Func="IsSingleValued"/>).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsInjective" Arg='map'/>

<Description>
is <K>true</K> if the images of different elements in the source <M>S</M>
of the general mapping <A>map</A> are disjoint, i.e.,
<M>x^{<A>map</A>} \cap y^{<A>map</A>} = \emptyset</M>
for <M>x \neq y \in S</M>,
and <K>false</K> otherwise.
<P/>
Equivalently, <C>IsInjective( <A>map</A> )</C> is <K>true</K>
if and only if each element in the range of <A>map</A> has at most one
preimage in <M>S</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSurjective" Arg='map'/>

<Description>
is <K>true</K> if each element in the range <M>R</M>
of the general mapping <A>map</A> has preimages in the source <M>S</M>
of <A>map</A>, i.e.,
<M>\{ s \in S \mid x \in s^{<A>map</A>} \} \neq \emptyset</M>
for all <M>x \in R</M>, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsBijective" Arg='map'/>

<Description>
A general mapping <A>map</A> is <E>bijective</E> if and only if it is
an injective and surjective mapping (see&nbsp;<Ref Func="IsMapping"/>,
<Ref Func="IsInjective"/>, <Ref Func="IsSurjective"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="Range" Arg='map' Label="of a general mapping"/>

<Description>
The range of a general mapping.
</Description>
</ManSection>

<ManSection>
<Attr Name="Source" Arg='map'/>

<Description>
The source of a general mapping.
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingRelation" Arg='map'/>

<Description>
The <E>underlying relation</E> of a general mapping <A>map</A> is the
domain of pairs <M>(s,r)</M>, with <M>s</M> in the source and <M>r</M> in
the range of <A>map</A> (see&nbsp;<Ref Func="Source"/>,
<Ref Func="Range" Label="of a general mapping"/>),
and <M>r \in</M> <C>ImagesElm( <A>map</A>, </C><M>s</M><C> )</C>.
<P/>
Each element of the underlying relation is represented by
a direct product element (see&nbsp;<Ref Func="IsDirectProductElement"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingGeneralMapping" Arg='map'/>

<Description>
attribute for underlying relations of general mappings
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Images under Mappings">
<Heading>Images under Mappings</Heading>

<ManSection>
<Attr Name="ImagesSource" Arg='map'/>

<Description>
is the set of images of the source of the general mapping <A>map</A>.
<P/>
<Ref Func="ImagesSource"/> delegates to <Ref Func="ImagesSet"/>,
it is introduced only to store the image of <A>map</A> as attribute
value.
</Description>
</ManSection>

<ManSection>
<Oper Name="ImagesRepresentative" Arg='map,elm'/>

<Description>
If <A>elm</A> is an element of the source of the general mapping
<A>map</A> then <Ref Func="ImagesRepresentative"/> returns either
a representative of the set of images of <A>elm</A> under <A>map</A>
or <K>fail</K>, the latter if and only if <A>elm</A> has no images under
<A>map</A>.
<P/>
Anything may happen if <A>elm</A> is not an element of the source of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ImagesElm" Arg='map, elm'/>

<Description>
If <A>elm</A> is an element of the source of the general mapping
<A>map</A> then <Ref Func="ImagesElm"/> returns the set of all images
of <A>elm</A> under <A>map</A>.
<P/>
Anything may happen if <A>elm</A> is not an element of the source of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ImagesSet" Arg='map, elms'/>

<Description>
If <A>elms</A> is a subset of the source of the general mapping
<A>map</A> then <Ref Func="ImagesSet"/> returns the set of all images of
<A>elms</A> under <A>map</A>.
<P/>
The result will be either a proper set or a domain.
Anything may happen if <A>elms</A> is not a subset of the source of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ImageElm" Arg='map, elm'/>

<Description>
If <A>elm</A> is an element of the source of the total and single-valued
mapping <A>map</A> then
<Ref Func="ImageElm"/> returns the unique image of <A>elm</A> under
<A>map</A>.
<P/>
Anything may happen if <A>elm</A> is not an element of the source of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Heading>Image</Heading>
<Func Name="Image" Arg='map'
 Label="set of images of the source of a general mapping"/>
<Func Name="Image" Arg='map, elm'
 Label="unique image of an element under a mapping"/>
<Func Name="Image" Arg='map, coll'
 Label="set of images of a collection under a mapping"/>

<Description>
<C>Image( <A>map</A> )</C> is the <E>image</E> of the general mapping
<A>map</A>, i.e.,
the subset of elements of the range of <A>map</A>
that are actually values of <A>map</A>.
<E>Note</E> that in this case the argument may also be multi-valued.
<P/>
<C>Image( <A>map</A>, <A>elm</A> )</C> is the image of the element
<A>elm</A> of the source of the mapping <A>map</A> under <A>map</A>,
i.e., the unique element of the range to which <A>map</A> maps
<A>elm</A>.
This can also be expressed as <A>elm</A><C>^</C><A>map</A>.
Note that <A>map</A> must be total and single valued,
a multi valued general mapping is not allowed
(see&nbsp;<Ref Func="Images" Label="set of images of the source of a general mapping"/>).
<P/>
<C>Image( <A>map</A>, <A>coll</A> )</C> is the image of the subset
<A>coll</A> of the source of the mapping <A>map</A> under <A>map</A>,
i.e., the subset of the range to which <A>map</A> maps elements of
<A>coll</A>.
<A>coll</A> may be a proper set or a domain.
The result will be either a proper set or a domain.
Note that in this case <A>map</A> may also be multi-valued.
(If <A>coll</A> and the result are lists then the positions of
entries do in general <E>not</E> correspond.)
<P/>
<Ref Func="Image" Label="set of images of the source of a general mapping"/>
delegates to <Ref Func="ImagesSource"/> when called
with one argument, and to <Ref Func="ImageElm"/> resp.
<Ref Func="ImagesSet"/> when called with two arguments.
<P/>
If the second argument is not an element or a subset of the source of
the first argument, an error is signalled.
</Description>
</ManSection>

<ManSection>
<Heading>Images</Heading>
<Func Name="Images" Arg='map'
 Label="set of images of the source of a general mapping"/>
<Func Name="Images" Arg='map, elm'
 Label="set of images of an element under a mapping"/>
<Func Name="Images" Arg='map, coll'
 Label="set of images of a collection under a mapping"/>

<Description>
<C>Images( <A>map</A> )</C> is the <E>image</E> of the general mapping
<A>map</A>, i.e., the subset of elements of the range of <A>map</A>
that are actually values of <A>map</A>.
<P/>
<C>Images( <A>map</A>, <A>elm</A> )</C> is the set of images of the
element <A>elm</A> of the source of the general mapping <A>map</A> under
<A>map</A>, i.e., the set of elements of the range to which <A>map</A>
maps <A>elm</A>.
<P/>
<C>Images( <A>map</A>, <A>coll</A> )</C> is the set of images of the
subset <A>coll</A> of the source of the general mapping <A>map</A> under
<A>map</A>, i.e., the subset of the range to which <A>map</A> maps
elements of <A>coll</A>.
<A>coll</A> may be a proper set or a domain.
The result will be either a proper set or a domain.
(If <A>coll</A> and the result are lists then the positions of
entries do in general <E>not</E> correspond.)
<P/>
<Ref Func="Images" Label="set of images of the source of a general mapping"/>
delegates to <Ref Func="ImagesSource"/> when called
with one argument, and to <Ref Func="ImagesElm"/> resp.
<Ref Func="ImagesSet"/> when called with two arguments.
<P/>
If the second argument is not an element or a subset of the source of
the first argument, an error is signalled.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Preimages under Mappings">
<Heading>Preimages under Mappings</Heading>

<ManSection>
<Attr Name="PreImagesRange" Arg='map'/>

<Description>
is the set of preimages of the range of the general mapping <A>map</A>.
<P/>
<Ref Func="PreImagesRange"/> delegates to <Ref Func="PreImagesSet"/>,
it is introduced only to store the preimage of <A>map</A> as attribute
value.
</Description>
</ManSection>

<ManSection>
<Oper Name="PreImagesElm" Arg='map, elm'/>

<Description>
If <A>elm</A> is an element of the range of the general mapping
<A>map</A> then <Ref Func="PreImagesElm"/> returns the set of all
preimages of <A>elm</A> under <A>map</A>.
<P/>
Anything may happen if <A>elm</A> is not an element of the range of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="PreImageElm" Arg='map, elm'/>

<Description>
If <A>elm</A> is an element of the range of the injective and surjective
general mapping <A>map</A> then
<Ref Func="PreImageElm"/> returns the unique preimage of <A>elm</A> under
<A>map</A>.
<P/>
Anything may happen if <A>elm</A> is not an element of the range of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="PreImagesRepresentative" Arg='map, elm'/>

<Description>
If <A>elm</A> is an element of the range of the general mapping
<A>map</A> then <Ref Func="PreImagesRepresentative"/> returns either a
representative of the set of preimages of <A>elm</A> under <A>map</A> or
<K>fail</K>, the latter if and only if <A>elm</A>
has no preimages under <A>map</A>.
<P/>
Anything may happen if <A>elm</A> is not an element of the range of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="PreImagesSet" Arg='map, elms'/>

<Description>
If <A>elms</A> is a subset of the range of the general mapping <A>map</A>
then <Ref Func="PreImagesSet"/> returns the set of all preimages of
<A>elms</A> under <A>map</A>.
<P/>
Anything may happen if <A>elms</A> is not a subset of the range of
<A>map</A>.
</Description>
</ManSection>

<ManSection>
<Heading>PreImage</Heading>
<Func Name="PreImage" Arg='map'
 Label="set of preimages of the range of a general mapping"/>
<Func Name="PreImage" Arg='map, elm'
 Label="unique preimage of an element under a general mapping"/>
<Func Name="PreImage" Arg='map, coll'
 Label="set of preimages of a collection under a general mapping"/>

<Description>
<C>PreImage( <A>map</A> )</C> is the preimage of the general mapping
<A>map</A>, i.e., the subset of elements of the source of <A>map</A>
that actually have values under <A>map</A>.
Note that in this case the argument may also be non-injective or
non-surjective.
<P/>
<C>PreImage( <A>map</A>, <A>elm</A> )</C> is the preimage of the element
<A>elm</A> of the range of the injective and surjective mapping
<A>map</A> under <A>map</A>, i.e., the unique element of the source
which is mapped under <A>map</A> to <A>elm</A>.
Note that <A>map</A> must be injective and surjective
(see&nbsp;<Ref Func="PreImages" Label="set of preimages of the range of a general mapping"/>).
<P/>
<C>PreImage( <A>map</A>, <A>coll</A> )</C> is the preimage of the subset
<A>coll</A> of the range of the general mapping <A>map</A> under
<A>map</A>, i.e., the subset of the source which is mapped under
<A>map</A> to elements of <A>coll</A>. <A>coll</A> may be a proper set
or a domain.
The result will be either a proper set or a domain.
Note that in this case <A>map</A> may also be non-injective or
non-surjective.
(If <A>coll</A> and the result are lists then the positions of
entries do in general <E>not</E> correspond.)
<P/>
<Ref Func="PreImage" Label="set of preimages of the range of a general mapping"/>
delegates to <Ref Func="PreImagesRange"/> when
called with one argument,
and to <Ref Func="PreImageElm"/> resp. <Ref Func="PreImagesSet"/> when
called with two arguments.
<P/>
If the second argument is not an element or a subset of the range of
the first argument, an error is signalled.
</Description>
</ManSection>

<ManSection>
<Heading>PreImages</Heading>
<Func Name="PreImages" Arg='map'
 Label="set of preimages of the range of a general mapping"/>
<Func Name="PreImages" Arg='map, elm'
 Label="set of preimages of an elm under a general mapping"/>
<Func Name="PreImages" Arg='map, coll'
 Label="set of preimages of a collection under a general mapping"/>

<Description>
<C>PreImages( <A>map</A> )</C> is the preimage of the general mapping
<A>map</A>, i.e., the subset of elements of the source of <A>map</A>
that have actually values under <A>map</A>.
<P/>
<C>PreImages( <A>map</A>, <A>elm</A> )</C> is the set of preimages of the
element <A>elm</A> of the range of the general mapping <A>map</A> under
<A>map</A>, i.e., the set of elements of the source which <A>map</A> maps
to <A>elm</A>.
<P/>
<C>PreImages( <A>map</A>, <A>coll</A> )</C> is the set of images of the
subset <A>coll</A> of the range of the general mapping <A>map</A> under
<A>map</A>, i.e., the subset of the source which <A>map</A> maps to
elements of <A>coll</A>.
<A>coll</A> may be a proper set or a domain.
The result will be either a proper set or a domain.
(If <A>coll</A> and the result are lists then the positions of
entries do in general <E>not</E> correspond.)
<P/>
<Ref Func="PreImages" Label="set of preimages of the range of a general mapping"/>
delegates to <Ref Func="PreImagesRange"/> when
called with one argument,
and to <Ref Func="PreImagesElm"/> resp. <Ref Func="PreImagesSet"/> when
called with two arguments.
<P/>
If the second argument is not an element or a subset of the range of
the first argument, an error is signalled.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Operations for General Mappings">
<Heading>Arithmetic Operations for General Mappings</Heading>

General mappings are arithmetic objects.
One can form groups and vector spaces of general mappings provided
that they are invertible or can be added and admit scalar multiplication,
respectively.
<P/>
For two general mappings with same source, range, preimage, and image,
the <E>sum</E> is defined pointwise, i.e.,
the images of a point under the sum is the set of all sums with
first summand in the images of the first general mapping and
second summand in the images of the second general mapping.
<P/>
<E>Scalar multiplication</E> of general mappings is defined likewise.
<P/>
The <E>product</E> of two general mappings is defined as the composition.
This multiplication is always associative.
In addition to the composition via <C>*</C>,
general mappings can be composed &ndash;in reversed order&ndash;
via <Ref Func="CompositionMapping"/>.
<P/>
General mappings are in the category of multiplicative elements with
inverses.
Similar to matrices, not every general mapping has an inverse or an
identity, and we define the behaviour of <Ref Func="One"/> and
<Ref Func="Inverse"/> for general mappings as follows.
<Ref Func="One"/> returns <K>fail</K> when called for a general mapping
whose source and range differ,
otherwise <Ref Func="One"/> returns the identity mapping of the source.
(Note that the source may differ from the preimage).
<Ref Func="Inverse"/> returns <K>fail</K> when called for a non-bijective
general mapping or for a general mapping whose source and range differ;
otherwise <Ref Func="Inverse"/> returns the inverse mapping.
<P/>
Besides the usual inverse of multiplicative elements, which means that
<C>Inverse( <A>g</A> ) * <A>g</A> = <A>g</A> * Inverse( <A>g</A> )
= One( <A>g</A> )</C>,
for general mappings we have the attribute
<Ref Func="InverseGeneralMapping"/>.
If <A>F</A> is a general mapping with source <M>S</M>, range <M>R</M>,
and underlying relation <M>Rel</M> then
<C>InverseGeneralMapping( <A>F</A> )</C> has source <M>R</M>,
range <M>S</M>,
and underlying relation <M>\{ (r,s) \mid (s,r) \in Rel \}</M>.
For a general mapping that has an inverse in the usual sense,
i.e., for a bijection of the source, of course both concepts coincide.
<P/>
<Ref Func="Inverse"/> may delegate to
<Ref Func="InverseGeneralMapping"/>.
<Ref Func="InverseGeneralMapping"/> must not delegate to
<Ref Func="Inverse"/>,
but a known value of <Ref Func="Inverse"/> may be fetched.
So methods to compute the inverse of a general mapping should be
installed for <Ref Func="InverseGeneralMapping"/>.
<P/>
(Note that in many respects, general mappings behave similar to matrices,
for example one can define left and right identities and inverses, which
do not fit into the current concepts of &GAP;.)


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mappings which are Compatible with Algebraic Structures">
<Heading>Mappings which are Compatible with Algebraic Structures</Heading>

From an algebraical point of view, the most important mappings are those
which are compatible with a structure. For Magmas, Groups and Rings, &GAP;
supports the following four types of such mappings:
<P/>
<Enum>
<Item>
  General mappings that respect multiplication
</Item>
<Item>
  General mappings that respect addition
</Item>
<Item>
  General mappings that respect scalar mult.
</Item>
<Item>
  General mappings that respect multiplicative and additive structure
</Item>
</Enum>
<P/>
(Very technical note:
&GAP; defines categories <C>IsSPGeneralMapping</C> and
<C>IsNonSPGeneralMapping</C>.
The distinction between these is orthogonal to the structure compatibility
described here and should not be confused.)

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Magma Homomorphisms">
<Heading>Magma Homomorphisms</Heading>

<ManSection>
<Prop Name="IsMagmaHomomorphism" Arg='mapp'/>

<Description>
A <E>magma homomorphism</E> is a total single valued mapping
which respects  multiplication.
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaHomomorphismByFunctionNC" Arg='G, H, fn'/>

<Description>
Creates the homomorphism from <A>G</A> to <A>H</A> without checking
that <A>fn</A> is a homomorphism.
</Description>
</ManSection>

<ManSection>
<Oper Name="NaturalHomomorphismByGenerators" Arg='f, s'/>

<Description>
returns a mapping from the magma <A>f</A> with <M>n</M> generators to the
magma <A>s</A> with <M>n</M> generators,
which maps the <M>i</M>-th generator of <A>f</A> to the 
<M>i</M>-th generator of <A>s</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mappings that Respect Multiplication">
<Heading>Mappings that Respect Multiplication</Heading>

<ManSection>
<Prop Name="RespectsMultiplication" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping with underlying relation
<M>F \subseteq S \times R</M>,
where <M>S</M> and <M>R</M> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsMultiplication"/> returns <K>true</K> if
<M>S</M> and <M>R</M> are magmas such that
<M>(s_1,r_1), (s_2,r_2) \in F</M> implies
<M>(s_1 * s_2,r_1 * r_2) \in F</M>,
and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then
<Ref Func="RespectsMultiplication"/> returns <K>true</K>
if and only if the equation
<C><A>s1</A>^<A>mapp</A> * <A>s2</A>^<A>mapp</A> =
(<A>s1</A> * <A>s2</A>)^<A>mapp</A></C>
holds for all <A>s1</A>, <A>s2</A> in <M>S</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="RespectsOne" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping with underlying relation
<M>F \subseteq <A>S</A> \times <A>R</A></M>,
where <A>S</A> and <A>R</A> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsOne"/> returns <K>true</K> if
<A>S</A> and <A>R</A> are magmas-with-one such that
<M>( </M><C>One(<A>S</A>)</C><M>, </M><C>One(<A>R</A>)</C><M> ) \in F</M>,
and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then <Ref Func="RespectsOne"/> returns
<K>true</K> if and only if the equation
<C>One( <A>S</A> )^<A>mapp</A> = One( <A>R</A> )</C>
holds.
</Description>
</ManSection>

<ManSection>
<Prop Name="RespectsInverses" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping with underlying relation
<M>F \subseteq <A>S</A> \times <A>R</A></M>,
where <A>S</A> and <A>R</A> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsInverses"/> returns <K>true</K> if
<A>S</A> and <A>R</A> are magmas-with-inverses such that,
for <M>s \in <A>S</A></M> and <M>r \in <A>R</A></M>, 
<M>(s,r) \in F</M> implies <M>(s^{{-1}},r^{{-1}}) \in F</M>,
and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then <Ref Func="RespectsInverses"/>
returns <K>true</K> if and only if the equation
<C>Inverse( <A>s</A> )^<A>mapp</A> = Inverse( <A>s</A>^<A>mapp</A> )</C>
holds for all <A>s</A> in <M>S</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGroupGeneralMapping" Arg='mapp'/>
<Prop Name="IsGroupHomomorphism" Arg='mapp'/>

<Description>
A <E>group general mapping</E> is a mapping which respects multiplication
and inverses.
If it is total and single valued it is called a
<E>group homomorphism</E>.
<P/>
Chapter&nbsp;<Ref Chap="Group Homomorphisms"/> explains
group homomorphisms in more detail.
</Description>
</ManSection>

<ManSection>
<Attr Name="KernelOfMultiplicativeGeneralMapping" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping.
Then <Ref Func="KernelOfMultiplicativeGeneralMapping"/> returns
the set of all elements in the source of <A>mapp</A> that have
the identity of the range in their set of images.
<P/>
(This is a monoid if <A>mapp</A> respects multiplication and one,
and if the source of <A>mapp</A> is associative.)
</Description>
</ManSection>

<ManSection>
<Attr Name="CoKernelOfMultiplicativeGeneralMapping" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping.
Then <Ref Func="CoKernelOfMultiplicativeGeneralMapping"/> returns
the set of all elements in the range of <A>mapp</A> that have
the identity of the source in their set of preimages.
<P/>
(This is a monoid if <A>mapp</A> respects multiplication and one,
and if the range of <A>mapp</A> is associative.)
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mappings that Respect Addition">
<Heading>Mappings that Respect Addition</Heading>

<ManSection>
<Prop Name="RespectsAddition" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping with underlying relation
<M>F \subseteq S \times R</M>,
where <M>S</M> and <M>R</M> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsAddition"/> returns <K>true</K> if
<M>S</M> and <M>R</M> are additive magmas such that
<M>(s_1,r_1), (s_2,r_2) \in F</M> implies
<M>(s_1 + s_2,r_1 + r_2) \in F</M>,
and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then <Ref Func="RespectsAddition"/>
returns <K>true</K> if and only if the equation
<C><A>s1</A>^<A>mapp</A> + <A>s2</A>^<A>mapp</A> =
(<A>s1</A>+<A>s2</A>)^<A>mapp</A></C>
holds for all <A>s1</A>, <A>s2</A> in <M>S</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="RespectsAdditiveInverses" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping with underlying relation
<M>F \subseteq S \times R</M>,
where <M>S</M> and <M>R</M> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsAdditiveInverses"/> returns <K>true</K> if
<M>S</M> and <M>R</M> are additive-magmas-with-inverses such that
<M>(s,r) \in F</M> implies <M>(-s,-r) \in F</M>,
and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then
<Ref Func="RespectsAdditiveInverses"/> returns <K>true</K>
if and only if the equation
<C>AdditiveInverse( <A>s</A> )^<A>mapp</A> =
AdditiveInverse( <A>s</A>^<A>mapp</A> )</C>
holds for all <A>s</A> in <M>S</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="RespectsZero" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping with underlying relation
<M>F \subseteq <A>S</A> \times <A>R</A></M>,
where <A>S</A> and <A>R</A> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsZero"/> returns <K>true</K> if
<A>S</A> and <A>R</A> are additive-magmas-with-zero such that
<M>( </M><C>Zero(<A>S</A>)</C><M>,
</M><C>Zero(<A>R</A>)</C><M> ) \in F</M>,
and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then <Ref Func="RespectsZero"/> returns
<K>true</K> if and only if the equation
<C>Zero( <A>S</A> )^<A>mapp</A> = Zero( <A>R</A> )</C>
holds.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAdditiveGroupGeneralMapping" Arg='mapp'/>
<Prop Name="IsAdditiveGroupHomomorphism" Arg='mapp'/>

<Description>
<Ref Prop="IsAdditiveGroupGeneralMapping"/>
specifies whether a general mapping <A>mapp</A> respects
addition (see <Ref Prop="RespectsAddition"/>) and respects
additive inverses (see <Ref Prop="RespectsAdditiveInverses"/>).
<P/>
<Ref Prop="IsAdditiveGroupHomomorphism"/> is a synonym for the meet of
<Ref Prop="IsAdditiveGroupGeneralMapping"/> and <Ref Prop="IsMapping"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="KernelOfAdditiveGeneralMapping" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping.
Then <Ref Func="KernelOfAdditiveGeneralMapping"/> returns
the set of all elements in the source of <A>mapp</A> that have
the zero of the range in their set of images.
</Description>
</ManSection>

<ManSection>
<Attr Name="CoKernelOfAdditiveGeneralMapping" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping.
Then <Ref Func="CoKernelOfAdditiveGeneralMapping"/> returns
the set of all elements in the range of <A>mapp</A> that have
the zero of the source in their set of preimages.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Linear Mappings">
<Heading>Linear Mappings</Heading>

Also see Sections&nbsp;<Ref Sect="Mappings that Respect Multiplication"/>,
<Ref Sect="Mappings that Respect Addition"/>,
and <Ref Func="KernelOfMultiplicativeGeneralMapping"/>,
<Ref Func="CoKernelOfMultiplicativeGeneralMapping"/>.

<ManSection>
<Prop Name="RespectsScalarMultiplication" Arg='mapp'/>

<Description>
Let <A>mapp</A> be a general mapping, with underlying relation
<M>F \subseteq S \times R</M>,
where <M>S</M> and <M>R</M> are the source and the range of <A>mapp</A>,
respectively.
Then <Ref Func="RespectsScalarMultiplication"/> returns <K>true</K> if
<M>S</M> and <M>R</M> are left modules with the left acting domain
<M>D</M> of <M>S</M> contained in the left acting domain of <M>R</M>
and such that
<M>(s,r) \in F</M> implies <M>(c * s,c * r) \in F</M> for all
<M>c \in D</M>, and <K>false</K> otherwise.
<P/>
If <A>mapp</A> is single-valued then
<Ref Func="RespectsScalarMultiplication"/> returns
<K>true</K> if and only if the equation
<C><A>c</A> * <A>s</A>^<A>mapp</A> =
(<A>c</A> * <A>s</A>)^<A>mapp</A></C>
holds for all <A>c</A> in <M>D</M> and <A>s</A> in <M>S</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLeftModuleGeneralMapping" Arg='mapp'/>
<Prop Name="IsLeftModuleHomomorphism" Arg='mapp'/>

<Description>
<Ref Prop="IsLeftModuleGeneralMapping"/>
specifies whether a general mapping <A>mapp</A> satisfies the property
<Ref Prop="IsAdditiveGroupGeneralMapping"/> and respects scalar 
multiplication (see <Ref Prop="RespectsScalarMultiplication"/>).
<P/>
<Ref Prop="IsLeftModuleHomomorphism"/> is a synonym for the meet of
<Ref Prop="IsLeftModuleGeneralMapping"/> and <Ref Prop="IsMapping"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsLinearMapping" Arg='F, mapp'/>

<Description>
For a field <A>F</A> and a general mapping <A>mapp</A>,
<Ref Func="IsLinearMapping"/> returns <K>true</K> if <A>mapp</A> is an
<A>F</A>-linear mapping, and <K>false</K> otherwise.
<P/>
A mapping <M>f</M> is a linear mapping (or vector space homomorphism)
if the source and range are vector spaces over the same division ring
<M>D</M>, and if
<M>f( a + b ) = f(a) + f(b)</M> and <M>f( s * a ) = s * f(a)</M> hold
for all elements <M>a</M>, <M>b</M> in the source of <M>f</M>
and <M>s \in D</M>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Ring Homomorphisms">
<Heading>Ring Homomorphisms</Heading>

<ManSection>
<Prop Name="IsRingGeneralMapping" Arg='mapp'/>
<Prop Name="IsRingHomomorphism" Arg='mapp'/>

<Description>
<Ref Prop="IsRingGeneralMapping"/> specifies whether a general mapping
<A>mapp</A> satisfies the property 
<Ref Prop="IsAdditiveGroupGeneralMapping"/> and respects multiplication 
(see <Ref Prop="RespectsMultiplication"/>).
<P/>
<Ref Prop="IsRingHomomorphism"/> is a synonym for the meet of
<Ref Prop="IsRingGeneralMapping"/> and <Ref Prop="IsMapping"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsRingWithOneGeneralMapping" Arg='mapp'/>
<Prop Name="IsRingWithOneHomomorphism" Arg='mapp'/>

<Description>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAlgebraGeneralMapping" Arg='mapp'/>
<Prop Name="IsAlgebraHomomorphism" Arg='mapp'/>

<Description>
<Ref Prop="IsAlgebraGeneralMapping"/> specifies whether a general 
mapping <A>mapp</A> satisfies both properties 
<Ref Prop="IsRingGeneralMapping"/> and 
(see <Ref Prop="IsLeftModuleGeneralMapping"/>).
<P/>
<Ref Prop="IsAlgebraHomomorphism"/> is a synonym for the meet of
<Ref Prop="IsAlgebraGeneralMapping"/> and <Ref Prop="IsMapping"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAlgebraWithOneGeneralMapping" Arg='mapp'/>
<Prop Name="IsAlgebraWithOneHomomorphism" Arg='mapp'/>

<Description>
<Ref Prop="IsAlgebraWithOneGeneralMapping"/>
specifies whether a general mapping <A>mapp</A> satisfies both 
properties <Ref Prop="IsAlgebraGeneralMapping"/> and 
<Ref Prop="RespectsOne"/>.
<P/>
<Ref Prop="IsAlgebraWithOneHomomorphism"/> is a synonym for the meet of
<Ref Prop="IsAlgebraWithOneGeneralMapping"/> and <Ref Prop="IsMapping"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFieldHomomorphism" Arg='mapp'/>

<Description>
A general mapping is a field homomorphism if and only if it is
a ring homomorphism with source a field.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="General Mappings">
<Heading>General Mappings</Heading>

<ManSection>
<Filt Name="IsGeneralMapping" Arg='map' Type='Category'/>

<Description>
Each general mapping lies in the category <Ref Func="IsGeneralMapping"/>.
It implies the categories
<Ref Func="IsMultiplicativeElementWithInverse"/>
and <Ref Func="IsAssociativeElement"/>;
for a discussion of these implications,
see&nbsp;<Ref Sect="Arithmetic Operations for General Mappings"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsConstantTimeAccessGeneralMapping" Arg='map'/>

<Description>
is <K>true</K> if the underlying relation of the general mapping
<A>map</A> knows its <Ref Func="AsList"/> value,
and <K>false</K> otherwise.
<P/>
In the former case, <A>map</A> is allowed to use this list for calls to
<Ref Func="ImagesElm"/> etc.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsEndoGeneralMapping" Arg='obj'/>

<Description>
If a general mapping has this property then its source and range are
equal.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Technical Matters Concerning General Mappings">
<Heading>Technical Matters Concerning General Mappings</Heading>

<Ref Func="Source"/> and <Ref Func="Range" Label="of a general mapping"/> 
are basic operations for general mappings.
<Ref Func="UnderlyingRelation"/> is secondary, its default method sets up
a domain that delegates tasks to the general mapping.
(Note that this allows one to handle also infinite relations by generic
methods if source or range of the general mapping is finite.)
<P/>
The distinction between basic operations and secondary operations for
general mappings may be a little bit complicated.
Namely, each general mapping must be in one of the two categories
<Ref Func="IsNonSPGeneralMapping"/>, <Ref Func="IsSPGeneralMapping"/>.
(The category <Ref Func="IsGeneralMapping"/> is defined as the disjoint
union of these two.)
<P/>
For general mappings of the first category, <Ref Func="ImagesElm"/> and
<Ref Func="PreImagesElm"/> are basic operations.
(Note that in principle it is possible to delegate
from <Ref Func="PreImagesElm"/> to <Ref Func="ImagesElm"/>.)
Methods for the secondary operations <Ref Func="ImageElm"/>,
<Ref Func="PreImageElm"/>, <Ref Func="ImagesSet"/>,
<Ref Func="PreImagesSet"/>, <Ref Func="ImagesRepresentative"/>,
and <Ref Func="PreImagesRepresentative"/> may use
<Ref Func="ImagesElm"/> and <Ref Func="PreImagesElm"/>, respectively,
and methods for <Ref Func="ImagesElm"/>, <Ref Func="PreImagesElm"/>
must <E>not</E> call the secondary operations.
In particular, there are no generic methods for
<Ref Func="ImagesElm"/> and <Ref Func="PreImagesElm"/>.
<P/>
Methods for <Ref Func="ImagesSet"/> and <Ref Func="PreImagesSet"/> must
<E>not</E> use <Ref Func="PreImagesRange"/> and
<Ref Func="ImagesSource"/>, e.g.,
compute the intersection of the set in question with the preimage of the
range resp. the image of the source.
<P/>
For general mappings of the second category (which means structure
preserving general mappings), the situation is different.
The set of preimages under a group homomorphism, for example, is either
empty or can be described as a coset of the (multiplicative) kernel.
So it is reasonable to have <Ref Func="ImagesRepresentative"/>,
<Ref Func="PreImagesRepresentative"/>,
<Ref Func="KernelOfMultiplicativeGeneralMapping"/>, and
<Ref Func="CoKernelOfMultiplicativeGeneralMapping"/> as basic operations
here, and to make <Ref Func="ImagesElm"/> and <Ref Func="PreImagesElm"/>
secondary operations that may delegate to these.
<P/>
In order to avoid infinite recursions,
we must distinguish between the two different types of mappings.
<P/>
(Note that the basic domain operations such as <Ref Func="AsList"/>
for the underlying relation of a general mapping may use either
<Ref Func="ImagesElm"/> or <Ref Func="ImagesRepresentative"/> and the
appropriate cokernel.
Conversely, if <Ref Func="AsList"/> for the underlying relation is known
then <Ref Func="ImagesElm"/> resp. <Ref Func="ImagesRepresentative"/>
may delegate to it,
the general mapping gets the property
<Ref Func="IsConstantTimeAccessGeneralMapping"/> for this;
note that this is not allowed if only an enumerator of the underlying
relation is known.)
<P/>
Secondary operations are
<Ref Func="IsInjective"/>, <Ref Func="IsSingleValued"/>,
<Ref Func="IsSurjective"/>, <Ref Func="IsTotal"/>;
they may use the basic operations, and must not be used by them.

<P/>
Methods for the operations <Ref Func="ImagesElm"/>,
<Ref Func="ImagesRepresentative"/>,
<Ref Func="ImagesSet"/>, <Ref Func="ImageElm"/>,
<Ref Func="PreImagesElm"/>,
<Ref Func="PreImagesRepresentative"/>, <Ref Func="PreImagesSet"/>,
and <Ref Func="PreImageElm"/> take two arguments, a general mapping
<A>map</A> and an element or collection of elements <A>elm</A>.
These methods must <E>not</E> check whether <A>elm</A> lies in the source
or the range of <A>map</A>.
In the case that <A>elm</A> does not, <K>fail</K> may be returned as well
as any other &GAP; object, and even an error message is allowed.
Checks of the arguments are done only by the functions
<Ref Func="Image" Label="set of images of the source of a general mapping"/>,
<Ref Func="Images" Label="set of images of the source of a general mapping"/>,
<Ref Func="PreImage" Label="set of preimages of the range of a general mapping"/>,
and <Ref Func="PreImages" Label="set of preimages of the range of a general mapping"/>,
which then delegate to the operations listed above.

<ManSection>
<Filt Name="IsSPGeneralMapping" Arg='map' Type='Category'/>
<Filt Name="IsNonSPGeneralMapping" Arg='map' Type='Category'/>

<Description>
<!--  What we want to express is that <C>IsGeneralMapping</C> is the disjoint union-->
<!--  of <C>IsSPGeneralMapping</C> and <C>IsNonSPGeneralMapping</C>.-->
</Description>
</ManSection>

<ManSection>
<Filt Name="IsGeneralMappingFamily" Arg='obj' Type='Category'/>

<Description>
The family category of the category of general mappings.
</Description>
</ManSection>

<ManSection>
<Attr Name="FamilyRange" Arg='Fam'/>

<Description>
is the elements family of the family of the range of each general
mapping in the family <A>Fam</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="FamilySource" Arg='Fam'/>

<Description>
is the elements family of the family of the source of each general
mapping in the family <A>Fam</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="FamiliesOfGeneralMappingsAndRanges" Arg='Fam'/>

<Description>
is a list that stores at the odd positions the families of general
mappings with source in the family <A>Fam</A>, at the even positions the
families of ranges of the general mappings.
</Description>
</ManSection>

<ManSection>
<Func Name="GeneralMappingsFamily" Arg='sourcefam, rangefam'/>

<Description>
All general mappings with same source family <A>FS</A> and same range
family <A>FR</A> lie in the family
<C>GeneralMappingsFamily( <A>FS</A>, <A>FR</A> )</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="TypeOfDefaultGeneralMapping" Arg='source, range, filter'/>

<Description>
is the type of mappings with <C>IsDefaultGeneralMappingRep</C> with
source <A>source</A> and range <A>range</A> and additional categories
<A>filter</A>.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  relation.msk                GAP documentation          Andrew Solomon       -->
<!-- %% -->
<!-- %A  @(#)<M>Id: relation.msk,v 1.13 2002/04/15 10:02:33 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Relations">
<Heading>Relations</Heading>

<Index>binary relation</Index>
<Index Key="IsBinaryRelation" Subkey="same as IsEndoGeneralMapping">
<C>IsBinaryRelation</C></Index>
<Index Key="IsEndoGeneralMapping" Subkey="same as IsBinaryRelation">
<C>IsEndoGeneralMapping</C></Index>
A <E>binary relation</E> <M>R</M> on a set <M>X</M> is a subset of
<M>X \times X</M>.
A binary relation can also be thought of as a (general) mapping
from <M>X</M> to itself or as a directed graph where each edge
represents an element of <M>R</M>.
<P/>
In &GAP;, a relation is conceptually represented as a general mapping
from <M>X</M> to itself.
The category <Ref Func="IsBinaryRelation"/> is a synonym for
<Ref Func="IsEndoGeneralMapping"/>.
Attributes and properties of relations in &GAP; are supported for
relations, via considering relations as a subset of <M>X \times X</M>,
or as a directed graph;
examples include finding the strongly connected components of a relation,
via <Ref Func="StronglyConnectedComponents"/>,
or enumerating the tuples of the relation.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="General Binary Relations">
<Heading>General Binary Relations</Heading>

This section lists general constructors of relations.

<ManSection>
<Filt Name="IsBinaryRelation" Arg='R' Type='Category'/>

<Description>
is   exactly   the   same   category   as   (i.e.    a    synonym    for)
<Ref Func="IsEndoGeneralMapping"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="BinaryRelationByElements" Arg='domain, elms'/>

<Description>
is the binary relation on <A>domain</A> and with underlying relation
consisting of the tuples collection <A>elms</A>.
This construction is similar to <Ref Func="GeneralMappingByElements"/>
where the source and range are the same set.
</Description>
</ManSection>

<ManSection>
<Heading>IdentityBinaryRelation</Heading>
<Func Name="IdentityBinaryRelation" Arg='degree' Label="for a degree"/>
<Func Name="IdentityBinaryRelation" Arg='domain' Label="for a domain"/>

<Description>
is the binary relation which consists of diagonal pairs, i.e., pairs of
the form <M>(x,x)</M>.
In the first form if a positive integer <A>degree</A> is given then
the domain is the set of the integers
<M>\{ 1, \ldots, <A>degree</A> \}</M>.
In the second form, the objects <M>x</M> are from the domain
<A>domain</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="EmptyBinaryRelation" Arg='degree' Label="for a degree"/>
<Func Name="EmptyBinaryRelation" Arg='domain' Label="for a domain"/>

<Description>
is the relation with <A>R</A> empty.
In the first form of the command with <A>degree</A> an integer,
the domain is the set of points <M>\{ 1, \ldots, <A>degree</A> \}</M>.
In the second form, the domain is that given by the argument
<A>domain</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties and Attributes of Binary Relations">
<Heading>Properties and Attributes of Binary Relations</Heading>

<ManSection>
<Prop Name="IsReflexiveBinaryRelation" Arg='R'/>

<Description>
returns <K>true</K> if the binary relation <A>R</A> is reflexive,
and <K>false</K> otherwise.
<P/>
<Index>reflexive relation</Index>
A binary relation <M>R</M> (as a set of pairs) on a set <M>X</M> is
<E>reflexive</E> if for all <M>x \in X</M>, <M>(x,x) \in R</M>.
Alternatively, <M>R</M> as a mapping
is reflexive if for all <M>x \in X</M>,
<M>x</M> is an element of the image set <M>R(x)</M>.
<P/>
A reflexive binary relation is necessarily a total endomorphic
mapping (tested via <Ref Func="IsTotal"/>).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSymmetricBinaryRelation" Arg='R'/>

<Description>
returns <K>true</K> if the binary relation <A>R</A> is symmetric,
and <K>false</K> otherwise.
<P/>
<Index>symmetric relation</Index>
A binary relation <M>R</M> (as a set of pairs) on a set <M>X</M> is
<E>symmetric</E> if <M>(x,y) \in R</M> then <M>(y,x) \in R</M>.
Alternatively, <M>R</M> as a mapping is symmetric
if for all <M>x \in X</M>, the preimage set of <M>x</M> under <M>R</M>
equals the image set <M>R(x)</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsTransitiveBinaryRelation" Arg='R'/>

<Description>
returns <K>true</K> if the binary relation <A>R</A> is transitive,
and <K>false</K> otherwise.
<P/>
<Index>transitive relation</Index>
A binary relation <A>R</A> (as a set of pairs) on a set <M>X</M> is
<E>transitive</E> if <M>(x,y), (y,z) \in R</M> implies
<M>(x,z) \in R</M>.
Alternatively, <M>R</M> as a mapping is transitive if for all
<M>x \in X</M>, the image set <M>R(R(x))</M> of the image
set <M>R(x)</M> of <M>x</M> is a subset of <M>R(x)</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAntisymmetricBinaryRelation" Arg='rel'/>

<Description>
returns <K>true</K> if the binary relation <A>rel</A> is antisymmetric,
and <K>false</K> otherwise.
<P/>
<Index>antisymmetric relation</Index>
A binary relation <A>R</A> (as a set of pairs) on a set <M>X</M> is
<E>antisymmetric</E> if <M>(x,y), (y,x) \in R</M> implies <M>x = y</M>.
Alternatively, <M>R</M> as a mapping is antisymmetric if for all
<M>x \in X</M>, the intersection of the preimage set of <M>x</M>
under <M>R</M> and the image set <M>R(x)</M> is <M>\{ x \}</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPreOrderBinaryRelation" Arg='rel'/>

<Description>
returns <K>true</K> if the binary relation <A>rel</A> is a preorder,
and <K>false</K> otherwise.
<P/>
<Index>preorder</Index>
A <E>preorder</E> is a binary relation that is both reflexive and
transitive.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPartialOrderBinaryRelation" Arg='rel'/>

<Description>
returns <K>true</K> if the binary relation <A>rel</A> is a partial order,
and <K>false</K> otherwise.
<P/>
<Index>partial order</Index>
A <E>partial order</E> is a preorder which is also antisymmetric.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsHasseDiagram" Arg='rel'/>

<Description>
returns <K>true</K> if the binary relation <A>rel</A> is a Hasse Diagram
of a partial order, i.e., was computed via
<Ref Func="HasseDiagramBinaryRelation"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsEquivalenceRelation" Arg='R'/>

<Description>
returns <K>true</K> if the binary relation <A>R</A> is an equivalence
relation, and <K>false</K> otherwise.
<P/>
<Index>equivalence relation</Index>
Recall, that a relation <A>R</A> is an <E>equivalence relation</E>
if it is symmetric, transitive, and reflexive.
</Description>
</ManSection>

<ManSection>
<Attr Name="Successors" Arg='R'/>

<Description>
returns the list of images of a binary relation <A>R</A>.
If the underlying domain of the relation is not <M>\{ 1, \ldots, n \}</M>,
for some positive integer <M>n</M>, then an error is signalled.
<P/>
The returned value of <Ref Func="Successors"/> is a list of lists where
the lists are ordered as the elements according to the sorted order of
the underlying set of <A>R</A>.
Each list consists of the images of the element whose index is the same
as the list with the underlying set in sorted order.
<P/>
The <Ref Func="Successors"/> of a relation is the adjacency list
representation of the relation.
</Description>
</ManSection>

<ManSection>
<Attr Name="DegreeOfBinaryRelation" Arg='R'/>

<Description>
returns the size of the underlying domain of the binary relation
<A>R</A>.
This is most natural when working with a binary relation on points.
</Description>
</ManSection>

<ManSection>
<Attr Name="PartialOrderOfHasseDiagram" Arg='HD'/>

<Description>
is the partial order associated with the Hasse Diagram <A>HD</A>
i.e. the partial order generated by the reflexive and
transitive closure of <A>HD</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Binary Relations on Points">
<Heading>Binary Relations on Points</Heading>

We have special construction methods when the underlying <A>X</A>
of our relation is the set of integers <M>\{ 1, \ldots, n \}</M>. 

<ManSection>
<Func Name="BinaryRelationOnPoints" Arg='list'/>
<Func Name="BinaryRelationOnPointsNC" Arg='list'/>

<Description>
Given a list of <M>n</M> lists,
each containing elements from the set <M>\{ 1, \ldots, n \}</M>,
this function constructs a binary relation such that <M>1</M> is related
to <A>list</A><C>[1]</C>, <M>2</M> to <A>list</A><C>[2]</C> and so on.
The first version checks whether the list supplied is valid.
The the <C>NC</C> version skips this check.
</Description>
</ManSection>

<ManSection>
<Func Name="RandomBinaryRelationOnPoints" Arg='degree'/>

<Description>
creates a relation on points with degree <A>degree</A>.
</Description>
</ManSection>

<ManSection>
<Heading>AsBinaryRelationOnPoints</Heading>
<Heading>AsBinaryRelationOnPoints</Heading>
<Func Name="AsBinaryRelationOnPoints" Arg='trans'
 Label="for a transformation"/>
<Func Name="AsBinaryRelationOnPoints" Arg='perm'
 Label="for a permutation"/>
<Func Name="AsBinaryRelationOnPoints" Arg='rel'
 Label="for a binary relation"/>

<Description>
return the relation on points represented by general relation <A>rel</A>,
transformation <A>trans</A> or permutation <A>perm</A>.
If <A>rel</A> is already a binary relation on points then <A>rel</A> is
returned.
<P/>
Transformations and permutations are special general endomorphic
mappings and have a natural representation as a binary relation on
points.
<P/>
In the last form, an isomorphic relation on points is constructed
where the points are indices of the elements of the underlying domain
in sorted order.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Closure Operations and Other Constructors">
<Heading>Closure Operations and Other Constructors</Heading>

<ManSection>
<Oper Name="ReflexiveClosureBinaryRelation" Arg='R'/>

<Description>
is the smallest binary relation containing the binary relation <A>R</A>
which is reflexive.
This closure inherits the properties symmetric and transitive from
<A>R</A>.
E.g., if <A>R</A> is symmetric then its reflexive closure
is also.
</Description>
</ManSection>

<ManSection>
<Oper Name="SymmetricClosureBinaryRelation" Arg='R'/>

<Description>
is the smallest binary relation containing the binary relation <A>R</A>
which is symmetric.
This closure inherits the properties reflexive and transitive from
<A>R</A>.
E.g., if <A>R</A> is reflexive then its symmetric closure is also.
</Description>
</ManSection>

<ManSection>
<Oper Name="TransitiveClosureBinaryRelation" Arg='rel'/>

<Description>
is the smallest binary relation containing the binary relation <A>R</A>
which is transitive.
This closure inherits the properties reflexive and symmetric from
<A>R</A>.
E.g., if <A>R</A> is symmetric then its transitive closure is also.
<P/>
<Ref Func="TransitiveClosureBinaryRelation"/> is a modified version of
the Floyd-Warshall method of solving the all-pairs shortest-paths problem
on a directed graph.
Its asymptotic runtime is <M>O(n^3)</M> where <M>n</M> is the size of the
vertex set.
It only assumes there is an arbitrary (but fixed) ordering of the vertex
set.
</Description>
</ManSection>

<ManSection>
<Oper Name="HasseDiagramBinaryRelation" Arg='partial-order'/>

<Description>
is the smallest relation contained in the partial order
<A>partial-order</A> whose reflexive and transitive closure is equal to
<A>partial-order</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="StronglyConnectedComponents" Arg='R'/>

<Description>
returns an equivalence relation on the vertices of the binary relation
<A>R</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="PartialOrderByOrderingFunction" Arg='dom, orderfunc'/>

<Description>
constructs a partial order whose elements are from the domain <A>dom</A>
and are ordered using the ordering function <A>orderfunc</A>.
The ordering function must be a binary function returning a boolean
value.
If the ordering function does not describe a partial order then
<K>fail</K> is returned.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Equivalence Relations">
<Heading>Equivalence Relations</Heading>

<Index>equivalence relation</Index>
An <E>equivalence relation</E> <A>E</A> over the set <A>X</A> is a relation
on <A>X</A> which is reflexive, symmetric, and transitive. 
A <E>partition</E> <A>P</A> is a set of subsets of <A>X</A> such that
for all <M>R, S \in P</M>, <M>R \cap S</M> is the empty set and
<M>\cup P = X</M>.  
An equivalence relation induces a partition such that if <M>(x,y) \in E</M>
then <M>x, y</M> are in the same element of <A>P</A>.
<P/>
Like all binary relations in &GAP; equivalence 
relations are regarded as general endomorphic mappings (and the operations,
properties and attributes of general mappings are available). 
However, partitions provide an efficient way of representing equivalence 
relations.  Moreover, only the non-singleton classes
or blocks are listed allowing for small equivalence relations to be
represented on infinite sets. Hence the main attribute of equivalence 
relations is <Ref Func="EquivalenceRelationPartition"/>
which provides the partition induced by the given equivalence.

<ManSection>
<Func Name="EquivalenceRelationByPartition" Arg='domain, list'/>
<Func Name="EquivalenceRelationByPartitionNC" Arg='domain, list'/>

<Description>
constructs the equivalence relation over the set <A>domain</A>
which induces the partition represented by <A>list</A>.
This representation includes only the non-trivial blocks
(or equivalent classes). <A>list</A> is a list of lists,
each of these lists contain elements of <A>domain</A> and are
pairwise mutually exclusive.
<P/>
The list of lists do not need to be in any order nor do the
elements in the blocks
(see <Ref Func="EquivalenceRelationPartition"/>).
a list of elements of <A>domain</A>
The partition <A>list</A> is a
list of lists, each of these is a list of elements of <A>domain</A>
that makes up a block (or equivalent class). The
<A>domain</A> is the domain over which the relation is defined, and
<A>list</A> is a list of lists, each of these is a list of elements
of <A>domain</A> which are related to each other.
<A>list</A> need only contain the nontrivial blocks
and singletons will be ignored. The <C>NC</C> version will not check
to see if the lists are pairwise mutually exclusive or that
they contain only elements of the domain.
</Description>
</ManSection>

<ManSection>
<Func Name="EquivalenceRelationByRelation" Arg='rel'/>

<Description>
returns the smallest equivalence
relation containing the binary relation <A>rel</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="EquivalenceRelationByPairs" Arg='D, elms'/>
<Func Name="EquivalenceRelationByPairsNC" Arg='D, elms'/>

<Description>
return the smallest equivalence relation
on the domain <A>D</A> such that every pair in <A>elms</A>
is in the relation.
<P/>
In the <C>NC</C> form, it is not checked that <A>elms</A> are in the
domain <A>D</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="EquivalenceRelationByProperty" Arg='domain, property'/>

<Description>
creates an equivalence relation on <A>domain</A> whose only defining
datum is that of having the property <A>property</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes of and Operations on Equivalence Relations">
<Heading>Attributes of and Operations on Equivalence Relations</Heading> 

<ManSection>
<Attr Name="EquivalenceRelationPartition" Arg='equiv'/>

<Description>
returns a list of lists of elements
of the underlying set of the equivalence relation <A>equiv</A>.
The lists are precisely the nonsingleton equivalence classes of the
equivalence.
This allows us to describe <Q>small</Q> equivalences on infinite sets.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfEquivalenceRelationPartition" Arg='equiv'/>

<Description>
is a set of generating pairs for the equivalence relation <A>equiv</A>.
This set is not unique.
The equivalence <A>equiv</A> is the smallest equivalence relation over
the underlying set which contains the generating pairs.
</Description>
</ManSection>

<ManSection>
<Oper Name="JoinEquivalenceRelations" Arg='equiv1, equiv2'/>
<Oper Name="MeetEquivalenceRelations" Arg='equiv1, equiv2'/>

<Description>
<Ref Func="JoinEquivalenceRelations"/> returns the smallest
equivalence relation containing both the equivalence relations
<A>equiv1</A> and <A>equiv2</A>.
<P/>
<Ref Func="MeetEquivalenceRelations"/> returns the
intersection of the two equivalence relations
<A>equiv1</A> and <A>equiv2</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Equivalence Classes">
<Heading>Equivalence Classes</Heading>

<ManSection>
<Filt Name="IsEquivalenceClass" Arg='obj' Type='Category'/>

<Description>
returns <K>true</K> if the object <A>obj</A> is an equivalence class,
and <K>false</K> otherwise.
<P/>
<Index>equivalence class</Index>
An <E>equivalence class</E> is a collection of elements which are mutually
related to each other in the associated equivalence relation.
Note, this is a special category of objects
and not just a list of elements.
</Description>
</ManSection>

<ManSection>
<Attr Name="EquivalenceClassRelation" Arg='C'/>

<Description>
returns the equivalence relation of which <A>C</A> is a class.
</Description>
</ManSection>

<ManSection>
<Attr Name="EquivalenceClasses" Arg='rel' Label="attribute"/>

<Description>
returns a list of all equivalence classes of the equivalence relation
<A>rel</A>.
Note that it is possible for different methods to yield the list
in different orders, so that for two equivalence relations
<M>c1</M> and <M>c2</M> we may have <M>c1 = c2</M> without having
<C>EquivalenceClasses</C><M>( c1 ) =
</M><C>EquivalenceClasses</C><M>( c2 )</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="EquivalenceClassOfElement" Arg='rel, elt'/>
<Oper Name="EquivalenceClassOfElementNC" Arg='rel, elt'/>

<Description>
return the equivalence class of <A>elt</A> in the binary relation
<A>rel</A>,
where <A>elt</A> is an element (i.e. a pair) of the domain of <A>rel</A>.
In the <C>NC</C> form, it is not checked that <A>elt</A> is in the domain
over which <A>rel</A> is defined.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  orders.msk                GAP documentation                Isabel Araújo -->
<!-- %% -->
<!-- %A  @(#)<M>Id: orders.msk,v 1.6 2002/04/15 10:02:31 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 2000 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Orderings">
<Heading>Orderings</Heading>

In &GAP; an ordering is a relation defined on a family, which is
reflexive, anti-symmetric and transitive.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsOrdering">
<Heading>IsOrdering (Filter)</Heading>

<ManSection>
<Filt Name="IsOrdering" Arg='obj' Type='Category'/>

<Description>
returns <K>true</K> if and only if the object <A>ord</A> is an ordering.
</Description>
</ManSection>

<ManSection>
<Attr Name="OrderingsFamily" Arg='fam'/>

<Description>
for a family <A>fam</A>, returns the family of all
orderings on elements of <A>fam</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Building new orderings">
<Heading>Building new orderings</Heading>

<ManSection>
<Oper Name="OrderingByLessThanFunctionNC" Arg='fam, lt[, l]'/>

<Description>
Called with two arguments, <Ref Func="OrderingByLessThanFunctionNC"/>
returns the ordering on the elements of the elements of the family
<A>fam</A>, according to the <Ref Func="LessThanFunction"/> value given
by <A>lt</A>,
where <A>lt</A> is a function that takes two
arguments in <A>fam</A> and returns <K>true</K> or <K>false</K>.
<P/>
Called with three arguments, for a family <A>fam</A>,
a function <A>lt</A> that takes two arguments in <A>fam</A> and returns
<K>true</K> or <K>false</K>, and a list <A>l</A>
of properties of orderings, <Ref Func="OrderingByLessThanFunctionNC"/>
returns the ordering on the elements of <A>fam</A> with
<Ref Func="LessThanFunction"/> value given by <A>lt</A>
and with the properties from <A>l</A> set to <K>true</K>.
</Description>
</ManSection>

<ManSection>
<Oper Name="OrderingByLessThanOrEqualFunctionNC" Arg='fam, lteq[, l]'/>

<Description>
Called with two arguments,
<Ref Func="OrderingByLessThanOrEqualFunctionNC"/> returns the ordering on
the elements of the elements of the family <A>fam</A> according to
the <Ref Func="LessThanOrEqualFunction"/> value given by <A>lteq</A>,
where <A>lteq</A> is a function that takes two arguments in <A>fam</A>
and returns <K>true</K> or <K>false</K>.
<P/>
Called with three arguments, for a family <A>fam</A>,
a function <A>lteq</A> that takes two arguments in <A>fam</A> and returns
<K>true</K> or <K>false</K>, and a list <A>l</A>
of properties of orderings,
<Ref Func="OrderingByLessThanOrEqualFunctionNC"/>
returns the ordering on the elements of <A>fam</A> with
<Ref Func="LessThanOrEqualFunction"/> value given by <A>lteq</A>
and with the properties from <A>l</A> set to <K>true</K>.
<P/>
Notice that these functions do not check whether <A>fam</A> and <A>lt</A>
or <A>lteq</A> are compatible,
and whether the properties listed in <A>l</A> are indeed satisfied.
<Example><![CDATA[
gap> f := FreeSemigroup("a","b");;
gap> a := GeneratorsOfSemigroup(f)[1];;
gap> b := GeneratorsOfSemigroup(f)[2];;
gap> lt := function(x,y) return Length(x)<Length(y); end;
function( x, y ) ... end
gap> fam := FamilyObj(a);;
gap> ord := OrderingByLessThanFunctionNC(fam,lt);
Ordering
]]></Example>
</Description>
</ManSection>

			 
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties and basic functionality">
<Heading>Properties and basic functionality</Heading>

<ManSection>
<Prop Name="IsWellFoundedOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A>,
returns <K>true</K> if and only if the ordering is well founded.
An ordering <A>ord</A> is well founded if it admits no infinite descending
chains.
Normally this property is set at the time of creation of the ordering
and there is no general method to check whether a certain ordering
is well founded.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsTotalOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A>,
returns true if and only if the ordering is total.
An ordering <A>ord</A> is total if any two elements of the family
are comparable under <A>ord</A>.
Normally this property is set at the time of creation of the ordering
and there is no general method to check whether a certain ordering
is total.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsIncomparableUnder" Arg='ord, el1, el2'/>

<Description>
for an ordering <A>ord</A> on the elements of the family of <A>el1</A>
and <A>el2</A>, returns <K>true</K> if <A>el1</A> <M>\neq</M> <A>el2</A>
and <C>IsLessThanUnder</C>(<A>ord</A>,<A>el1</A>,<A>el2</A>),
<C>IsLessThanUnder</C>(<A>ord</A>,<A>el2</A>,<A>el1</A>) are both
<K>false</K>; and returns <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="FamilyForOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A>,
returns the family of elements that the ordering <A>ord</A> compares.
</Description>
</ManSection>

<ManSection>
<Attr Name="LessThanFunction" Arg='ord'/>

<Description>
for an ordering <A>ord</A>,
returns a function <M>f</M> which takes two elements <M>el1</M>,
<M>el2</M> in <C>FamilyForOrdering</C>(<A>ord</A>) and returns
<K>true</K> if <M>el1</M> is strictly less than <M>el2</M>
(with respect to <A>ord</A>), and returns <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="LessThanOrEqualFunction" Arg='ord'/>

<Description>
for an ordering <A>ord</A>,
returns a function that takes two elements <M>el1</M>, <M>el2</M> in
<C>FamilyForOrdering</C>(<A>ord</A>) and returns <K>true</K>
if <M>el1</M> is less than <E>or equal to</E> <M>el2</M>
(with respect to <A>ord</A>), and returns <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsLessThanUnder" Arg='ord, el1, el2'/>

<Description>
for an ordering <A>ord</A> on the elements of the family of <A>el1</A>
and <A>el2</A>, returns <K>true</K> if <A>el1</A> is (strictly) less than
<A>el2</A> with respect to <A>ord</A>, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsLessThanOrEqualUnder" Arg='ord, el1, el2'/>

<Description>
for an ordering <A>ord</A> on the elements of the family of <A>el1</A>
and <A>el2</A>, returns <K>true</K> if <A>el1</A> is less than or equal
to <A>el2</A> with respect to <A>ord</A>, and <K>false</K> otherwise.
<Example><![CDATA[
gap> IsLessThanUnder(ord,a,a*b);
true
gap> IsLessThanOrEqualUnder(ord,a*b,a*b);
true
gap> IsIncomparableUnder(ord,a,b);
true
gap> FamilyForOrdering(ord) = FamilyObj(a);
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Orderings on families of associative words">
<Heading>Orderings on families of associative words</Heading>

We now consider orderings on families of associative words.
<P/>
Examples of families of associative words are the families of elements
of a free semigroup or a free monoid;
these are the two cases that we consider mostly.
Associated with those families is
an alphabet, which is the semigroup (resp. monoid) generating set
of the correspondent free semigroup (resp. free monoid).
For definitions of the orderings considered,
see Sims <Cite Key="Sims94"/>.

<ManSection>
<Prop Name="IsOrderingOnFamilyOfAssocWords" Arg='ord'/>

<Description>
for an ordering <A>ord</A>,
returns true if <A>ord</A> is an ordering over a family of associative
words.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsTranslationInvariantOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A> on a family of associative words,
returns <K>true</K> if and only if the ordering is translation invariant.
<P/>
This is a property of orderings on families of associative words.
An ordering <A>ord</A> over a family <M>F</M>, with alphabet <M>X</M>
is translation invariant if
<C>IsLessThanUnder(</C> <A>ord</A>, <M>u</M>, <M>v</M> <C>)</C> implies
that for any <M>a, b \in X^*</M>,
<C>IsLessThanUnder(</C> <A>ord</A>, <M>a*u*b</M>, <M>a*v*b</M> <C>)</C>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsReductionOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A> on a family of associative words,
returns <K>true</K> if and only if the ordering is a reduction ordering.
An ordering <A>ord</A> is a reduction ordering
if it is well founded and translation invariant.
</Description>
</ManSection>

<ManSection>
<Attr Name="OrderingOnGenerators" Arg='ord'/>

<Description>
for an ordering <A>ord</A> on a family of associative words,
returns a list in which the generators are considered.
This could be indeed the ordering of the generators in the ordering,
but, for example, if a weight is associated to each generator
then this is not true anymore.
See the example for <Ref Func="WeightLexOrdering"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LexicographicOrdering" Arg='D[, gens]'/>

<Description>
Let <A>D</A> be a free semigroup, a free monoid, or the elements
family of such a domain.
Called with only argument <A>D</A>,
<Ref Func="LexicographicOrdering"/> returns the lexicographic
ordering on the elements of <A>D</A>.
<P/>
The optional argument <A>gens</A> can be either the list of free
generators of <A>D</A>, in the desired order,
or a list of the positions of these generators,
in the desired order,
and <Ref Func="LexicographicOrdering"/> returns the lexicographic
ordering on the elements of <A>D</A> with the ordering on the
generators as given.
<Example><![CDATA[
gap> f := FreeSemigroup(3);
<free semigroup on the generators [ s1, s2, s3 ]>
gap> lex := LexicographicOrdering(f,[2,3,1]);
Ordering
gap> IsLessThanUnder(lex,f.2*f.3,f.3);
true
gap> IsLessThanUnder(lex,f.3,f.2);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ShortLexOrdering" Arg='D[, gens]'/>

<Description>
Let <A>D</A> be a free semigroup, a free monoid, or the elements
family of such a domain.
Called with only argument <A>D</A>,
<Ref Func="ShortLexOrdering"/> returns the shortlex
ordering on the elements of <A>D</A>.
<P/>
The optional argument <A>gens</A> can be either the list of free
generators of <A>D</A>, in the desired order,
or a list of the positions of these generators,
in the desired order,
and <Ref Func="ShortLexOrdering"/> returns the shortlex
ordering on the elements of <A>D</A> with the ordering on the
generators as given.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsShortLexOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A> of a family of associative words,
returns <K>true</K> if and only if <A>ord</A> is a shortlex ordering.
<Example><![CDATA[
gap> f := FreeSemigroup(3);
<free semigroup on the generators [ s1, s2, s3 ]>
gap> sl := ShortLexOrdering(f,[2,3,1]);
Ordering
gap> IsLessThanUnder(sl,f.1,f.2);
false
gap> IsLessThanUnder(sl,f.3,f.2);
false
gap> IsLessThanUnder(sl,f.3,f.1);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="WeightLexOrdering" Arg='D, gens, wt'/>

<Description>
Let <A>D</A> be a free semigroup, a free monoid, or the elements
family of such a domain. <A>gens</A> can be either the list of free
generators of <A>D</A>, in the desired order,
or a list of the positions of these generators, in the desired order.
Let <A>wt</A> be a list of weights.
<Ref Func="WeightLexOrdering"/> returns the weightlex
ordering on the elements of <A>D</A> with the ordering on the
generators and weights of the generators as given.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsWeightLexOrdering" Arg='ord'/>

<Description>
for an ordering <A>ord</A> on a family of associative words,
returns <K>true</K> if and only if <A>ord</A> is a weightlex ordering.
</Description>
</ManSection>

<ManSection>
<Attr Name="WeightOfGenerators" Arg='ord'/>

<Description>
for a weightlex ordering <A>ord</A>,
returns a list with length the size of the alphabet of the family.
This list gives the weight of each of the letters of the alphabet
which are used for weightlex orderings with respect to the
ordering given by <Ref Func="OrderingOnGenerators"/>.
<Example><![CDATA[
gap> f := FreeSemigroup(3);
<free semigroup on the generators [ s1, s2, s3 ]>
gap> wtlex := WeightLexOrdering(f,[f.2,f.3,f.1],[3,2,1]);
Ordering
gap> IsLessThanUnder(wtlex,f.1,f.2);
true
gap> IsLessThanUnder(wtlex,f.3,f.2);
true
gap> IsLessThanUnder(wtlex,f.3,f.1);
false
gap> OrderingOnGenerators(wtlex);
[ s2, s3, s1 ]
gap> WeightOfGenerators(wtlex);
[ 3, 2, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="BasicWreathProductOrdering" Arg='D[, gens]'/>

<Description>
Let <A>D</A> be a free semigroup, a free monoid, or the elements
family of such a domain.
Called with only argument <A>D</A>,
<Ref Func="BasicWreathProductOrdering"/> returns the basic wreath product
ordering on the elements of <A>D</A>.
<P/>
The optional argument <A>gens</A> can be either the list of free
generators of <A>D</A>, in the desired order,
or a list of the positions of these generators,
in the desired order,
and <Ref Func="BasicWreathProductOrdering"/> returns the lexicographic
ordering on the elements of <A>D</A> with the ordering on the
generators as given.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsBasicWreathProductOrdering" Arg='ord'/>

<Description>
<Example><![CDATA[
gap> f := FreeSemigroup(3);
<free semigroup on the generators [ s1, s2, s3 ]>
gap> basic := BasicWreathProductOrdering(f,[2,3,1]);
Ordering
gap> IsLessThanUnder(basic,f.3,f.1);
true
gap> IsLessThanUnder(basic,f.3*f.2,f.1);
true
gap> IsLessThanUnder(basic,f.3*f.2*f.1,f.1*f.3);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="WreathProductOrdering" Arg='D[, gens], levels'/>

<Description>
Let <A>D</A> be a free semigroup, a free monoid, or the elements
family of such a domain,
let <A>gens</A> be either the list of free generators of <A>D</A>,
in the desired order,
or a list of the positions of these generators, in the desired order,
and let <A>levels</A> be a list of levels for the generators.
If <A>gens</A> is omitted then the default ordering is taken.
<Ref Func="WreathProductOrdering"/> returns the wreath product
ordering on the elements of <A>D</A> with the ordering on the
generators as given.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsWreathProductOrdering" Arg='ord'/>

<Description>
specifies whether an ordering is a wreath product ordering 
(see <Ref Oper="WreathProductOrdering"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="LevelsOfGenerators" Arg='ord'/>

<Description>
for a wreath product ordering <A>ord</A>, returns the levels
of the generators as given at creation
(with respect to <Ref Func="OrderingOnGenerators"/>).
<Example><![CDATA[
gap> f := FreeSemigroup(3);
<free semigroup on the generators [ s1, s2, s3 ]>
gap> wrp := WreathProductOrdering(f,[1,2,3],[1,1,2,]);
Ordering
gap> IsLessThanUnder(wrp,f.3,f.1);
false
gap> IsLessThanUnder(wrp,f.3,f.2);
false
gap> IsLessThanUnder(wrp,f.1,f.2);
true
gap> LevelsOfGenerators(wrp);
[ 1, 1, 2 ]
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  magma.msk                  GAP documentation                Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: magma.msk,v 1.10 2002/04/15 10:02:30 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Magmas">
<Heading>Magmas</Heading>

This chapter deals with domains
(see&nbsp;<Ref Chap="Domains and their Elements"/>)
that are closed under multiplication <C>*</C>.
Following&nbsp;<Cite Key="Bourbaki70"/>, we call them <E>magmas</E> in &GAP;.
Together with the domains closed under addition <C>+</C>
(see&nbsp;<Ref Chap="Additive Magmas"/>),
they are the basic algebraic structures;
every semigroup,
monoid (see&nbsp;<Ref Chap="Semigroups"/>),
group (see&nbsp;<Ref Chap="Groups"/>),
ring (see&nbsp;<Ref Chap="Rings"/>),
or field (see&nbsp;<Ref Chap="Fields and Division Rings"/>) is a magma.
In the cases of a <E>magma-with-one</E> or <E>magma-with-inverses</E>,
additional multiplicative structure is present,
see&nbsp;<Ref Sect="Magma Categories"/>.
For functions to create free magmas, see&nbsp;<Ref Sect="Free Magmas"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Magma Categories">
<Heading>Magma Categories</Heading>

<ManSection>
<Filt Name="IsMagma" Arg='obj' Type='Category'/>

<Description>
A <E>magma</E> in &GAP; is a domain <M>M</M> with
(not necessarily associative) multiplication
<C>*</C><M>: M \times M \rightarrow M</M>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMagmaWithOne" Arg='obj' Type='Category'/>

<Description>
A <E>magma-with-one</E> in &GAP; is a magma <M>M</M> with an operation
<C>^0</C> (or <Ref Func="One"/>) that yields the identity of <M>M</M>.
<P/>
So a magma-with-one <M>M</M> does always contain a unique
multiplicatively neutral element <M>e</M>, i.e.,
<M>e</M><C> * </C><M>m = m = m</M><C> * </C><M>e</M> holds
for all <M>m \in M</M>
(see&nbsp;<Ref Func="MultiplicativeNeutralElement"/>).
This element <M>e</M> can be computed with the operation
<Ref Oper="One"/> as <C>One( </C><M>M</M><C> )</C>,
and <M>e</M> is also equal to <C>One( </C><M>m</M><C> )</C> and to
<M>m</M><C>^0</C> for each element <M>m \in M</M>.
<P/>
<E>Note</E> that a magma may contain a multiplicatively neutral element
but <E>not</E> an identity (see&nbsp;<Ref Oper="One"/>),
and a magma containing an identity may <E>not</E> lie in the category
<Ref Func="IsMagmaWithOne"/>
(see Section&nbsp;<Ref Sect="Domain Categories"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMagmaWithInversesIfNonzero" Arg='obj' Type='Category'/>

<Description>
An object in this &GAP; category is a magma-with-one <M>M</M>
with an operation
<C>^-1</C><M>: M \setminus Z \rightarrow M \setminus Z</M>
that maps each element <M>m</M> of <M>M \setminus Z</M> to its inverse
<M>m</M><C>^-1</C>
(or <C>Inverse( </C><M>m</M><C> )</C>, see&nbsp;<Ref Attr="Inverse"/>),
where <M>Z</M> is either empty or consists exactly of one element of
<M>M</M>.
<P/>
This category was introduced mainly to describe division rings,
since the nonzero elements in a division ring form a group;
So an object <M>M</M> in <Ref Func="IsMagmaWithInversesIfNonzero"/>
will usually have both a multiplicative and an additive structure
(see&nbsp;<Ref Chap="Additive Magmas"/>),
and the set <M>Z</M>, if it is nonempty, contains exactly the zero
element (see&nbsp;<Ref Func="Zero"/>) of <M>M</M>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMagmaWithInverses" Arg='obj' Type='Category'/>

<Description>
A <E>magma-with-inverses</E> in &GAP; is a magma-with-one <M>M</M> with
an operation <C>^-1</C><M>: M \rightarrow M</M> that maps each element
<M>m</M> of <M>M</M> to its inverse <M>m</M><C>^-1</C>
(or <C>Inverse( </C><M>m</M><C> )</C>, see&nbsp;<Ref Func="Inverse"/>).
<P/>
Note that not every trivial magma is a magma-with-one,
but every trivial magma-with-one is a magma-with-inverses.
This holds also if the identity of the magma-with-one is a zero element.
So a magma-with-inverses-if-nonzero can be a magma-with-inverses
if either it contains no zero element or consists of a zero element that
has itself as zero-th power.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Magma Generation">
<Heading>Magma Generation</Heading>

This section describes
functions that create magmas from generators
(see <Ref Func="Magma"/>, <Ref Func="MagmaWithOne"/>,
<Ref Func="MagmaWithInverses"/>),
the underlying operations for which methods can be installed
(see <Ref Func="MagmaByGenerators"/>, <Ref Func="MagmaWithOneByGenerators"/>,
<Ref Func="MagmaWithInversesByGenerators"/>),
functions for forming submagmas
(see <Ref Func="Submagma"/>, <Ref Func="SubmagmaWithOne"/>,
<Ref Func="SubmagmaWithInverses"/>),
and functions that form a magma equal to a given collection
(see <Ref Func="AsMagma"/>, <Ref Func="AsSubmagma"/>).
<P/>
<Ref Func="InjectionZeroMagma"/> creates a new magma which is the original
magma with a zero adjoined.

<ManSection>
<Func Name="Magma" Arg='[Fam, ]gens'/>

<Description>
returns the magma <M>M</M> that is generated by the elements
in the list <A>gens</A>, that is,
the closure of <A>gens</A> under multiplication <Ref Func="\*"/>.
The family <A>Fam</A> of <M>M</M> can be entered as the first argument;
this is obligatory if <A>gens</A> is empty
(and hence also <M>M</M> is empty).
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaWithOne" Arg='[Fam, ]gens'/>

<Description>
returns the magma-with-one <M>M</M> that is generated by the elements
in the list <A>gens</A>, that is,
the closure of <A>gens</A> under multiplication <Ref Func="\*"/> and
<Ref Func="One"/>.
The family <A>Fam</A> of <M>M</M> can be entered as first argument;
this is obligatory if <A>gens</A> is empty
(and hence <M>M</M> is trivial).
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaWithInverses" Arg='[Fam, ]gens'/>

<Description>
returns the magma-with-inverses <M>M</M> that is generated by the
elements in the list <A>gens</A>, that is,
the closure of <A>gens</A> under multiplication <Ref Func="\*"/>,
<Ref Func="One"/>, and <Ref Func="Inverse"/>.
The family <A>Fam</A> of <M>M</M> can be entered as first argument;
this is obligatory if <A>gens</A> is empty
(and hence <M>M</M> is trivial).
</Description>
</ManSection>

<ManSection>
<Oper Name="MagmaByGenerators" Arg='[Fam, ]gens'/>

<Description>
An underlying operation for <Ref Func="Magma"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="MagmaWithOneByGenerators" Arg='[Fam, ]gens'/>

<Description>
An underlying operation for <Ref Func="MagmaWithOne"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="MagmaWithInversesByGenerators" Arg='[Fam, ]gens'/>

<Description>
An underlying operation for <Ref Func="MagmaWithInverses"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="Submagma" Arg='D, gens'/>
<Func Name="SubmagmaNC" Arg='D, gens'/>

<Description>
<Ref Func="Submagma"/> returns the magma generated by
the elements in the list <A>gens</A>, with parent the domain <A>D</A>.
<Ref Func="SubmagmaNC"/> does the same, except that it is not checked
whether the elements of <A>gens</A> lie in <A>D</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="SubmagmaWithOne" Arg='D, gens'/>
<Func Name="SubmagmaWithOneNC" Arg='D, gens'/>

<Description>
<Ref Func="SubmagmaWithOne"/> returns the magma-with-one generated by
the elements in the list <A>gens</A>, with parent the domain <A>D</A>.
<Ref Func="SubmagmaWithOneNC"/> does the same, except that it is not
checked whether the elements of <A>gens</A> lie in <A>D</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="SubmagmaWithInverses" Arg='D, gens'/>
<Func Name="SubmagmaWithInversesNC" Arg='D, gens'/>

<Description>
<Ref Func="SubmagmaWithInverses"/> returns the magma-with-inverses
generated by the elements in the list <A>gens</A>,
with parent the domain <A>D</A>.
<Ref Func="SubmagmaWithInversesNC"/> does the same,
except that it is not checked whether the elements of <A>gens</A>
lie in <A>D</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="AsMagma" Arg='C'/>

<Description>
For a collection <A>C</A> whose elements form a magma,
<Ref Func="AsMagma"/> returns this magma.
Otherwise <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Oper Name="AsSubmagma" Arg='D, C'/>

<Description>
Let <A>D</A> be a domain and <A>C</A> a collection.
If <A>C</A> is a subset of <A>D</A> that forms a magma then
<Ref Func="AsSubmagma"/> returns this magma, with parent <A>D</A>.
Otherwise <K>fail</K> is returned.
</Description>
</ManSection>


<ManSection>
  <Filt Name="IsMagmaWithZeroAdjoined" Arg='M' Type="Category"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
  <C>IsMagmaWithZeroAdjoined</C> returns <K>true</K> if the magma <A>M</A> was
  created using <Ref Attr="InjectionZeroMagma"/> or 
  <Ref Oper="MagmaWithZeroAdjoined"/> and returns <K>false</K> if it was not.
<Example><![CDATA[
gap> S:=Semigroup(Transformation([1,1,1]), Transformation([1,3,2]));;
gap> IsMagmaWithZeroAdjoined(S);
false
gap> M:=MagmaWithZeroAdjoined(S);
<<transformation semigroup of degree 3 with 2 generators>
  with 0 adjoined>
gap> IsMagmaWithZeroAdjoined(M);
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="InjectionZeroMagma" Arg='M'/>
  <Oper Name="MagmaWithZeroAdjoined" Arg='M'/>
  <Description>
  <C>InjectionZeroMagma</C> returns an embedding from the magma <A>M</A>
  into a new magma formed from <A>M</A> by adjoining a single new element 
  which is the multiplicative zero of the resulting magma.
  The elements of the new magma form a family of elements in the 
  category <Ref Filt="IsMultiplicativeElementWithZero"/> and the magma
  itself satisfies <Ref Prop="IsMagmaWithZeroAdjoined"/>.<P/>
  
  <C>MagmaWithZeroAdjoined</C> is just shorthand for
  <C>Range(InjectionZeroMagma(<A>M</A>)))</C>.<P/>
  
  If <C>N</C> is a magma with zero adjoined, then the embedding 
  used to create <C>N</C> can be recovered using 
  <Ref Attr="UnderlyingInjectionZeroMagma"/>.
<Example><![CDATA[
gap> S:=Monoid(Transformation( [ 7, 7, 5, 3, 1, 3, 7 ] ),
> Transformation( [ 5, 1, 4, 1, 4, 4, 7 ] ));;
gap> MultiplicativeZero(S);
Transformation( [ 7, 7, 7, 7, 7, 7, 7 ] )
gap> T:=MagmaWithZeroAdjoined(S);
<<transformation monoid of degree 7 with 2 generators>
  with 0 adjoined>
gap> map:=UnderlyingInjectionZeroMagma(T);;
gap> x:=Transformation( [ 7, 7, 7, 3, 7, 3, 7 ] );;
gap> x^map;
<monoid with 0 adjoined elt: Transformation( [ 7, 7, 7, 3, 7, 3, 7 ]
 )>
gap> PreImage(map, x^map)=x;
true
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="UnderlyingInjectionZeroMagma" Arg='M'/>
  <Description>
  <C>UnderlyingInjectionZeroMagma</C> 
  returns the embedding used to create the magma with zero adjoined 
  <A>M</A>. 
<Example><![CDATA[
gap> S:=Monoid(Transformation( [ 8, 7, 5, 3, 1, 3, 8, 8 ] ),
> Transformation( [ 5, 1, 4, 1, 4, 4, 7, 8 ] ));;
gap> MultiplicativeZero(S);
Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8 ] )
gap> T:=MagmaWithZeroAdjoined(S);
<<transformation monoid of degree 8 with 2 generators>
  with 0 adjoined>
gap> UnderlyingInjectionZeroMagma(T);
MappingByFunction( <transformation monoid of degree 8 with 2 
 generators>, <<transformation monoid of degree 8 with 2 generators>
  with 0 adjoined>, function( elt ) ... end, function( x ) ... end )
]]></Example>
  </Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Magmas Defined by Multiplication Tables">
<Heading>Magmas Defined by Multiplication Tables</Heading>

The most elementary (but of course usually not recommended) way to implement
a magma with only few elements is via a multiplication table.

<ManSection>
<Func Name="MagmaByMultiplicationTable" Arg='A'/>

<Description>
For a square matrix <A>A</A> with <M>n</M> rows such that all entries of
<A>A</A> are in the range <M>[ 1 .. n ]</M>,
<Ref Func="MagmaByMultiplicationTable"/> returns a magma
<M>M</M> with multiplication <C>*</C> defined by <A>A</A>.
That is, <M>M</M> consists of the elements <M>m_1, m_2, \ldots, m_n</M>,
and <M>m_i * m_j = m_k</M>, with <M>k =</M> <A>A</A><M>[i][j]</M>.
<P/>
The ordering of elements is defined by
<M>m_1 &lt; m_2 &lt; \cdots &lt; m_n</M>,
so <M>m_i</M> can be accessed as
<C>MagmaElement( <A>M</A>, <A>i</A> )</C>,
see&nbsp;<Ref Func="MagmaElement"/>.
<Example><![CDATA[
gap> MagmaByMultiplicationTable([[1,2,3],[2,3,1],[1,1,1]]);
<magma with 3 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaWithOneByMultiplicationTable" Arg='A'/>

<Description>
The only differences between <Ref Func="MagmaByMultiplicationTable"/> and
<Ref Func="MagmaWithOneByMultiplicationTable"/> are that the latter
returns a magma-with-one (see&nbsp;<Ref Func="MagmaWithOne"/>)
if the magma described by the matrix <A>A</A> has an identity,
and returns <K>fail</K> if not.
<Example><![CDATA[
gap> MagmaWithOneByMultiplicationTable([[1,2,3],[2,3,1],[3,1,1]]);
<magma-with-one with 3 generators>
gap> MagmaWithOneByMultiplicationTable([[1,2,3],[2,3,1],[1,1,1]]);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaWithInversesByMultiplicationTable" Arg='A'/>

<Description>
<Ref Func="MagmaByMultiplicationTable"/> and
<Ref Func="MagmaWithInversesByMultiplicationTable"/>
differ only in that the latter returns
magma-with-inverses (see&nbsp;<Ref Func="MagmaWithInverses"/>)
if each element in the magma described by the matrix <A>A</A>
has an inverse,
and returns <K>fail</K> if not.
<Example><![CDATA[
gap> MagmaWithInversesByMultiplicationTable([[1,2,3],[2,3,1],[3,1,2]]);
<magma-with-inverses with 3 generators>
gap> MagmaWithInversesByMultiplicationTable([[1,2,3],[2,3,1],[3,2,1]]);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaElement" Arg='M, i'/>

<Description>
For a magma <A>M</A> and a positive integer <A>i</A>,
<Ref Func="MagmaElement"/> returns the <A>i</A>-th element of <A>M</A>,
w.r.t.&nbsp;the ordering <C>&lt;</C>.
If <A>M</A> has less than <A>i</A> elements then <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Heading>MultiplicationTable</Heading>
<Attr Name="MultiplicationTable" Arg='elms'
 Label="for a list of elements"/>
<Attr Name="MultiplicationTable" Arg='M' Label="for a magma"/>

<Description>
For a list <A>elms</A> of elements that form a magma <M>M</M>,
<Ref Func="MultiplicationTable" Label="for a list of elements"/> returns
a square matrix <M>A</M> of positive integers such that
<M>A[i][j] = k</M> holds if and only if
<A>elms</A><M>[i] *</M> <A>elms</A><M>[j] =</M> <A>elms</A><M>[k]</M>.
This matrix can be used to construct a magma isomorphic to <M>M</M>,
using <Ref Func="MagmaByMultiplicationTable"/>.
<P/>
For a magma <A>M</A>,
<Ref Func="MultiplicationTable" Label="for a magma"/> returns
the multiplication table w.r.t.&nbsp;the sorted list of elements of
<A>M</A>.
<P/>
<Example><![CDATA[
gap> l:= [ (), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;
gap> a:= MultiplicationTable( l );
[ [ 1, 2, 3, 4 ], [ 2, 1, 4, 3 ], [ 3, 4, 1, 2 ], [ 4, 3, 2, 1 ] ]
gap> m:= MagmaByMultiplicationTable( a );
<magma with 4 generators>
gap> One( m );
m1
gap> elm:= MagmaElement( m, 2 );  One( elm );  elm^2;
m2
m1
m1
gap> Inverse( elm );
m2
gap> AsGroup( m );
<group of size 4 with 2 generators>
gap> a:= [ [ 1, 2 ], [ 2, 2 ] ];
[ [ 1, 2 ], [ 2, 2 ] ]
gap> m:= MagmaByMultiplicationTable( a );
<magma with 2 generators>
gap> One( m );  Inverse( MagmaElement( m, 2 ) );
m1
fail
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties for Magmas">
<Heading>Attributes and Properties for Magmas</Heading>

<E>Note</E> that <Ref Func="IsAssociative"/> and <Ref Func="IsCommutative"/>
always refer to the multiplication of a domain.
If a magma <A>M</A> has also an <E>additive structure</E>,
e.g., if <A>M</A> is a ring (see&nbsp;<Ref Chap="Rings"/>),
then the addition <C>+</C> is always assumed to be associative and
commutative,
see&nbsp;<Ref Sect="Arithmetic Operations for Elements"/>.

<ManSection>
<Attr Name="GeneratorsOfMagma" Arg='M'/>

<Description>
is a list <A>gens</A> of elements of the magma <A>M</A> that generates
<A>M</A> as a magma, that is,
the closure of <A>gens</A> under multiplication <Ref Func="\*"/>
is <A>M</A>.
<P/>
For a free magma, each generator can also be accessed using 
the <C>.</C> operator (see <Ref Attr="GeneratorsOfDomain"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfMagmaWithOne" Arg='M'/>

<Description>
is a list <A>gens</A> of elements of the magma-with-one <A>M</A> that
generates <A>M</A> as a magma-with-one,
that is, the closure of <A>gens</A> under multiplication <Ref Func="\*"/>
and <Ref Func="One"/> is <A>M</A>.
<P/>
For a free magma with one, each generator can also be accessed using 
the <C>.</C> operator (see <Ref Attr="GeneratorsOfDomain"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfMagmaWithInverses" Arg='M'/>

<Description>
is a list <A>gens</A> of elements of the magma-with-inverses <A>M</A>
that generates <A>M</A> as a magma-with-inverses,
that is, the closure of <A>gens</A> under multiplication <Ref Func="\*"/>
and taking inverses (see&nbsp;<Ref Func="Inverse"/>) is <A>M</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Centralizer" Arg='M, elm'
 Label="for a magma and an element"/>
<Oper Name="Centralizer" Arg='M, S'
 Label="for a magma and a submagma"/>
<Attr Name="Centralizer" Arg='class'
 Label="for a class of objects in a magma"/>

<Description>
<Index>centraliser</Index><Index>center</Index>
For an element <A>elm</A> of the magma <A>M</A> this operation returns
the  <E>centralizer</E> of <A>elm</A>.
This is the domain of those elements <A>m</A> <M>\in</M> <A>M</A>
that commute  with <A>elm</A>.
<P/>
For a submagma <A>S</A> it returns the domain of those elements that
commute with <E>all</E> elements <A>s</A> of <A>S</A>.
<P/>
If <A>class</A> is a class of objects of a magma (this magma then is
stored as the <C>ActingDomain</C> of <A>class</A>)
such as given by <Ref Func="ConjugacyClass"/>,
<Ref Oper="Centralizer" Label="for a magma and an element"/> returns the
centralizer of <C>Representative(<A>class</A>)</C> (which is a slight
abuse of the notation).
<!-- do we really want this?-->
<!-- (we may be interested in using the <E>attribute</E> also for conjugacy classes,-->
<!-- but also the <E>function</E>?)-->
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> Centralizer(g,(1,2,3));
Group([ (1,2,3) ])
gap> Centralizer(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3) ])
gap> Centralizer(g,Subgroup(g,[(1,2,3),(1,2)]));
Group(())
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Centre" Arg='M'/>
<Attr Name="Center" Arg='M'/>

<Description>
<Ref Func="Centre"/> returns the <E>centre</E> of the magma <A>M</A>,
i.e., the domain of those elements <A>m</A> <M>\in</M> <A>M</A>
that commute and associate with all elements of <A>M</A>.
That is, the set
<M>\{ m \in M; \forall a, b \in M: ma = am,
(ma)b = m(ab), (am)b = a(mb), (ab)m = a(bm) \}</M>.
<P/>
<Ref Func="Center"/> is just a synonym for <Ref Func="Centre"/>.
<P/>
For associative magmas we have that 
<C>Centre( <A>M</A> ) = Centralizer( <A>M</A>, <A>M</A> )</C>,
see&nbsp;<Ref Func="Centralizer" Label="for a magma and a submagma"/>.
<P/>
The centre of a magma is always commutative
(see&nbsp;<Ref Func="IsCommutative"/>).
(When one installs a new method for <Ref Func="Centre"/>,
one should set the <Ref Func="IsCommutative"/> value of the result to
<K>true</K>, in order to make this information available.)
</Description>
</ManSection>

<ManSection>
<Attr Name="Idempotents" Arg='M'/>

<Description>
The set of elements of <A>M</A> which are their own squares.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAssociative" Arg='M'/>

<Description>
A magma <A>M</A> is <E>associative</E> if for all elements
<M>a, b, c \in</M> <A>M</A> the equality
<M>(a</M><C> * </C><M>b)</M><C> * </C><M>c =
a</M><C> * </C><M>(b</M><C> * </C><M>c)</M> holds.
<P/>
An associative magma is called a <E>semigroup</E>
(see&nbsp;<Ref Chap="Semigroups"/>),
an associative magma-with-one is called a <E>monoid</E>
(see&nbsp;<Ref Chap="Semigroups"/>),
and an associative magma-with-inverses is called a <E>group</E>
(see&nbsp;<Ref Chap="Groups"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="IsCentral" Arg='M, obj'/>

<Description>
<Ref Func="IsCentral"/> returns <K>true</K> if the object <A>obj</A>,
which must either be an element or a magma,
commutes with all elements in the magma <A>M</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsCommutative" Arg='M'/>
<Prop Name="IsAbelian" Arg='M'/>

<Description>
A magma <A>M</A> is <E>commutative</E> if for all elements
<M>a, b \in</M> <A>M</A> the
equality <M>a</M><C> * </C><M>b = b</M><C> * </C><M>a</M> holds.
<Ref Prop="IsAbelian"/> is a synonym of <Ref Prop="IsCommutative"/>.
<P/>
Note that the commutativity of the <E>addition</E> <Ref Func="\+"/> in an
additive structure can be tested with
<Ref Func="IsAdditivelyCommutative"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="MultiplicativeNeutralElement" Arg='M'/>

<Description>
returns the element <M>e</M> in the magma <A>M</A> with the property that
<M>e</M><C> * </C><M>m = m = m</M><C> * </C><M>e</M> holds for all
<M>m \in</M> <A>M</A>,
if such an element exists.
Otherwise <K>fail</K> is returned.
<P/>
A magma that is not a magma-with-one can have a multiplicative neutral
element <M>e</M>;
in this case, <M>e</M> <E>cannot</E> be obtained as
<C>One( <A>M</A> )</C>, see&nbsp;<Ref Func="One"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="MultiplicativeZero" Arg='M'/>
<Oper Name="IsMultiplicativeZero" Arg='M, z'/>
<Description>
<C>MultiplicativeZero</C> returns the multiplicative zero of the magma
<A>M</A>  which is the element
<C>z</C> in <A>M</A> such that <C><A>z</A> *  <A>m</A> = <A>m</A> *
<A>z</A> = <A>z</A></C> for all <A>m</A> in <A>M</A>.<P/>

<C>IsMultiplicativeZero</C> returns <K>true</K> if the element <A>z</A> of
the magma <A>M</A> equals the multiplicative zero of <A>M</A>. 
<Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 1, 1, 1 ] ), 
> Transformation( [ 2, 3, 1 ] ) );
<transformation semigroup of degree 3 with 2 generators>
gap> MultiplicativeZero(S);
fail
gap> S:=Semigroup( Transformation( [ 1, 1, 1 ] ), 
> Transformation( [ 1, 3, 2 ] ) );
<transformation semigroup of degree 3 with 2 generators>
gap> MultiplicativeZero(S);
Transformation( [ 1, 1, 1 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SquareRoots" Arg='M, elm'/>

<Description>
is the proper set of all elements <M>r</M> in the magma <A>M</A>
such that <M>r * r =</M> <A>elm</A> holds.
</Description>
</ManSection>

<ManSection>
<Attr Name="TrivialSubmagmaWithOne" Arg='M'/>

<Description>
is the magma-with-one that has the identity of the magma-with-one
<A>M</A> as only element.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  word.msk                    GAP documentation               Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: word.msk,v 1.5 2002/04/15 10:02:34 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Words">
<Heading>Words</Heading>

This chapter describes categories of <E>words</E> and
<E>nonassociative words</E>, and operations for them.
For information about <E>associative words</E>,
which occur for example as elements in free groups,
see Chapter&nbsp;<Ref Chap="Associative Words"/>.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Categories of Words and Nonassociative Words">
<Heading>Categories of Words and Nonassociative Words</Heading>

<ManSection>
<Filt Name="IsWord" Arg='obj' Type='Category'/>
<Filt Name="IsWordWithOne" Arg='obj' Type='Category'/>
<Filt Name="IsWordWithInverse" Arg='obj' Type='Category'/>

<Description>
<Index>abstract word</Index>
Given a free multiplicative structure <M>M</M> that is freely generated
by a subset <M>X</M>,
any expression of an element in <M>M</M> as an iterated product of
elements in <M>X</M> is called a <E>word</E> over <M>X</M>.
<P/>
Interesting cases of free multiplicative structures are those of
free semigroups, free monoids, and free groups,
where the multiplication is associative
(see&nbsp;<Ref Func="IsAssociative"/>),
which are described in Chapter&nbsp;<Ref Chap="Associative Words"/>,
and also the case of free magmas,
where the multiplication is nonassociative
(see&nbsp;<Ref Func="IsNonassocWord"/>).
<P/>
Elements in free magmas
(see&nbsp;<Ref Func="FreeMagma" Label="for given rank"/>)
lie in the category <Ref Func="IsWord"/>;
similarly, elements in free magmas-with-one
(see&nbsp;<Ref Func="FreeMagmaWithOne" Label="for given rank"/>) 
lie in the category <Ref Func="IsWordWithOne"/>, and so on.
<P/>
<Ref Func="IsWord"/> is mainly a <Q>common roof</Q> for the two
<E>disjoint</E> categories
<Ref Func="IsAssocWord"/> and <Ref Func="IsNonassocWord"/>
of associative and nonassociative words.
This means that associative words are <E>not</E> regarded as special
cases of nonassociative words.
The main reason for this setup is that we are interested in different
external representations for associative and nonassociative words
(see&nbsp;<Ref Sect="External Representation for Nonassociative Words"/>
and <Ref Sect="The External Representation for Associative Words"/>).
<P/>
Note that elements in finitely presented groups and also elements in
polycyclic groups in &GAP; are <E>not</E> in <Ref Func="IsWord"/>
although they are usually called words,
see Chapters&nbsp;<Ref Chap="Finitely Presented Groups"/>
and&nbsp;<Ref Chap="Pc Groups"/>.
<P/>
Words are <E>constants</E>
(see&nbsp;<Ref Sect="Mutability and Copyability"/>),
that is, they are not copyable and not mutable.
<P/>
The usual way to create words is to form them as products of known words,
starting from <E>generators</E> of a free structure such as a free magma
or a free group (see&nbsp;<Ref Func="FreeMagma" Label="for given rank"/>,
<Ref Func="FreeGroup" Label="for given rank"/>).
<P/>
Words are also used to implement free algebras,
in the same way as group elements are used to implement group algebras
(see&nbsp;<Ref Sect="Constructing Algebras as Free Algebras"/>
and Chapter&nbsp;<Ref Chap="Magma Rings"/>).
<P/>
<Example><![CDATA[
gap> m:= FreeMagmaWithOne( 2 );;  gens:= GeneratorsOfMagmaWithOne( m );
[ x1, x2 ]
gap> w1:= gens[1] * gens[2] * gens[1];
((x1*x2)*x1)
gap> w2:= gens[1] * ( gens[2] * gens[1] );
(x1*(x2*x1))
gap> w1 = w2;  IsAssociative( m );
false
false
gap> IsWord( w1 );  IsAssocWord( w1 );  IsNonassocWord( w1 );
true
false
true
gap> s:= FreeMonoid( 2 );;  gens:= GeneratorsOfMagmaWithOne( s );
[ m1, m2 ]
gap> u1:= ( gens[1] * gens[2] ) * gens[1];
m1*m2*m1
gap> u2:= gens[1] * ( gens[2] * gens[1] );
m1*m2*m1
gap> u1 = u2;  IsAssociative( s );
true
true
gap> IsWord( u1 );  IsAssocWord( u1 );  IsNonassocWord( u1 );
true
true
false
gap> a:= (1,2,3);;  b:= (1,2);;
gap> w:= a*b*a;;  IsWord( w );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsWordCollection" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsWordCollection"/> is the collections category
(see&nbsp;<Ref Func="CategoryCollections"/>) of <Ref Func="IsWord"/>.
<Example><![CDATA[
gap> IsWordCollection( m );  IsWordCollection( s );
true
true
gap> IsWordCollection( [ "a", "b" ] );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNonassocWord" Arg='obj' Type='Category'/>
<Filt Name="IsNonassocWordWithOne" Arg='obj' Type='Category'/>

<Description>
A <E>nonassociative word</E> in &GAP; is an element in a free magma or
a free magma-with-one (see&nbsp;<Ref Sect="Free Magmas"/>).
<P/>
The default methods for <Ref Func="ViewObj"/> and <Ref Func="PrintObj"/>
show nonassociative words as products of letters,
where the succession of multiplications is determined by round brackets.
<P/>
In this sense each nonassociative word describes a <Q>program</Q> to
form a product of generators.
(Also associative words can be interpreted as such programs,
except that the exact succession of multiplications is not prescribed
due to the associativity.)
The function <Ref Func="MappedWord"/> implements a way to
apply such a program.
A more general way is provided by straight line programs
(see&nbsp;<Ref Sect="Straight Line Programs"/>).
<P/>
Note that associative words
(see Chapter&nbsp;<Ref Chap="Associative Words"/>)
are <E>not</E> regarded as special cases of nonassociative words
(see&nbsp;<Ref Func="IsWord"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNonassocWordCollection" Arg='obj' Type='Category'/>
<Filt Name="IsNonassocWordWithOneCollection" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsNonassocWordCollection"/> is the collections category
(see&nbsp;<Ref Func="CategoryCollections"/>) of
<Ref Func="IsNonassocWord"/>,
and <Ref Func="IsNonassocWordWithOneCollection"/> is the collections
category of <Ref Func="IsNonassocWordWithOne"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Words">
<Heading>Comparison of Words</Heading>

<ManSection>
<Func Name="\=" Label="for nonassociative words" Arg='w1, w2'/>

<Description>
<Index Subkey="nonassociative words">equality</Index>
<P/>
Two words are equal if and only if they are words over the same alphabet
and with equal external representations
(see&nbsp;<Ref Sect="External Representation for Nonassociative Words"/>
and <Ref Sect="The External Representation for Associative Words"/>).
For nonassociative words, the latter means that the words arise from the
letters of the alphabet by the same sequence of multiplications.
</Description>
</ManSection>

<ManSection>
<Func Name="\&lt;" Label="for nonassociative words" Arg='w1, w2'/>

<Description>
<Index Subkey="nonassociative words">smaller</Index>
Words are ordered according to their external representation.
More precisely, two words can be compared if they are words over the same
alphabet, and the word with smaller external representation is smaller.
For nonassociative words, the ordering is defined
in&nbsp;<Ref Sect="External Representation for Nonassociative Words"/>;
associative words are ordered by the shortlex ordering via <C>&lt;</C>
(see&nbsp;<Ref Sect="The External Representation for Associative Words"/>).
<P/>
Note that the alphabet of a word is determined by its family
(see&nbsp;<Ref Sect="Families"/>),
and that the result of each call to
<Ref Func="FreeMagma" Label="for given rank"/>,
<Ref Func="FreeGroup" Label="for given rank"/> etc. consists of words
over a new alphabet.
In particular, there is no <Q>universal</Q> empty word,
every families of words in <Ref Func="IsWordWithOne"/> has its own
empty word.
<P/>
<Example><![CDATA[
gap> m:= FreeMagma( "a", "b" );;
gap> x:= FreeMagma( "a", "b" );;
gap> mgens:= GeneratorsOfMagma( m );
[ a, b ]
gap> xgens:= GeneratorsOfMagma( x );
[ a, b ]
gap> a:= mgens[1];;  b:= mgens[2];;
gap> a = xgens[1];
false
gap> a*(a*a) = (a*a)*a;  a*b = b*a;  a*a = a*a;
false
false
true
gap> a < b;  b < a;  a < a*b;
true
false
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Words">
<Heading>Operations for Words</Heading>

Two words can be multiplied via <C>*</C> only if they are words over the
same alphabet (see&nbsp;<Ref Sect="Comparison of Words"/>).

<ManSection>
<Oper Name="MappedWord" Arg='w, gens, imgs'/>

<Description>
<Ref Func="MappedWord"/> returns the object that is obtained by replacing
each occurrence in the word <A>w</A> of a generator in the list
<A>gens</A> by the corresponding object in the list <A>imgs</A>.
The lists <A>gens</A> and <A>imgs</A> must of course have the same length.
<P/>
<Ref Func="MappedWord"/> needs to do some preprocessing to get internal
generator numbers etc. When mapping many (several thousand) words, an
explicit loop over the words syllables might be faster.
<P/>
For example, if the elements in <A>imgs</A> are all
<E>associative words</E>
(see Chapter&nbsp;<Ref Chap="Associative Words"/>)
in the same family as the elements in <A>gens</A>,
and some of them are equal to the corresponding generators in <A>gens</A>,
then those may be omitted from <A>gens</A> and <A>imgs</A>.
In this situation, the special case that the lists <A>gens</A>
and <A>imgs</A> have only length <M>1</M> is handled more efficiently by
<Ref Func="EliminatedWord"/>.
<Example><![CDATA[
gap> m:= FreeMagma( "a", "b" );;  gens:= GeneratorsOfMagma( m );;
gap> a:= gens[1];  b:= gens[2];
a
b
gap> w:= (a*b)*((b*a)*a)*b;
(((a*b)*((b*a)*a))*b)
gap> MappedWord( w, gens, [ (1,2), (1,2,3,4) ] );
(2,4,3)
gap> a:= (1,2);; b:= (1,2,3,4);;  (a*b)*((b*a)*a)*b;
(2,4,3)
gap> f:= FreeGroup( "a", "b" );;
gap> a:= GeneratorsOfGroup(f)[1];;  b:= GeneratorsOfGroup(f)[2];;
gap> w:= a^5*b*a^2/b^4*a;
a^5*b*a^2*b^-4*a
gap> MappedWord( w, [ a, b ], [ (1,2), (1,2,3,4) ] );
(1,3,4,2)
gap> (1,2)^5*(1,2,3,4)*(1,2)^2/(1,2,3,4)^4*(1,2);
(1,3,4,2)
gap> MappedWord( w, [ a ], [ a^2 ] );
a^10*b*a^4*b^-4*a^2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Free Magmas">
<Heading>Free Magmas</Heading>

The easiest way to create a family of words is to construct the free
object generated by these words.
Each such free object defines a unique alphabet,
and its generators are simply the words of length one over this alphabet;
These generators can be accessed via <Ref Func="GeneratorsOfMagma"/> in
the case of a free magma,
and via <Ref Func="GeneratorsOfMagmaWithOne"/> in the case of a free
magma-with-one.

<ManSection>
<Heading>FreeMagma</Heading>
<Func Name="FreeMagma" Arg='rank[, name]'
 Label="for given rank"/>
<Func Name="FreeMagma" Arg='name1, name2, ...'
 Label="for various names"/>
<Func Name="FreeMagma" Arg='names'
 Label="for a list of names"/>
<Func Name="FreeMagma" Arg='infinity, name, init'
 Label="for infinitely many generators"/>

<Description>
Called with a positive integer <A>rank</A>,
<Ref Func="FreeMagma" Label="for given rank"/> returns
a free magma on <A>rank</A> generators.
If the optional argument <A>name</A> is given then the generators are
printed as <A>name</A><C>1</C>, <A>name</A><C>2</C> etc.,
that is, each name is the concatenation of the string <A>name</A> and an
integer from <C>1</C> to <A>range</A>.
The default for <A>name</A> is the string <C>"m"</C>.
<P/>
Called in the second form,
<Ref Func="FreeMagma" Label="for various names"/> returns
a free magma on as many generators as arguments, printed as
<A>name1</A>, <A>name2</A> etc.
<P/>
Called in the third form,
<Ref Func="FreeMagma" Label="for a list of names"/> returns
a free magma on as many generators as the length of the list
<A>names</A>, the <M>i</M>-th generator being printed as
<A>names</A><C>[</C><M>i</M><C>]</C>.
<P/>
Called in the fourth form,
<Ref Func="FreeMagma" Label="for infinitely many generators"/>
returns a free magma on infinitely many generators, where the first
generators are printed by the names in the list <A>init</A>,
and the other generators by <A>name</A> and an appended number.
</Description>
</ManSection>

<ManSection>
<Heading>FreeMagmaWithOne</Heading>
<Func Name="FreeMagmaWithOne" Arg='rank[, name]'
 Label="for given rank"/>
<Func Name="FreeMagmaWithOne" Arg='name1, name2, ...'
 Label="for various names"/>
<Func Name="FreeMagmaWithOne" Arg='names'
 Label="for a list of names"/>
<Func Name="FreeMagmaWithOne" Arg='infinity, name, init'
 Label="for infinitely many generators"/>

<Description>
Called with a positive integer <A>rank</A>,
<Ref Func="FreeMagmaWithOne" Label="for given rank"/> returns
a free magma-with-one on <A>rank</A> generators.
If the optional argument <A>name</A> is given then the generators are
printed as <A>name</A><C>1</C>, <A>name</A><C>2</C> etc.,
that is, each name is the concatenation of the string <A>name</A> and an
integer from <C>1</C> to <A>range</A>.
The default for <A>name</A> is the string <C>"m"</C>.
<P/>
Called in the second form,
<Ref Func="FreeMagmaWithOne" Label="for various names"/> returns
a free magma-with-one on as many generators as arguments, printed as
<A>name1</A>, <A>name2</A> etc.
<P/>
Called in the third form,
<Ref Func="FreeMagmaWithOne" Label="for a list of names"/> returns
a free magma-with-one on as many generators as the length of the list
<A>names</A>, the <M>i</M>-th generator being printed as
<A>names</A><C>[</C><M>i</M><C>]</C>.
<P/>
Called in the fourth form,
<Ref Func="FreeMagmaWithOne" Label="for infinitely many generators"/>
returns a free magma-with-one on infinitely many generators, where the
first generators are printed by the names in the list <A>init</A>,
and the other generators by <A>name</A> and an appended number.
<P/>
<Example><![CDATA[
gap> FreeMagma( 3 );
<free magma on the generators [ x1, x2, x3 ]>
gap> FreeMagma( "a", "b" );
<free magma on the generators [ a, b ]>
gap> FreeMagma( infinity );
<free magma with infinity generators>
gap> FreeMagmaWithOne( 3 );
<free magma-with-one on the generators [ x1, x2, x3 ]>
gap> FreeMagmaWithOne( "a", "b" );
<free magma-with-one on the generators [ a, b ]>
gap> FreeMagmaWithOne( infinity );
<free magma-with-one with infinity generators>
]]></Example>
<P/>
Remember that the names of generators used for printing
do not necessarily distinguish letters of the alphabet;
so it is possible to create arbitrarily weird
situations by choosing strange letter names.
<P/>
<Example><![CDATA[
gap> m:= FreeMagma( "x", "x" );  gens:= GeneratorsOfMagma( m );;
<free magma on the generators [ x, x ]>
gap> gens[1] = gens[2];
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="External Representation for Nonassociative Words">
<Heading>External Representation for Nonassociative Words</Heading>

The external representation of nonassociative words is defined
as follows.
The <M>i</M>-th generator of the family of elements in question has
external representation <M>i</M>,
the identity (if exists) has external representation <M>0</M>,
the inverse of the <M>i</M>-th generator (if exists) has external
representation <M>-i</M>.
If <M>v</M> and <M>w</M> are nonassociative words with external
representations <M>e_v</M> and <M>e_w</M>,
respectively then the product <M>v * w</M> has external
representation <M>[ e_v, e_w ]</M>.
So the external representation of any nonassociative word is either an
integer or a nested list of integers and lists, where each list has
length two.
<P/>
One can create a nonassociative word from a family of words and the
external representation of a nonassociative word using
<Ref Func="ObjByExtRep"/>.
<P/>
<Example><![CDATA[
gap> m:= FreeMagma( 2 );;  gens:= GeneratorsOfMagma( m );
[ x1, x2 ]
gap> w:= ( gens[1] * gens[2] ) * gens[1];
((x1*x2)*x1)
gap> ExtRepOfObj( w );  ExtRepOfObj( gens[1] );
[ [ 1, 2 ], 1 ]
1
gap>  ExtRepOfObj( w*w );
[ [ [ 1, 2 ], 1 ], [ [ 1, 2 ], 1 ] ]
gap> ObjByExtRep( FamilyObj( w ), 2 );
x2
gap> ObjByExtRep( FamilyObj( w ), [ 1, [ 2, 1 ] ] );
(x1*(x2*x1))
]]></Example>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  wordass.msk                 GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: wordass.msk,v 1.28 2006/02/26 14:37:20 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Associative Words">
<Heading>Associative Words</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Categories of Associative Words">
<Heading>Categories of Associative Words</Heading>

Associative words are used to represent elements in free groups,
semigroups and monoids in &GAP;
(see&nbsp;<Ref Sect="Free Groups, Monoids and Semigroups"/>).
An associative word is just a sequence of letters,
where each letter is an element of an alphabet (in the following called a
<E>generator</E>) or its inverse.
Associative words can be multiplied;
in free monoids also the computation of an identity is permitted,
in free groups also the computation of inverses
(see&nbsp;<Ref Sect="Operations for Associative Words"/>).
<P/>
Different alphabets correspond to different families of associative words.
There is no relation whatsoever between words in different families.
<P/>
<Example><![CDATA[
gap> f:= FreeGroup( "a", "b", "c" );
<free group on the generators [ a, b, c ]>
gap> gens:= GeneratorsOfGroup(f);
[ a, b, c ]
gap> w:= gens[1]*gens[2]/gens[3]*gens[2]*gens[1]/gens[1]*gens[3]/gens[2];
a*b*c^-1*b*c*b^-1
gap> w^-1;
b*c^-1*b^-1*c*b^-1*a^-1
]]></Example>
<P/>
Words are displayed as products of letters.
The letters are usually printed like <C>f1</C>, <C>f2</C>, <M>\ldots</M>,
but it is possible to give user defined names to them,
which can be arbitrary strings.
These names do not necessarily identify a unique letter (generator),
it is possible to have several letters
&ndash;even in the same family&ndash; that are displayed in the same way.
Note also that
<E>there is no relation between the names of letters and variable names</E>.
In the example above, we might have typed
<P/>
<Example><![CDATA[
gap> a:= f.1;; b:= f.2;; c:= f.3;;
]]></Example>
<P/>
(<E>Interactively</E>, the function
<Ref Func="AssignGeneratorVariables"/> provides a shorthand for this.)
This allows us to define <C>w</C> more conveniently:
<P/>
<Example><![CDATA[
gap> w := a*b/c*b*a/a*c/b;
a*b*c^-1*b*c*b^-1
]]></Example>
<P/>
Using homomorphisms it is possible to express elements of a group as words
in terms of generators,
see&nbsp;<Ref Sect="Expressing Group Elements as Words in Generators"/>.

<ManSection>
<Filt Name="IsAssocWord" Arg='obj' Type='Category'/>
<Filt Name="IsAssocWordWithOne" Arg='obj' Type='Category'/>
<Filt Name="IsAssocWordWithInverse" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsAssocWord"/> is the category of associative words
in free semigroups,
<Ref Func="IsAssocWordWithOne"/> is the category of associative words
in free monoids
(which admit the operation <Ref Func="One"/> to compute an identity),
<Ref Func="IsAssocWordWithInverse"/> is the category of associative words
in free groups (which have an inverse).
See&nbsp;<Ref Func="IsWord"/> for more general categories of words.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Free Groups, Monoids and Semigroups">
<Heading>Free Groups, Monoids and Semigroups</Heading>

Usually a family of associative words will be generated by constructing
the free object generated by them.
See <Ref Func="FreeMonoid" Label="for given rank"/>,
<Ref Func="FreeSemigroup" Label="for given rank"/> for details.

<ManSection>
<Heading>FreeGroup</Heading>
<Func Name="FreeGroup" Arg='[wfilt, ]rank[, name]'
 Label="for given rank"/>
<Func Name="FreeGroup" Arg='[wfilt, ]name1, name2, ...'
 Label="for various names"/>
<Func Name="FreeGroup" Arg='[wfilt, ]names'
 Label="for a list of names"/>
<Func Name="FreeGroup" Arg='[wfilt, ]infinity, name, init'
 Label="for infinitely many generators"/>

<Description>
Called with a positive integer <A>rank</A>,
<Ref Func="FreeGroup" Label="for given rank"/> returns
a free group on <A>rank</A> generators.
If the optional argument <A>name</A> is given then the generators are
printed as <A>name</A><C>1</C>, <A>name</A><C>2</C> etc.,
that is, each name is the concatenation of the string <A>name</A> and an
integer from <C>1</C> to <A>range</A>.
The default for <A>name</A> is the string <C>"f"</C>.
<P/>
Called in the second form,
<Ref Func="FreeGroup" Label="for various names"/> returns
a free group on as many generators as arguments, printed as
<A>name1</A>, <A>name2</A> etc.
<P/>
Called in the third form,
<Ref Func="FreeGroup" Label="for a list of names"/> returns
a free group on as many generators as the length of the list
<A>names</A>, the <M>i</M>-th generator being printed as
<A>names</A><C>[</C><M>i</M><C>]</C>.
<P/>
Called in the fourth form,
<Ref Func="FreeGroup" Label="for infinitely many generators"/>
returns a free group on infinitely many generators, where the first
generators are printed by the names in the list <A>init</A>,
and the other generators by <A>name</A> and an appended number.
<P/>
If the extra argument <A>wfilt</A> is given, it must be either
<C>IsSyllableWordsFamily</C> or <C>IsLetterWordsFamily</C> or
<C>IsWLetterWordsFamily</C> or <C>IsBLetterWordsFamily</C>.
This filter then specifies the representation used for the elements of
the free group
(see&nbsp;<Ref Sect="Representations for Associative Words"/>).
If no such filter is given, a letter representation is used.
<P/>
(For interfacing to old code that omits the representation flag, use of
the syllable representation is also triggered by setting the option
<C>FreeGroupFamilyType</C> to the string <C>"syllable"</C>.)
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFreeGroup" Arg='obj' Type='Category'/>

<Description>
Any group consisting of elements in <Ref Func="IsAssocWordWithInverse"/>
lies in the filter <Ref Func="IsFreeGroup"/>;
this holds in particular for any group created with
<Ref Func="FreeGroup" Label="for given rank"/>,
or any subgroup of such a group.
<P/>
<!--  Note that we cannot define <C>IsFreeMonoid</C> as-->
<!--  <C>IsAssocWordWithOneCollection and IsMonoid</C> because then-->
<!--  every free group would be a free monoid, which is not true!-->
<!--  Instead we just make it a property and set it at creation-->
Also see Chapter&nbsp;<Ref Chap="Finitely Presented Groups"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="AssignGeneratorVariables" Arg='G'/>

<Description>
If <A>G</A> is a group, whose generators are represented by symbols (for 
example a free group, a finitely presented group or a pc group) this
function assigns these generators to global variables with the same 
names.
<P/>
The aim of this function is to make it easy in interactive use to work
with (for example) a free group. It is a shorthand for a sequence of
assignments of the form
<P/>
<Log><![CDATA[
var1:=GeneratorsOfGroup(G)[1];
var2:=GeneratorsOfGroup(G)[2];
...
varn:=GeneratorsOfGroup(G)[n];
]]></Log>
<P/>
However, since overwriting global variables can be very dangerous,
<E>it is not permitted to use this function within a function</E>.
(If &ndash;despite this warning&ndash; this is done,
the result is undefined.)
<P/>
If the assignment overwrites existing variables a warning is given, if
any of the variables if write protected, or any of the generator names   
would not be a proper variable name, an error is raised.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Associative Words">
<Heading>Comparison of Associative Words</Heading>

<ManSection>
<Func Name="\=" Arg='w1, w2' Label="for associative words"/>

<Description>
<Index Subkey="associative words">equality</Index>
Two associative words are equal if they are words over the same alphabet
and if they are sequences of the same letters.
This is equivalent to saying that the external representations of the
words are equal,
see&nbsp;<Ref Sect="The External Representation for Associative Words"/>
and <Ref Sect="Comparison of Words"/>.
<P/>
There is no <Q>universal</Q> empty word,
every alphabet (that is, every family of words) has its own empty word.
<Example><![CDATA[
gap> f:= FreeGroup( "a", "b", "b" );;
gap> gens:= GeneratorsOfGroup(f);
[ a, b, b ]
gap> gens[2] = gens[3];
false
gap> x:= gens[1]*gens[2];
a*b
gap> y:= gens[2]/gens[2]*gens[1]*gens[2];
a*b
gap> x = y;
true
gap> z:= gens[2]/gens[2]*gens[1]*gens[3];
a*b
gap> x = z;
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="\&lt;" Arg='w1, w2' Label="for associative words"/>

<Description>
<Index Subkey="associative words">smaller</Index>
The ordering of associative words is defined by length and lexicography
(this ordering is called <E>short-lex</E> ordering),
that is, shorter words are smaller than longer words,
and words of the same length are compared w.r.t.&nbsp;the lexicographical
ordering induced by the ordering of generators.
Generators are sorted according to the order in which they were created.
If the generators are invertible then each generator <A>g</A> is larger
than its inverse <A>g</A><C>^-1</C>,
and <A>g</A><C>^-1</C> is larger than every generator that is smaller
than <A>g</A>.
<Example><![CDATA[
gap> f:= FreeGroup( 2 );;  gens:= GeneratorsOfGroup( f );;
gap> a:= gens[1];;  b:= gens[2];;
gap> One(f) < a^-1;  a^-1 < a;  a < b^-1;  b^-1 < b; b < a^2;  a^2 < a*b;
true
true
true
true
true
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsShortLexLessThanOrEqual" Arg='u, v'/>

<Description>
returns <C>IsLessThanOrEqualUnder(<A>ord</A>, <A>u</A>, <A>v</A>)</C>
where <A>ord</A> is the short less ordering for the family of <A>u</A>
and <A>v</A>.
(This is here for compatibility with &GAP;&nbsp;4.2.)
</Description>
</ManSection>

<ManSection>
<Func Name="IsBasicWreathLessThanOrEqual" Arg='u, v'/>

<Description>
returns <C>IsLessThanOrEqualUnder(<A>ord</A>, <A>u</A>, <A>v</A>)</C>
where <A>ord</A> is the basic wreath product ordering for the family of
<A>u</A> and <A>v</A>.
(This is here for compatibility with &GAP;&nbsp;4.2.)
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Associative Words">
<Heading>Operations for Associative Words</Heading>

The product of two given associative words is defined as the freely
reduced concatenation of the words.
<Index Subkey="of words">product</Index>
<Index Subkey="of words">quotient</Index>
<Index Subkey="of words">power</Index>
<Index Subkey="of a word">conjugate</Index>
Besides the multiplication <Ref Func="\*"/>, the arithmetical operators
<Ref Func="One"/> (if the word lies in a family with identity)
and (if the generators are invertible) <Ref Func="Inverse"/>,
<Ref Func="\/"/>,<Ref Func="\^"/>,
<Index Key="Comm" Subkey="for words"><C>Comm</C></Index>
<Ref Func="Comm"/>, and
<Index Key="LeftQuotient" Subkey="for words"><C>LeftQuotient</C></Index>
<Ref Func="LeftQuotient"/> are applicable to associative words,
see&nbsp;<Ref Sect="Arithmetic Operations for Elements"/>.
<P/>
See also <Ref Func="MappedWord"/>, an operation that is applicable to
arbitrary words.
<P/>
See Section <Ref Sect="Representations for Associative Words"/>
for a discussion of the internal representations of associative words
that are supported by &GAP;.
Note that operations to extract or act on parts of words
(letter or syllables) can carry substantially different
costs, depending on the representation the words are in.

<P/>
<ManSection>
<Attr Name="Length" Arg='w' Label="for a associative word"/>

<Description>
<Index Subkey="of a word">length</Index>
For an associative word <A>w</A>,
<Ref Func="Length" Label="for a associative word"/> returns
the number of letters in <A>w</A>.
<P/>
<Example><![CDATA[
gap> f := FreeGroup("a","b");; gens := GeneratorsOfGroup(f);;
gap> a := gens[1];; b := gens[2];;w := a^5*b*a^2*b^-4*a;;
gap>  w; Length( w );  Length( a^17 );  Length( w^0 );
a^5*b*a^2*b^-4*a
13
17
0
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentSumWord" Arg='w, gen'/>

<Description>
For an associative word <A>w</A> and a generator <A>gen</A>,
<Ref Func="ExponentSumWord"/> returns the number of times <A>gen</A>
appears in <A>w</A> minus the number of times its inverse appears in
<A>w</A>.
If both <A>gen</A> and its inverse do not occur in <A>w</A> then <M>0</M>
is returned.
<A>gen</A> may also be the inverse of a generator.
<Example><![CDATA[
gap> w;  ExponentSumWord( w, a );  ExponentSumWord( w, b );
a^5*b*a^2*b^-4*a
8
-3
gap> ExponentSumWord( (a*b*a^-1)^3, a );  ExponentSumWord( w, b^-1 );
0
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Subword" Arg='w, from, to'/>

<Description>
For an associative word <A>w</A> and two positive integers <A>from</A>
and <A>to</A>,
<Ref Oper="Subword"/> returns the subword of <A>w</A> that begins
at position <A>from</A> and ends at position <A>to</A>.
Indexing is done with origin 1.
<Example><![CDATA[
gap> w;  Subword( w, 3, 7 );
a^5*b*a^2*b^-4*a
a^3*b*a
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PositionWord" Arg='w, sub, from'/>

<Description>
Let <A>w</A> and <A>sub</A> be associative words,
and <A>from</A> a positive integer.
<Ref Func="PositionWord"/> returns the position of the first occurrence
of <A>sub</A> as a subword of <A>w</A>, starting at position <A>from</A>.
If there is no such occurrence, <K>fail</K> is returned.
Indexing is done with origin 1.
<P/>
In other words, <C>PositionWord( <A>w</A>, <A>sub</A>, <A>from</A> )</C>
is the smallest integer <M>i</M> larger than or equal to <A>from</A> such
that <C>Subword( <A>w</A>, </C><M>i</M><C>,</C>
<M>i</M><C>+Length( <A>sub</A> )-1 ) =</C>
<A>sub</A>, see&nbsp;<Ref Func="Subword"/>.
<P/>
<Example><![CDATA[
gap> w;  PositionWord( w, a/b, 1 );
a^5*b*a^2*b^-4*a
8
gap> Subword( w, 8, 9 );
a*b^-1
gap> PositionWord( w, a^2, 1 );
1
gap> PositionWord( w, a^2, 2 );
2
gap> PositionWord( w, a^2, 6 );
7
gap> PositionWord( w, a^2, 8 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>SubstitutedWord</Heading>
<Oper Name="SubstitutedWord" Arg='w, from, to, by'
 Label="replace an interval by a given word"/>
<Oper Name="SubstitutedWord" Arg='w, sub, from, by'
 Label="replace a subword by a given word"/>

<Description>
Let <A>w</A> be an associative word.
<P/>
In the first form,
<Ref Func="SubstitutedWord" Label="replace an interval by a given word"/>
returns the associative word obtained by replacing the subword of
<A>w</A> that begins at position <A>from</A> and ends at position
<A>to</A> by the associative word <A>by</A>.
<A>from</A> and <A>to</A> must be positive integers,
indexing is done with origin 1.
In other words,
<C>SubstitutedWord( <A>w</A>, <A>from</A>, <A>to</A>, <A>by</A> )</C>
is the product of the three words
<C>Subword( <A>w</A>, 1, <A>from</A>-1 )</C>, <A>by</A>,
and <C>Subword( <A>w</A>, <A>to</A>+1, Length( <A>w</A> ) )</C>,
see&nbsp;<Ref Func="Subword"/>.
<P/>
In the second form,
<Ref Func="SubstitutedWord" Label="replace a subword by a given word"/>
returns the associative word obtained by replacing the first occurrence
of the associative word <A>sub</A> of <A>w</A>, starting at position
<A>from</A>, by the associative word <A>by</A>;
if there is no such occurrence, <K>fail</K> is returned.
<Example><![CDATA[
gap> w;  SubstitutedWord( w, 3, 7, a^19 );
a^5*b*a^2*b^-4*a
a^22*b^-4*a
gap> SubstitutedWord( w, a, 6, b^7 );
a^5*b^8*a*b^-4*a
gap> SubstitutedWord( w, a*b, 6, b^7 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EliminatedWord" Arg='w, gen, by'/>

<Description>
For an associative word <A>w</A>, a generator <A>gen</A>,
and an associative word <A>by</A>, <Ref Func="EliminatedWord"/> returns
the associative word obtained by replacing each occurrence of <A>gen</A>
in <A>w</A> by <A>by</A>.
<Example><![CDATA[
gap> w;  EliminatedWord( w, a, a^2 );  EliminatedWord( w, a, b^-1 );
a^5*b*a^2*b^-4*a
a^10*b*a^4*b^-4*a^2
b^-11
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Associative Words by their Syllables">
<Heading>Operations for Associative Words by their Syllables</Heading>

For an associative word
<A>w</A> <M>= x_1^{{n_1}} x_2^{{n_2}} \cdots x_k^{{n_k}}</M>
over an alphabet containing <M>x_1, x_2, \ldots, x_k</M>,
such that <M>x_i \neq x_{{i+1}}^{{\pm 1}}</M> for
<M>1 \leq i \leq k-1</M>,
the subwords <M>x_i^{{e_i}}</M> are uniquely determined;
these powers of generators are called the <E>syllables</E> of <M>w</M>.

<ManSection>
<Attr Name="NumberSyllables" Arg='w'/>

<Description>
<Ref Func="NumberSyllables"/> returns the number of syllables of the
associative word <A>w</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentSyllable" Arg='w, i'/>

<Description>
<Ref Func="ExponentSyllable"/> returns the exponent of the <A>i</A>-th
syllable of the associative word <A>w</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="GeneratorSyllable" Arg='w, i'/>

<Description>
<Ref Func="GeneratorSyllable"/> returns the number of the generator that
is involved in the <A>i</A>-th syllable of the associative word <A>w</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="SubSyllables" Arg='w, from, to'/>

<Description>
<Ref Func="SubSyllables"/> returns the subword of the associative word
<A>w</A> that consists of the syllables from positions <A>from</A> to
<A>to</A>, where <A>from</A> and <A>to</A> must be positive integers,
and indexing is done with origin 1.
<Example><![CDATA[
gap> w;  NumberSyllables( w );
a^5*b*a^2*b^-4*a
5
gap> ExponentSyllable( w, 3 );
2
gap> GeneratorSyllable( w, 3 );
1
gap> SubSyllables( w, 2, 3 );
b*a^2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Representations for Associative Words">
<Heading>Representations for Associative Words</Heading>

&GAP; provides two different internal kinds of representations of
associative words.  The first one are <Q>syllable representations</Q> in which
words are stored in syllable (i.e. generator,exponent) form. (Older versions
of &GAP; only used this representation.) The second kind are <Q>letter
representations</Q> in which each letter in a word is represented by its index
number. Negative numbers are used for inverses. Unless the syllable
representation is specified explicitly when creating the free group/monoid
or semigroup, a letter representation is used by default.
<P/>
Depending on the task in mind, either of these two representations will
perform better in time or in memory use and algorithms that are syllable or
letter based (for example <Ref Func="GeneratorSyllable"/> and
<Ref Func="Subword"/>) perform substantially better in the corresponding
representation.
For example when creating pc groups (see&nbsp;<Ref Chap="Pc Groups"/>),
it is advantageous to use a syllable representation while calculations in
free groups usually benefit from using a letter representation.

<ManSection>
<Filt Name="IsLetterAssocWordRep" Arg='obj' Type='Representation'/>

<Description>
A word in letter representation stores a list of generator/inverses
numbers (as given by <Ref Func="LetterRepAssocWord"/>).
Letter access is fast, syllable access is slow for such words.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLetterWordsFamily" Arg='obj' Type='Category'/>

<Description>
A letter word family stores words by default in letter form. 
<P/>
Internally, there are letter representations that use integers (4 Byte)
to represent a generator and letter representations that use single bytes
to represent a character.
The latter are more memory efficient, but can only be used if there are
less than 128 generators (in which case they are used by default).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsBLetterAssocWordRep" Arg='obj' Type='Representation'/>
<Filt Name="IsWLetterAssocWordRep" Arg='obj' Type='Representation'/>

<Description>
these two subrepresentations of <Ref Func="IsLetterAssocWordRep"/>
indicate whether the word is stored as a list of bytes (in a string)
or as a list of integers).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsBLetterWordsFamily" Arg='obj' Type='Category'/>
<Filt Name="IsWLetterWordsFamily" Arg='obj' Type='Category'/>

<Description>
These two subcategories of <Ref Func="IsLetterWordsFamily"/> specify the
type of letter representation to be used.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsSyllableAssocWordRep" Arg='obj' Type='Representation'/>

<Description>
A word in syllable representation stores generator/exponents pairs (as
given by <Ref Func="ExtRepOfObj"/>.
Syllable access is fast, letter access is slow for such words.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsSyllableWordsFamily" Arg='obj' Type='Category'/>

<Description>
A syllable word family stores words by default in syllable form.
There are also different versions of syllable representations, which
compress a generator exponent pair in 8, 16 or 32 bits or use a pair of
integers.
Internal mechanisms try to make this as memory efficient as possible.
</Description>
</ManSection>

<ManSection>
<Filt Name="Is16BitsFamily" Arg='obj' Type='Category'/>
<Filt Name="Is32BitsFamily" Arg='obj' Type='Category'/>
<Filt Name="IsInfBitsFamily" Arg='obj' Type='Category'/>

<Description>
Regardless of the internal representation used, it is possible to convert
a word in a list of numbers in letter or syllable representation and vice
versa.
</Description>
</ManSection>

<ManSection>
<Oper Name="LetterRepAssocWord" Arg='w[, gens]'/>

<Description>
The <E>letter representation</E> of an associated word is as a list of
integers, each entry corresponding to a group generator. Inverses of the
generators are represented by negative numbers. The generator numbers
are as associated to the family.
<P/>
This operation returns the letter representation of the associative word
<A>w</A>.
<P/>
In the call with two arguments, the generator numbers correspond to the
generator order given in the list <A>gens</A>.
<P/>
(For words stored in syllable form the letter representation has to be
computed.)
</Description>
</ManSection>

<ManSection>
<Oper Name="AssocWordByLetterRep" Arg='Fam, lrep[, gens]'/>

<Description>
takes a letter representation <A>lrep</A>
(see <Ref Func="LetterRepAssocWord"/>) and returns an associative word in
family <A>fam</A> corresponding to this letter representation.
<P/>
If <A>gens</A> is given, the numbers in the letter
representation correspond to <A>gens</A>.
<Example><![CDATA[
gap> w:=AssocWordByLetterRep( FamilyObj(a), [-1,2,1,-2,-2,-2,1,1,1,1]);
a^-1*b*a*b^-3*a^4
gap> LetterRepAssocWord( w^2 );
[ -1, 2, 1, -2, -2, -2, 1, 1, 1, 2, 1, -2, -2, -2, 1, 1, 1, 1 ]
]]></Example>
<P/>
The external representation
(see section&nbsp;<Ref Sect="The External Representation for Associative Words"/>)
can be used if a syllable representation is needed.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The External Representation for Associative Words">
<Heading>The External Representation for Associative Words</Heading>

The external representation of the associative word <M>w</M> is defined
as follows.
If
<M>w = g_{{i_1}}^{{e_1}} * g_{{i_2}}^{{e_2}} * \cdots * g_{{i_k}}^{{e_k}}</M>
is a word over the alphabet <M>g_1, g_2, \ldots</M>,
i.e., <M>g_i</M> denotes the <M>i</M>-th generator of the family of
<M>w</M>, then <M>w</M> has external representation
<M>[ i_1, e_1, i_2, e_2, \ldots, i_k, e_k ]</M>.
The empty list describes the identity element (if exists) of the family.
Exponents may be negative if the family allows inverses.
The external representation of an associative word is guaranteed to be
freely reduced;
for example,
<M>g_1 * g_2 * g_2^{{-1}} * g_1</M> has the external representation
<C>[ 1, 2 ]</C>.
<P/>
Regardless of the family preference for letter or syllable
representations
(see&nbsp;<Ref Sect="Representations for Associative Words"/>),
<C>ExtRepOfObj</C> and <C>ObjByExtRep</C> can be used and interface to
this <Q>syllable</Q>-like representation.
<P/>
<Example><![CDATA[
gap> w:= ObjByExtRep( FamilyObj(a), [1,5,2,-7,1,3,2,4,1,-2] );
a^5*b^-7*a^3*b^4*a^-2
gap> ExtRepOfObj( w^2 );
[ 1, 5, 2, -7, 1, 3, 2, 4, 1, 3, 2, -7, 1, 3, 2, 4, 1, -2 ]
]]></Example>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Straight Line Programs">
<Heading>Straight Line Programs</Heading>

<E>Straight line programs</E> describe an efficient way for evaluating an
abstract word at concrete generators,
in a more efficient way than with <Ref Func="MappedWord"/>.
For example,
the associative word <M>ababbab</M> of length <M>7</M> can be computed
from the generators <M>a</M>, <M>b</M> with only four multiplications,
by first computing <M>c = ab</M>, then <M>d = cb</M>,
and then <M>cdc</M>;
Alternatively, one can compute <M>c = ab</M>, <M>e = bc</M>,
and <M>aee</M>.
In each step of these computations, one forms words in terms of the
words computed in the previous steps.
<P/>
A straight line program in &GAP; is represented by an object in the
category <Ref Filt="IsStraightLineProgram"/>)
that stores a list of <Q>lines</Q>
each of which has one of the following three forms.
<Enum>
<Item>
    a nonempty dense list <M>l</M> of integers,
</Item>
<Item>
    a pair <M>[ l, i ]</M>
    where <M>l</M> is a list of form 1.
    and <M>i</M> is a positive integer,
</Item>
<Item>
    a list <M>[ l_1, l_2, \ldots, l_k ]</M>
    where each <M>l_i</M> is a list of form 1.;
    this may occur only for the last line of the program.
</Item>
</Enum>
<P/>
The lists of integers that occur are interpreted as external
representations of associative words (see Section&nbsp;
<Ref Sect="The External Representation for Associative Words"/>);
for example, the list <M>[ 1, 3, 2, -1 ]</M> represents the word
<M>g_1^3 g_2^{{-1}}</M>, with <M>g_1</M> and <M>g_2</M> the first and
second abstract generator, respectively.
<P/>
For the meaning of the list of lines, see
<Ref Oper="ResultOfStraightLineProgram"/>.
<P/>
Straight line programs can be constructed using
<Ref Func="StraightLineProgram" Label="for a list of lines (and the number of generators)"/>.
<P/>
Defining attributes for straight line programs are
<Ref Attr="NrInputsOfStraightLineProgram"/>
and <Ref Attr="LinesOfStraightLineProgram"/>.
Another operation for straight line programs is
<Ref Oper="ResultOfStraightLineProgram"/>.
<P/>
Special methods applicable to straight line programs are installed for
the operations <Ref Oper="Display"/>,
<Ref Func="IsInternallyConsistent"/>, <Ref Oper="PrintObj"/>,
and <Ref Oper="ViewObj"/>.
<P/>
For a straight line program <A>prog</A>,
the default <Ref Oper="Display"/> method prints the interpretation
of <A>prog</A> as a sequence of assignments of associative words;
a record with components <C>gensnames</C> (with value a list of strings)
and <C>listname</C> (a string) may be entered as second argument of
<Ref Oper="Display"/>,
in this case these names are used, the default for <C>gensnames</C> is
<C>[ g1, g2, </C><M>\ldots</M><C> ]</C>,
the default for <C>listname</C> is <M>r</M>.

<ManSection>
<Filt Name="IsStraightLineProgram" Arg='obj' Type='Category'/>

<Description>
Each straight line program in &GAP; lies in the category
<Ref Filt="IsStraightLineProgram"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="StraightLineProgram" Arg='lines[, nrgens]'
 Label="for a list of lines (and the number of generators)"/>
<Func Name="StraightLineProgram" Arg='string, gens'
 Label="for a string and a list of generators names"/>
<Func Name="StraightLineProgramNC" Arg='lines[, nrgens]'
 Label="for a list of lines (and the number of generators)"/>
<Func Name="StraightLineProgramNC" Arg='string, gens'
 Label="for a string and a list of generators names"/>

<Description>
In the first form, <A>lines</A> must be a list of lists that defines
a unique straight line program
(see&nbsp;<Ref Func="IsStraightLineProgram"/>); in this case
<Ref Func="StraightLineProgram" Label="for a list of lines (and the number of generators)"/>
returns this program, otherwise an error is signalled.
The optional argument <A>nrgens</A> specifies the number of input
generators of the program;
if a line of form 1. (that is, a list of integers) occurs in <A>lines</A>
except in the last position,
this number is not determined by <A>lines</A> and therefore <E>must</E>
be specified by the argument <A>nrgens</A>;
if not then
<Ref Func="StraightLineProgram" Label="for a list of lines (and the number of generators)"/>
returns <K>fail</K>.
<P/>
In the second form, <A>string</A> must be a string describing an
arithmetic expression in terms of the strings in the list <A>gens</A>,
where multiplication is denoted by concatenation, powering is denoted by
<C>^</C>, and round brackets <C>(</C>, <C>)</C> may be used.
Each entry in <A>gens</A> must consist only of uppercase or lowercase
letters (i.e., letters in <Ref Func="IsAlphaChar"/>)
such that no entry is an initial part of another one.
Called with this input,
<Ref Func="StraightLineProgram" Label="for a string and a list of generators names"/>
returns a straight line program that evaluates to the word corresponding
to <A>string</A> when called with generators corresponding to
<A>gens</A>.
<P/>
The <C>NC</C> variant does the same,
except that the internal consistency of the program is not checked.
</Description>
</ManSection>

<ManSection>
<Attr Name="LinesOfStraightLineProgram" Arg='prog'/>

<Description>
For a straight line program <A>prog</A>,
<Ref Attr="LinesOfStraightLineProgram"/> returns
the list of program lines.
There is no default method to compute these lines if they are not stored.
</Description>
</ManSection>

<ManSection>
<Attr Name="NrInputsOfStraightLineProgram" Arg='prog'/>

<Description>
For a straight line program <A>prog</A>,
<Ref Attr="NrInputsOfStraightLineProgram"/>
returns the number of generators that are needed as input.
<P/>
If a line of form 1. (that is, a list of integers) occurs in the lines of
<A>prog</A> except the last line
then the number of generators is not determined by the lines,
and must be set in the construction of the straight line program
(see&nbsp;<Ref Func="StraightLineProgram" Label="for a list of lines (and the number of generators)"/>).
So if <A>prog</A> contains a line of form 1. other than the last line
and does <E>not</E> store the number of generators
then <Ref Attr="NrInputsOfStraightLineProgram"/> signals an error.
</Description>
</ManSection>

<ManSection>
<Oper Name="ResultOfStraightLineProgram" Arg='prog, gens'/>

<Description>
<Ref Oper="ResultOfStraightLineProgram"/> evaluates the straight line
program (see&nbsp;<Ref Func="IsStraightLineProgram"/>) <A>prog</A>
at the group elements in the list <A>gens</A>.
<P/>
The <E>result</E> of a straight line program with lines
<M>p_1, p_2, \ldots, p_k</M>
when applied to <A>gens</A> is defined as follows.
<List>
<Mark>(a)</Mark>
<Item>
    First a list <M>r</M> of intermediate results is initialized
    with a shallow copy of <A>gens</A>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>i &lt; k</M>, before the <M>i</M>-th step,
    let <M>r</M> be of length <M>n</M>.
    If <M>p_i</M> is the external representation of an associative word
    in the first <M>n</M> generators then the image of this word under
    the homomorphism that is given by mapping <M>r</M> to these first
    <M>n</M> generators is added to <M>r</M>;
    if <M>p_i</M> is a pair <M>[ l, j ]</M>, for a list <M>l</M>,
    then the same element is computed, but instead of being added to
    <M>r</M>, it replaces the <M>j</M>-th entry of <M>r</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    For <M>i = k</M>, if <M>p_k</M> is the external representation of an
    associative word then the element described in (b) is the result
    of the program,
    if <M>p_k</M> is a pair <M>[ l, j ]</M>, for a list <M>l</M>,
    then the result is the element described by <M>l</M>,
    and if <M>p_k</M> is a list <M>[ l_1, l_2, \ldots, l_k ]</M> of lists
    then the result is a list of group elements, where each <M>l_i</M> is
    treated as in (b).
</Item>
</List>
<P/>
<Example><![CDATA[
gap> f:= FreeGroup( "x", "y" );;  gens:= GeneratorsOfGroup( f );;
gap> x:= gens[1];;  y:= gens[2];;
gap> prg:= StraightLineProgram( [ [] ] );
<straight line program>
gap> ResultOfStraightLineProgram( prg, [] );
[  ]
]]></Example>
The above straight line program <C>prg</C> returns
&ndash;for <E>any</E> list of input generators&ndash; an empty list.
<Example><![CDATA[
gap> StraightLineProgram( [ [1,2,2,3], [3,-1] ] );
fail
gap> prg:= StraightLineProgram( [ [1,2,2,3], [3,-1] ], 2 );
<straight line program>
gap> LinesOfStraightLineProgram( prg );
[ [ 1, 2, 2, 3 ], [ 3, -1 ] ]
gap> prg:= StraightLineProgram( "(a^2b^3)^-1", [ "a", "b" ] );
<straight line program>
gap> LinesOfStraightLineProgram( prg );
[ [ [ 1, 2, 2, 3 ], 3 ], [ [ 3, -1 ], 4 ] ]
gap> res:= ResultOfStraightLineProgram( prg, gens );
y^-3*x^-2
gap> res = (x^2 * y^3)^-1;
true
gap> NrInputsOfStraightLineProgram( prg );
2
gap> Print( prg, "\n" );
StraightLineProgram( [ [ [ 1, 2, 2, 3 ], 3 ], [ [ 3, -1 ], 4 ] ], 2 )
gap> Display( prg );
# input:
r:= [ g1, g2 ];
# program:
r[3]:= r[1]^2*r[2]^3;
r[4]:= r[3]^-1;
# return value:
r[4]
gap> IsInternallyConsistent( StraightLineProgramNC( [ [1,2] ] ) );
true
gap> IsInternallyConsistent( StraightLineProgramNC( [ [1,2,3] ] ) );
false
gap> prg1:= StraightLineProgram( [ [1,1,2,2], [3,3,1,1] ], 2 );;
gap> prg2:= StraightLineProgram( [ [ [1,1,2,2], 2 ], [2,3,1,1] ] );;
gap> res1:= ResultOfStraightLineProgram( prg1, gens );
(x*y^2)^3*x
gap> res1 = (x*y^2)^3*x;
true
gap> res2:= ResultOfStraightLineProgram( prg2, gens );
(x*y^2)^3*x
gap> res2 = (x*y^2)^3*x;
true
gap> prg:= StraightLineProgram( [ [2,3], [ [3,1,1,4], [1,2,3,1] ] ], 2 );;
gap> res:= ResultOfStraightLineProgram( prg, gens );
[ y^3*x^4, x^2*y^3 ]
]]></Example>
</Description>
</ManSection>

<Index Subkey="for the result of a straight line program">LaTeX</Index>
<ManSection>
<Func Name="StringOfResultOfStraightLineProgram"
Arg='prog, gensnames[, "LaTeX"]'/>

<Description>
<Ref Func="StringOfResultOfStraightLineProgram"/> returns a string
that describes the result of the straight line program
(see&nbsp;<Ref Func="IsStraightLineProgram"/>) <A>prog</A>
as word(s) in terms of the strings in the list <A>gensnames</A>.
If the result of <A>prog</A> is a single element then the return value of
<Ref Func="StringOfResultOfStraightLineProgram"/> is a string consisting
of the entries of <A>gensnames</A>, opening and closing brackets <C>(</C>
and <C>)</C>, and powering by integers via <C>^</C>.
If the result of <A>prog</A> is a list of elements then the return value
of <Ref Func="StringOfResultOfStraightLineProgram"/> is a comma separated
concatenation of the strings of the single elements,
enclosed in square brackets <C>[</C>, <C>]</C>.
<Example><![CDATA[
gap> prg:= StraightLineProgram( [ [ 1, 2, 2, 3 ], [ 3, -1 ] ], 2 );;
gap> StringOfResultOfStraightLineProgram( prg, [ "a", "b" ] );
"(a^2b^3)^-1"
gap> StringOfResultOfStraightLineProgram( prg, [ "a", "b" ], "LaTeX" );
"(a^{2}b^{3})^{-1}"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CompositionOfStraightLinePrograms" Arg='prog2, prog1'/>

<Description>
For two straight line programs <A>prog1</A> and <A>prog2</A>,
<Ref Func="CompositionOfStraightLinePrograms"/> returns a straight line
program <A>prog</A> with the properties that <A>prog1</A> and <A>prog</A>
have the same number of inputs, and the result of <A>prog</A>
when applied to given generators <A>gens</A> equals the result of
<A>prog2</A> when this is applied to the output of
<A>prog1</A> applied to <A>gens</A>.
<P/>
(Of course the number of outputs of <A>prog1</A> must be the same as the
number of inputs of <A>prog2</A>.)
<Example><![CDATA[
gap> prg1:= StraightLineProgram( "a^2b", [ "a","b" ] );;
gap> prg2:= StraightLineProgram( "c^5", [ "c" ] );;
gap> comp:= CompositionOfStraightLinePrograms( prg2, prg1 );
<straight line program>
gap> StringOfResultOfStraightLineProgram( comp, [ "a", "b" ] );
"(a^2b)^5"
gap> prg:= StraightLineProgram( [ [2,3], [ [3,1,1,4], [1,2,3,1] ] ], 2 );;
gap> StringOfResultOfStraightLineProgram( prg, [ "a", "b" ] );
"[ b^3a^4, a^2b^3 ]"
gap> comp:= CompositionOfStraightLinePrograms( prg, prg );
<straight line program>
gap> StringOfResultOfStraightLineProgram( comp, [ "a", "b" ] );
"[ (a^2b^3)^3(b^3a^4)^4, (b^3a^4)^2(a^2b^3)^3 ]"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IntegratedStraightLineProgram" Arg='listofprogs'/>

<Description>
For a nonempty dense list <A>listofprogs</A> of straight line programs
that have the same number <M>n</M>, say, of inputs
(see&nbsp;<Ref Func="NrInputsOfStraightLineProgram"/>) and for which the
results (see&nbsp;<Ref Func="ResultOfStraightLineProgram"/>) are single
elements (i.e., <E>not</E> lists of elements),
<Ref Func="IntegratedStraightLineProgram"/> returns a straight line
program <A>prog</A> with <M>n</M> inputs such that for each
<M>n</M>-tuple <A>gens</A> of generators,
<C>ResultOfStraightLineProgram( <A>prog</A>, <A>gens</A> )</C>
is equal to the list
<C>List( <A>listofprogs</A>, <A>p</A> -&tgt; ResultOfStraightLineProgram( <A>p</A>, <A>gens</A> )</C>.
<Example><![CDATA[
gap> f:= FreeGroup( "x", "y" );;  gens:= GeneratorsOfGroup( f );;
gap> prg1:= StraightLineProgram([ [ [ 1, 2 ], 1 ], [ 1, 2, 2, -1 ] ], 2);;
gap> prg2:= StraightLineProgram([ [ [ 2, 2 ], 3 ], [ 1, 3, 3, 2 ] ], 2);;
gap> prg3:= StraightLineProgram([ [ 2, 2 ], [ 1, 3, 3, 2 ] ], 2);;
gap> prg:= IntegratedStraightLineProgram( [ prg1, prg2, prg3 ] );;
gap> ResultOfStraightLineProgram( prg, gens );
[ x^4*y^-1, x^3*y^4, x^3*y^4 ]
gap> prg:= IntegratedStraightLineProgram( [ prg2, prg3, prg1 ] );;
gap> ResultOfStraightLineProgram( prg, gens );
[ x^3*y^4, x^3*y^4, x^4*y^-1 ]
gap> prg:= IntegratedStraightLineProgram( [ prg3, prg1, prg2 ] );;
gap> ResultOfStraightLineProgram( prg, gens );
[ x^3*y^4, x^4*y^-1, x^3*y^4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RestrictOutputsOfSLP" Arg='slp, k'/>

<Description>
<A>slp</A> must be a straight line program returning a tuple
of values. This function
returns a new slp that calculates only those outputs specified by
<A>k</A>. The argument
<A>k</A> may be an integer or a list of integers. If <A>k</A> is an integer,
the resulting slp calculates only the result with that number
in the original output tuple. 
If <A>k</A> is a list of integers, the resulting slp calculates those
results with indices <A>k</A> in the original output tuple. 
In both cases the resulting slp
does only what is necessary. Obviously, the slp must have a line with 
enough expressions (lists) for the supplied <A>k</A> as its last line.
<A>slp</A> is either an slp or a pair where the first entry are the lines
of the slp and the second is the number of inputs.
</Description>
</ManSection>

<ManSection>
<Func Name="IntermediateResultOfSLP" Arg='slp, k'/>

<Description>
Returns a new slp that calculates only the value of slot <A>k</A>
at the end of <A>slp</A> doing only what is necessary. 
slp is either an slp or a pair where the first entry are the lines
of the slp and the second is the number of inputs.
Note that this assumes a general SLP with possible overwriting.
If you know that your SLP does not overwrite slots, please use
<Ref Func="IntermediateResultOfSLPWithoutOverwrite"/>,
which is much faster in this case.
</Description>
</ManSection>

<ManSection>
<Func Name="IntermediateResultOfSLPWithoutOverwrite" Arg='slp, k'/>

<Description>
Returns a new slp that calculates only the value of slot <A>k</A>, which
must be an integer.
Note that <A>slp</A> must not overwrite slots but only append!!!
Use <Ref Func="IntermediateResultOfSLP"/> in the other case!
<A>slp</A> is either an slp or a pair where the first entry is the lines
of the slp and the second is the number of inputs.
</Description>
</ManSection>

<ManSection>
<Func Name="IntermediateResultsOfSLPWithoutOverwrite" Arg='slp, k'/>

<Description>
Returns a new slp that calculates only the value of slots contained
in the list k.
Note that <A>slp</A> must not overwrite slots but only append!!!
Use <Ref Func="IntermediateResultOfSLP"/> in the other case!
<A>slp</A> is either a slp or a pair where the first entry is the lines
of the slp and the second is the number of inputs.
</Description>
</ManSection>

<ManSection>
<Func Name="ProductOfStraightLinePrograms" Arg='s1, s2'/>

<Description>
<A>s1</A> and <A>s2</A> must be two slps that return a single element with the same
number of inputs. This function constructs an slp that returns the product
of the two results the slps <A>s1</A> and <A>s2</A> would produce with the same
input.
</Description>
</ManSection>

<ManSection>
<Attr Name="SlotUsagePattern" Arg="s"/>

<Description>
Analyses the straight line program <A>s</A> for more efficient
evaluation. This means in particular two things, when this attribute
is known: First of all,
intermediate results which are not actually needed later on are
not computed at all, and once an intermediate result is used for
the last time in this SLP, it is discarded. The latter leads to 
the fact that the evaluation of the SLP needs less memory.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Straight Line Program Elements">
<Heading>Straight Line Program Elements</Heading>

When computing with very large (in terms of memory) elements, for
example permutations of degree a few hundred thousands, it can be
helpful (in terms of memory usage) to represent them via straight line
programs in terms of an original generator set. (So every element takes
only small extra storage for the straight line program.)
<P/>
A straight line program element has a <E>seed</E>
(a list of group elements) and a straight line program
on the same number of generators as the length of this seed,
its value is the value of the evaluated straight line program. 
<P/>
At the moment, the entries of the straight line program have to be
simple lists (i.e. of the first form).
<P/>
Straight line program elements are in the same categories
and families as the elements of the seed, so they should work together
with existing algorithms.
<P/>
Note however, that due to the different way of storage some normally
very cheap operations (such as testing for element equality) can become
more expensive when dealing with straight line program elements. This is
essentially the tradeoff for using less memory.
<P/>
See also
Section&nbsp;<Ref Sect="Working with large degree permutation groups"/>.

<ManSection>
<Filt Name="IsStraightLineProgElm" Arg='obj' Type='Representation'/>

<Description>
A straight line program element is a group element given (for memory
reasons) as a straight line program. Straight line program elements are
positional objects, the first component is a record with a component
<C>seeds</C>, the second component the straight line program.
</Description>
</ManSection>

<ManSection>
<Func Name="StraightLineProgElm" Arg='seed,prog'/>

<Description>
Creates a straight line program element for seed <A>seed</A> and program
<A>prog</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="StraightLineProgGens" Arg='gens[,base]'/>

<Description>
returns a set of straight line program elements corresponding to the
generators in <A>gens</A>.
If <A>gens</A> is a set of permutations then <A>base</A> can be given
which must be a base for the group generated by <A>gens</A>.
(Such a base will be used to speed up equality tests.)
</Description>
</ManSection>

<ManSection>
<Func Name="EvalStraightLineProgElm" Arg='slpel'/>

<Description>
evaluates a straight line program element <A>slpel</A> from its seeds.
</Description>
</ManSection>

<ManSection>
<Oper Name="StretchImportantSLPElement" Arg='elm'/>

<Description>
If <A>elm</A> is a straight line program element whose straight line
representation is very long, this operation changes the
representation of <A>elm</A> to a straight line program element, equal to
<A>elm</A>, whose seed contains the evaluation of <A>elm</A> and whose
straight line program has length 1.
<P/>
For other objects nothing happens.
<P/>
This operation permits to designate <Q>important</Q> elements within an
algorithm (elements that will be referred to often), which will be
represented by guaranteed short straight line program elements.
<Example><![CDATA[
gap> gens:=StraightLineProgGens([(1,2,3,4),(1,2)]);
[ <[ [ 2, 1 ] ]|(1,2,3,4)>, <[ [ 1, 1 ] ]|(1,2)> ]
gap> g:=Group(gens);;
gap> (gens[1]^3)^gens[2];
<[ [ 1, -1, 2, 3, 1, 1 ] ]|(1,2,4,3)>
gap> Size(g);
24
gap> Random(g);
<
[ [ 1, -1, 2, -1, 1, 1, 2, -1, 1, -1, 2, 1, 1, 1, 2, 1, 1, -1, 2, 2, 
      1, 1 ], 
  [ 3, -2, 2, -2, 1, -1, 2, -2, 1, 1, 2, -1, 1, -1, 2, -2, 1, 1, 2, 
      -1, 1, -1, 2, -1, 1, 1, 2, 1, 1, -1, 2, 1, 1, 1 ] ]>
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  rws.msk                GAP documentation                Andrew Solomon -->
<!-- %% -->
<!-- %A  @(#)<M>Id: rws.msk,v 1.11 2003/07/31 20:04:19 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Rewriting Systems">
<Heading>Rewriting Systems</Heading>

Rewriting systems in &GAP; are a framework for dealing with 
the very general task of rewriting elements of a free (or <E>term</E>) algebra
in some normal form.  Although most rewriting systems currently in use
are <E>string rewriting systems</E> (where the algebra has only one 
binary operation which is associative) the framework in &GAP;
is general enough to encompass the task of rewriting algebras of
any signature from groups to semirings.
<P/>
Rewriting systems are already implemented in  &GAP; 
for finitely presented semigroups and for pc groups. The use of these 
particular rewriting systems is described in the corresponding chapters.
We describe here only the general framework of rewriting systems with 
a particular emphasis on material which would be 
helpful for a  developer implementing a rewriting system. 
<P/>
We fix some definitions and terminology for the rest of this chapter.
Let <M>T</M> be a term algebra in some signature. 
A <E>term rewriting system</E> for <M>T</M> is a set of ordered pairs of 
elements of <M>T</M> of the form <M>(l, r)</M>.
Viewed as a set of relations, the 
rewriting system determines a presentation for a quotient algebra <M>A</M>
of <M>T</M>. 
<P/>
When we take into account the fact that
the relations are expressed as <E>ordered</E> pairs, we have a way of 
<E>reducing</E> the elements of <M>T</M>.
Suppose an element <M>u</M> of <M>T</M> has a 
subword <M>l</M> and <M>(l, r)</M> is a rule of the rewriting system, then
we can replace the subterm <M>l</M> of <M>u</M> by the term <M>r</M>
and obtain a new word <M>v</M>.
We say that we have <E>rewritten</E> <M>u</M> as <M>v</M>. 
Note that <M>u</M> and <M>v</M> represent the same element of <M>A</M>.
If <M>u</M> can not be rewritten using any rule of the rewriting system
we sat that <M>u</M> is <E>reduced</E>. 


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations on rewriting systems">
<Heading>Operations on rewriting systems</Heading>

<ManSection>
<Filt Name="IsRewritingSystem" Arg='obj' Type='Category'/>

<Description>
This is the category in which all rewriting systems lie.
</Description>
</ManSection>

<ManSection>
<Attr Name="Rules" Arg='rws'/>

<Description>
The rules comprising the rewriting system. Note that these may 
change through the life of the rewriting system, however they
will always be a set of defining relations of the algebra
described by the rewriting system.
</Description>
</ManSection>

<ManSection>
<Attr Name="OrderOfRewritingSystem" Arg='rws'/>
<Attr Name="OrderingOfRewritingSystem" Arg='rws'/>

<Description>
return the ordering of the rewriting system <A>rws</A>.
<!-- %the synonym here guarantees compatibility with &GAP;&nbsp;4.1 and &GAP;&nbsp;4.2. -->
</Description>
</ManSection>

<ManSection>
<Oper Name="ReducedForm" Arg='rws, u'/>

<Description>
Given an element <A>u</A> in the free (or term) algebra <M>T</M> over
which <A>rws</A> is defined,
rewrite <A>u</A> by successive applications of the
rules of <A>rws</A> until no further rewriting is possible, and return
the resulting element of <M>T</M>.
</Description>
</ManSection>

<ManSection>
<Heading>IsConfluent</Heading>
<Prop Name="IsConfluent" Arg='rws' Label="for a rewriting system"/>
<Prop Name="IsConfluent" Arg='A'
 Label="for an algebra with canonical rewriting system"/>

<Description>
For a rewriting system <A>rws</A>,
<Ref Func="IsConfluent" Label="for a rewriting system"/> returns
<K>true</K> if and only if <A>rws</A> is confluent. 
A rewriting system is <E>confluent</E> if, for every two words 
<M>u</M> and <M>v</M> in the free algebra <M>T</M> which represent the
same element  of the algebra <M>A</M> defined by <A>rws</A>,
<C>ReducedForm( <A>rws</A>, </C><M>u</M> <C>) =
ReducedForm( <A>rws</A>, </C><M>v</M><C>)</C> as words in the
free algebra <M>T</M>.
This element is the <E>unique normal form</E>
of the element represented by <M>u</M>.
<P/>
For an algebra <A>A</A> with a canonical rewriting system associated
with it,
<Ref Prop="IsConfluent" Label="for an algebra with canonical rewriting system"/>
checks whether that rewriting system is confluent.
<P/>
Also see&nbsp;<Ref Prop="IsConfluent" Label="for pc groups"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ConfluentRws" Arg='rws'/>

<Description>
Return a new rewriting system defining the same algebra as <A>rws</A> 
which is confluent.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsReduced" Arg='rws'/>

<Description>
A rewriting system is reduced if for each rule <M>(l, r)</M>,
<M>l</M> and <M>r</M> are both reduced.
<P/>
</Description>
</ManSection>

<ManSection>
<Oper Name="ReduceRules" Arg='rws'/>

<Description>
Reduce rules and remove redundant rules to make <A>rws</A> reduced.
</Description>
</ManSection>

<ManSection>
<Oper Name="AddRule" Arg='rws, rule'/>

<Description>
Add  <A>rule</A> to a rewriting system <A>rws</A>. 
</Description>
</ManSection>

<ManSection>
<Oper Name="AddRuleReduced" Arg='rws, rule'/>

<Description>
Add <A>rule</A> to rewriting system <A>rws</A>.
Performs a reduction operation on the resulting system,
so that if <A>rws</A> is reduced it will remain reduced.
</Description>
</ManSection>

<ManSection>
<Oper Name="MakeConfluent" Arg='rws'/>

<Description>
Add rules (and perhaps reduce) in order to make <A>rws</A> confluent
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfRws" Arg='rws'/>

<Description>
Returns the list of generators of the rewriting system <A>rws</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations on elements of the algebra">
<Heading>Operations on elements of the algebra</Heading>

In this section let <M>u</M> denote an element of the term algebra
<M>T</M> representing <M>[u]</M> in the quotient algebra <M>A</M>.

<ManSection>
<Oper Name="ReducedProduct" Arg='rws, u, v'/>
<Oper Name="ReducedSum" Arg='rws, left, right'/>
<Oper Name="ReducedOne" Arg='rws'/>
<Oper Name="ReducedAdditiveInverse" Arg='rws, obj'/>
<Oper Name="ReducedComm" Arg='rws, left, right'/>
<Oper Name="ReducedConjugate" Arg='rws, left, right'/>
<Oper Name="ReducedDifference" Arg='rws, left, right'/>
<Oper Name="ReducedInverse" Arg='rws, obj'/>
<Oper Name="ReducedLeftQuotient" Arg='rws, left, right'/>
<Oper Name="ReducedPower" Arg='rws, obj, pow'/>
<Oper Name="ReducedQuotient" Arg='rws, left, right'/>
<Oper Name="ReducedScalarProduct" Arg='rws, left, right'/>
<Oper Name="ReducedZero" Arg='rws'/>

<Description>
The result of <Ref Prop="ReducedProduct"/> is <M>w</M> where 
<M>[w]</M> equals [<A>u</A>][<A>v</A>] in <M>A</M> and <M>w</M> 
is in reduced form.
<P/>
The remaining operations are defined similarly when they
are defined (as determined by the signature of the term algebra).
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties of rewriting systems">
<Heading>Properties of rewriting systems</Heading>

<ManSection>
<Prop Name="IsBuiltFromAdditiveMagmaWithInverses" Arg='obj'/>
<Prop Name="IsBuiltFromMagma" Arg='obj'/>
<Prop Name="IsBuiltFromMagmaWithOne" Arg='obj'/>
<Prop Name="IsBuiltFromMagmaWithInverses" Arg='obj'/>
<Prop Name="IsBuiltFromSemigroup" Arg='obj'/>
<Prop Name="IsBuiltFromGroup" Arg='obj'/>

<Description>
These properties may be used to identify the type of term algebra 
over which the rewriting system is defined.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Rewriting in Groups and Monoids">
<Heading>Rewriting in Groups and Monoids</Heading>

One application of rewriting is to reduce words in finitely presented groups
and monoids. The rewriting system still has to be built for a finitely
presented monoid (using <C>IsomorphismFpMonoid</C> for conversion). Rewriting
then can take place for words in the underlying free monoid. (These can be
obtained from monoid elements with the command <C>UnderlyingElement</C>.)
<P/>
<Example><![CDATA[
gap> f:=FreeGroup(3);;
gap> rels:=[f.1*f.2^2/f.3,f.2*f.3^2/f.1,f.3*f.1^2/f.2];;
gap> g:=f/rels;
<fp group on the generators [ f1, f2, f3 ]>
gap> mhom:=IsomorphismFpMonoid(g);
MappingByFunction( <fp group on the generators 
[ f1, f2, f3 ]>, <fp monoid on the generators 
[ f1, f1^-1, f2, f2^-1, f3, f3^-1 
 ]>, function( x ) ... end, function( x ) ... end )
gap> mon:=Image(mhom);
<fp monoid on the generators [ f1, f1^-1, f2, f2^-1, f3, f3^-1 ]>
gap> k:=KnuthBendixRewritingSystem(mon);
Knuth Bendix Rewriting System for Monoid( 
[ f1, f1^-1, f2, f2^-1, f3, f3^-1 ] ) with rules 
[ [ f1*f1^-1, <identity ...> ], [ f1^-1*f1, <identity ...> ], 
  [ f2*f2^-1, <identity ...> ], [ f2^-1*f2, <identity ...> ], 
  [ f3*f3^-1, <identity ...> ], [ f3^-1*f3, <identity ...> ], 
  [ f1*f2^2*f3^-1, <identity ...> ], [ f2*f3^2*f1^-1, <identity ...> ]
    , [ f3*f1^2*f2^-1, <identity ...> ] ]
gap> MakeConfluent(k);
gap> a:=Product(GeneratorsOfMonoid(mon));
f1*f1^-1*f2*f2^-1*f3*f3^-1
gap> ReducedForm(k,UnderlyingElement(a));
<identity ...>
]]></Example>
<P/>
To rewrite a word in the finitely presented group, one has to convert it to
a word in the monoid first, rewrite in the underlying free monoid and
convert back (by forming first again an element of the fp monoid) to the
finitely presented group.
<P/>
<!-- % this example uses random and would be a hassle to modify every time -->
<!-- % something changes -->
<Log><![CDATA[
gap> r:=PseudoRandom(g);;
gap> Length(r);
3704
gap> melm:=Image(mhom,r);;
gap> red:=ReducedForm(k,UnderlyingElement(melm));
f1^-1^3*f2^-1*f1^2
gap> melm:=ElementOfFpMonoid(FamilyObj(One(mon)),red);
f1^-1^3*f2^-1*f1^2
gap> gpelm:=PreImagesRepresentative(mhom,melm);
f1^-3*f2^-1*f1^2
gap> r=gpelm;
true
gap> CategoriesOfObject(red);
[ "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsAssociativeElement", "IsWord" ]
gap> CategoriesOfObject(melm);
[ "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsAssociativeElement", 
  "IsElementOfFpMonoid" ]
gap> CategoriesOfObject(gpelm);
[ "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsMultiplicativeElementWithInverse", 
  "IsAssociativeElement", "IsElementOfFpGroup" ]
]]></Log>
<P/>
Note, that the elements <C>red</C> (free monoid) <C>melm</C> (fp monoid) and <C>gpelm</C>
(group) differ, though they are displayed identically.
<P/>
Under Unix, it is possible to use the <Package>kbmag</Package> package
to replace the built-in rewriting by this packages efficient C implementation.
You can do this (after loading the <Package>kbmag</Package> package)
by assigning the variable <Ref Func="KB_REW"/> to <C>KBMAG_REW</C>.
Assignment to <C>GAPKB_REW</C> reverts to the built-in implementation.
<Log><![CDATA[
gap> LoadPackage("kbmag");
true
gap> KB_REW:=KBMAG_REW;;
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Developing rewriting systems">
<Heading>Developing rewriting systems</Heading>

The key point to note about rewriting systems is that they have 
properties such as
<Ref Func="IsConfluent" Label="for a rewriting system"/>
and attributes such as <Ref Func="Rules"/>, however
they are rarely stored, but rather computed afresh each time they
are asked for, from data stored in the private members of the rewriting
system object.  This is because a rewriting system often evolves
through a session, starting with some rules which define the
algebra <A>A</A> as relations, and then adding more rules to make
the system confluent.
For example, in the case of Knuth-Bendix rewriting systems (see
Chapter&nbsp;<Ref Chap="Finitely Presented Semigroups and Monoids"/>),
the function <C>CreateKnuthBendixRewritingSystem</C> creating the
rewriting system (in the file <F>lib/kbsemi.gi</F>) uses
<P/>
<Log><![CDATA[
kbrws := Objectify(NewType(rwsfam, 
  IsMutable and IsKnuthBendixRewritingSystem and 
  IsKnuthBendixRewritingSystemRep), 
  rec(family:= fam,
  reduced:=false,
  tzrules:=List(relwco,i->
   [LetterRepAssocWord(i[1]),LetterRepAssocWord(i[2])]),
  pairs2check:=CantorList(Length(r)),
  ordering:=wordord,
  freefam:=freefam));
]]></Log>
<P/>
In particular, since we don't use the filter
<C>IsAttributeStoringRep</C>
in the <Ref Func="Objectify"/>,
whenever <Ref Func="IsConfluent" Label="for a rewriting system"/> is
called,
the appropriate method to determine confluence is called. 


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  groups.msk                  GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: groups.msk,v 1.111 2006/08/17 14:09:37 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St  Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Groups">
<Heading>Groups</Heading>

This chapter explains how to create groups and defines operations for
groups, that is operations whose definition does not depend on the
representation used.
However methods for these operations in most cases will make use of the
representation.
<P/>
If not otherwise specified, in all examples in this chapter the group <C>g</C>
will be the symmetric group <M>S_4</M> acting on the letters
<M>\{ 1, \ldots, 4 \}</M>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Group Elements">
<Heading>Group Elements</Heading>

Groups in &GAP; are written multiplicatively.
The elements from which a group can be generated must permit
multiplication and multiplicative inversion
(see&nbsp;<Ref Sect="Useful Categories of Elements"/>).
<P/>
<Example><![CDATA[
gap> a:=(1,2,3);;b:=(2,3,4);;
gap> One(a);
()
gap> Inverse(b);
(2,4,3)
gap> a*b;
(1,3)(2,4)
gap> Order(a*b);
2
gap> Order( [ [ 1, 1 ], [ 0, 1 ] ] );
infinity
]]></Example>
<P/>
The next example may run into an infinite loop
because the given matrix in fact has infinite order.
<P/>
<Log><![CDATA[
gap> Order( [ [ 1, 1 ], [ 0, 1 ] ] * Indeterminate( Rationals ) );
#I  Order: warning, order of <mat> might be infinite
]]></Log>
<P/>
<Index Subkey="of a group">order</Index>
Since groups are domains, the recommended command to compute the order
of a group is <Ref Func="Size"/>.
For convenience, group orders can also be computed with <Ref Func="Order"/>.
<P/>
The operation <Ref Func="Comm"/> can be used to compute the commutator of
two elements, the operation <Ref Func="LeftQuotient"/> computes the
product <M>x^{{-1}} y</M>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Groups">
<Heading>Creating Groups</Heading>

When groups are created from generators,
this means that the generators must be elements that can be multiplied
and inverted (see also&nbsp;<Ref Sect="Constructing Domains"/>).
For creating a free group on a set of symbols,
see&nbsp;<Ref Func="FreeGroup" Label="for given rank"/>.

<ManSection>
<Func Name="Group" Arg='gen, ...' Label="for several generators"/>
<Func Name="Group" Arg='gens[, id]'
 Label="for a list of generators (and an identity element)"/>

<Description>
<C>Group( <A>gen</A>, ... )</C> is the group generated by the arguments
<A>gen</A>, ...
<P/>
If the only argument <A>gens</A> is a list that is not a matrix then
<C>Group( <A>gens</A> )</C> is the group generated by the elements of
that list.
<P/>
If there are two arguments, a list <A>gens</A> and an element <A>id</A>,
then <C>Group( <A>gens</A>, <A>id</A> )</C> is the group generated by the
elements of <A>gens</A>, with identity <A>id</A>.
<P/>
Note that the value of the attribute <Ref Func="GeneratorsOfGroup"/>
need not be equal to the list <A>gens</A> of generators entered as
argument.
Use <Ref Func="GroupWithGenerators"/> if you want to be
sure that the argument <A>gens</A> is stored as value of
<Ref Attr="GeneratorsOfGroup"/>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GroupByGenerators" Arg='gens'/>
<Oper Name="GroupByGenerators" Arg='gens, id'
 Label="with explicitly specified identity element"/>

<Description>
<Ref Oper="GroupByGenerators"/> returns the group <M>G</M> generated by the list <A>gens</A>.
If a second argument <A>id</A> is present then this is stored as the identity
element of the group.
<P/>
The value of the attribute <Ref Attr="GeneratorsOfGroup"/> of <M>G</M> need not be equal
to <A>gens</A>.
<Ref Oper="GroupByGenerators"/> is the underlying operation called by <Ref Func="Group" Label="for several generators"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="GroupWithGenerators" Arg='gens[, id]'/>

<Description>
<Ref Oper="GroupWithGenerators"/> returns the group <M>G</M> generated by
the list <A>gens</A>.
If a second argument <A>id</A> is present then this is stored as the
identity element of the group.
The value of the attribute <Ref Attr="GeneratorsOfGroup"/> of <M>G</M>
is equal to <A>gens</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfGroup" Arg='G'/>

<Description>
returns a list of generators of the group <A>G</A>.
If <A>G</A> has been created by the command
<Ref Func="GroupWithGenerators"/> with argument <A>gens</A>,
then the list returned by <Ref Attr="GeneratorsOfGroup"/>
will be equal to <A>gens</A>. For such a group, each generator 
can also be accessed using the <C>.</C> operator 
(see <Ref Attr="GeneratorsOfDomain"/>): for a positive integer
<M>i</M>, <C><A>G</A>.i</C> returns the <M>i</M>-th element of
the list returned by <Ref Attr="GeneratorsOfGroup"/>. Moreover,
if <A>G</A> is a free group, and <C>name</C> is the name of a 
generator of <A>G</A> then <C><A>G</A>.name</C> also returns 
this generator. 
<Example><![CDATA[
gap> g:=GroupWithGenerators([(1,2,3,4),(1,2)]);
Group([ (1,2,3,4), (1,2) ])
gap> GeneratorsOfGroup(g);
[ (1,2,3,4), (1,2) ]
]]></Example>
<P/>
While in this example &GAP; displays the group via the generating set
stored in the attribute <Ref Func="GeneratorsOfGroup"/>,
the methods installed for <Ref Func="View"/> will in general display only
some information about the group which may even be just the fact that it
is a group.
</Description>
</ManSection>

<ManSection>
<Attr Name="AsGroup" Arg='D'/>

<Description>
if the elements of the collection <A>D</A> form a group the command returns
this group, otherwise it returns <K>fail</K>.
<Example><![CDATA[
gap> AsGroup([(1,2)]);
fail
gap> AsGroup([(),(1,2)]);
Group([ (1,2) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ConjugateGroup" Arg='G, obj'/>

<Description>
returns the conjugate group of <A>G</A>, obtained by applying the 
conjugating element <A>obj</A>.
<P/>
To form a conjugate (group) by any object acting via <C>^</C>, 
one can also use the infix operator <C>^</C>.
<Example><![CDATA[
gap> ConjugateGroup(g,(1,5));
Group([ (2,3,4,5), (2,5) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsGroup" Arg='obj' Type='Category'/>

<Description>
A group is a magma-with-inverses (see&nbsp;<Ref Func="IsMagmaWithInverses"/>)
and associative (see&nbsp;<Ref Func="IsAssociative"/>) multiplication.
<P/>
<C>IsGroup</C> tests whether the object <A>obj</A> fulfills these conditions,
it does <E>not</E> test whether <A>obj</A> is a set of elements that forms a group
under multiplication;
use <Ref Func="AsGroup"/> if you want to perform such a test.
(See&nbsp;<Ref Sect="Categories"/> for details about categories.)
<Example><![CDATA[
gap> IsGroup(g);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoGroup"/>

<Description>
is the info class for the generic group theoretic functions
(see&nbsp;<Ref Sect="Info Functions"/>).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroups">
<Heading>Subgroups</Heading>

For the general concept of parents and subdomains,
see&nbsp;<Ref Sect="Parents"/> and&nbsp;<Ref Sect="Constructing Subdomains"/>.
More functions that construct certain subgroups can be found
in the sections&nbsp;<Ref Sect="Normal Structure"/>, <Ref Sect="Specific and Parametrized Subgroups"/>,
<Ref Sect="Sylow Subgroups and Hall Subgroups"/>,
and&nbsp;<Ref Sect="Subgroups characterized by prime powers"/>.
<P/>
If a group <M>U</M> is created as a subgroup of another group <M>G</M>,
<M>G</M> becomes the parent of <M>U</M>.
There is no <Q>universal</Q> parent group,
parent-child chains can be arbitrary long.
&GAP; stores the result of some operations
(such as <Ref Func="Normalizer" Label="for two groups"/>)
with the parent as an attribute.

<ManSection>
<Func Name="Subgroup" Arg='G, gens'/>
<Func Name="SubgroupNC" Arg='G, gens'/>
<Func Name="Subgroup" Arg='G' Label="for a group"/>

<Description>
creates the subgroup <A>U</A> of <A>G</A> generated by <A>gens</A>.
The <Ref Func="Parent"/> value of <A>U</A> will be <A>G</A>.
The <C>NC</C> version does not check, whether the elements in <A>gens</A>
actually lie in <A>G</A>.
<P/>
The unary version of <Ref Func="Subgroup" Label="for a group"/>
creates a (shell) subgroup that does not even
know generators but can be used to collect information about a
particular subgroup over time.
<Example><![CDATA[
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);
Group([ (1,2,3), (1,2) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Index (&GAP; operation)</Heading>
<Oper Name="Index" Arg='G, U' Label="for a group and its subgroup"/>
<Oper Name="IndexNC" Arg='G, U' Label="for a group and its subgroup"/>

<Description>
For a subgroup <A>U</A> of the group <A>G</A>,
<Ref Func="Index" Label="for a group and its subgroup"/> returns the index
<M>[<A>G</A>:<A>U</A>] = |<A>G</A>| / |<A>U</A>|</M>
of <A>U</A> in <A>G</A>.
The <C>NC</C> version does not test whether <A>U</A> is contained in
<A>G</A>.
<Example><![CDATA[
gap> Index(g,u);
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IndexInWholeGroup" Arg='G'/>

<Description>
If the family of elements of <A>G</A> itself forms a group <A>P</A>, this
attribute returns the index of <A>G</A> in <A>P</A>. It is used
primarily for free groups or finitely presented groups.
</Description>
</ManSection>

<Example><![CDATA[
gap> freegp:=FreeGroup(1);;
gap> freesub:=Subgroup(freegp,[freegp.1^5]);;
gap> IndexInWholeGroup(freesub);
5
]]></Example>

<ManSection>
<Oper Name="AsSubgroup" Arg='G, U'/>

<Description>
creates a subgroup of <A>G</A> which contains the same elements as <A>U</A>
<Example><![CDATA[
gap> v:=AsSubgroup(g,Group((1,2,3),(1,4)));
Group([ (1,2,3), (1,4) ])
gap> Parent(v);
Group([ (1,2,3,4), (1,2) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsSubgroup" Arg='G, U'/>

<Description>
<C>IsSubgroup</C> returns <K>true</K> if <A>U</A> is a group that is a subset of the
domain <A>G</A>.
This is actually checked by calling <C>IsGroup( <A>U</A> )</C> and
<C>IsSubset( <A>G</A>, <A>U</A> )</C>;
note that special methods for <Ref Func="IsSubset"/> are available
that test only generators of <A>U</A> if <A>G</A> is closed under the group
operations.
So in most cases,
for example whenever one knows already that <A>U</A> is a group,
it is better to call only <Ref Func="IsSubset"/>.
<Example><![CDATA[
gap> IsSubgroup(g,u);
true
gap> v:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> u=v;
true
gap> IsSubgroup(g,v);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsNormal" Arg='G, U'/>

<Description>
returns <K>true</K> if the group <A>G</A> normalizes the group <A>U</A>
and <K>false</K> otherwise.
<P/>
A group <A>G</A> <E>normalizes</E> a group <A>U</A> if and only if for every <M>g \in <A>G</A></M>
and <M>u \in <A>U</A></M> the element <M>u^g</M> is a member of <A>U</A>.
Note that <A>U</A> need not be a subgroup of <A>G</A>.
<Example><![CDATA[
gap> IsNormal(g,u);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsCharacteristicSubgroup" Arg='G,N'/>

<Description>
tests whether <A>N</A> is invariant under all automorphisms of <A>G</A>.
<Example><![CDATA[
gap> IsCharacteristicSubgroup(g,u);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ConjugateSubgroup" Arg='G, g'/>

<Description>
For a group <A>G</A> which has a parent group <C>P</C>
(see <Ref Func="Parent"/>), returns the subgroup of <C>P</C>,
obtained by conjugating <A>G</A> using the conjugating
element <A>g</A>.
<P/>
If <A>G</A> has no parent group, it just delegates to the
call to <Ref Oper="ConjugateGroup"/> with the same arguments. 
<P/>
To form a conjugate (subgroup) by any object acting via <C>^</C>, 
one can also use the infix operator <C>^</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ConjugateSubgroups" Arg='G, U'/>

<Description>
returns a list of all images of the group <A>U</A> under conjugation action
by <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsSubnormal" Arg='G, U'/>

<Description>
A subgroup <A>U</A> of the group <A>G</A> is subnormal if it is contained in a
subnormal series of <A>G</A>.
<Example><![CDATA[
gap> IsSubnormal(g,Group((1,2,3)));
false
gap> IsSubnormal(g,Group((1,2)(3,4)));
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubgroupByProperty" Arg='G, prop'/>

<Description>
creates a subgroup of <A>G</A> consisting of those elements fulfilling
<A>prop</A> (which is a tester function).
No test is done whether the property actually defines a subgroup.
<P/>
Note that currently very little functionality beyond an element test
exists for groups created this way.
</Description>
</ManSection>

<ManSection>
<Func Name="SubgroupShell" Arg='G'/>

<Description>
creates a subgroup of <A>G</A> which at this point is not yet specified
further (but will be later, for example by assigning a generating set).
<Example><![CDATA[
gap> u:=SubgroupByProperty(g,i->3^i=3);
<subgrp of Group([ (1,2,3,4), (1,2) ]) by property>
gap> (1,3) in u; (1,4) in u; (1,5) in u;
false
true
false
gap> GeneratorsOfGroup(u);
[ (1,2), (1,4,2) ]
gap> u:=SubgroupShell(g);
<group>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Closures of (Sub)groups">
<Heading>Closures of (Sub)groups</Heading>

<ManSection>
<Oper Name="ClosureGroup" Arg='G, obj'/>

<Description>
creates the group generated by the elements of <A>G</A> and <A>obj</A>.
<A>obj</A> can be either an element or a collection of elements,
in particular another group.
<Example><![CDATA[
gap> g:=SmallGroup(24,12);;u:=Subgroup(g,[g.3,g.4]);
Group([ f3, f4 ])
gap> ClosureGroup(u,g.2);
Group([ f2, f3, f4 ])
gap> ClosureGroup(u,[g.1,g.2]);
Group([ f1, f2, f3, f4 ])
gap> ClosureGroup(u,Group(g.2*g.1));
Group([ f1*f2^2, f3, f4 ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ClosureGroupAddElm" Arg='G, elm'/>
<Func Name="ClosureGroupCompare" Arg='G, elm'/>
<Func Name="ClosureGroupIntest" Arg='G, elm'/>

<Description>
These three functions together with <Ref Func="ClosureGroupDefault"/>
implement the main methods for <Ref Func="ClosureGroup"/>.
In the ordering given, they just add <A>elm</A> to the generators, remove
duplicates and identity elements, and test whether <A>elm</A> is already
contained in <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="ClosureGroupDefault" Arg='G, elm'/>

<Description>
This functions returns the closure of the group <A>G</A> with the element
<A>elm</A>.
If <A>G</A> has the attribute <Ref Func="AsSSortedList"/> then also the
result has this attribute.
This is used to implement the default method for
<Ref Func="Enumerator"/> and <Ref Func="EnumeratorSorted"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ClosureSubgroup" Arg='G, obj'/>
<Func Name="ClosureSubgroupNC" Arg='G, obj'/>

<Description>
For a group <A>G</A> that stores a parent group (see&nbsp;<Ref Sect="Parents"/>),
<Ref Func="ClosureSubgroup"/> calls <Ref Func="ClosureGroup"/> with the same
arguments;
if the result is a subgroup of the parent of <A>G</A> then the parent of <A>G</A>
is set as parent of the result, otherwise an error is raised.
The check whether the result is contained in the parent of <A>G</A> is omitted
by the <C>NC</C> version. As a wrong parent might imply wrong properties this
version should be used with care.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Expressing Group Elements as Words in Generators">
<Heading>Expressing Group Elements as Words in Generators</Heading>

<Index>factorization</Index>
<Index Subkey="in generators">words</Index>

Using homomorphisms (see chapter&nbsp;<Ref Chap="Group Homomorphisms"/>) is is possible to
express group elements as words in given generators: Create a free group
(see&nbsp;<Ref Func="FreeGroup" Label="for given rank"/>)
on the correct number of generators and create a
homomorphism from this free group onto the group <A>G</A> in whose generators you
want to factorize. Then the preimage of an element of <A>G</A> is a word in the
free generators, that will map on this element again.
<P/>
<ManSection>
<Attr Name="EpimorphismFromFreeGroup" Arg='G'/>

<Description>
For a group <A>G</A> with a known generating set, this attribute returns
a homomorphism from a free group that maps the free generators to the
groups generators.
<P/>
The option <C>names</C> can be used to prescribe a (print) name
for the free generators.
<P/>
The following example shows how to decompose elements of <M>S_4</M> in the
generators <C>(1,2,3,4)</C> and <C>(1,2)</C>:
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> hom:=EpimorphismFromFreeGroup(g:names:=["x","y"]);
[ x, y ] -> [ (1,2,3,4), (1,2) ]
gap> PreImagesRepresentative(hom,(1,4));
y^-1*x^-1*(x^-1*y^-1)^2*x
]]></Example>
<P/>
The following example stems from a real request to the &GAP; Forum.
In September 2000 a &GAP; user working with puzzles wanted to express the
permutation <C>(1,2)</C> as a word as short as possible in particular
generators of the symmetric group <M>S_{16}</M>.
<P/>
<Example><![CDATA[
gap> perms := [ (1,2,3,7,11,10,9,5), (2,3,4,8,12,11,10,6),
>   (5,6,7,11,15,14,13,9), (6,7,8,12,16,15,14,10) ];;
gap> puzzle := Group( perms );;Size( puzzle );
20922789888000
gap> hom:=EpimorphismFromFreeGroup(puzzle:names:=["a", "b", "c", "d"]);;
gap> word := PreImagesRepresentative( hom, (1,2) );
a^-1*c*b*c^-1*a*b^-1*a^-2*c^-1*a*b^-1*c*b
gap> Length( word );
13
]]></Example>
</Description>
</ManSection>

<!-- % randomization effect is now gone. -->
<ManSection>
<Oper Name="Factorization" Arg='G, elm'/>

<Description>
returns a factorization of <A>elm</A> as word in the generators of the
group <A>G</A> given in the attribute <Ref Func="GeneratorsOfGroup"/>.
The attribute <Ref Func="EpimorphismFromFreeGroup"/> of <A>G</A>
will contain a map from the group <A>G</A> to the free group
in which the word is expressed.
The attribute <Ref Attr="MappingGeneratorsImages"/> of this map gives a
list of generators and corresponding letters.
<P/>
The algorithm used forms all elements of the group to ensure a short
word is found. Therefore this function should <E>not</E> be used when the
group <A>G</A> has more than a few million elements.
Because of this, one should not call this function within algorithms,
but use homomorphisms instead.
<Example><![CDATA[
gap> G:=SymmetricGroup( 6 );;
gap> r:=(3,4);; s:=(1,2,3,4,5,6);;
gap> # create subgroup to force the system to use the generators r and s:
gap> H:= Subgroup(G, [ r, s ] );
Group([ (3,4), (1,2,3,4,5,6) ])
gap> Factorization( H, (1,2,3) );
(x2*x1)^2*x2^-2
gap> s*r*s*r*s^-2;
(1,2,3)
gap> MappingGeneratorsImages(EpimorphismFromFreeGroup(H));
[ [ x1, x2 ], [ (3,4), (1,2,3,4,5,6) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GrowthFunctionOfGroup" Arg='G'/>
<Oper Name="GrowthFunctionOfGroup" Arg='G, radius' Label="with word length limit"/>

<Description>
For a group <A>G</A> with a generating set given in
<Ref Func="GeneratorsOfGroup"/>, 
this function calculates the number of elements whose shortest expression as
words in the generating set is of a particular length. It returns a list
<A>L</A>, whose <M>i+1</M> entry counts the number of elements whose
shortest word expression has length <M>i</M>.
If a maximal length <A>radius</A> is given, only words up to length
<A>radius</A> are counted. Otherwise the group must be finite and all
elements are enumerated.
<Example><![CDATA[
gap> GrowthFunctionOfGroup(MathieuGroup(12));  
[ 1, 5, 19, 70, 255, 903, 3134, 9870, 25511, 38532, 16358, 382 ]
gap> GrowthFunctionOfGroup(MathieuGroup(12),2);
[ 1, 5, 19 ]
gap> GrowthFunctionOfGroup(MathieuGroup(12),99);
[ 1, 5, 19, 70, 255, 903, 3134, 9870, 25511, 38532, 16358, 382 ]
gap> free:=FreeGroup("a","b");
<free group on the generators [ a, b ]>
gap> product:=free/ParseRelators(free,"a2,b3");
<fp group on the generators [ a, b ]>
gap> SetIsFinite(product,false);
gap> GrowthFunctionOfGroup(product,10);
[ 1, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Structure Descriptions">
<Heading>Structure Descriptions</Heading>

<ManSection>
<Attr Name="StructureDescription" Arg="G"/>

<Description>
The method for <Ref Func="StructureDescription"/> exhibits a structure
of the given group <A>G</A> to some extent, using the strategy outlined
  below. The idea is to return a possibly short string which gives some
  insight in the structure of the considered group. It is intended
primarily for small groups (order less than 100) or groups with few normal
subgroups, in other cases, in particular large <M>p</M>-groups, it can
be very costly. Furthermore, the string returned is -- as the action on
chief factors is not described -- often not the most useful way to describe
a group.<P/>

The string returned by <Ref Func="StructureDescription"/> is
<B>not</B> an isomorphism invariant: non-isomorphic groups can have the
same string value, and two isomorphic groups in different representations
can produce different strings.

The value returned by <Ref Func="StructureDescription"/> is a string of
the following form: <P/>
<Listing><![CDATA[
  StructureDescription(<G>) ::=
      1                                 ; trivial group 
    | C<size>                           ; cyclic group
    | A<degree>                         ; alternating group
    | S<degree>                         ; symmetric group
    | D<size>                           ; dihedral group
    | Q<size>                           ; quaternion group
    | QD<size>                          ; quasidihedral group
    | PSL(<n>,<q>)                      ; projective special linear group
    | SL(<n>,<q>)                       ; special linear group
    | GL(<n>,<q>)                       ; general linear group
    | PSU(<n>,<q>)                      ; proj. special unitary group
    | O(2<n>+1,<q>)                     ; orthogonal group, type B
    | O+(2<n>,<q>)                      ; orthogonal group, type D
    | O-(2<n>,<q>)                      ; orthogonal group, type 2D
    | PSp(2<n>,<q>)                     ; proj. special symplectic group
    | Sz(<q>)                           ; Suzuki group
    | Ree(<q>)                          ; Ree group (type 2F or 2G)
    | E(6,<q>) | E(7,<q>) | E(8,<q>)    ; Lie group of exceptional type
    | 2E(6,<q>) | F(4,<q>) | G(2,<q>)
    | 3D(4,<q>)                         ; Steinberg triality group
    | M11 | M12 | M22 | M23 | M24
    | J1 | J2 | J3 | J4 | Co1 | Co2
    | Co3 | Fi22 | Fi23 | Fi24' | Suz
    | HS | McL | He | HN | Th | B
    | M | ON | Ly | Ru                  ; sporadic simple group
    | 2F(4,2)'                          ; Tits group
    | PerfectGroup(<size>,<id>)         ; the indicated group from the
                                        ; library of perfect groups
    | A x B                             ; direct product
    | N : H                             ; semidirect product
    | C(G) . G/C(G) = G' . G/G'         ; non-split extension
                                        ; (equal alternatives and
                                        ; trivial extensions omitted)
    | Phi(G) . G/Phi(G)                 ; non-split extension:
                                        ; Frattini subgroup and
                                        ; Frattini factor group
]]></Listing>
<P/>
Note that the <Ref Func="StructureDescription"/> is only <E>one</E>
possible way of building up the given group from smaller pieces. <P/>

The option <Q>short</Q> is recognized - if this option is set, an
abbreviated output format is used (e.g. <C>"6x3"</C> instead of
<C>"C6 x C3"</C>). <P/>

If the <Ref Func="Name"/> attribute is not bound, but
<Ref Func="StructureDescription"/> is, <Ref Func="View"/> prints the
value of the attribute <Ref Func="StructureDescription"/>.
The <Ref Func="Print"/>ed representation of a group is not affected
by computing a <Ref Func="StructureDescription"/>. <P/>

The strategy used to compute a <Ref Func="StructureDescription"/> is
as follows:
<P/>
<List>
<Mark>1.</Mark>
<Item>
  Lookup in a precomputed list, if the order of <A>G</A> is not
  larger than 100 and not equal to 64.
</Item>
<Mark>2.</Mark>
<Item>
  If <A>G</A> is abelian, then decompose it into cyclic factors
  in <Q>elementary divisors style</Q>. For example,
  <C>"C2 x C3 x C3"</C> is <C>"C6 x C3"</C>.
</Item>
<Mark>3.</Mark>
<Item>
  Recognize alternating groups, symmetric groups,
  dihedral groups, quasidihedral groups, quaternion groups,
  PSL's, SL's, GL's and simple groups not listed so far
  as basic building blocks.
</Item>
<Mark>4.</Mark>
<Item>
  Decompose <A>G</A> into a direct product of irreducible factors.
</Item>
<Mark>5.</Mark>
<Item>
  Recognize semidirect products <A>G</A>=<M>N</M>:<M>H</M>,
  where <M>N</M> is normal.
  Select a pair <M>N</M>, <M>H</M> with the following preferences:
  <List>
  <Mark>1.</Mark>
  <Item>
    <M>H</M> is abelian
  </Item>
  <Mark>2.</Mark>
  <Item>
    <M>N</M> is abelian
  </Item>
  <Mark>2a.</Mark>
  <Item>
    <M>N</M> has many abelian invariants
  </Item>
  <Mark>3.</Mark>
  <Item>
    <M>N</M> is a direct product
  </Item>
  <Mark>3a.</Mark>
  <Item>
    <M>N</M> has many direct factors
  </Item>
  <Mark>4.</Mark>
  <Item>
    <M>\phi: H \rightarrow</M> Aut(<M>N</M>), 
    <M>h \mapsto (n \mapsto n^h)</M> is injective.
  </Item>
  </List>
</Item>
<Mark>6.</Mark>
<Item>
  Fall back to non-splitting extensions:
  If the centre or the commutator factor group is non-trivial,
  write <A>G</A> as Z(<A>G</A>).<A>G</A>/Z(<A>G</A>) or
  <A>G</A>'.<A>G</A>/<A>G</A>', respectively.
  Otherwise if the Frattini subgroup is non-trivial, write <A>G</A>
  as <M>\Phi</M>(<A>G</A>).<A>G</A>/<M>\Phi</M>(<A>G</A>).
</Item>
<Mark>7.</Mark>
<Item>
  If no decomposition is found (maybe this is not the case for
  any finite group), try to identify <A>G</A> in the perfect groups
  library. If this fails also, then return a string describing this
  situation.
</Item>
</List>
Note that <Ref Func="StructureDescription"/> is <E>not</E> intended
to be a research tool, but rather an educational tool. The reasons for
this are as follows:
<List>
  <Mark>1.</Mark>
  <Item>
    <Q>Most</Q> groups do not have <Q>nice</Q> decompositions.
    This is in some contrast to what is often taught in elementary
    courses on group theory, where it is sometimes suggested that
    basically every group can be written as iterated direct or
    semidirect product of cyclic groups and nonabelian simple groups.
  </Item>
  <Mark>2.</Mark>
  <Item>
    In particular many <M>p</M>-groups have very <Q>similar</Q>
    structure, and <Ref Func="StructureDescription"/> can only
    exhibit a little of it. Changing this would likely make the
    output not essentially easier to read than a pc presentation.
  </Item>
</List>
<Example><![CDATA[
gap> l := AllSmallGroups(12);;
gap> List(l,StructureDescription);; l;
[ C3 : C4, C12, A4, D12, C6 x C2 ]
gap> List(AllSmallGroups(40),G->StructureDescription(G:short));
[ "5:8", "40", "5:8", "5:Q8", "4xD10", "D40", "2x(5:4)", "(10x2):2", 
  "20x2", "5xD8", "5xQ8", "2x(5:4)", "2^2xD10", "10x2^2" ]
gap> List(AllTransitiveGroups(DegreeAction,6),
>         G->StructureDescription(G:short));
[ "6", "S3", "D12", "A4", "3xS3", "2xA4", "S4", "S4", "S3xS3", 
  "(3^2):4", "2xS4", "A5", "(S3xS3):2", "S5", "A6", "S6" ]
gap> StructureDescription(PSL(4,2));
"A8"
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Cosets">
<Heading>Cosets</Heading>

<Index>right cosets</Index>
<Index>coset</Index>
<ManSection>
<Oper Name="RightCoset" Arg='U, g'/>

<Description>
returns the right coset of <A>U</A> with representative <A>g</A>,
which is the set of all elements of the form <M>ug</M> for all
<M>u \in <A>U</A></M>.  <A>g</A> must be an
element of a larger group <A>G</A> which contains <A>U</A>. 
For element operations such as <K>in</K> a right coset behaves like a set of
group elements.
<P/>
Right cosets are
external orbits for the action of <A>U</A> which acts via
<Ref Func="OnLeftInverse"/>.
Of course the action of a larger group <A>G</A> on right cosets is via
<Ref Func="OnRight"/>.
<Example><![CDATA[
gap> u:=Group((1,2,3), (1,2));;
gap> c:=RightCoset(u,(2,3,4));
RightCoset(Group( [ (1,2,3), (1,2) ] ),(2,3,4))
gap> ActingDomain(c);
Group([ (1,2,3), (1,2) ])
gap> Representative(c);
(2,3,4)
gap> Size(c);
6
gap> AsList(c);
[ (2,3,4), (1,4,2), (1,3,4,2), (1,3)(2,4), (2,4), (1,4,2,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RightCosets" Arg='G, U'/>
<Oper Name="RightCosetsNC" Arg='G, U'/>

<Description>
computes a duplicate free list of right cosets <A>U</A> <M>g</M> for
<M>g \in</M> <A>G</A>.
A set of representatives for the elements in this list forms a right
transversal of <A>U</A> in <A>G</A>.
(By inverting the representatives one obtains
a list of representatives of the left cosets of <A>U</A>.)
The <C>NC</C> version does not check whether <A>U</A> is a subgroup of
<A>G</A>.
<Example><![CDATA[
gap> RightCosets(g,u);
[ RightCoset(Group( [ (1,2,3), (1,2) ] ),()), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)(2,3)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,2)(3,4)) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CanonicalRightCosetElement" Arg='U, g'/>

<Description>
returns a <Q>canonical</Q> representative of the right coset
<A>U</A> <A>g</A>
which is independent of the given representative <A>g</A>.
This can be used to compare cosets by comparing their canonical
representatives.
<P/>
The representative chosen to be the <Q>canonical</Q> one
is representation dependent and only guaranteed to remain the same
within one &GAP; session.
<Example><![CDATA[
gap> CanonicalRightCosetElement(u,(2,4,3));
(3,4)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRightCoset" Arg='obj' Type='Category'/>

<Description>
The category of right cosets.
<P/>
<Index>left cosets</Index>
&GAP; does not provide left cosets as a separate data type, but as the
left coset <M>gU</M> consists of exactly the inverses of the elements of
the right coset <M>Ug^{{-1}}</M> calculations with left cosets can be
emulated using right cosets by inverting the representatives.
</Description>
</ManSection>

<ManSection>
<Func Name="CosetDecomposition" Arg='G,S'/>

<Description>
For a finite group <A>G</A> and a subgroup <M><A>S</A>\le<A>G</A></M>
this function returns a partition of the elements of <A>G</A> according to
the (right) cosets of <A>S</A>. The result is a list of lists, each sublist
corresponding to one coset. The first sublist is the elements list of the
subgroup, the other lists are arranged accordingly.
<Example><![CDATA[
gap> CosetDecomposition(SymmetricGroup(4),SymmetricGroup(3));          
[ [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ], 
  [ (1,4), (1,4)(2,3), (1,2,4), (1,2,3,4), (1,3,2,4), (1,3,4) ], 
  [ (1,4,2), (1,4,2,3), (2,4), (2,3,4), (1,3)(2,4), (1,3,4,2) ], 
  [ (1,4,3), (1,4,3,2), (1,2,4,3), (1,2)(3,4), (2,4,3), (3,4) ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Transversals">
<Heading>Transversals</Heading>

<ManSection>
<Oper Name="RightTransversal" Arg='G, U'/>

<Description>
A right transversal <M>t</M> is a list of representatives for the set
<M><A>U</A> \setminus <A>G</A></M> of right
cosets (consisting of cosets <M>Ug</M>) of <M>U</M> in <M>G</M>.
<P/>
The object returned by <Ref Func="RightTransversal"/> is not a
plain list, but an object that behaves like an immutable list of length
<M>[<A>G</A>:<A>U</A>]</M>,
except if <A>U</A> is the trivial subgroup of <A>G</A>
in which case <Ref Func="RightTransversal"/> may return the
sorted plain list of coset representatives.
<P/>
The operation <Ref Func="PositionCanonical"/>,
called for a transversal <M>t</M>
and an element <M>g</M> of <A>G</A>, will return the position of the
representative in <M>t</M> that lies in the same coset of <A>U</A> as the
element <M>g</M> does.
(In comparison, <Ref Func="Position"/> will return <K>fail</K> if the
element is not equal to the representative.)
Functions that implement group actions such as
<Ref Func="Action" Label="for a group, an action domain, etc."/> or
<Ref Func="Permutation" Label="for a group, an action domain, etc."/>
(see Chapter&nbsp;<Ref Chap="Group Actions"/>)
use <Ref Func="PositionCanonical"/>, therefore it is possible to
<Q>act</Q> on a right transversal to implement the action on the cosets.
This is often much more efficient than acting on cosets.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;
gap> rt:=RightTransversal(g,u);
RightTransversal(Group([ (1,2,3,4), (1,2) ]),Group([ (1,2,3), (1,2) ]))
gap> Length(rt);
4
gap> Position(rt,(1,2,3));
fail
]]></Example>
<P/>
Note that the elements of a right transversal are not necessarily
<Q>canonical</Q> in the sense of
<Ref Func="CanonicalRightCosetElement"/>, but we may compute a list of
canonical coset representatives by calling that function.
(See also <Ref Func="PositionCanonical"/>.)
<P/>
<Example><![CDATA[
gap> List(RightTransversal(g,u),i->CanonicalRightCosetElement(u,i));
[ (), (2,3,4), (1,2,3,4), (3,4) ]
gap> PositionCanonical(rt,(1,2,3));
1
gap> rt[1];
()
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Double Cosets">
<Heading>Double Cosets</Heading>

<ManSection>
<Oper Name="DoubleCoset" Arg='U, g, V'/>

<Description>
The groups <A>U</A> and <A>V</A> must be subgroups of a common supergroup
<A>G</A> of which <A>g</A> is an element.
This command constructs the double coset <A>U</A> <A>g</A> <A>V</A>
which is the set of all elements of the form <M>ugv</M> for any
<M>u \in <A>U</A></M>, <M>v \in <A>V</A></M>.
For element operations such as <K>in</K>, a double coset behaves
like a set of group elements. The double coset stores <A>U</A> in the
attribute <C>LeftActingGroup</C>,
<A>g</A> as <Ref Func="Representative"/>,
and <A>V</A> as <C>RightActingGroup</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="RepresentativesContainedRightCosets" Arg='D'/>

<Description>
A double coset <M><A>D</A> = U g V</M> can be considered as a union of
right cosets <M>U h_i</M>.
(It is the union of the orbit of <M>U g</M> under right multiplication by
<M>V</M>.)
For a double coset <A>D</A> this function returns a set
of representatives <M>h_i</M> such that
<A>D</A> <M>= \bigcup_{{h_i}} U h_i</M>.
The representatives returned are canonical for <M>U</M> (see
<Ref Func="CanonicalRightCosetElement"/>) and form a set.
<Example><![CDATA[
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;v:=Subgroup(g,[(3,4)]);;
gap> c:=DoubleCoset(u,(2,4),v);
DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(2,4),Group( [ (3,4) ] ))
gap> (1,2,3) in c;
false
gap> (2,3,4) in c;
true
gap> LeftActingGroup(c);
Group([ (1,2,3), (1,2) ])
gap> RightActingGroup(c);
Group([ (3,4) ])
gap> RepresentativesContainedRightCosets(c);
[ (2,3,4) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DoubleCosets" Arg='G, U, V'/>
<Oper Name="DoubleCosetsNC" Arg='G, U, V'/>

<Description>
computes a duplicate free list of all double cosets
<A>U</A> <M>g</M> <A>V</A> for <M>g \in <A>G</A></M>.
The groups <A>U</A> and <A>V</A> must be subgroups of the group <A>G</A>.
The <C>NC</C> version does not check whether <A>U</A> and <A>V</A> are
subgroups of <A>G</A>.
<Example><![CDATA[
gap> dc:=DoubleCosets(g,u,v);
[ DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(),Group( [ (3,4) ] )), 
  DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4),Group( 
    [ (3,4) ] )), DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)
    (2,3),Group( [ (3,4) ] )) ]
gap> List(dc,Representative);
[ (), (1,3)(2,4), (1,4)(2,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsDoubleCoset" Arg='obj' Type='Category' Label="operation"/>

<Description>
The category of double cosets.
</Description>
</ManSection>

<ManSection>
<Oper Name="DoubleCosetRepsAndSizes" Arg='G, U, V'/>

<Description>
returns a list of double coset representatives and their sizes,
the entries are lists of the form <M>[ r, n ]</M>
where <M>r</M> and <M>n</M> are an element of the double coset and the
size of the coset, respectively.
This operation is faster than <Ref Func="DoubleCosetsNC"/> because no
double coset objects have to be created.
<Example><![CDATA[
gap> dc:=DoubleCosetRepsAndSizes(g,u,v);
[ [ (), 12 ], [ (1,3)(2,4), 6 ], [ (1,4)(2,3), 6 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoCoset"/>

<Description>
The information function for coset and double coset operations is
<Ref InfoClass="InfoCoset"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Conjugacy Classes">
<Heading>Conjugacy Classes</Heading>

<ManSection>
<Oper Name="ConjugacyClass" Arg='G, g'/>

<Description>
creates the conjugacy class in <A>G</A> with representative <A>g</A>.
This class is an external set, so functions such as
<Ref Func="Representative"/> (which returns <A>g</A>),
<Ref Func="ActingDomain"/> (which returns <A>G</A>),
<Ref Func="StabilizerOfExternalSet"/> (which returns the centralizer of
<A>g</A>) and <Ref Func="AsList"/> work for it.
<P/>
A conjugacy class is an external orbit (see <Ref Func="ExternalOrbit"/>)
of group elements with the group acting by conjugation on it.
Thus element tests or operation representatives can be computed.
The attribute
<Ref Func="Centralizer" Label="for a class of objects in a magma"/>
gives the centralizer of the representative (which is the same result as
<Ref Func="StabilizerOfExternalSet"/>).
(This is a slight abuse of notation: This is <E>not</E> the centralizer
of the class as a <E>set</E> which would be the standard behaviour of
<Ref Func="Centralizer" Label="for a class of objects in a magma"/>.)
</Description>
</ManSection>

<ManSection>
<Attr Name="ConjugacyClasses" Arg='G' Label="attribute"/>

<Description>
returns the conjugacy classes of elements of <A>G</A> as a list of
class objects of <A>G</A>
(see&nbsp;<Ref Func="ConjugacyClass"/> for details). 
It is guaranteed that the class of the
identity is in the first position, the further arrangement depends on
the method chosen (and might be different for equal but not identical
groups).
<P/>
For very small groups (of size up to 500) the classes will be computed
by the conjugation action of <A>G</A> on itself
(see&nbsp;<Ref Func="ConjugacyClassesByOrbits"/>).
This can be deliberately switched off using the <Q><C>noaction</C></Q>
option shown below.
<P/>
For solvable groups, the default method to compute the classes is by
homomorphic lift
(see section&nbsp;<Ref Sect="Conjugacy Classes in Solvable Groups"/>).
<P/>
For other groups the method of <Cite Key="HulpkeClasses"/> is employed.
<P/>
<Ref Attr="ConjugacyClasses" Label="attribute"/> supports the following
options that can be used to modify this strategy:
<List>
<Mark><C>random</C></Mark>
<Item>
  The classes are computed by random search.
  See <Ref Func="ConjugacyClassesByRandomSearch"/> below.
</Item>
<Mark><C>action</C></Mark>
<Item>
  The classes are computed by action of <A>G</A> on itself.
  See <Ref Func="ConjugacyClassesByOrbits"/> below.
</Item>
<Mark><C>noaction</C></Mark>
<Item>
  Even for small groups
  <Ref Func="ConjugacyClassesByOrbits"/>
  is not used as a default. This can be useful if the elements of the
  group use a lot of memory.
</Item>
</List>
<Example><![CDATA[
gap> g:=SymmetricGroup(4);;
gap> cl:=ConjugacyClasses(g);
[ ()^G, (1,2)^G, (1,2)(3,4)^G, (1,2,3)^G, (1,2,3,4)^G ]
gap> Representative(cl[3]);Centralizer(cl[3]);
(1,2)(3,4)
Group([ (1,2), (1,3)(2,4), (3,4) ])
gap> Size(Centralizer(cl[5]));
4
gap> Size(cl[2]);
6
]]></Example>
<P/>
In general, you will not need to have to influence the method, but simply
call <Ref Func="ConjugacyClasses" Label="attribute"/>
&ndash;&GAP; will try to select a suitable method on its own.
The method specifications are provided here mainly for expert use.
</Description>
</ManSection>

<ManSection>
<Func Name="ConjugacyClassesByRandomSearch" Arg='G'/>

<Description>
computes the classes of the group <A>G</A> by random search.
This works very efficiently for almost simple groups.
<P/>
This function is also accessible via the option <C>random</C> to
the function <Ref Func="ConjugacyClass"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ConjugacyClassesByOrbits" Arg='G'/>

<Description>
computes the classes of the group <A>G</A> as orbits of <A>G</A> on its
elements.
This can be quick but unsurprisingly may also take a lot of memory if
<A>G</A> becomes larger.
All the classes will store their element list and
thus a membership test will be quick as well.
<P/>
This function is also accessible via the option <C>action</C> to
the function <Ref Func="ConjugacyClass"/>.
<P/>
Typically, for small groups (roughly of order up to <M>10^3</M>)
the computation of classes as orbits under the action is fastest;
memory restrictions (and the increasing cost of eliminating duplicates)
make this less efficient for larger groups.
<P/>
Calculation by random search has the smallest memory requirement, but in
generally performs worse, the more classes are there.
<P/>
The following example shows the effect of this for a small group
with many classes:
<P/>
<!-- this example is time and load-status dependent. No point in testing -->
<Log><![CDATA[
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:noaction);;time;
110
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:random);;time;
300
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:action);;time;
30
]]></Log>
</Description>
</ManSection>

<ManSection>
<Attr Name="NrConjugacyClasses" Arg='G'/>

<Description>
returns the number of conjugacy classes of <A>G</A>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> NrConjugacyClasses(g);
5
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RationalClass" Arg='G, g'/>

<Description>
creates the rational class in <A>G</A> with representative <A>g</A>.
A rational class consists of all elements that are conjugate to
<A>g</A> or to an <M>i</M>-th power of <A>g</A> where <M>i</M> is coprime
to the order of <M>g</M>.
Thus a rational class can be interpreted as a conjugacy class of cyclic
subgroups.
A rational class is an external set (<Ref Func="IsExternalSet"/>) of
group elements with the group acting by conjugation on it, but not an
external orbit.
</Description>
</ManSection>

<ManSection>
<Attr Name="RationalClasses" Arg='G'/>

<Description>
returns a list of the rational classes of the group <A>G</A>. (See
<Ref Func="RationalClass"/>.)
<Example><![CDATA[
gap> RationalClasses(DerivedSubgroup(g));
[ RationalClass( AlternatingGroup( [ 1 .. 4 ] ), () ), 
  RationalClass( AlternatingGroup( [ 1 .. 4 ] ), (1,2)(3,4) ), 
  RationalClass( AlternatingGroup( [ 1 .. 4 ] ), (1,2,3) ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GaloisGroup" Arg='ratcl'
 Label="of rational class of a group"/>

<Description>
Suppose that <A>ratcl</A> is a rational class of a group <M>G</M> with
representative <M>g</M>.
The exponents <M>i</M> for which <M>g^i</M> lies already in the ordinary
conjugacy class of <M>g</M>, form a subgroup of the
<E>prime residue class group</E> <M>P_n</M>
(see <Ref Func="PrimitiveRootMod"/>),
the so-called <E>Galois group</E>  of the rational class.
The prime residue class group <M>P_n</M> is obtained in
&GAP; as <C>Units( Integers mod <A>n</A> )</C>,
the unit group of a residue class ring.
The Galois group of a rational class <A>ratcl</A> is stored in the
attribute <Ref Func="GaloisGroup" Label="of rational class of a group"/>
as a subgroup of this group.
</Description>
</ManSection>

<ManSection>
<Heading>IsConjugate</Heading>
<Oper Name="IsConjugate" Arg='G, x, y'
 Label="for a group and two elements"/>
<Oper Name="IsConjugate" Arg='G, U, V'
 Label="for a group and two groups"/>

<Description>
tests whether the elements <A>x</A> and <A>y</A>
or the subgroups <A>U</A> and <A>V</A> are
conjugate under the action of <A>G</A>.
(They do not need to be <E>contained in</E> <A>G</A>.)
This command is only a shortcut to <Ref Func="RepresentativeAction"/>.
<Example><![CDATA[
gap> IsConjugate(g,Group((1,2,3,4),(1,3)),Group((1,3,2,4),(1,2)));
true
]]></Example>
<P/>
<Ref Func="RepresentativeAction"/> can be used to
obtain conjugating elements.
<Example><![CDATA[
gap> RepresentativeAction(g,(1,2),(3,4));
(1,3)(2,4)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NthRootsInGroup" Arg='G, e, n'/>

<Description>
Let <A>e</A> be an element in the group <A>G</A>.
This function returns a list of all those elements in <A>G</A>
whose <A>n</A>-th power is <A>e</A>.
<P/>
<Example><![CDATA[
gap> NthRootsInGroup(g,(1,2)(3,4),2);
[ (1,3,2,4), (1,4,2,3) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Normal Structure">
<Heading>Normal Structure</Heading>

For the operations
<Ref Func="Centralizer" Label="for a magma and a submagma"/> and
<Ref Func="Centre"/>, see Chapter&nbsp;<Ref Chap="Magmas"/>.

<Index>normalizer</Index>
<ManSection>
<Heading>Normalizer</Heading>
<Oper Name="Normalizer" Arg='G, U' Label="for two groups"/>
<Oper Name="Normalizer" Arg='G, g'
 Label="for a group and a group element"/>

<Description>
For two groups <A>G</A>, <A>U</A>,
<Ref Func="Normalizer" Label="for two groups"/> computes the
normalizer <M>N_{<A>G</A>}(<A>U</A>)</M>,
that is, the stabilizer of <A>U</A>
under the conjugation action of <A>G</A>.
<P/>
For a group <A>G</A> and a group element <A>g</A>,
<Ref Func="Normalizer" Label="for a group and a group element"/>
computes <M>N_{<A>G</A>}(\langle <A>g</A> \rangle)</M>.
<P/>
<Example><![CDATA[
gap> Normalizer(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3), (2,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Core" Arg='S, U'/>

<Description>
If <A>S</A> and <A>U</A> are groups of elements in the same family, this
operation
returns the core of <A>U</A> in <A>S</A>, that is the intersection of all
<A>S</A>-conjugates of <A>U</A>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> Core(g,Subgroup(g,[(1,2,3,4)]));
Group(())
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PCore" Arg='G, p'/>

<Description>
<Index Key="Op(G)" Subkey="see PCore"><C>PCore</C></Index>
The <E><A>p</A>-core</E> of <A>G</A> is the largest normal
<A>p</A>-subgroup of <A>G</A>.
It is the core of a Sylow <A>p</A> subgroup of <A>G</A>,
see <Ref Func="Core"/>.
<Example><![CDATA[
gap> PCore(g,2);
Group([ (1,4)(2,3), (1,2)(3,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="NormalClosure" Arg='G, U'/>

<Description>
The normal closure of <A>U</A> in <A>G</A> is the smallest normal subgroup 
of the closure of <A>G</A> and <A>U</A> which contains <A>U</A>.
<Example><![CDATA[
gap> NormalClosure(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3), (2,3,4) ])
gap> NormalClosure(g,Group((3,4,5)));
Group([ (3,4,5), (1,5,4), (1,2,5) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="NormalIntersection" Arg='G, U'/>

<Description>
computes the intersection of <A>G</A> and <A>U</A>, assuming that <A>G</A> is normalized
by <A>U</A>. This works faster than <C>Intersection</C>, but will not produce the
intersection if <A>G</A> is not normalized by <A>U</A>.
<Example><![CDATA[
gap> NormalIntersection(Group((1,2)(3,4),(1,3)(2,4)),Group((1,2,3,4)));
Group([ (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ComplementClassesRepresentatives" Arg='G, N'/>

<Description>
Let <A>N</A> be a normal subgroup of <A>G</A>.
This command returns a set of representatives for the conjugacy classes
of complements of <A>N</A> in <A>G</A>.
Complements are subgroups of <A>G</A> which intersect trivially with
<A>N</A> and together with <A>N</A> generate <A>G</A>.
<P/>
At the moment only methods for a solvable <A>N</A> are available.
<Example><![CDATA[
gap> ComplementClassesRepresentatives(g,Group((1,2)(3,4),(1,3)(2,4)));
[ Group([ (3,4), (2,4,3) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoComplement"/>

<Description>
Info class for the complement routines.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Specific and Parametrized Subgroups">
<Heading>Specific and Parametrized Subgroups</Heading>

The centre of a group (the subgroup of those elements that commute with all
other elements of the group) can be computed by the operation
<Ref Func="Centre"/>.

<ManSection>
<Attr Name="TrivialSubgroup" Arg='G'/>

<Description>
<Example><![CDATA[
gap> TrivialSubgroup(g);
Group(())
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CommutatorSubgroup" Arg='G, H'/>

<Description>
If <A>G</A> and <A>H</A> are two groups of elements in the same family,
this operation returns the group generated by all commutators
<M>[ g, h ] = g^{{-1}} h^{{-1}} g h</M> (see&nbsp;<Ref Func="Comm"/>)
of elements <M>g \in <A>G</A></M> and
<M>h \in <A>H</A></M>, that is the group
<M>\left \langle [ g, h ] \mid g \in <A>G</A>, h \in <A>H</A> \right \rangle</M>.
<Example><![CDATA[
gap> CommutatorSubgroup(Group((1,2,3),(1,2)),Group((2,3,4),(3,4)));
Group([ (1,4)(2,3), (1,3,4) ])
gap> Size(last);
12
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DerivedSubgroup" Arg='G'/>

<Description>
The derived subgroup <M><A>G</A>'</M> of <A>G</A> is the subgroup
generated by all commutators of pairs of elements of <A>G</A>.
It is normal in <A>G</A> and the factor group <M><A>G</A>/<A>G</A>'</M>
is the largest abelian factor group of <A>G</A>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> DerivedSubgroup(g);
Group([ (1,3,2), (2,4,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CommutatorLength" Arg='G'/>

<Description>
returns the minimal number <M>n</M> such that each element
in the derived subgroup (see&nbsp;<Ref Func="DerivedSubgroup"/>) of the
group <A>G</A> can be written as a product of (at most) <M>n</M>
commutators of elements in <A>G</A>.
<Example><![CDATA[
gap> CommutatorLength( g );
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="FittingSubgroup" Arg='G'/>

<Description>
The Fitting subgroup of a group <A>G</A> is its largest nilpotent normal
subgroup.
<Example><![CDATA[
gap> FittingSubgroup(g);
Group([ (1,2)(3,4), (1,4)(2,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="FrattiniSubgroup" Arg='G'/>

<Description>
The Frattini subgroup of a group <A>G</A> is the intersection of all
maximal subgroups of <A>G</A>.
<Example><![CDATA[
gap> FrattiniSubgroup(g);
Group(())
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PrefrattiniSubgroup" Arg='G'/>

<Description>
returns a Prefrattini subgroup of the finite solvable group <A>G</A>.
<P/>
A factor <M>M/N</M> of <A>G</A> is called a Frattini factor if
<M>M/N</M> is contained in the Frattini subgroup of <M><A>G</A>/N</M>.
A subgroup <M>P</M> is a Prefrattini subgroup of <A>G</A> if <M>P</M>
covers each Frattini chief factor of <A>G</A>, and if for each maximal
subgroup of <A>G</A> there exists a conjugate maximal subgroup, which
contains <M>P</M>.
In a finite solvable group <A>G</A> the Prefrattini subgroups
form a characteristic conjugacy class of subgroups and the intersection
of all these subgroups is the Frattini subgroup of <A>G</A>.
<Example><![CDATA[
gap> G := SmallGroup( 60, 7 );
<pc group of size 60 with 4 generators>
gap> P := PrefrattiniSubgroup(G);
Group([ f2 ])
gap> Size(P);
2
gap> IsNilpotent(P);
true
gap> Core(G,P);
Group([  ])
gap> FrattiniSubgroup(G);
Group([  ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PerfectResiduum" Arg='G'/>

<Description>
is the smallest normal subgroup of <A>G</A> that has a solvable factor group.
<Example><![CDATA[
gap> PerfectResiduum(Group((1,2,3,4,5),(1,2)));
Group([ (1,3,2), (1,4,3), (1,5,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RadicalGroup" Arg='G'/>

<Description>
is the radical of <A>G</A>, i.e., the largest solvable normal subgroup of <A>G</A>.
<Example><![CDATA[
gap> RadicalGroup(SL(2,5));
<group of 2x2 matrices of size 2 over GF(5)>
gap> Size(last);
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Socle" Arg='G'/>

<Description>
The socle of the group <A>G</A> is the subgroup generated by
all minimal normal subgroups.
<Example><![CDATA[
gap> Socle(g);
Group([ (1,4)(2,3), (1,2)(3,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SupersolvableResiduum" Arg='G'/>

<Description>
is the supersolvable residuum of the group <A>G</A>, that is,
its smallest normal subgroup <M>N</M> such that the factor group
<M><A>G</A> / N</M> is supersolvable.
<Example><![CDATA[
gap> SupersolvableResiduum(g);
Group([ (1,2)(3,4), (1,4)(2,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PRump" Arg='G, p'/>

<Description>
For a prime <M>p</M>, the <E><A>p</A>-rump</E> of a group <A>G</A> is
the subgroup <M><A>G</A>' <A>G</A>^{<A>p</A>}</M>.
<P/>
<E>@example missing!@</E>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sylow Subgroups and Hall Subgroups">
<Heading>Sylow Subgroups and Hall Subgroups</Heading>

With respect to the following &GAP; functions,
please note that by theorems of P.&nbsp;Hall,
a group <M>G</M> is solvable if and only if one of the following conditions holds.
<Enum>
<Item>
    For each prime <M>p</M> dividing the order of <M>G</M>,
    there exists a <M>p</M>-complement (see&nbsp;<Ref Func="SylowComplement"/>).
</Item>
<Item>
    For each set <M>P</M> of primes dividing the order of <M>G</M>,
    there exists a <M>P</M>-Hall subgroup (see&nbsp;<Ref Func="HallSubgroup"/>).
</Item>
<Item>
    <M>G</M> has a Sylow system (see&nbsp;<Ref Func="SylowSystem"/>).
</Item>
<Item>
    <M>G</M> has a complement system (see&nbsp;<Ref Func="ComplementSystem"/>).
</Item>
</Enum>

<ManSection>
<Func Name="SylowSubgroup" Arg='G, p'/>

<Description>
returns a Sylow <A>p</A> subgroup of the finite group <A>G</A>.
This is a <A>p</A>-subgroup of <A>G</A> whose index in <A>G</A> is
coprime to <A>p</A>.
<Ref Func="SylowSubgroup"/> computes Sylow subgroups via the operation
<C>SylowSubgroupOp</C>.
<Example><![CDATA[
gap> g:=SymmetricGroup(4);;
gap> SylowSubgroup(g,2);
Group([ (1,2), (3,4), (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SylowComplement" Arg='G, p'/>

<Description>
returns a Sylow <A>p</A>-complement of the finite group <A>G</A>.
This is a subgroup <M>U</M> of order coprime to <A>p</A> such that the
index <M>[<A>G</A>:U]</M> is a <A>p</A>-power.
<P/>
At the moment methods exist only if <A>G</A> is solvable and &GAP; will
issue an error if <A>G</A> is not solvable.
<P/>
<Example><![CDATA[
gap> SylowComplement(g,3);
Group([ (1,2), (3,4), (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="HallSubgroup" Arg='G, P'/>

<Description>
computes a <A>P</A>-Hall subgroup for a set <A>P</A> of primes.
This is a subgroup the order of which is only divisible by primes in
<A>P</A> and whose index is coprime to all primes in <A>P</A>. Such a
subgroup is unique up to conjugacy if <A>G</A> is solvable.
The function computes Hall subgroups via the operation
<C>HallSubgroupOp</C>.
<P/>
If <A>G</A> is solvable this function always returns a subgroup. If
<A>G</A> is not solvable this function might return a subgroup (if it is
unique up to conjugacy), a list of subgroups (which are representatives of
the conjugacy classes in case there are several such classes) or <K>fail</K>
if no such subgroup exists.
<Example><![CDATA[
gap> h:=SmallGroup(60,10);;
gap> u:=HallSubgroup(h,[2,3]);
Group([ f1, f2, f3 ])
gap> Size(u);
12
gap> h:=PSL(3,5);;
gap> HallSubgroup(h,[2,3]);  
[ <permutation group of size 96 with 6 generators>, 
  <permutation group of size 96 with 6 generators> ]
gap> u := HallSubgroup(h,[3,31]);;
gap> Size(u); StructureDescription(u);
93
"C31 : C3"
gap> HallSubgroup(h,[5,31]);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SylowSystem" Arg='G'/>

<Description>
A Sylow system of a group <A>G</A> is a set of Sylow subgroups of
<A>G</A> such that every pair of subgroups from this set commutes as
subgroups.
Sylow systems exist only for solvable groups. The operation returns
<K>fail</K> if the group <A>G</A> is not solvable.
<Example><![CDATA[
gap> h:=SmallGroup(60,10);;
gap> SylowSystem(h);
[ Group([ f1, f2 ]), Group([ f3 ]), Group([ f4 ]) ]
gap> List(last,Size);
[ 4, 3, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ComplementSystem" Arg='G'/>

<Description>
A complement system of a group <A>G</A> is a set of Hall
<M>p'</M>-subgroups of <A>G</A>,
where <M>p'</M> runs through the subsets of prime factors of
<M>|<A>G</A>|</M> that omit exactly one prime.
Every pair of subgroups from this set commutes as subgroups.
Complement systems exist only for solvable groups, therefore
<Ref Func="ComplementSystem"/> returns <K>fail</K> if the group <A>G</A>
is not solvable.
<Example><![CDATA[
gap> ComplementSystem(h);
[ Group([ f3, f4 ]), Group([ f1, f2, f4 ]), Group([ f1, f2, f3 ]) ]
gap> List(last,Size);
[ 15, 20, 12 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="HallSystem" Arg='G'/>

<Description>
returns a list containing one Hall <M>P</M>-subgroup for each set
<M>P</M> of prime divisors of the order of <A>G</A>.
Hall systems exist only for solvable groups. The operation returns
<K>fail</K> if the group <A>G</A> is not solvable.
<Example><![CDATA[
gap> HallSystem(h);
[ Group([  ]), Group([ f1, f2 ]), Group([ f1, f2, f3 ]), 
  Group([ f1, f2, f3, f4 ]), Group([ f1, f2, f4 ]), Group([ f3 ]), 
  Group([ f3, f4 ]), Group([ f4 ]) ]
gap> List(last,Size);
[ 1, 4, 12, 60, 20, 3, 15, 5 ]
]]></Example>
</Description>
</ManSection>


<!-- %%  The methods for Sylow subgroups in polycyclic groups and for Hall -->
<!-- %%  Systems are due to Bettina Eick. -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroups characterized by prime powers">
<Heading>Subgroups characterized by prime powers</Heading>

<ManSection>
<Oper Name="Omega" Arg='G, p[, n]'/>

<Description>
For a <A>p</A>-group <A>G</A>, one defines
<M>\Omega_{<A>n</A>}(<A>G</A>) =
\{ g \in <A>G</A> \mid g^{{<A>p</A>^{<A>n</A>}}} = 1 \}</M>.
The default value for <A>n</A> is <C>1</C>.
<P/>
<E>@At the moment methods exist only for abelian <A>G</A> and <A>n</A>=1.@</E>
<Example><![CDATA[
gap> h:=SmallGroup(16,10);
<pc group of size 16 with 4 generators>
gap> Omega(h,2);
Group([ f2, f3, f4 ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Agemo" Arg='G, p[, n]'/>

<Description>
For a <A>p</A>-group <A>G</A>, one defines
<M>\mho_{<A>n</A>}(G) =
\langle g^{{<A>p</A>^{<A>n</A>}}} \mid g \in <A>G</A> \rangle</M>.
The default value for <A>n</A> is <C>1</C>.
<Example><![CDATA[
gap> Agemo(h,2);Agemo(h,2,2);
Group([ f4 ])
Group([  ])
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Group Properties">
<Heading>Group Properties</Heading>

Some properties of groups can be defined not only for groups but also for
other structures.
For example, nilpotency and solvability make sense also for algebras.
Note that these names refer to different definitions for groups and
algebras, contrary to the situation with finiteness or commutativity.
In such cases, the name of the function for groups got a suffix <C>Group</C>
to distinguish different meanings for different structures.
<P/>
Some functions, such as <Ref Func="IsPSolvable"/> and
<Ref Func="IsPNilpotent"/>, although they are mathematical
properties, are not properties in the sense of &GAP;
(see&nbsp;<Ref Sect="Attributes"/> and <Ref Sect="Properties"/>),
as they depend on a parameter.

<ManSection>
<Prop Name="IsCyclic" Arg='G'/>

<Description>
A group is <E>cyclic</E> if it can be generated by one element.
For a cyclic group, one can compute a generating set consisting of only
one element using <Ref Func="MinimalGeneratingSet"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsElementaryAbelian" Arg='G'/>

<Description>
A group <A>G</A> is elementary abelian if it is commutative and if there is a
prime <M>p</M> such that the order of each element in <A>G</A> divides <M>p</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNilpotentGroup" Arg='G'/>

<Description>
A group is <E>nilpotent</E> if the lower central series
(see&nbsp;<Ref Func="LowerCentralSeriesOfGroup"/> for a definition)
reaches the trivial subgroup in a finite number of steps.
</Description>
</ManSection>

<ManSection>
<Attr Name="NilpotencyClassOfGroup" Arg='G'/>

<Description>
The nilpotency class of a nilpotent group <A>G</A> is the number of steps in
the lower central series of <A>G</A> (see <Ref Func="LowerCentralSeriesOfGroup"/>);
<P/>
If <A>G</A> is not nilpotent an error is issued.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPerfectGroup" Arg='G'/>

<Description>
A group is <E>perfect</E> if it equals its derived subgroup
(see&nbsp;<Ref Func="DerivedSubgroup"/>).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSolvableGroup" Arg='G'/>

<Description>
A group is <E>solvable</E> if the derived series
(see&nbsp;<Ref Func="DerivedSeriesOfGroup"/> for a definition)
reaches the trivial subgroup in a finite number of steps.
<P/>
For finite groups this is the same as being polycyclic
(see&nbsp;<Ref Func="IsPolycyclicGroup"/>),
and each polycyclic group is solvable,
but there are infinite solvable groups that are not polycyclic.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPolycyclicGroup" Arg='G'/>

<Description>
A group is polycyclic if it has a subnormal series with cyclic factors.
For finite groups this is the same as if the group is solvable
(see&nbsp;<Ref Func="IsSolvableGroup"/>).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSupersolvableGroup" Arg='G'/>

<Description>
A finite group is <E>supersolvable</E> if it has a normal series
with cyclic factors.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsMonomialGroup" Arg='G'/>

<Description>
A finite group is <E>monomial</E> if every irreducible complex character is
induced from a linear character of a subgroup.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSimpleGroup" Arg='G'/>

<Description>
A group is <E>simple</E> if it is nontrivial and has no nontrivial normal
subgroups.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAlmostSimpleGroup" Arg='G'/>

<Description>
A group <A>G</A> is <E>almost simple</E> if a nonabelian simple group
<M>S</M> exists such that <A>G</A> is isomorphic to a subgroup of the
automorphism group of <M>S</M> that contains all inner automorphisms of
<M>S</M>.
<P/>
Equivalently, <A>G</A> is almost simple if and only if it has a unique
minimal normal subgroup <M>N</M> and if <M>N</M> is a nonabelian simple
group.
<P/>
<!--
(Note that the centralizer of <M>N</M> in <A>G</A> is trivial because
it is a normal subgroup of <A>G</A> that intersects <M>N</M>
trivially,
so if it would be nontrivial then it would contain another minimal normal
subgroup of <A>G</A>.
Hence the conjugation action of <A>G</A> on <M>N</M> defines an embedding
of <A>G</A> into the automorphism group of <M>N</M>,
and this embedding maps <M>N</M> to the group of inner automorphisms of
<M>N</M>.)
<P/>
-->
Note that an almost simple group is <E>not</E> defined as an extension of
a simple group by outer automorphisms,
since we want to exclude extensions of groups of prime order.
In particular, a <E>simple</E> group is <E>almost simple</E> if and only
if it is nonabelian.
<P/>
<Example><![CDATA[
gap> IsAlmostSimpleGroup( AlternatingGroup( 5 ) );
true
gap> IsAlmostSimpleGroup( SymmetricGroup( 5 ) );
true
gap> IsAlmostSimpleGroup( SymmetricGroup( 3 ) );
false
gap> IsAlmostSimpleGroup( SL( 2, 5 ) );            
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>IsomorphismTypeInfoFiniteSimpleGroup</Heading>
<Attr Name="IsomorphismTypeInfoFiniteSimpleGroup" Arg='G'
 Label="for a group"/>
<Attr Name="IsomorphismTypeInfoFiniteSimpleGroup" Arg='n'
 Label="for a group order"/>

<Description>
For a finite simple group <A>G</A>,
<Ref Func="IsomorphismTypeInfoFiniteSimpleGroup" Label="for a group"/>
returns a record with the components <C>series</C>, <C>name</C>
and possibly <C>parameter</C>,
describing the isomorphism type of <A>G</A>.
The component <C>name</C> is a string that gives name(s) for <A>G</A>,
and <C>series</C> is a string that describes the following series.
<P/>
(If different characterizations of <A>G</A> are possible
only one is given by <C>series</C> and <C>parameter</C>,
while <C>name</C> may give several names.)
<List>
<Mark><C>"A"</C></Mark>
<Item>
 Alternating groups, <C>parameter</C> gives the natural degree.
</Item>
<Mark><C>"L"</C></Mark>
<Item>
 Linear groups (Chevalley type <M>A</M>),
 <C>parameter</C> is a list <M>[ n, q ]</M> that indicates
 <M>L(n,q)</M>.
</Item>
<Mark><C>"2A"</C></Mark>
<Item>
 Twisted Chevalley type <M>{}^2A</M>,
 <C>parameter</C> is a list <M>[ n, q ]</M> that indicates
 <M>{}^2A(n,q)</M>.
</Item>
<Mark><C>"B"</C></Mark>
<Item>
 Chevalley type <M>B</M>,
 <C>parameter</C> is a list <M>[n, q ]</M> that indicates
 <M>B(n,q)</M>.
</Item>
<Mark><C>"2B"</C></Mark>
<Item>
 Twisted Chevalley type <M>{}^2B</M>,
 <C>parameter</C> is a value <M>q</M> that indicates <M>{}^2B(2,q)</M>.
</Item>
<Mark><C>"C"</C></Mark>
<Item>
 Chevalley type <M>C</M>,
 <C>parameter</C> is a list <M>[ n, q ]</M> that indicates
 <M>C(n,q)</M>.
</Item>
<Mark><C>"D"</C></Mark>
<Item>
 Chevalley type <M>D</M>,
 <C>parameter</C> is a list <M>[ n, q ]</M> that indicates
 <M>D(n,q)</M>.
</Item>
<Mark><C>"2D"</C></Mark>
<Item>
 Twisted Chevalley type <M>{}^2D</M>,
 <C>parameter</C> is a list <M>[ n, q ]</M> that indicates
 <M>{}^2D(n,q)</M>.
</Item>
<Mark><C>"3D"</C></Mark>
<Item>
 Twisted Chevalley type <M>{}^3D</M>,
 <C>parameter</C> is a value <M>q</M> that indicates <M>{}^3D(4,q)</M>.
</Item>
<Mark><C>"E"</C></Mark>
<Item>
 Exceptional Chevalley type <M>E</M>,
 <C>parameter</C> is a list <M>[ n, q ]</M> that indicates
 <M>E_n(q)</M>.
 The value of <A>n</A> is 6, 7, or 8.
</Item>
<Mark><C>"2E"</C></Mark>
<Item>
 Twisted exceptional Chevalley type <M>E_6</M>,
 <C>parameter</C> is a value <M>q</M> that indicates <M>{}^2E_6(q)</M>.
</Item>
<Mark><C>"F"</C></Mark>
<Item>
 Exceptional Chevalley type <M>F</M>,
 <C>parameter</C> is a value <M>q</M> that indicates <M>F(4,q)</M>.
</Item>
<Mark><C>"2F"</C></Mark>
<Item>
 Twisted exceptional Chevalley type <M>{}^2F</M> (Ree groups),
 <C>parameter</C> is a value <M>q</M> that indicates <M>{}^2F(4,q)</M>.
</Item>
<Mark><C>"G"</C></Mark>
<Item>
 Exceptional Chevalley type <M>G</M>,
 <C>parameter</C> is a value <M>q</M> that indicates <M>G(2,q)</M>.
</Item>
<Mark><C>"2G"</C></Mark>
<Item>
 Twisted exceptional Chevalley type <M>{}^2G</M> (Ree groups),
 <C>parameter</C> is a value <M>q</M> that indicates <M>{}^2G(2,q)</M>.
</Item>
<Mark><C>"Spor"</C></Mark>
<Item>
 Sporadic simple groups, <C>name</C> gives the name.
</Item>
<Mark><C>"Z"</C></Mark>
<Item>
 Cyclic groups of prime size, <C>parameter</C> gives the size.
</Item>
</List>
<P/>
An equal sign in the name denotes different naming schemes for the same
group, a tilde sign abstract isomorphisms between groups constructed
in a different way.
<P/>
<Example><![CDATA[
gap> IsomorphismTypeInfoFiniteSimpleGroup(
>                             Group((4,5)(6,7),(1,2,4)(3,5,6)));
rec( 
  name := "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,\
7) = U(2,7) ~ A(2,2) = L(3,2)", parameter := [ 2, 7 ], series := "L" )
]]></Example>
<P/>
For a positive integer <A>n</A>,
<Ref Func="IsomorphismTypeInfoFiniteSimpleGroup" Label="for a group order"/>
returns <K>fail</K> if <A>n</A> is not the order of a finite simple
group, and a record as described for the case of a group <A>G</A>
otherwise.
If more than one simple group of order <A>n</A> exists then the result
record contains only the <C>name</C> component, a string that lists the
two possible isomorphism types of simple groups of this order.
<P/>
<Example><![CDATA[
gap> IsomorphismTypeInfoFiniteSimpleGroup( 5 );    
rec( name := "Z(5)", parameter := 5, series := "Z" )
gap> IsomorphismTypeInfoFiniteSimpleGroup( 6 );
fail
gap> IsomorphismTypeInfoFiniteSimpleGroup(Size(SymplecticGroup(6,3))/2);
rec( 
  name := "cannot decide from size alone between B(3,3) = O(7,3) and C\
(3,3) = S(6,3)", parameter := [ 3, 3 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SimpleGroup" Arg='id [,param]'/>

<Description>
This function will construct <B>an</B> instance of the specified simple group.
Groups are specified via their name in ATLAS style notation, with parameters added
if necessary. The intelligence applied to parsing the name is limited, and at the
moment no proper extensions can be constructed.
For groups who do not have a permutation representation of small degree the
ATLASREP package might need to be installed to construct theses groups.
<Example><![CDATA[
gap> g:=SimpleGroup("M(23)");
M23
gap> Size(g);
10200960
gap> g:=SimpleGroup("PSL",3,5);
PSL(3,5)
gap> Size(g);
372000
gap> g:=SimpleGroup("PSp6",2);    
PSp(6,2)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SimpleGroupsIterator" Arg='[start[,end]]'/>

<Description>
This function returns an iterator that will run over all simple groups, starting
at order <A>start</A> if specified, up to order <M>10^{18}</M> (or -- if specified
-- order <A>end</A>). If the option <A>NOPSL2</A> is given, groups of type
<M>PSL_2(q)</M> are omitted.
<Example><![CDATA[
gap> it:=SimpleGroupsIterator(20000);
<iterator>
gap> List([1..8],x->NextIterator(it)); 
[ A8, PSL(3,4), PSL(2,37), PSp(4,3), Sz(8), PSL(2,32), PSL(2,41), 
  PSL(2,43) ]
gap> it:=SimpleGroupsIterator(1,2000);;
gap> l:=[];;for i in it do Add(l,i);od;l;
[ A5, PSL(2,7), A6, PSL(2,8), PSL(2,11), PSL(2,13) ]
gap> it:=SimpleGroupsIterator(20000,100000:NOPSL2);;
gap> l:=[];;for i in it do Add(l,i);od;l;
[ A8, PSL(3,4), PSp(4,3), Sz(8), PSU(3,4), M12 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SmallSimpleGroup" Arg='order[, i]'/>
<Returns>
  The <A>i</A>th simple group of order <A>order</A> in the stored list,
  given in a small-degree permutation representation, or <Ref Var="fail"/>
  if no such simple group exists.
</Returns>
<Description>
  If <A>i</A> is not given, it defaults to&nbsp;1.
  Currently, all simple groups of order less than <M>10^6</M> are
  available via this function.
<Example>
gap> SmallSimpleGroup(60);
A5
gap> SmallSimpleGroup(20160,1);
A8
gap> SmallSimpleGroup(20160,2);
PSL(3,4)
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AllSmallNonabelianSimpleGroups" Arg='orders'/>
<Returns>
  A list of all nonabelian simple groups whose order lies in the range
  <A>orders</A>.
</Returns>
<Description>
  The groups are given in small-degree permutation representations.
  The returned list is sorted by ascending group order.
  Currently, all simple groups of order less than <M>10^6</M> are
  available via this function.
<Example>
gap> List(AllSmallNonabelianSimpleGroups([1..1000000]),
>         StructureDescription);
[ "A5", "PSL(3,2)", "A6", "PSL(2,8)", "PSL(2,11)", "PSL(2,13)", 
  "PSL(2,17)", "A7", "PSL(2,19)", "PSL(2,16)", "PSL(3,3)", 
  "PSU(3,3)", "PSL(2,23)", "PSL(2,25)", "M11", "PSL(2,27)", 
  "PSL(2,29)", "PSL(2,31)", "A8", "PSL(3,4)", "PSL(2,37)", "O(5,3)", 
  "Sz(8)", "PSL(2,32)", "PSL(2,41)", "PSL(2,43)", "PSL(2,47)", 
  "PSL(2,49)", "PSU(3,4)", "PSL(2,53)", "M12", "PSL(2,59)", 
  "PSL(2,61)", "PSU(3,5)", "PSL(2,67)", "J1", "PSL(2,71)", "A9", 
  "PSL(2,73)", "PSL(2,79)", "PSL(2,64)", "PSL(2,81)", "PSL(2,83)", 
  "PSL(2,89)", "PSL(3,5)", "M22", "PSL(2,97)", "PSL(2,101)", 
  "PSL(2,103)", "HJ", "PSL(2,107)", "PSL(2,109)", "PSL(2,113)", 
  "PSL(2,121)", "PSL(2,125)", "O(5,4)" ]
</Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFinitelyGeneratedGroup" Arg='G'/>

<Description>
tests whether the group <A>G</A> can be generated by a finite number of
generators. (This property is mainly used to obtain finiteness
conditions.)
<P/>
Note that this is a pure existence statement. Even if a group is known
to be generated by a finite number of elements, it can be very hard or
even impossible to obtain such a generating set if it is not known.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSubsetLocallyFiniteGroup" Arg='U'/>

<Description>
A group is called locally finite if every finitely generated subgroup is
finite. This property checks whether the group <A>U</A> is a subset of a
locally finite group. This is used to check whether finite generation
will imply finiteness, as it does for example for permutation groups.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPGroup" Arg='G'/>

<Description>
<Index Key="p-group"><M>p</M>-group</Index>
A <E><M>p</M>-group</E> is a finite group whose order
(see&nbsp;<Ref Func="Size"/>) is of the form <M>p^n</M> for a prime
integer <M>p</M> and a nonnegative integer <M>n</M>.
<Ref Prop="IsPGroup"/> returns <K>true</K> if <A>G</A> is a
<M>p</M>-group, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="PrimePGroup" Arg='G'/>

<Description>
If <A>G</A> is a nontrivial <M>p</M>-group
(see&nbsp;<Ref Func="IsPGroup"/>), <Ref Func="PrimePGroup"/> returns
the prime integer <M>p</M>;
if <A>G</A> is trivial then <Ref Func="PrimePGroup"/> returns
<K>fail</K>. 
Otherwise an error is issued.
<P/>
(One should avoid a common error of writing 
<C>if IsPGroup(g) then ... PrimePGroup(g) ...</C> where the code 
represented by dots assumes that <C>PrimePGroup(g)</C> is an integer.)
</Description>
</ManSection>

<ManSection>
<Attr Name="PClassPGroup" Arg='G'/>

<Description>
The <M>p</M>-class of a <M>p</M>-group <A>G</A>
(see&nbsp;<Ref Func="IsPGroup"/>)
is the length of the lower <M>p</M>-central series
(see&nbsp;<Ref Func="PCentralSeries"/>) of <A>G</A>.
If <A>G</A> is not a <M>p</M>-group then an error is issued.
</Description>
</ManSection>

<ManSection>
<Attr Name="RankPGroup" Arg='G'/>

<Description>
For a <M>p</M>-group <A>G</A> (see&nbsp;<Ref Func="IsPGroup"/>),
<Ref Func="RankPGroup"/> returns the <E>rank</E> of <A>G</A>,
which is defined as the minimal size of a generating system of <A>G</A>.
If <A>G</A> is not a <M>p</M>-group then an error is issued.
<Example><![CDATA[
gap> h:=Group((1,2,3,4),(1,3));;
gap> PClassPGroup(h);
2
gap> RankPGroup(h);
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPSolvable" Arg='G, p'/>

<Description>
A finite group is <M>p</M>-solvable if every chief factor either has
order not divisible by <M>p</M>, or is solvable.
<P/>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPNilpotent" Arg='G, p'/>

<Description>
A group is <M>p</M>-nilpotent if it possesses a normal <M>p</M>-complement.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Numerical Group Attributes">
<Heading>Numerical Group Attributes</Heading>

This section gives only some examples of numerical group attributes, so
it should not serve as a collection of all numerical group attributes.
The manual contains more such attributes documented in this manual, for
example, <Ref Attr="NrConjugacyClasses"/>, 
<Ref Attr="NilpotencyClassOfGroup"/> and others.
<P/>
Note also that some functions, such as <Ref Func="EulerianFunction"/>,
are mathematical attributes, but not &GAP; attributes
(see <Ref Sect="Attributes"/>) as they are depending on a parameter.

<ManSection>
<Attr Name="AbelianInvariants" Arg='G'/>

<Description>
<Index Subkey="for groups" Key="AbelianInvariants">
<C>AbelianInvariants</C></Index>
returns the abelian invariants (also sometimes called primary
decomposition) of the commutator factor group of the
group <A>G</A>. These are given as a list of prime-powers or zeroes and
describe the structure of <M><A>G</A>/<A>G</A>'</M> as a direct product
of cyclic groups of prime power (or infinite) order.
<P/>
(See <Ref Func="IndependentGeneratorsOfAbelianGroup"/> to obtain actual
generators).
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2),(5,6));;
gap> AbelianInvariants(g);
[ 2, 2 ]
gap> h:=FreeGroup(2);;h:=h/[h.1^3];;
gap> AbelianInvariants(h);
[ 0, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Exponent" Arg='G'/>

<Description>
The exponent <M>e</M> of a group <A>G</A> is the lcm of the orders of its
elements, that is, <M>e</M> is the smallest integer such that
<M>g^e = 1</M> for all <M>g \in <A>G</A></M>.
<Example><![CDATA[
gap> Exponent(g);
12
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EulerianFunction" Arg='G, n'/>

<Description>
returns the number of <A>n</A>-tuples <M>(g_1, g_2, \ldots, g_n)</M>
of elements of the group <A>G</A> that generate the whole group <A>G</A>.
The elements of such an <A>n</A>-tuple need not be different.
<P/>
In <Cite Key="Hal36"/>, the notation <M>\phi_{<A>n</A>}(<A>G</A>)</M>
is used for the value returned by <Ref Func="EulerianFunction"/>,
and the quotient of <M>\phi_{<A>n</A>}(<A>G</A>)</M> by the order of the
automorphism group of <A>G</A> is called <M>d_{<A>n</A>}(<A>G</A>)</M>.
If <A>G</A> is a nonabelian simple group then
<M>d_{<A>n</A>}(<A>G</A>)</M> is the greatest number <M>d</M> for which
the direct product of <M>d</M> groups isomorphic with <A>G</A>
can be generated by <A>n</A> elements.
<P/>
If the Library of Tables of Marks
(see Chapter <Ref Chap="Tables of Marks"/>) covers the group <A>G</A>,
you may also use <Ref Func="EulerianFunctionByTom"/>.
<P/>
<Example><![CDATA[
gap> EulerianFunction( g, 2 );
432
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroup Series">
<Heading>Subgroup Series</Heading>

In group theory many subgroup series are considered,
and &GAP; provides commands to compute them.
In the following sections, there is always a series
<M>G = U_1 > U_2 > \cdots > U_m = \langle 1 \rangle</M> of subgroups considered.
A series also may stop without reaching <M>G</M> or <M>\langle 1 \rangle</M>.
<P/>
A series is called <E>subnormal</E> if every <M>U_{{i+1}}</M> is normal in
<M>U_i</M>.
<P/>
A series is called <E>normal</E> if every <M>U_i</M> is normal in <M>G</M>.
<P/>
A series of normal subgroups is called <E>central</E> if <M>U_i/U_{{i+1}}</M>
is central in <M>G / U_{{i+1}}</M>.
<P/>
We call a series <E>refinable</E> if intermediate subgroups can be added to
the series without destroying the properties of the series.
<P/>
Unless explicitly declared otherwise, all subgroup series are descending.
That is they are stored in decreasing order.

<ManSection>
<Attr Name="ChiefSeries" Arg='G'/>

<Description>
is a series of normal subgroups of <A>G</A> which cannot be refined
further.
That is there is no normal subgroup <M>N</M> of <A>G</A> with
<M>U_i > N > U_{{i+1}}</M>.
This attribute returns <E>one</E> chief series (of potentially many
possibilities).
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> ChiefSeries(g);
[ Group([ (1,2,3,4), (1,2) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group(()) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ChiefSeriesThrough" Arg='G, l'/>

<Description>
is a chief series of the group <A>G</A> going through
the normal subgroups in the list <A>l</A>, which must be a list of normal
subgroups of <A>G</A> contained in each other, sorted by descending size.
This attribute returns <E>one</E>
chief series (of potentially many possibilities).
</Description>
</ManSection>

<ManSection>
<Oper Name="ChiefSeriesUnderAction" Arg='H, G'/>

<Description>
returns a series of normal subgroups of <A>G</A> which are invariant under
<A>H</A> such that the series cannot be refined any further.
<A>G</A> must be a subgroup of <A>H</A>.
This attribute returns <E>one</E> such series (of potentially many
possibilities).
</Description>
</ManSection>

<ManSection>
<Oper Name="SubnormalSeries" Arg='G, U'/>

<Description>
If <A>U</A> is a subgroup of <A>G</A> this operation returns a subnormal
series that descends from <A>G</A> to a subnormal subgroup
<M>V \geq </M><A>U</A>. If <A>U</A> is subnormal, <M>V =</M> <A>U</A>.
<Example><![CDATA[
gap> s:=SubnormalSeries(g,Group((1,2)(3,4)));
[ Group([ (1,2,3,4), (1,2) ]), Group([ (1,2)(3,4), (1,4)(2,3) ]),
  Group([ (1,2)(3,4) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CompositionSeries" Arg='G'/>

<Description>
A composition series is a subnormal series which cannot be refined.
This attribute returns <E>one</E> composition series (of potentially many
possibilities).
</Description>
</ManSection>

<ManSection>
<Func Name="DisplayCompositionSeries" Arg='G'/>

<Description>
Displays a composition series of <A>G</A> in a nice way, identifying the
simple factors.
<Example><![CDATA[
gap> CompositionSeries(g);
[ Group([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group([ (1,3)(2,4) ]), Group(()) 
 ]
gap> DisplayCompositionSeries(Group((1,2,3,4,5,6,7),(1,2)));
G (2 gens, size 5040)
 | Z(2)
S (5 gens, size 2520)
 | A(7)
1 (0 gens, size 1)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DerivedSeriesOfGroup" Arg='G'/>

<Description>
The derived series of a group is obtained by <M>U_{{i+1}} = U_i'</M>.
It stops if <M>U_i</M> is perfect.
</Description>
</ManSection>

<ManSection>
<Attr Name="DerivedLength" Arg='G'/>

<Description>
The derived length of a group is the number of steps in the derived
series. (As there is always the group, it is the series length minus 1.)
<Example><![CDATA[
gap> List(DerivedSeriesOfGroup(g),Size);
[ 24, 12, 4, 1 ]
gap> DerivedLength(g);
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>ElementaryAbelianSeries</Heading>
<Attr Name="ElementaryAbelianSeries" Arg='G' Label="for a group"/>
<Attr Name="ElementaryAbelianSeriesLargeSteps" Arg='G'/>
<Attr Name="ElementaryAbelianSeries" Arg='list' Label="for a list"/>

<Description>
returns a series of normal subgroups of <M>G</M> such that all factors are
elementary abelian. If the group is not solvable (and thus no such series
exists) it returns <K>fail</K>.
<P/>
The variant <Ref Func="ElementaryAbelianSeriesLargeSteps"/> tries to make
the steps in this series large (by eliminating intermediate subgroups if
possible) at a small additional cost.
<P/>
In the third variant, an elementary abelian series through the given
series of normal subgroups in the list <A>list</A> is constructed.
<Example><![CDATA[
gap> List(ElementaryAbelianSeries(g),Size);
[ 24, 12, 4, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="InvariantElementaryAbelianSeries" Arg='G, morph[, N [, fine]]'/>

<Description>
For a (solvable) group <A>G</A> and a list of automorphisms <A>morph</A>
of <A>G</A>, this command finds a normal series of <A>G</A> with
elementary abelian factors such that every group in this series is
invariant under every automorphism in <A>morph</A>.
<P/>
If a normal subgroup <A>N</A> of <A>G</A> which is invariant under
<A>morph</A> is given, this series is chosen to contain <A>N</A>.
No tests are performed to check the validity of the arguments.
<P/>
The series obtained will be constructed to prefer large steps unless
<A>fine</A> is given as <K>true</K>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,3));
Group([ (1,2,3,4), (1,3) ])
gap> hom:=GroupHomomorphismByImages(g,g,GeneratorsOfGroup(g),
> [(1,4,3,2),(1,4)(2,3)]);
[ (1,2,3,4), (1,3) ] -> [ (1,4,3,2), (1,4)(2,3) ]
gap> InvariantElementaryAbelianSeries(g,[hom]);
[ Group([ (1,2,3,4), (1,3) ]), Group([ (1,3)(2,4) ]), Group(()) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LowerCentralSeriesOfGroup" Arg='G'/>

<Description>
The lower central series of a group <A>G</A> is defined as
<M>U_{{i+1}}:= [<A>G</A>, U_i]</M>.
It is a central series of normal subgroups.
The name derives from the fact that <M>U_i</M> is contained in the
<M>i</M>-th step subgroup of any central series.
</Description>
</ManSection>

<ManSection>
<Attr Name="UpperCentralSeriesOfGroup" Arg='G'/>

<Description>
The upper central series of a group <A>G</A> is defined as an ending
series <M>U_i / U_{{i+1}}:= Z(<A>G</A>/U_{{i+1}})</M>.
It is a central series of normal subgroups.
The name derives from the fact that <M>U_i</M> contains every <M>i</M>-th
step subgroup of a central series.
</Description>
</ManSection>

<ManSection>
<Func Name="PCentralSeries" Arg='G, p'/>

<Description>
The <A>p</A>-central series of <A>G</A> is defined by
<M>U_1:= <A>G</A></M>,
<M>U_i:= [<A>G</A>, U_{{i-1}}] U_{{i-1}}^{<A>p</A>}</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="JenningsSeries" Arg='G'/>

<Description>
For a <M>p</M>-group <A>G</A>, this function returns its Jennings series.
This series is defined by setting
<M>G_1 = <A>G</A></M> and for <M>i \geq 0</M>,
<M>G_{{i+1}} = [G_i,<A>G</A>] G_j^p</M>,
where <M>j</M> is the smallest integer <M>\geq i/p</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="DimensionsLoewyFactors" Arg='G'/>

<Description>
This operation computes the dimensions of the factors of the Loewy
series of <A>G</A>.
(See <Cite Key="Hup82" Where="p. 157"/> for the slightly complicated
definition of the Loewy Series.)
<P/>
The dimensions are computed via the <Ref Func="JenningsSeries"/> without computing
the Loewy series itself.
<Example><![CDATA[
gap> G:= SmallGroup( 3^6, 100 );
<pc group of size 729 with 6 generators>
gap> JenningsSeries( G );
[ <pc group of size 729 with 6 generators>, Group([ f3, f4, f5, f6 ]),
  Group([ f4, f5, f6 ]), Group([ f5, f6 ]), Group([ f5, f6 ]), 
  Group([ f5, f6 ]), Group([ f6 ]), Group([ f6 ]), Group([ f6 ]), 
  Group([ <identity> of ... ]) ]
gap> DimensionsLoewyFactors(G);
[ 1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 
  27, 27, 27, 27, 27, 27, 27, 27, 27, 26, 25, 23, 22, 20, 19, 17, 16, 
  14, 13, 11, 10, 8, 7, 5, 4, 2, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AscendingChain" Arg='G, U'/>

<Description>
This function computes an ascending chain of subgroups from <A>U</A> to
<A>G</A>.
This chain is given as a list whose first entry is <A>U</A> and the last
entry is <A>G</A>.
The function tries to make the links in this chain small.
<P/>
The option <C>refineIndex</C> can be used to give a bound for refinements
of steps to avoid &GAP; trying to enforce too small steps.
The option <C>cheap</C> (if set to <K>true</K>) will overall limit the
amount of heuristic searches.
</Description>
</ManSection>

<ManSection>
<Func Name="IntermediateGroup" Arg='G, U'/>

<Description>
This routine tries to find a subgroup <M>E</M> of <A>G</A>,
such that <M><A>G</A> > E > <A>U</A></M> holds.
If <A>U</A> is maximal in <A>G</A>, the function returns <K>fail</K>.
This is done by finding minimal blocks for
the operation of <A>G</A> on the right cosets of <A>U</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IntermediateSubgroups" Arg='G, U'/>

<Description>
returns a list of all subgroups of <A>G</A> that properly contain
<A>U</A>; that is all subgroups between <A>G</A> and <A>U</A>.
It returns a record with a component <C>subgroups</C>, which is a list of
these subgroups, as well as a component <C>inclusions</C>,
which lists all maximality inclusions among these subgroups.
A maximality inclusion is given as a list <M>[i, j]</M> indicating that
the subgroup number <M>i</M> is a maximal subgroup of the subgroup number
<M>j</M>,
the numbers <M>0</M> and <M>1 +</M> <C>Length(subgroups)</C> are used to
denote <A>U</A> and <A>G</A>, respectively.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Factor Groups">
<Heading>Factor Groups</Heading>

<ManSection>
<Func Name="NaturalHomomorphismByNormalSubgroup" Arg='G, N'/>
<Func Name="NaturalHomomorphismByNormalSubgroupNC" Arg='G, N'/>

<Description>
returns a homomorphism from <A>G</A> to another group whose kernel is <A>N</A>.
&GAP; will try to select the image group as to make computations in it
as efficient as possible. As the factor group <M><A>G</A>/<A>N</A></M> can be identified
with the image of <A>G</A> this permits efficient computations in the factor
group.
The homomorphism returned is not necessarily surjective, so
<Ref Func="ImagesSource"/> should be used instead of 
<Ref Func="Range" Label="of a general mapping"/>
to get a group isomorphic to the factor group.
The <C>NC</C> variant does not check whether <A>N</A> is normal in
<A>G</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="FactorGroup" Arg='G, N'/>
<Oper Name="FactorGroupNC" Arg='G, N'/>

<Description>
returns the image of the <C>NaturalHomomorphismByNormalSubgroup(<A>G</A>,<A>N</A>)</C>.
The homomorphism will be returned by calling the function
<C>NaturalHomomorphism</C> on the result.
The <C>NC</C> version does not test whether <A>N</A> is normal in <A>G</A>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap> hom:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (1,2,3,4), (1,2) ] -> [ f1*f2, f1 ]
gap> Size(ImagesSource(hom));
6
gap> FactorGroup(g,n);;
gap> StructureDescription(last);
"S3"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CommutatorFactorGroup" Arg='G'/>

<Description>
computes the commutator factor group <M><A>G</A>/<A>G</A>'</M> of the group <A>G</A>.
<Example><![CDATA[
gap> CommutatorFactorGroup(g);
Group([ f1 ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MaximalAbelianQuotient" Arg='G'/>

<Description>
returns an epimorphism from <A>G</A> onto the maximal abelian quotient of
<A>G</A>.
The kernel of this epimorphism is the derived subgroup of <A>G</A>,
see <Ref Func="DerivedSubgroup"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="HasAbelianFactorGroup" Arg='G, N'/>

<Description>
tests whether <A>G</A> <M>/</M> <A>N</A> is abelian
(without explicitly constructing the factor group).
</Description>
</ManSection>

<ManSection>
<Oper Name="HasElementaryAbelianFactorGroup" Arg='G, N'/>

<Description>
tests whether <A>G</A> <M>/</M> <A>N</A> is elementary abelian
(without explicitly constructing the factor group).
<Example><![CDATA[
gap> HasAbelianFactorGroup(g,n);
false
gap> HasAbelianFactorGroup(DerivedSubgroup(g),n);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CentralizerModulo" Arg='G, N, elm'/>

<Description>
Computes the full preimage of the centralizer
<M>C_{{<A>G</A>/<A>N</A>}}(<A>elm</A> \cdot <A>N</A>)</M> in <A>G</A>
(without necessarily constructing the factor group).
<Example><![CDATA[
gap> CentralizerModulo(g,n,(1,2));
Group([ (3,4), (1,3)(2,4), (1,4)(2,3) ])
]]></Example>
</Description>
</ManSection>


<!-- %%  The code for factor groups is due to Alexander Hulpke and Heiko Theißen. -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sets of Subgroups">
<Heading>Sets of Subgroups</Heading>

<ManSection>
<Oper Name="ConjugacyClassSubgroups" Arg='G, U'/>

<Description>
generates the conjugacy class of subgroups of <A>G</A> with
representative <A>U</A>.
This class is an external set,
so functions such as <Ref Attr="Representative"/>,
(which returns <A>U</A>),
<Ref Func="ActingDomain"/> (which returns <A>G</A>),
<Ref Func="StabilizerOfExternalSet"/> (which returns the normalizer of
<A>U</A>), and <Ref Func="AsList"/> work for it.
<P/>
(The use of the <C>[]</C>
list access to select elements of the class is considered obsolescent
and will be removed in future versions.
Use <Ref Func="ClassElementLattice"/> instead.)
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;IsNaturalSymmetricGroup(g);;
gap> cl:=ConjugacyClassSubgroups(g,Subgroup(g,[(1,2)]));
Group( [ (1,2) ] )^G
gap> Size(cl);
6
gap> ClassElementLattice(cl,4);
Group([ (2,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsConjugacyClassSubgroupsRep" Arg='obj'
 Type='Representation'/>
<Filt Name="IsConjugacyClassSubgroupsByStabilizerRep" Arg='obj'
 Type='Representation'/>

<Description>
Is the representation &GAP; uses for conjugacy classes of subgroups.
It can be used to check whether an object is a class of subgroups.
The second representation
<Ref Func="IsConjugacyClassSubgroupsByStabilizerRep"/> in
addition is an external orbit by stabilizer and will compute its
elements via a transversal of the stabilizer.
</Description>
</ManSection>

<ManSection>
<Attr Name="ConjugacyClassesSubgroups" Arg='G'/>

<Description>
This attribute returns a list of all conjugacy classes of subgroups of
the group <A>G</A>.
It also is applicable for lattices of subgroups (see&nbsp;<Ref Func="LatticeSubgroups"/>).
The order in which the classes are listed depends on the method chosen by
&GAP;.
For each class of subgroups, a representative can be accessed using
<Ref Attr="Representative"/>.
<Example><![CDATA[
gap> ConjugacyClassesSubgroups(g);
[ Group( () )^G, Group( [ (1,3)(2,4) ] )^G, Group( [ (3,4) ] )^G, 
  Group( [ (2,4,3) ] )^G, Group( [ (1,4)(2,3), (1,3)(2,4) ] )^G, 
  Group( [ (3,4), (1,2)(3,4) ] )^G, 
  Group( [ (1,3,2,4), (1,2)(3,4) ] )^G, Group( [ (3,4), (2,4,3) ] )^G,
  Group( [ (1,4)(2,3), (1,3)(2,4), (3,4) ] )^G, 
  Group( [ (1,4)(2,3), (1,3)(2,4), (2,4,3) ] )^G, 
  Group( [ (1,4)(2,3), (1,3)(2,4), (2,4,3), (3,4) ] )^G ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ConjugacyClassesMaximalSubgroups" Arg='G'/>

<Description>
returns the conjugacy classes of maximal subgroups of <A>G</A>.
Representatives of the classes can be computed directly by
<Ref Func="MaximalSubgroupClassReps"/>.
<Example><![CDATA[
gap> ConjugacyClassesMaximalSubgroups(g);
[ AlternatingGroup( [ 1 .. 4 ] )^G, Group( [ (1,2,3), (1,2) ] )^G, 
  Group( [ (1,2), (3,4), (1,3)(2,4) ] )^G ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AllSubgroups" Arg='G'/>

<Description>
For a finite group <A>G</A> 
<Ref Func="AllSubgroups"/> returns a list of all subgroups of <A>G</A>,
intended primarily for use in class for small examples.
This list will quickly get very long and in general use of
<Ref Func="ConjugacyClassesSubgroups"/> is recommended.
<Example><![CDATA[
gap> AllSubgroups(SymmetricGroup(3));
[ Group(()), Group([ (2,3) ]), Group([ (1,2) ]), Group([ (1,3) ]), 
  Group([ (1,2,3) ]), Group([ (1,2,3), (2,3) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MaximalSubgroupClassReps" Arg='G'/>

<Description>
returns a list of conjugacy representatives of the maximal subgroups
of <A>G</A>.
<Example><![CDATA[
gap> MaximalSubgroupClassReps(g);
[ Alt( [ 1 .. 4 ] ), Group([ (1,2,3), (1,2) ]), 
  Group([ (1,2), (3,4), (1,3)(2,4) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MaximalSubgroups" Arg='G'/>

<Description>
returns a list of all maximal subgroups of <A>G</A>. This may take up much
space, therefore the command should be avoided if possible. See
<Ref Func="ConjugacyClassesMaximalSubgroups"/>.
<Example><![CDATA[
gap> MaximalSubgroups(Group((1,2,3),(1,2)));
[ Group([ (1,2,3) ]), Group([ (2,3) ]), Group([ (1,2) ]), 
  Group([ (1,3) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NormalSubgroups" Arg='G'/>

<Description>
returns a list of all normal subgroups of <A>G</A>.
<Example><![CDATA[
gap> g:=SymmetricGroup(4);;NormalSubgroups(g);
[ Sym( [ 1 .. 4 ] ), Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group(()) ]
]]></Example>
<P/>
The algorithm for the computation of normal subgroups is described in
<Cite Key="Hulpke98"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="MaximalNormalSubgroups" Arg='G'/>

<Description>
is a list containing those proper normal subgroups of the group <A>G</A>
that are maximal among the proper normal subgroups.
<Example><![CDATA[
gap> MaximalNormalSubgroups( g );
[ Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MinimalNormalSubgroups" Arg='G'/>

<Description>
is a list containing those nontrivial normal subgroups of the group <A>G</A>
that are minimal among the nontrivial normal subgroups.
<Example><![CDATA[
gap> MinimalNormalSubgroups( g );
[ Group([ (1,4)(2,3), (1,3)(2,4) ]) ]
]]></Example>
</Description>
</ManSection>


<!-- %%  Bettina Eick designed and wrote the code for maximal subgroups of a solvable -->
<!-- %%  group. The code for normal subgroups <Cite Key="Hulpke98"/> and for subgroups of a -->
<!-- %%  solvable group is due to Alexander Hulpke. -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroup Lattice">
<Heading>Subgroup Lattice</Heading>

<ManSection>
<Attr Name="LatticeSubgroups" Arg='G'/>

<Description>
computes the lattice of subgroups of the group <A>G</A>.  This lattice has
the conjugacy classes of subgroups as attribute
<Ref Func="ConjugacyClassesSubgroups"/> and
permits one to test maximality/minimality relations.
<Example><![CDATA[
gap> g:=SymmetricGroup(4);;
gap> l:=LatticeSubgroups(g);
<subgroup lattice of Sym( [ 1 .. 4 ] ), 11 classes, 30 subgroups>
gap> ConjugacyClassesSubgroups(l);
[ Group( () )^G, Group( [ (1,3)(2,4) ] )^G, Group( [ (3,4) ] )^G, 
  Group( [ (2,4,3) ] )^G, Group( [ (1,4)(2,3), (1,3)(2,4) ] )^G, 
  Group( [ (3,4), (1,2)(3,4) ] )^G, 
  Group( [ (1,3,2,4), (1,2)(3,4) ] )^G, Group( [ (3,4), (2,4,3) ] )^G,
  Group( [ (1,4)(2,3), (1,3)(2,4), (3,4) ] )^G, 
  Group( [ (1,4)(2,3), (1,3)(2,4), (2,4,3) ] )^G, 
  Group( [ (1,4)(2,3), (1,3)(2,4), (2,4,3), (3,4) ] )^G ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ClassElementLattice" Arg='C, n'/>

<Description>
For a class <A>C</A> of subgroups, obtained by a lattice computation,
this operation returns the <A>n</A>-th conjugate subgroup in the class.
<P/>
<E>Because of other methods installed, calling <Ref Func="AsList"/> with
<A>C</A> can give a different arrangement of the class elements!</E>
<P/>
The &GAP; package <Package>XGAP</Package> permits a graphical display of
the lattice of subgroups in a nice way.
</Description>
</ManSection>

<ManSection>
<Func Name="DotFileLatticeSubgroups" Arg='L, file'/>

<Description>
<Index>dot-file</Index>
<Index>graphviz</Index>
<Index>OmniGraffle</Index>
This function produces a graphical representation of the subgroup
lattice <A>L</A> in file <A>file</A>. The output is in <C>.dot</C> (also known as
<C>GraphViz</C> format). For details on the format, and information about how to
display or edit this format see <URL>http://www.graphviz.org</URL>. (On the
Macintosh, the program <C>OmniGraffle</C> is also able to read this format.)
<P/>
Subgroups are labelled in the form <C><A>i</A>-<A>j</A></C> where <A>i</A> is the number of
the class of subgroups and <A>j</A> the number within this class. Normal
subgroups are represented by a box. 
<P/>
<Log><![CDATA[
gap> DotFileLatticeSubgroups(l,"s4lat.dot");
]]></Log>
</Description>
</ManSection>

<ManSection>
<Attr Name="MaximalSubgroupsLattice" Arg='lat'/>

<Description>
For a lattice <A>lat</A> of subgroups this attribute contains the maximal
subgroup relations among the subgroups of the lattice.
It is a list corresponding to the <Ref Func="ConjugacyClassesSubgroups"/>
value of the lattice, each entry giving a list of the maximal subgroups
of the representative of this class.
Every maximal subgroup is indicated by a list of the form <M>[ c, n ]</M>
which means that the <M>n</M>-th subgroup in class number <M>c</M> is a
maximal subgroup of the representative. 
<P/>
The number <M>n</M> corresponds to access via
<Ref Func="ClassElementLattice"/>
and <E>not</E> necessarily the <Ref Func="AsList"/> arrangement!
See also <Ref Func="MinimalSupergroupsLattice"/>.
<Example><![CDATA[
gap> MaximalSubgroupsLattice(l);
[ [  ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], 
  [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ] ], [ [ 3, 1 ], [ 3, 6 ], [ 2, 3 ] ], 
  [ [ 2, 3 ] ], [ [ 4, 1 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ], 
  [ [ 7, 1 ], [ 6, 1 ], [ 5, 1 ] ], 
  [ [ 5, 1 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 10, 1 ], [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 8, 1 ], [ 8, 2 ], 
      [ 8, 3 ], [ 8, 4 ] ] ]
gap> last[6];
[ [ 3, 1 ], [ 3, 6 ], [ 2, 3 ] ]
gap> u1:=Representative(ConjugacyClassesSubgroups(l)[6]);
Group([ (3,4), (1,2)(3,4) ])
gap> u2:=ClassElementLattice(ConjugacyClassesSubgroups(l)[3],1);;
gap> u3:=ClassElementLattice(ConjugacyClassesSubgroups(l)[3],6);;
gap> u4:=ClassElementLattice(ConjugacyClassesSubgroups(l)[2],3);;
gap> IsSubgroup(u1,u2);IsSubgroup(u1,u3);IsSubgroup(u1,u4);
true
true
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MinimalSupergroupsLattice" Arg='lat'/>

<Description>
For a lattice <A>lat</A> of subgroups this attribute contains the minimal
supergroup relations among the subgroups of the lattice.
It is a list corresponding to the <Ref Func="ConjugacyClassesSubgroups"/>
value of the lattice, each entry giving a list of the minimal supergroups
of the representative of this class.
Every minimal supergroup is indicated by a list of the form
<M>[ c, n ]</M>, which means that the <M>n</M>-th subgroup in class
number <M>c</M> is a minimal supergroup of the representative.
<P/>
The number <M>n</M> corresponds to access via
<Ref Func="ClassElementLattice"/>
and <E>not</E> necessarily the <Ref Func="AsList"/> arrangement!
See also <Ref Func="MaximalSubgroupsLattice"/>.
<Example><![CDATA[
gap> MinimalSupergroupsLattice(l);
[ [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], 
      [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], 
      [ 4, 4 ] ], [ [ 5, 1 ], [ 6, 2 ], [ 7, 2 ] ], 
  [ [ 6, 1 ], [ 8, 1 ], [ 8, 3 ] ], [ [ 8, 1 ], [ 10, 1 ] ], 
  [ [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 10, 1 ] ], [ [ 9, 1 ] ], 
  [ [ 9, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], [  ] ]
gap> last[3];
[ [ 6, 1 ], [ 8, 1 ], [ 8, 3 ] ]
gap> u5:=ClassElementLattice(ConjugacyClassesSubgroups(l)[8],1);
Group([ (3,4), (2,4,3) ])
gap> u6:=ClassElementLattice(ConjugacyClassesSubgroups(l)[8],3);
Group([ (1,3), (1,3,4) ])
gap> IsSubgroup(u5,u2);
true
gap> IsSubgroup(u6,u2);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RepresentativesPerfectSubgroups" Arg='G'/>
<Attr Name="RepresentativesSimpleSubgroups" Arg='G'/>

<Description>
returns a list of conjugacy representatives of perfect (respectively
simple) subgroups of <A>G</A>.
This uses the library of perfect groups
(see <Ref Func="PerfectGroup" Label="for group order (and index)"/>),
thus it will issue an error if the library is insufficient to determine
all perfect subgroups.
<Example><![CDATA[
gap> m11:=TransitiveGroup(11,6);
M(11)
gap> r:=RepresentativesPerfectSubgroups(m11);;
gap> List(r,Size);
[ 60, 60, 360, 660, 7920, 1 ]
gap> List(r,StructureDescription);
[ "A5", "A5", "A6", "PSL(2,11)", "M11", "1" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ConjugacyClassesPerfectSubgroups" Arg='G'/>

<Description>
returns a list of the conjugacy classes of perfect subgroups of <A>G</A>.
(see <Ref Func="RepresentativesPerfectSubgroups"/>.)
<Example><![CDATA[
gap> r := ConjugacyClassesPerfectSubgroups(m11);;
gap> List(r, x -> StructureDescription(Representative(x)));
[ "A5", "A5", "A6", "PSL(2,11)", "M11", "1" ]
gap> SortedList( List(r,Size) );
[ 1, 1, 11, 12, 66, 132 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Zuppos" Arg='G'/>

<Description>
The <E>Zuppos</E> of a group are the cyclic subgroups of prime power order.
(The name <Q>Zuppo</Q> derives from the German abbreviation for <Q>zyklische
Untergruppen von Primzahlpotenzordnung</Q>.) This attribute
gives generators of all such subgroups of a group <A>G</A>. That is all elements
of <A>G</A> of prime power order up to the equivalence that they generate the
same cyclic subgroup.
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoLattice"/>

<Description>
is the information class used by the cyclic extension methods for
subgroup lattice calculations.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Specific Methods for Subgroup Lattice Computations">
<Heading>Specific Methods for Subgroup Lattice Computations</Heading>

<ManSection>
<Func Name="LatticeByCyclicExtension" Arg='G[, func[, noperf]]'/>

<Description>
computes the lattice of <A>G</A> using the cyclic extension algorithm. If the
function <A>func</A> is given, the algorithm will discard all subgroups not
fulfilling <A>func</A> (and will also not extend them), returning a partial
lattice. This can be useful to compute only subgroups with certain
properties. Note however that this will <E>not</E> necessarily yield all
subgroups that fulfill <A>func</A>, but the subgroups whose subgroups are used
for the construction must also fulfill <A>func</A> as well.
(In fact the filter <A>func</A> will simply discard subgroups in the cyclic
extension algorithm. Therefore the trivial subgroup will always be
included.) Also note, that for such a partial lattice
maximality/minimality inclusion relations cannot be computed.
(If <A>func</A> is a list of length 2, its first entry is such a
discarding function, the second a function for discarding zuppos.)
<P/>
The cyclic extension algorithm requires the perfect subgroups of <A>G</A>.
However &GAP; cannot analyze the function <A>func</A> for its implication
but can only apply it. If it is known that <A>func</A> implies solvability,
the computation of the perfect subgroups can be avoided by giving a
third parameter <A>noperf</A> set to <K>true</K>. 
<P/>
<Example><![CDATA[
gap> g:=WreathProduct(Group((1,2,3),(1,2)),Group((1,2,3,4)));;
gap> l:=LatticeByCyclicExtension(g,function(G)
> return Size(G) in [1,2,3,6];end);
<subgroup lattice of <permutation group of size 5184 with 
9 generators>, 47 classes, 
2628 subgroups, restricted under further condition l!.func>
]]></Example>
<P/>
The total number of classes in this example is much bigger, as the
following example shows:
<Example><![CDATA[
gap> LatticeSubgroups(g);
<subgroup lattice of <permutation group of size 5184 with 
9 generators>, 566 classes, 27134 subgroups>
]]></Example> ##  </Description>
</ManSection>

<ManSection>
<Func Name="InvariantSubgroupsElementaryAbelianGroup"
 Arg='G, homs[, dims]'/>

<Description>
Let <A>G</A> be an elementary abelian group
and <A>homs</A> be a set of automorphisms of <A>G</A>.
Then this function computes all subspaces of
<A>G</A> which are invariant under all automorphisms in <A>homs</A>.
When considering <A>G</A> as a module for the algebra generated by
<A>homs</A>, these are all submodules.
If <A>homs</A> is empty, it computes all subgroups. 
If the optional parameter <A>dims</A> is given, only submodules of this
dimension are computed.
<Example><![CDATA[
gap> g:=Group((1,2,3),(4,5,6),(7,8,9));
Group([ (1,2,3), (4,5,6), (7,8,9) ])
gap> hom:=GroupHomomorphismByImages(g,g,[(1,2,3),(4,5,6),(7,8,9)],
> [(7,8,9),(1,2,3),(4,5,6)]);
[ (1,2,3), (4,5,6), (7,8,9) ] -> [ (7,8,9), (1,2,3), (4,5,6) ]
gap> u:=InvariantSubgroupsElementaryAbelianGroup(g,[hom]);
[ Group(()), Group([ (1,2,3)(4,5,6)(7,8,9) ]), 
  Group([ (1,3,2)(7,8,9), (1,3,2)(4,5,6) ]), 
  Group([ (7,8,9), (4,5,6), (1,2,3) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubgroupsSolvableGroup" Arg='G[, opt]'/>

<Description>
This function (implementing the algorithm published in
<Cite Key="Hulpke99"/>) computes subgroups of a solvable group <A>G</A>,
using the homomorphism principle.
It returns a list of representatives up to <A>G</A>-conjugacy.
<P/>
The optional argument <A>opt</A> is a record, which may
be used to put restrictions on the subgroups computed. The following record
components of <A>opt</A> are recognized and have the following effects:
<List>
<Mark><C>actions</C></Mark>
<Item>
must be a list of automorphisms of <A>G</A>. If given, only groups
which are invariant under all these automorphisms are computed. The
algorithm must know the normalizer in <A>G</A> of the group generated by
<C>actions</C> (defined formally by embedding in the semidirect product of
<A>G</A> with <A>actions</A>).
This can be given in the component <C>funcnorm</C> and
will be computed if this component is not given.
</Item>
<Mark><C>normal</C></Mark>
<Item>
if set to <K>true</K> only normal subgroups are guaranteed to be
returned (though some of the returned subgroups might still be not
normal).
</Item>
<Mark><C>consider</C></Mark>
<Item>
a function to restrict the groups computed. This must be a
function of five parameters, <M>C</M>, <M>A</M>, <M>N</M>, <M>B</M>,
<M>M</M>, that are interpreted as follows:
The arguments are subgroups of a factor <M>F</M> of <A>G</A> in the
relation <M>F \geq C > A > N > B > M</M>.
<M>N</M> and <M>M</M> are normal subgroups.
<M>C</M> is the full preimage of the normalizer of <M>A/N</M>
in <M>F/N</M>.
When computing modulo <M>M</M> and looking for subgroups <M>U</M> such
that <M>U \cap N = B</M> and <M>\langle U, N \rangle = A</M>,
this function is called.
If it returns <K>false</K> then
all potential groups <M>U</M> (and therefore all groups later arising
from them) are disregarded. This can be used for example to compute only
subgroups of certain sizes. 
<P/>
(<E>This is just a restriction to speed up computations. The function may
still return (invariant) subgroups which don't fulfill this condition!</E>)
This parameter is used to permit calculations of some subgroups if the
set of all subgroups would be too large to handle.
<P/>
The actual groups <M>C</M>, <M>A</M>, <M>N</M> and <M>B</M> which are
passed to this function are not necessarily subgroups of <A>G</A>
but might be subgroups of a proper factor group <M>F = <A>G</A>/H</M>.
Therefore the <C>consider</C> function may
not relate the parameter groups to <A>G</A>.
</Item>
<Mark><C>retnorm</C></Mark>
<Item>
if set to <K>true</K> the function not only returns a list <C>subs</C>
of subgroups but also a corresponding list <C>norms</C> of normalizers
in the form <C>[ subs, norms ]</C>.
</Item>
<Mark><C>series</C></Mark>
<Item>
is an elementary abelian series of <A>G</A> which will be used for
the computation.
</Item>
<Mark><C>groups</C></Mark>
<Item>
is a list of groups to seed the calculation. Only subgroups of
these groups are constructed.
</Item>
</List>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8));
Group([ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ])
gap> hom:=GroupHomomorphismByImages(g,g,
> [(1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8)],
> [(4,5,6),(4,5),(7,8,9),(7,8),(1,2,3),(1,2)]);
[ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ] -> 
[ (4,5,6), (4,5), (7,8,9), (7,8), (1,2,3), (1,2) ]
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom]));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 2, 6, 18, 108, 4, 216, 8 ]
gap> Length(ConjugacyClassesSubgroups(g)); # to compare
162
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SizeConsiderFunction" Arg='size'/>

<Description>
This function returns a function <C>consider</C> of four arguments
that can be used in <Ref Func="SubgroupsSolvableGroup"/> for
the option <C>consider</C> to compute subgroups whose sizes are divisible
by <A>size</A>.
<Example><![CDATA[
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=SizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 18, 108, 216 ]
]]></Example>
<P/>
This example shows that in general the <C>consider</C> function does not
provide a perfect filter.
It is guaranteed that all subgroups fulfilling the
condition are returned, but not all subgroups returned necessarily fulfill
the condition.
</Description>
</ManSection>

<ManSection>
<Func Name="ExactSizeConsiderFunction" Arg='size'/>

<Description>
This function returns a function <C>consider</C> of four arguments
that can be used in <Ref Func="SubgroupsSolvableGroup"/> for
the option <C>consider</C> to compute subgroups whose sizes are exactly
<A>size</A>.
<Example><![CDATA[
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=ExactSizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 108, 216 ]
]]></Example>
<P/>
Again, the <C>consider</C> function does not provide
a perfect filter. It is guaranteed that all subgroups fulfilling the
condition are returned, but not all subgroups returned necessarily fulfill
the condition.
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoPcSubgroup"/>

<Description>
Information function for the subgroup lattice functions using pcgs.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Special Generating Sets">
<Heading>Special Generating Sets</Heading>

<ManSection>
<Attr Name="GeneratorsSmallest" Arg='G'/>

<Description>
returns a <Q>smallest</Q> generating set for the group <A>G</A>.
This is the lexicographically (using &GAP;s order of group elements)
smallest list <M>l</M> of elements of <A>G</A> such that
<M>G = \langle l \rangle</M> and
<M>l_i \not \in \langle l_1, \ldots, l_{{i-1}} \rangle</M>
(in particular <M>l_1</M> is not the identity element of the group).
The comparison of two groups via
lexicographic comparison of their sorted element lists yields the same
relation as lexicographic comparison of their smallest generating sets.
<Example><![CDATA[
gap> g:=SymmetricGroup(4);;
gap> GeneratorsSmallest(g);
[ (3,4), (2,3), (1,2) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LargestElementGroup" Arg='G'/>

<Description>
returns the largest element of <A>G</A> with respect to the ordering <C>&lt;</C> of
the elements family.
</Description>
</ManSection>

<ManSection>
<Attr Name="MinimalGeneratingSet" Arg='G'/>

<Description>
returns a generating set of <A>G</A> of minimal possible length.
<P/>
Note that &ndash;apart from special cases&ndash; currently there are only
efficient methods known to compute minimal generating sets of finite
solvable groups and of finitely generated nilpotent groups.
Hence so far these are the only cases for which methods are available.
The former case is covered by a method implemented in the &GAP; library,
while the second case requires the package <Package>Polycyclic</Package>.
<P/>
If you do not really need a minimal generating set, but are satisfied
with getting a reasonably small set of generators, you better use
<Ref Func="SmallGeneratingSet"/>.
<P/>
Information about the minimal generating sets of the finite simple
groups of order less than <M>10^6</M> can be found in <Cite Key="MY79"/>.
See also the package <Package>AtlasRep</Package>.
<Example><![CDATA[
gap> MinimalGeneratingSet(g);
[ (2,4,3), (1,4,2,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SmallGeneratingSet" Arg='G'/>

<Description>
returns a generating set of <A>G</A> which has few elements. As neither
irredundancy, nor minimal length is proven it runs much faster than
<Ref Func="MinimalGeneratingSet"/>.
It can be used whenever a short generating set is desired which not
necessarily needs to be optimal.
<Example><![CDATA[
gap> SmallGeneratingSet(g);
[ (1,2,3,4), (1,2) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IndependentGeneratorsOfAbelianGroup" Arg='A'/>

<Description>
returns a list of generators <M>a_1, a_2, \ldots</M> of prime power order
or infinite order of the abelian group <A>A</A> such that <A>A</A> is the
direct product of the cyclic groups generated by the <M>a_i</M>.
The list of orders of the returned generators must match the result of
<Ref Func="AbelianInvariants"/> (taking into account that zero
and <Ref Var="infinity"/> are identified).
<Example><![CDATA[
gap> g:=AbelianGroup(IsPermGroup,[15,14,22,78]);;
gap> List(IndependentGeneratorsOfAbelianGroup(g),Order);
[ 2, 2, 2, 3, 3, 5, 7, 11, 13 ]
gap> AbelianInvariants(g);
[ 2, 2, 2, 3, 3, 5, 7, 11, 13 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IndependentGeneratorExponents" Arg='G, g'/>

<Description>
For an abelian group <A>G</A>,
with <Ref Func="IndependentGeneratorsOfAbelianGroup"/> value the
list <M>[ a_1, \ldots, a_n ]</M>,
this operation returns the exponent vector
<M>[ e_1, \ldots, e_n ]</M> to represent
<M><A>g</A> = \prod_i a_i^{{e_i}}</M>.
<Example><![CDATA[
gap> g := AbelianGroup([16,9,625]);;
gap> gens := IndependentGeneratorsOfAbelianGroup(g);;
gap> List(gens, Order);
[ 9, 16, 625 ]
gap> AbelianInvariants(g);
[ 9, 16, 625 ]
gap> r:=gens[1]^4*gens[2]^12*gens[3]^128;;
gap> IndependentGeneratorExponents(g,r);
[ 4, 12, 128 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="1-Cohomology">
<Heading>1-Cohomology</Heading>

<Index>one cohomology</Index>
<Index>cohomology</Index>
<Index>cocycles</Index>

Let <M>G</M> be a finite group and  <M>M</M> an elementary abelian normal <M>p</M>-subgroup
of <M>G</M>.  Then the group  of 1-cocycles <M>Z^1(  G/M, M  )</M> is
defined as
<Display Mode="M">
Z^1(G/M, M) = \{ \gamma: G/M \rightarrow M \mid \forall g_1, g_2 \in G :
                                 \gamma(g_1 M \cdot g_2 M ) 
                                   = \gamma(g_1 M)^{{g_2}} \cdot \gamma(g_2 M) \}
</Display>
and is a <M>GF(p)</M>-vector space.
<P/>
The group of 1-coboundaries <M>B^1( G/M, M )</M> is defined as
<Display Mode="M">
B^1(G/M, M) = \{ \gamma : G/M \rightarrow M \mid \exists m \in M
                                 \forall g \in G : 
                                  \gamma(gM) = (m^{{-1}})^g \cdot m \}
</Display>
It also is a <M>GF(p)</M>-vector space.
<P/>
Let <M>\alpha</M> be the isomorphism of <M>M</M> into a row vector space
<M>{\cal W}</M> and <M>(g_1, \ldots, g_l)</M> representatives for a
generating set of <M>G/M</M>.
Then there exists a monomorphism <M>\beta</M> of <M>Z^1( G/M, M )</M> in the
<M>l</M>-fold direct sum of <M>{\cal W}</M>,
such that
<M>\beta( \gamma ) = ( \alpha( \gamma(g_1 M) ),\ldots, \alpha( \gamma(g_l M) ) )</M>
for every <M>\gamma \in Z^1( G/M, M )</M>.

<ManSection>
<Heading>OneCocycles</Heading>
<Oper Name="OneCocycles" Arg='G, M' Label="for two groups"/>
<Oper Name="OneCocycles" Arg='G, mpcgs' Label="for a group and a pcgs"/>
<Oper Name="OneCocycles" Arg='gens, M'
 Label="for generators and a group"/>
<Oper Name="OneCocycles" Arg='gens, mpcgs'
 Label="for generators and a pcgs"/>

<Description>
Computes the group of 1-cocycles <M>Z^1(<A>G</A>/<A>M</A>,<A>M</A>)</M>.
The normal subgroup <A>M</A> may be given by a (Modulo)Pcgs <A>mpcgs</A>.
In this case the whole calculation is performed modulo the normal
subgroup defined by <C>DenominatorOfModuloPcgs(<A>mpcgs</A>)</C>
(see&nbsp;<Ref Sect="Polycyclic Generating Systems"/>).
Similarly the group <A>G</A> may instead be specified by a set of
elements <A>gens</A> that are representatives for a generating system for
the factor group <A>G</A>/<A>M</A>.
If this is done the 1-cocycles are computed
with respect to these generators (otherwise the routines try to select
suitable generators themselves).
The current version of the code assumes that <A>G</A> is a permutation
group or a pc group.
</Description>
</ManSection>

<ManSection>
<Oper Name="OneCoboundaries" Arg='G, M'/>

<Description>
computes the group of 1-coboundaries.
Syntax of input and output otherwise is the same as with
<Ref Func="OneCocycles" Label="for two groups"/> except that entries that
refer to cocycles are not computed.
<P/>
The operations <Ref Func="OneCocycles" Label="for two groups"/> and
<Ref Func="OneCoboundaries"/> return a record with
(at least) the components:
<P/>
<List>
<Mark><C>generators</C></Mark>
<Item>
Is a list of representatives for a generating set of <A>G</A>/<A>M</A>.
Cocycles are represented with respect to these generators.
</Item>
<Mark><C>oneCocycles</C></Mark>
<Item>
A space of row vectors over GF(<M>p</M>), representing <M>Z^1</M>.
The vectors are represented in dimension <M>a \cdot b</M> where <M>a</M>
is the length of <C>generators</C> and <M>p^b</M> the size of <A>M</A>.
</Item>
<Mark><C>oneCoboundaries</C></Mark>
<Item>
A space of row vectors that represents <M>B^1</M>.
</Item>
<Mark><C>cocycleToList</C></Mark>
<Item>
is a function to convert a cocycle (a row vector in <C>oneCocycles</C>) to
a corresponding list of elements of <A>M</A>.
</Item>
<Mark><C>listToCocycle</C></Mark>
<Item>
is a function to convert a list of elements of <A>M</A> to a cocycle.
</Item>
<Mark><C>isSplitExtension</C></Mark>
<Item>
indicates whether <A>G</A> splits over <A>M</A>.
The following components are only bound if the extension splits.
Note that if <A>M</A> is given by a modulo pcgs all subgroups are given
as subgroups of <A>G</A> by generators corresponding to <C>generators</C>
and thus may not contain the denominator of the modulo pcgs.
In this case taking the closure with this denominator will give the full
preimage of the complement in the factor group.
</Item>
<Mark><C>complement</C></Mark>
<Item>
One complement to <A>M</A> in <A>G</A>.
</Item>
<Mark><C>cocycleToComplement( cyc )</C></Mark>
<Item>
is a function that takes a cocycle from <C>oneCocycles</C> and returns
the corresponding complement to <A>M</A> in <A>G</A>
(with respect to the fixed complement <C>complement</C>).
</Item>
<Mark><C>complementToCocycle(<A>U</A>)</C></Mark>
<Item>
is a function that takes a complement and returns the corresponding
cocycle.
</Item>
</List>
<P/>
If the factor <A>G</A>/<A>M</A> is given by a (modulo) pcgs <A>gens</A>
then special methods are used that compute a presentation for the factor
implicitly from the pcgs.
<P/>
Note that the groups of 1-cocycles and 1-coboundaries are not groups in
the sense of <Ref Func="Group" Label="for several generators"/> for &GAP;
but vector spaces.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> n:=Group((1,2)(3,4),(1,3)(2,4));;
gap> oc:=OneCocycles(g,n);
rec( cocycleToComplement := function( c ) ... end, 
  cocycleToList := function( c ) ... end, 
  complement := Group([ (3,4), (2,4,3) ]), 
  complementGens := [ (3,4), (2,4,3) ], 
  complementToCocycle := function( K ) ... end, 
  factorGens := [ (3,4), (2,4,3) ], generators := [ (3,4), (2,4,3) ], 
  isSplitExtension := true, listToCocycle := function( L ) ... end, 
  oneCoboundaries := <vector space over GF(2), with 2 generators>, 
  oneCocycles := <vector space over GF(2), with 2 generators> )
gap> oc.cocycleToList([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
[ (1,2)(3,4), (1,2)(3,4) ]
gap> oc.listToCocycle([(),(1,3)(2,4)]) = Z(2) * [ 0, 0, 1, 0];
true
gap> oc.cocycleToComplement([ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]);
Group([ (3,4), (1,3,4) ])
gap> oc.complementToCocycle(Group((1,2,4),(1,4))) = Z(2) * [ 0, 1, 1, 1 ];
true
]]></Example>
<P/>
The factor group
<M>H^1(<A>G</A>/<A>M</A>, <A>M</A>) =
Z^1(<A>G</A>/<A>M</A>, <A>M</A>) / B^1(<A>G</A>/<A>M</A>, <A>M</A>)</M>
is called the first cohomology group.
Currently there is no function which explicitly computes this group.
The easiest way to represent it is as a vector space complement to
<M>B^1</M> in <M>Z^1</M>.
<P/>
If the only purpose of the calculation of <M>H^1</M> is the determination
of complements it might be desirable to stop calculations
once it is known that the extension cannot split.
This can be achieved via the more technical function
<Ref Func="OCOneCocycles"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="OCOneCocycles" Arg='ocr, onlySplit'/>

<Description>
is the more technical function to compute 1-cocycles. It takes an record
<A>ocr</A> as first argument which must contain at least the components
<C>group</C> for the group and <C>modulePcgs</C> for a (modulo) pcgs of
the module. This record
will also be returned with components as described under
<Ref Func="OneCocycles" Label="for two groups"/>
(with the exception of <C>isSplitExtension</C> which is indicated by the
existence of a <C>complement</C>)
but components such as <C>oneCoboundaries</C> will only be
computed if not already present.
<P/>
If <A>onlySplit</A> is <K>true</K>,
<Ref Func="OCOneCocycles"/> returns <K>false</K> as soon as
possible if the extension does not split.
</Description>
</ManSection>

<ManSection>
<Oper Name="ComplementClassesRepresentativesEA" Arg='G, N'/>

<Description>
computes complement classes to an elementary abelian normal subgroup
<A>N</A> via 1-Cohomology. Normally, a user program should call
<Ref Func="ComplementClassesRepresentatives"/> instead, which also works
for a solvable (not necessarily elementary abelian) <A>N</A>.
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoCoh"/>

<Description>
The info class for the cohomology calculations is
<Ref InfoClass="InfoCoh"/>.
</Description>
</ManSection>


<!-- %%  The computation of the 1-Cohomology follows <Cite Key="CNW90"/> and was implemented -->
<!-- %%  by Frank Celler and Alexander Hulpke. -->
<!-- % </Section>
<Section Label="AutomorphisGroups and Testing Isomorphism">
<Heading>AutomorphisGroups and Testing Isomorphism</Heading> -->
<!-- %T Is dealt with in section on group homomorphisms! -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Schur Covers and Multipliers">
<Heading>Schur Covers and Multipliers</Heading>

Additional attributes and properties of a group can be derived
from computing its Schur cover.
For example, if <M>G</M> is a finitely presented group, the
derived subgroup of a Schur cover of <M>G</M> is invariant and isomorphic to
the <Ref Func="NonabelianExteriorSquare"/> value of <M>G</M>,
see <Cite Key="BJR87"/>. 

<Index Subkey="see EpimorphismSchurCover">Darstellungsgruppe</Index>
<ManSection>
<Oper Name="EpimorphismSchurCover" Arg='G[, pl]'/>

<Description>
returns an epimorphism <M>epi</M> from a group <M>D</M> onto <A>G</A>.
The group <M>D</M> is one (of possibly several) Schur covers of <A>G</A>.
The group <M>D</M> can be obtained as the <Ref Func="Source"/> value of
<A>epi</A>.
The kernel of <M>epi</M> is the Schur multiplier of <A>G</A>.
If <A>pl</A> is given as a list of primes,
only the multiplier part for these primes is realized.
At the moment, <M>D</M> is represented as a finitely presented group.
</Description>
</ManSection>

<ManSection>
<Oper Name="SchurCover" Arg='G'/>

<Description>
returns one (of possibly several) Schur covers of the group <A>G</A>.
<P/>
At the moment this cover is represented as a finitely presented group
and <Ref Func="IsomorphismPermGroup"/> would be needed to convert it to a
permutation group.
<P/>
If also the relation to <A>G</A> is needed,
<Ref Func="EpimorphismSchurCover"/> should be used.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> epi:=EpimorphismSchurCover(g);
[ f1, f2, f3 ] -> [ (3,4), (2,4,3), (1,3)(2,4) ]
gap> Size(Source(epi));
48
]]></Example>
<P/>
If the group becomes bigger, Schur Cover calculations might become
unfeasible.
<P/>
There is another operation, <Ref Func="AbelianInvariantsMultiplier"/>,
which only returns the structure of the Schur Multiplier,
and which should work for larger groups as well.
</Description>
</ManSection>

<ManSection>
<Attr Name="AbelianInvariantsMultiplier" Arg='G'/>

<Description>
<Index>Multiplier</Index>
<Index>Schur multiplier</Index>
returns a list of the abelian invariants of the Schur multiplier of
<A>G</A>.
<P/>
At the moment, this operation will not give any information about how to
extend the multiplier to a Schur Cover.
<Example><![CDATA[
gap> AbelianInvariantsMultiplier(g);
[ 2 ]
gap> AbelianInvariantsMultiplier(AlternatingGroup(6));
[ 2, 3 ]
gap> AbelianInvariantsMultiplier(SL(2,3));
[  ]
gap> AbelianInvariantsMultiplier(SL(3,2));
[ 2 ]
gap> AbelianInvariantsMultiplier(PSU(4,2));
[ 2 ]
]]></Example>
(Note that the last command from the example will take some time.)
<P/>
The &GAP;&nbsp;4.4.12 manual contained examples for larger groups e.g.
<M>M_{22}</M>. However, some issues that may very rarely (and not 
easily reproducibly) lead to wrong results were discovered in the code
capable of handling larger groups, and in &GAP;&nbsp;4.5 it was replaced 
by a more reliable basic method. To deal with larger groups, one can use 
the function <Ref BookName="cohomolo" Func="SchurMultiplier"/> from the
<Package>cohomolo</Package> package. Also, additional methods for 
<Ref Attr="AbelianInvariantsMultiplier"/> are installed in the 
<Package>Polycyclic</Package> package for pcp-groups.
</Description>
</ManSection>

<ManSection>
<Attr Name="Epicentre" Arg='G'/>
<Attr Name="ExteriorCentre" Arg='G'/>

<Description>
There are various ways of describing the epicentre of a group <A>G</A>.
It is the smallest normal subgroup <M>N</M> of <A>G</A> such that
<M><A>G</A>/N</M> is a central quotient of a group.
It is also equal to the Exterior Center of <A>G</A>,
see <Cite Key="Ellis98"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="NonabelianExteriorSquare" Arg='G'/>

<Description>
Computes the nonabelian exterior square <M><A>G</A> \wedge <A>G</A></M>
of the group <A>G</A>, which for a finitely presented group is the
derived subgroup of any Schur cover of <A>G</A>
(see <Cite Key="BJR87"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="EpimorphismNonabelianExteriorSquare" Arg='G'/>

<Description>
Computes the mapping
<M><A>G</A> \wedge <A>G</A> \rightarrow <A>G</A></M>.
The kernel of this mapping is equal to the Schur multiplier of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsCentralFactor" Arg='G'/>

<Description>
This function determines if there exists a group <M>H</M> such that
<A>G</A> is isomorphic to the quotient <M>H/Z(H)</M>.
A group with this property is called in literature <E>capable</E>.
A group being capable is 
equivalent to the epicentre of <A>G</A> being trivial,
see <Cite Key="BFS79"/>.
</Description>
</ManSection>


<Subsection><Heading>Covering groups of symmetric groups</Heading>

The covering groups of symmetric groups were classified in <Cite
Key="Schur1911"/>; an inductive procedure to construct faithful,
irreducible representations of minimal degree over all fields was presented
in <Cite Key="Maas2010"/>. Methods for <Ref Func="EpimorphismSchurCover"/> are
provided for natural symmetric groups which use these representations. For
alternating groups, the restriction of these representations are provided,
but they may not be irreducible.  In the case of degree <M>6</M> and
<M>7</M>, they are not the full covering groups and so matrix
representations are just stored explicitly for the six-fold covers.

<Example><![CDATA[
gap> EpimorphismSchurCover(SymmetricGroup(15));
[ < immutable compressed matrix 64x64 over GF(9) >, 
  < immutable compressed matrix 64x64 over GF(9) > ] -> 
[ (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), (1,2) ]
gap> EpimorphismSchurCover(AlternatingGroup(15));
[ < immutable compressed matrix 64x64 over GF(9) >, 
  < immutable compressed matrix 64x64 over GF(9) > ] -> 
[ (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), (13,14,15) ]
gap> SchurCoverOfSymmetricGroup(12);
<matrix group of size 958003200 with 2 generators>
gap> DoubleCoverOfAlternatingGroup(12);
<matrix group of size 479001600 with 2 generators>
gap> BasicSpinRepresentationOfSymmetricGroup( 10, 3, -1 );
[ < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) >, 
  < immutable compressed matrix 16x16 over GF(9) > ]
]]></Example>

</Subsection>


<ManSection>

<Func Name="BasicSpinRepresentationOfSymmetricGroup" Arg="n, p, sign"/>

<Description> Constructs the image of the Coxeter generators in the basic
spin (projective) representation of the symmetric group of degree <A>n</A>
over a field of characteristic <M><A>p</A> \geq 0</M>. There are two such
representations and <A>sign</A> controls which is returned: +1 gives a
group where the preimage of an adjacent transposition <M>(i,i+1)</M> has
order 4, -1 gives a group where the preimage of an adjacent transposition
<M>(i,i+1)</M> has order 2.  If no <A>sign</A> is specified, +1 is used by
default.  If no <A>p</A> is specified, 3 is used by default.
(Note that the convention of which cover is labelled as +1 is
inconsistent in the literature.)</Description>

</ManSection>




<ManSection> <Oper Name="SchurCoverOfSymmetricGroup" Arg='n, p, sign'/>

<Description> Constructs a Schur cover of <C>SymmetricGroup(<A>n</A>)</C>
as a faithful, irreducible matrix group in characteristic <A>p</A>
(<M><A>p</A> \neq 2</M>).  For <M><A>n</A> \geq 4</M>, there are two such
covers, and <A>sign</A> determines which is returned: +1 gives a group
where the preimage of an adjacent transposition <M>(i,i+1)</M> has order 4,
-1 gives a group where the preimage of an adjacent transposition
<M>(i,i+1)</M> has order 2.  If no <A>sign</A> is specified, +1 is used by
default.  If no <A>p</A> is specified, 3 is used by default.
(Note that the convention of which cover is labelled as +1 is
inconsistent in the literature.)

For <M><A>n</A> \leq 3</M>, the symmetric group is its own Schur cover and
<A>sign</A> is ignored. For <M><A>p</A> = 2</M>, there is no faithful,
irreducible representation of the Schur cover unless <M><A>n</A> = 1</M> or
<M><A>n</A> = 3</M>, so <K>fail</K> is returned if <M><A>p</A> = 2</M>. For
<M><A>p</A> = 3</M>, <M><A>n</A> = 3</M>, the representation is
indecomposable, but reducible.

The field of the matrix group is generally <C>GF(<A>p</A>^2)</C> if
<M><A>p</A> &gt; 0</M>, and an abelian number field if <M><A>p</A> = 0</M>.

</Description> </ManSection>




<ManSection> <Oper Name="DoubleCoverOfAlternatingGroup" Arg='n, p'/>

<Description> 

Constructs a double cover of <C>AlternatingGroup(<A>n</A>)</C> as a
faithful, completely reducible matrix group in characteristic <A>p</A>
(<M>p \neq 2</M>) for <M>n \geq 4</M>.

For <M>n \leq 3</M>, the alternating group is its own Schur cover, and
<K>fail</K> is returned. For <M>p = 2</M>, there is no faithful, completely
reducible representation of the double cover, so <K>fail</K> is returned.

The field of the matrix group is generally <C>GF(p^2)</C> if <M>p>0</M>,
and an abelian number field if <M>p=0</M>.  If <A>p</A> is omitted, the
default is 3.

</Description> </ManSection>





</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tests for the Availability of Methods">
<Heading>Tests for the Availability of Methods</Heading>

The following filters and operations indicate capabilities of &GAP;.
They can be used in the method selection or algorithms to check whether
it is feasible to compute certain operations for a given group.
In general, they return <K>true</K> if good algorithms for the given arguments
are available in &GAP;.
An answer <K>false</K> indicates that no method for this group may exist,
or that the existing methods might run into problems.
<P/>
Typical examples when this might happen is with finitely presented
groups, for which many of the methods cannot be guaranteed to succeed in
all situations.
<P/>
The willingness of &GAP; to perform certain operations may change,
depending on which further information is known about the arguments.
Therefore the filters used are not implemented as properties but as
<Q>other filters</Q> (see&nbsp;<Ref Sect="Properties"/> and&nbsp;<Ref Sect="Other Filters"/>).

<ManSection>
<Func Name="CanEasilyTestMembership" Arg='G'/>

<Description>
This filter indicates whether &GAP; can test membership of elements in
the group <A>G</A>
(via the operation <Ref Oper="\in" Label="for a collection"/>)
in reasonable time.
It is used by the method selection to decide whether an algorithm
that relies on membership tests may be used.
</Description>
</ManSection>

<ManSection>
<Func Name="CanEasilyComputeWithIndependentGensAbelianGroup" Arg='G'/>

<Description>
This filter indicates whether &GAP; can in reasonable time compute
independent abelian generators of the group <A>G</A>
(via <Ref Func="IndependentGeneratorsOfAbelianGroup"/>) and
then can decompose arbitrary group elements with respect to these
generators using <Ref Func="IndependentGeneratorExponents"/>.

It is used by the method selection to decide whether an algorithm
that relies on these two operations may be used.
</Description>
</ManSection>

<ManSection>
<Func Name="CanComputeSize" Arg='dom'/>

<Description>
This filter indicates whether the size of the domain <A>dom</A>
(which might be <Ref Var="infinity"/>) can be computed.
</Description>
</ManSection>

<ManSection>
<Func Name="CanComputeSizeAnySubgroup" Arg='G'/>

<Description>
This filter indicates whether &GAP; can easily compute the size of any
subgroup of the group <A>G</A>.
(This is for example advantageous if one can test that a stabilizer index
equals the length of the orbit computed so far to stop early.)
</Description>
</ManSection>

<ManSection>
<Func Name="CanComputeIndex" Arg='G, H'/>

<Description>
This function indicates whether the index <M>[<A>G</A>:<A>H</A>]</M>
(which might be <Ref Var="infinity"/>) can be computed.
It assumes that <M><A>H</A> \leq <A>G</A></M>
(see <Ref Func="CanComputeIsSubset"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="CanComputeIsSubset" Arg='A, B'/>

<Description>
This filter indicates that &GAP; can test (via <Ref Func="IsSubset"/>)
whether <A>B</A> is a subset of <A>A</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="KnowsHowToDecompose" Arg='G[, gens]'/>

<Description>
Tests whether the group <A>G</A> can decompose elements in the generators
<A>gens</A>.
If <A>gens</A> is not given it tests, whether it can decompose in the
generators given in the <Ref Func="GeneratorsOfGroup"/> value of
<A>G</A>.
<P/>
This property can be used for example to check whether a
group homomorphism by images
(see <Ref Func="GroupHomomorphismByImages"/>) can be reasonably defined
from this group.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grphomom.msk                GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grphomom.msk,v 1.47 2006/01/10 23:26:49 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Group Homomorphisms">
<Heading>Group Homomorphisms</Heading>

A group homomorphism is a mapping from one group to another that respects
multiplication and inverses.
They are implemented as a special class of mappings,
so in particular all operations for mappings, such as
<Ref Func="Image" Label="set of images of the source of a general mapping"/>,
<Ref Func="PreImage" Label="set of preimages of the range of a general mapping"/>,
<Ref Func="PreImagesRepresentative"/>,
<Ref Func="KernelOfMultiplicativeGeneralMapping"/>,
<Ref Func="Source"/>, <Ref Func="Range" Label="of a general mapping"/>, 
<Ref Func="IsInjective"/> and <Ref Func="IsSurjective"/>
(see chapter&nbsp;<Ref Chap="Mappings"/>, in particular
section&nbsp;<Ref Sect="Mappings that Respect Multiplication"/>)
are applicable to them.
<P/>
Homomorphisms can be used to transfer calculations into isomorphic groups in
another representation, for which better algorithms are available.
Section&nbsp;<Ref Sect="Nice Monomorphisms"/> explains a technique
how to enforce this automatically.
<P/>
Homomorphisms are also used to represent group automorphisms, and section
<Ref Sect="Group Automorphisms"/> explains explains &GAP;'s facilities to work
with automorphism groups.
<P/>
Section <Ref Sect="Searching for Homomorphisms"/> explains
how to make &GAP; to search for all homomorphisms between two groups which
fulfill certain specifications.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Group Homomorphisms">
<Heading>Creating Group Homomorphisms</Heading>

The most important way of creating group homomorphisms is to give images for
a set of group generators and to extend it to the group generated by them
by the homomorphism property.
<P/>
<E>A second</E> way to create homomorphisms is to give functions
that compute image and preimage.
(A similar case are homomorphisms that are induced by conjugation.
Special constructors for such mappings are described in
section&nbsp;<Ref Sect="Group Automorphisms"/>).
<P/>
<E>The third</E> class are epimorphisms from a group onto its factor
group. Such homomorphisms can be constructed by
<Ref Func="NaturalHomomorphismByNormalSubgroup"/>.
<P/>
<E>The fourth</E> class is homomorphisms in a permutation group
that are induced by an action on a set.
Such homomorphisms are described in the context of group actions,
see chapter&nbsp;<Ref Chap="Group Actions"/> and in particular
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>.

<ManSection>
<Func Name="GroupHomomorphismByImages" Arg='G, H[[, gens], imgs]'/>

<Description>
<Ref Func="GroupHomomorphismByImages"/> returns the group homomorphism
with source <A>G</A> and range <A>H</A> that is defined by mapping the
list <A>gens</A> of generators of <A>G</A> to the list <A>imgs</A> of
images in <A>H</A>.
<P/>
If omitted, the arguments <A>gens</A> and <A>imgs</A> default to
the <Ref Func="GeneratorsOfGroup"/> value of <A>G</A> and <A>H</A>,
respectively. If <A>H</A> is not given the maopping is automatically
considered as surjective.
<P/>
If <A>gens</A> does not generate <A>G</A> or if the mapping of the
generators does not extend to a homomorphism
(i.e., if mapping the generators describes only a multi-valued mapping)
then <K>fail</K> is returned.
<P/>
This test can be quite expensive. If one is certain that the mapping of
the generators extends to a homomorphism,
one can avoid the checks by calling
<Ref Func="GroupHomomorphismByImagesNC"/>.
(There also is the possibility to
construct potentially multi-valued mappings with
<Ref Func="GroupGeneralMappingByImages"/> and to test with
<Ref Func="IsMapping"/> whether they are indeed homomorphisms.)
</Description>
</ManSection>

<ManSection>
<Oper Name="GroupHomomorphismByImagesNC" Arg='G, H[[, gens], imgs]'/>

<Description>
<Ref Func="GroupHomomorphismByImagesNC"/> creates a homomorphism as
<Ref Func="GroupHomomorphismByImages"/> does, however it does not test
whether <A>gens</A> generates <A>G</A> and that the mapping of
<A>gens</A> to <A>imgs</A> indeed defines a group homomorphism.
Because these tests can be expensive it can be substantially faster than
<Ref Func="GroupHomomorphismByImages"/>.
Results are unpredictable if the conditions do not hold.
<P/>
If omitted, the arguments <A>gens</A> and <A>imgs</A> default to
the <Ref Func="GeneratorsOfGroup"/> value of <A>G</A> and <A>H</A>,
respectively.
<P/>
(For creating a possibly multi-valued mapping from <A>G</A> to <A>H</A>
that respects multiplication and inverses,
<Ref Func="GroupGeneralMappingByImages"/> can be used.)
<!-- If we could guarantee that it does not matter whether we construct the-->
<!-- homomorphism directly or whether we construct first a general mapping-->
<!-- and ask it for  being a homomorphism,-->
<!-- then this operation would be obsolete,-->
<!-- and <C>GroupHomomorphismByImages</C> would be allowed to return the general-->
<!-- mapping itself after the checks.-->
<!-- (See also the declarations of <C>AlgebraHomomorphismByImagesNC</C>,-->
<!-- <C>AlgebraWithOneHomomorphismByImagesNC</C>,-->
<!-- <C>LeftModuleHomomorphismByImagesNC</C>.)-->
<P/>
<Example><![CDATA[
gap> gens:=[(1,2,3,4),(1,2)];
[ (1,2,3,4), (1,2) ]
gap> g:=Group(gens);
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);
[ (1,2,3,4), (1,2) ] -> [ (1,2), (1,3) ]
gap> Image(hom,(1,4));
(2,3)
gap> map:=GroupHomomorphismByImages(g,h,gens,[(1,2,3),(1,2)]);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GroupGeneralMappingByImages" Arg='G, H, gens, imgs'/>
<Oper Name="GroupGeneralMappingByImages" Arg='G, gens, imgs' Label="from group to itself"/>
<Oper Name="GroupGeneralMappingByImagesNC" Arg='G, H, gens, imgs'/>
<Oper Name="GroupGeneralMappingByImagesNC" Arg='G, gens, imgs' Label="from group to itself"/>

<Description>
returns a general mapping defined by extending the mapping from
<A>gens</A> to <A>imgs</A> homomorphically. If the range <A>H</A> is not
given the mapping will be made automatically surjective. The NC version
does not test whether <A>gens</A> are contained in <A>G</A> or <A>imgs</A>
are contained in <A>H</A>.
(<Ref Func="GroupHomomorphismByImages"/> creates
a group general mapping by images and
tests whether it is in <Ref Func="IsMapping"/>.)
<Example><![CDATA[
gap> map:=GroupGeneralMappingByImages(g,h,gens,[(1,2,3),(1,2)]);
[ (1,2,3,4), (1,2) ] -> [ (1,2,3), (1,2) ]
gap> IsMapping(map);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>GroupHomomorphismByFunction</Heading>
<Func Name="GroupHomomorphismByFunction" Arg='S, R, fun[, invfun]'
 Label="by function (and inverse function) between two domains"/>
<Func Name="GroupHomomorphismByFunction" Arg='S, R, fun, false, prefun'
 Label="by function and function that computes one preimage"/>

<Description>
<Ref Func="GroupHomomorphismByFunction" Label="by function (and inverse function) between two domains"/>
returns a group homomorphism
<C>hom</C> with source <A>S</A> and range <A>R</A>,
such that each element <C>s</C> of <A>S</A> is mapped to the element
<A>fun</A><C>( s )</C>, where <A>fun</A> is a &GAP; function.
<P/>
If the argument <A>invfun</A> is bound then <A>hom</A> is a bijection
between <A>S</A> and <A>R</A>,
and the preimage of each element <C>r</C> of <A>R</A> is given by
<A>invfun</A><C>( r )</C>,
where <A>invfun</A> is a &GAP; function.
<P/>
If five arguments are given and the fourth argument is <K>false</K> then
the &GAP; function <A>prefun</A> can be used to compute a single preimage
also if <C>hom</C> is not bijective.
<P/>
No test is performed on whether the functions actually give an
homomorphism between both groups because this would require testing the
full multiplication table.
<P/>
<Ref Func="GroupHomomorphismByFunction" Label="by function (and inverse function) between two domains"/>
creates a mapping which lies in <Ref Func="IsSPGeneralMapping"/>.
<P/>
<Example><![CDATA[
gap> hom:=GroupHomomorphismByFunction(g,h,
> function(x) if SignPerm(x)=-1 then return (1,2); else return ();fi;end);
MappingByFunction( Group([ (1,2,3,4), (1,2) ]), Group(
[ (1,2,3), (1,2) ]), function( x ) ... end )
gap> ImagesSource(hom);
Group([ (1,2), (1,2) ])
gap> Image(hom,(1,2,3,4));
(1,2)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AsGroupGeneralMappingByImages" Arg='map'/>

<Description>
If <A>map</A> is a mapping from one group to another this attribute
returns a group general mapping that which implements the same abstract
mapping. (Some operations can be performed more effective in this
representation, see
also&nbsp;<Ref Func="IsGroupGeneralMappingByAsGroupGeneralMappingByImages"/>.)
<Example><![CDATA[
gap> AsGroupGeneralMappingByImages(hom);
[ (1,2,3,4), (1,2) ] -> [ (1,2), (1,2) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Group Homomorphisms">
<Heading>Operations for Group Homomorphisms</Heading>
<Index Subkey="group homomorphism">kernel</Index>

Group homomorphisms are mappings, so all the operations and properties for
mappings described in chapter&nbsp;<Ref Chap="Mappings"/> are applicable to
them.
(However often much better methods,
than for general mappings are available.)
<P/>
Group homomorphisms will map groups to groups by just mapping the set of
generators.
<P/>
<Ref Func="KernelOfMultiplicativeGeneralMapping"/> can be used to compute
the kernel of a group homomorphism.
<P/>
<Example><![CDATA[
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);;
gap> Kernel(hom);
Group([ (1,4)(2,3), (1,2)(3,4) ])
]]></Example>
<P/>
Homomorphisms can map between groups in different representations and are
also used to get isomorphic groups in a different representation.
<P/>
<Example><![CDATA[
gap> m1:=[[0,-1],[1,0]];;m2:=[[0,-1],[1,1]];;
gap> sl2z:=Group(m1,m2);; # SL(2,Integers) as matrix group
gap> F:=FreeGroup(2);;
gap> psl2z:=F/[F.1^2,F.2^3]; #PSL(2,Z) as FP group
<fp group on the generators [ f1, f2 ]>
gap> phom:=GroupHomomorphismByImagesNC(sl2z,psl2z,[m1,m2],
> GeneratorsOfGroup(psl2z)); # the non NC-version would be expensive
[ [ [ 0, -1 ], [ 1, 0 ] ], [ [ 0, -1 ], [ 1, 1 ] ] ] -> [ f1, f2 ]
gap> Kernel(phom); # the diagonal matrices
Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, -1 ] ] ])
gap> p1:=(1,2)(3,4);;p2:=(2,4,5);;a5:=Group(p1,p2);;
gap> ahom:=GroupHomomorphismByImages(psl2z,a5,
> GeneratorsOfGroup(psl2z),[p1,p2]); # here homomorphism test is cheap.
[ f1, f2 ] -> [ (1,2)(3,4), (2,4,5) ]
gap> u:=PreImage(ahom,Group((1,2,3),(1,2)(4,5)));
Group(<fp, no generators known>)
gap> Index(psl2z,u);
10
gap> isofp:=IsomorphismFpGroup(u);; Image(isofp);
<fp group of size infinity on the generators [ F1, F2, F3, F4 ]>
gap> RelatorsOfFpGroup(Image(isofp));
[ F1^2, F4^2, F3^3 ]
gap> up:=PreImage(phom,u);;
gap> List(GeneratorsOfGroup(up),TraceMat);
[ -2, -2, 0, -4, 1, 0 ]
]]></Example>
<P/>
For an automorphism <A>aut</A>,
<Ref Func="Inverse"/>
<Index Subkey="group homomorphism">Inverse</Index>
returns the inverse automorphism <M><A>aut</A>^{{-1}}</M>.
However if <A>hom</A> is a bijective homomorphism between
different groups, or if <A>hom</A> is injective and considered to be
a bijection to its image,
the operation <Ref Func="InverseGeneralMapping"/> should be used instead.
(See&nbsp;<Ref Func="Inverse"/> for a further discussion of this problem.)
<P/>
<Example><![CDATA[
gap> iso:=IsomorphismPcGroup(g);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -> [ f1, f2, f3, f4 ]
gap> Inverse(iso);
#I  The mapping must be bijective and have source=range
#I  You might want to use `InverseGeneralMapping'
fail
gap> InverseGeneralMapping(iso);
[ f1, f2, f3, f4 ] -> Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Efficiency of Homomorphisms">
<Heading>Efficiency of Homomorphisms</Heading>

&GAP; permits to create homomorphisms between arbitrary groups.
This section considers the efficiency of the implementation and shows ways
how to choose suitable representations.
For permutation groups (see&nbsp;<Ref Chap="Permutation Groups"/>)
or Pc groups (see&nbsp;<Ref Chap="Pc Groups"/>)
this is normally nothing to worry about,
unless the groups get extremely large. For other groups however
certain calculations might be expensive and some precaution might be needed
to avoid unnecessarily expensive calculations.
<P/>
In short, it is always worth to tell a mapping that it is a homomorphism
(this can be done by calling <C>SetIsMapping</C>)
(or to create it directly with <Ref Func="GroupHomomorphismByImagesNC"/>).
<P/>
The basic operations required are to compute image and preimage of elements
and to test whether a mapping is a homomorphism. Their cost
will differ depending on the type of the mapping.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Mappings given on generators">
<Heading>Mappings given on generators</Heading>

See <Ref Func="GroupHomomorphismByImages"/> and
<Ref Func="GroupGeneralMappingByImages"/>.
<P/>
Computing images requires to express an element of the source as word in the
generators. If it cannot be done effectively (this is determined by
<Ref Func="KnowsHowToDecompose"/> which returns <K>true</K> for
example for arbitrary permutation groups, for Pc groups or for finitely
presented groups with the images of the free generators) the span of the
generators has to be computed elementwise which can be very expensive and
memory consuming.
<P/>
Computing preimages adheres to the same rules with swapped rôles of
generators and their images.
<P/>
The test whether a mapping is a homomorphism requires
the computation of a presentation for the source and evaluation of its
relators in the images of its generators. For larger groups this can be
expensive and <Ref Func="GroupHomomorphismByImagesNC"/> should be used
if the mapping is known to be a homomorphism.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Action homomorphisms">
<Heading>Action homomorphisms</Heading>

See
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>.
<P/>
The calculation of images is determined by the acting function used and
&ndash;for large domains&ndash; is often dominated by the search for the
position of an image in a list of the domain elements.
This can be improved by sorting this list if an efficient method for
<Ref Func="\&lt;"/> to compare elements of the domain is available.
<P/>
Once the images of a generating set are computed, computing preimages
(which is done via <Ref Func="AsGroupGeneralMappingByImages"/>)
and computing the kernel behaves the same as for a homomorphism
created with <Ref Func="GroupHomomorphismByImages"/> from a permutation
group.
<P/>
&GAP; will always assume that the acting function provided implements
a proper group action and thus that the mapping is indeed a homomorphism.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Mappings given by functions">
<Heading>Mappings given by functions</Heading>

See <Ref Func="GroupHomomorphismByFunction" Label="by function (and inverse function) between two domains"/>.
<!-- commented out a reference to a nonexisting function: -->
<!-- , <Ref Func="GroupGeneralMappingByFunctions"/>.-->
<P/>
Computing images is wholly determined by the function that performs the
image calculation. If no function to compute preimages is given, computing
preimages requires mapping every element of the source to find an element
that maps to the requested image. This is time and memory consuming.
<P/>
<!-- commented out a paragraph on a nonexisting function: -->
<!-- Testing whether a mapping constructed with
<Ref Func="GroupGeneralMappingByFunctions"/> is a homomorphism would
require mapping all products of elements and thus should be avoided. -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Other operations">
<Heading>Other operations</Heading>

To compute the kernel of a homomorphism (unless the mapping is known to be
injective) requires the capability to compute a
presentation of the image and to evaluate the relators of this presentation
in preimages of the presentations generators.
<P/>
The calculation of the
<Ref Func="Image" Label="set of images of the source of a general mapping"/>
(respectively <Ref Func="ImagesSource"/>) value requires to map
a generating set of the source,
testing surjectivity is a comparison for equality with the range.
<P/>
Testing injectivity is a test for triviality of the kernel.
<P/>
The comparison of mappings is based on a lexicographic comparison of a
sorted element list of the source.
For group homomorphisms, this can be simplified,
using <Ref Func="ImagesSmallestGenerators"/>

</Subsection>

<ManSection>
<Attr Name="ImagesSmallestGenerators" Arg='map'/>

<Description>
returns the list of images of <C>GeneratorsSmallest(Source(<A>map</A>))</C>.
This list can be used to compare group homomorphisms.  (The standard
comparison is to compare the image lists on the set of elements of the
source. If however x and y have the same images under a and b,
certainly all their products have. Therefore it is sufficient to test
this on the images of the smallest generators.)
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Homomorphism for very large groups">
<Heading>Homomorphism for very large groups</Heading>

Some homomorphisms (notably particular actions) transfer known information
about the source group (such as a stabilizer chain) to the image group if
this is substantially cheaper than to compute the information in the image
group anew. In most cases this is no problem and in fact speeds up further
calculations notably.
<P/>
For a huge source group, however this can be time consuming or take a large
amount of extra memory for storage. In this case it can be helpful to avoid
as much automatism as possible.
<P/>
The following list of tricks might be useful in such a case. (However you
will lose much automatic deduction. So please restrict the use of these to
cases where the standard approach does not work.)
<List>
<Item>
  Compute only images (or the <Ref Func="PreImagesRepresentative"/>) of
  group elements.
  Do not compute the images of (sub)groups or the full preimage of a subgroup.
</Item>
<Item>
  Create action homomorphisms as <Q>surjective</Q> (see
  <Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>),
  otherwise the range is set to be the full symmetric group.
  However do not compute <Ref Func="Range" Label="of a general mapping"/> or
  <Ref Func="Image" Label="set of images of the source of a general mapping"/>
  values,
  but only the images of a generator set.
</Item>
<Item>
  If you suspect an action homomorphism to do too much internally,
  replace the action function with a function that does the same;
  i.e. replace <Ref Func="OnPoints"/> by
  <C>function( p, g ) return p^g; end;</C>.
  The action will be the same, but as the action function is not
  <Ref Func="OnPoints"/>,
  the extra processing for special cases is not triggered.
</Item>
</List>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Nice Monomorphisms">
<Heading>Nice Monomorphisms</Heading>

&GAP; contains very efficient algorithms for some special representations
of groups (for example pc groups or permutation groups) while for other
representations only slow generic methods are available. In this case it
can be worthwhile to do all calculations rather in an isomorphic image of
the group, which is in a <Q>better</Q> representation. The way to achieve this
in &GAP; is via <E>nice monomorphisms</E>.
<P/>
For this mechanism to work, of course there must be effective methods to
evaluate the <Ref Func="NiceMonomorphism"/> value on elements and to take
preimages under it.
As by definition no good algorithms exist for the source group,
normally this can only be achieved by using the result of a call to
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>
or <Ref Func="GroupHomomorphismByFunction" Label="by function (and inverse function) between two domains"/>
(see also section&nbsp;<Ref Sect="Efficiency of Homomorphisms"/>).

<ManSection>
<Prop Name="IsHandledByNiceMonomorphism" Arg='obj'/>

<Description>
If this property is <K>true</K>, high-valued methods that translate all
calculations in <A>obj</A> in the image under the
<Ref Func="NiceMonomorphism"/> value of <A>obj</A>
become available for <A>obj</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="NiceMonomorphism" Arg='obj'/>

<Description>
is a homomorphism that is defined (at least) on the whole of <A>obj</A>
and whose restriction to <A>obj</A> is injective.
The concrete morphism (and also the image group) will depend on the
representation of <A>obj</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="NiceObject" Arg='obj'/>

<Description>
The <Ref Func="NiceObject"/> value of <A>obj</A> is the image of
<A>obj</A> under the mapping stored as the value of
<Ref Func="NiceMonomorphism"/> for <A>obj</A>.
<P/>
A typical example are finite matrix groups, which use a faithful action
on vectors to translate all calculations in a permutation group.
<P/>
<Example><![CDATA[
gap> gl:=GL(3,2);
SL(3,2)
gap> IsHandledByNiceMonomorphism(gl);
true
gap> NiceObject(gl);
Group([ (5,7)(6,8), (2,3,5)(4,7,6) ])
gap> Image(NiceMonomorphism(gl),Z(2)*[[1,0,0],[0,1,1],[1,0,1]]);
(2,6)(3,4,7,8)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsCanonicalNiceMonomorphism" Arg='nhom'/>

<Description>
A nice monomorphism (see <Ref Func="NiceMonomorphism"/> <A>nhom</A> is
canonical if the image set will only depend on the set of group elements
but not on the generating set and <Ref Func="\&lt;"/> comparison
of group elements translates through the nice monomorphism.
This implies that equal objects will always have equal
<Ref Func="NiceObject"/> values.
In some situations however this condition would be expensive to
achieve, therefore it is not guaranteed for every nice monomorphism.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Group Automorphisms">
<Heading>Group Automorphisms</Heading>

Group automorphisms are bijective homomorphism from a group onto itself.
An important subclass are automorphisms which are induced by conjugation of
the group itself or a supergroup.

<ManSection>
<Oper Name="ConjugatorIsomorphism" Arg='G, g'/>

<Description>
Let <A>G</A> be a group, and <A>g</A> an element in the same family as
the elements of <A>G</A>.
<Ref Func="ConjugatorIsomorphism"/> returns the isomorphism from <A>G</A>
to <C><A>G</A>^<A>g</A></C> defined by <M>h \mapsto h^{<A>g</A>}</M>
for all <M>h \in <A>G</A></M>.
<P/>
If <A>g</A> normalizes <A>G</A> then <Ref Func="ConjugatorIsomorphism"/>
does the same as <Ref Func="ConjugatorAutomorphismNC"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ConjugatorAutomorphism" Arg='G, g'/>
<Oper Name="ConjugatorAutomorphismNC" Arg='G, g'/>

<Description>
Let <A>G</A> be a group, and <A>g</A> an element in the same family as
the elements of <A>G</A> such that <A>g</A> normalizes <A>G</A>.
<Ref Func="ConjugatorAutomorphism"/> returns the automorphism of <A>G</A>
defined by <M>h \mapsto h^{<A>g</A>}</M> for all <M>h \in <A>G</A></M>.
<P/>
If conjugation by <A>g</A> does <E>not</E> leave <A>G</A> invariant,
<Ref Func="ConjugatorAutomorphism"/> returns <K>fail</K>;
in this case,
the isomorphism from <A>G</A> to <C><A>G</A>^<A>g</A></C> induced by
conjugation with <A>g</A> can be constructed with
<Ref Func="ConjugatorIsomorphism"/>.
<P/>
<Ref Oper="ConjugatorAutomorphismNC"/> does the same as
<Ref Func="ConjugatorAutomorphism"/>,
except that the check is omitted whether <A>g</A> normalizes <A>G</A>
and it is assumed that <A>g</A> is chosen to be in <A>G</A> if possible.
</Description>
</ManSection>

<ManSection>
<Func Name="InnerAutomorphism" Arg='G, g'/>
<Oper Name="InnerAutomorphismNC" Arg='G, g'/>

<Description>
Let <A>G</A> be a group, and <M><A>g</A> \in <A>G</A></M>.
<Ref Func="InnerAutomorphism"/> returns the automorphism of <A>G</A>
defined by <M>h \mapsto h^{<A>g</A>}</M> for all <M>h \in <A>G</A></M>.
<P/>
If <A>g</A> is <E>not</E> an element of <A>G</A>,
<Ref Func="InnerAutomorphism"/> returns <K>fail</K>;
in this case,
the isomorphism from <A>G</A> to <C><A>G</A>^<A>g</A></C> induced by
conjugation with <A>g</A> can be constructed
with <Ref Func="ConjugatorIsomorphism"/>
or with <Ref Func="ConjugatorAutomorphism"/>.
<P/>
<Ref Oper="InnerAutomorphismNC"/> does the same as
<Ref Func="InnerAutomorphism"/>,
except that the check is omitted whether <M><A>g</A> \in <A>G</A></M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsConjugatorIsomorphism" Arg='hom'/>
<Prop Name="IsConjugatorAutomorphism" Arg='hom'/>
<Prop Name="IsInnerAutomorphism" Arg='hom'/>

<Description>
Let <A>hom</A> be a group general mapping
(see&nbsp;<Ref Func="IsGroupGeneralMapping"/>) with source <M>G</M>, say.
<Ref Prop="IsConjugatorIsomorphism"/> returns <K>true</K> if <A>hom</A>
is induced by conjugation of <M>G</M> by an element <M>g</M> that lies in
<M>G</M> or in a group into which <M>G</M> is naturally embedded
in the sense described below, and <K>false</K> otherwise.
<P/>
Natural embeddings are dealt with in the case that <M>G</M> is
a permutation group (see Chapter&nbsp;<Ref Chap="Permutation Groups"/>),
a matrix group (see Chapter&nbsp;<Ref Chap="Matrix Groups"/>),
a finitely presented group
(see Chapter&nbsp;<Ref Chap="Finitely Presented Groups"/>), or
a group given w.r.t.&nbsp;a polycyclic presentation
(see Chapter&nbsp;<Ref Chap="Pc Groups"/>).
In all other cases, <Ref Prop="IsConjugatorIsomorphism"/> may return
<K>false</K> if <A>hom</A> is induced by conjugation
but is not an inner automorphism.
<P/>
If <Ref Prop="IsConjugatorIsomorphism"/> returns <K>true</K> for
<A>hom</A> then an element <M>g</M> that induces <A>hom</A> can be
accessed as value of the attribute
<Ref Func="ConjugatorOfConjugatorIsomorphism"/>.
<P/>
<Ref Prop="IsConjugatorAutomorphism"/> returns <K>true</K> if <A>hom</A>
is an automorphism (see&nbsp;<Ref Func="IsEndoGeneralMapping"/>)
that is regarded as a conjugator isomorphism
by <Ref Prop="IsConjugatorIsomorphism"/>, and <K>false</K> otherwise.
<P/>
<Ref Prop="IsInnerAutomorphism"/> returns <K>true</K> if <A>hom</A> is a
conjugator automorphism such that an element <M>g</M> inducing <A>hom</A>
can be chosen in <M>G</M>, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="ConjugatorOfConjugatorIsomorphism" Arg='hom'/>

<Description>
For a conjugator isomorphism <A>hom</A>
(see&nbsp;<Ref Func="ConjugatorIsomorphism"/>),
<Ref Func="ConjugatorOfConjugatorIsomorphism"/> returns an element
<M>g</M> such that mapping under <A>hom</A> is induced by conjugation
with <M>g</M>.
<P/>
To avoid problems with <Ref Func="IsInnerAutomorphism"/>,
it is guaranteed that the conjugator is taken from the source of
<A>hom</A> if possible.
<P/>
<Example><![CDATA[
gap> hgens:=[(1,2,3),(1,2,4)];;h:=Group(hgens);;
gap> hom:=GroupHomomorphismByImages(h,h,hgens,[(1,2,3),(2,3,4)]);;
gap> IsInnerAutomorphism(hom);
true
gap> ConjugatorOfConjugatorIsomorphism(hom);
(1,2,3)
gap> hom:=GroupHomomorphismByImages(h,h,hgens,[(1,3,2),(1,4,2)]);
[ (1,2,3), (1,2,4) ] -> [ (1,3,2), (1,4,2) ]
gap> IsInnerAutomorphism(hom);
false
gap> IsConjugatorAutomorphism(hom);
true
gap> ConjugatorOfConjugatorIsomorphism(hom);
(1,2)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Groups of Automorphisms">
<Heading>Groups of Automorphisms</Heading>

Group automorphism can be multiplied and inverted and thus it is possible
to form groups of automorphisms.

<ManSection>
<Attr Name="AutomorphismGroup" Arg='G'/>

<Description>
returns the full automorphism group of the group <A>G</A>.
The automorphisms act on <A>G</A> by the caret operator <C>^</C>.
The automorphism group often stores a <Ref Func="NiceMonomorphism"/>
value whose image is a permutation group,
obtained by the action on a subset of <A>G</A>.
<P/>
Note that current methods for the calculation of the automorphism group
of a group <M>G</M> require <M>G</M> to be a permutation group or
a pc group to be efficient. For groups in other representations the 
calculation is likely very slow.
<P/>
Also, the <Package>AutPGrp</Package> package installs enhanced methods 
for <Ref Oper="AutomorphismGroup"/> for finite <M>p</M>-groups, and 
the <Package>FGA</Package> package - for finitely generated subgroups 
of free groups. 
<P/> 
Methods may be installed for <Ref Oper="AutomorphismGroup"/> 
for other domains, such as e.g. for linear codes in the
<Package>GUAVA</Package> package, loops in the <Package>loops</Package>  
package and nilpotent Lie algebras in the <Package>Sophus</Package> 
package (see package manuals for their descriptions).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGroupOfAutomorphisms" Arg='G'/>

<Description>
indicates whether <A>G</A> consists of automorphisms of another group
<M>H</M>, say.
The group <M>H</M> can be obtained from <A>G</A> via the attribute
<Ref Func="AutomorphismDomain"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="AutomorphismDomain" Arg='G'/>

<Description>
If <A>G</A> consists of automorphisms of <M>H</M>,
this attribute returns <M>H</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAutomorphismGroup" Arg='G'/>

<Description>
indicates whether <A>G</A> is the full automorphism group of another
group <M>H</M>, this group is given as <Ref Func="AutomorphismDomain"/>
value of <A>G</A>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,3));
Group([ (1,2,3,4), (1,3) ])
gap> au:=AutomorphismGroup(g);
<group of size 8 with 3 generators>
gap> GeneratorsOfGroup(au);
[ Pcgs([ (2,4), (1,2,3,4), (1,3)(2,4) ]) -> 
    [ (1,2)(3,4), (1,2,3,4), (1,3)(2,4) ], 
  Pcgs([ (2,4), (1,2,3,4), (1,3)(2,4) ]) -> 
    [ (1,3), (1,2,3,4), (1,3)(2,4) ], 
  Pcgs([ (2,4), (1,2,3,4), (1,3)(2,4) ]) -> 
    [ (2,4), (1,4,3,2), (1,3)(2,4) ] ]
gap> NiceObject(au);
Group([ (1,2,3,4), (1,3)(2,4), (2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="InnerAutomorphismsAutomorphismGroup" Arg='autgroup'/>

<Description>
For an automorphism group <A>autgroup</A> of a group
this attribute stores the subgroup of inner automorphisms
(automorphisms induced by conjugation) of the original group.
<Example><![CDATA[
gap> InnerAutomorphismsAutomorphismGroup(au);
<group with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedAutomorphism" Arg='epi, aut'/>

<Description>
Let <A>aut</A> be an automorphism of a group <M>G</M> and <A>epi</A> be
a homomorphism from <M>G</M> to a group <M>H</M> such that the kernel of
<A>epi</A> is fixed under <A>aut</A>.
Let <M>U</M> be the image of <A>epi</A>.
This command returns the automorphism of <M>U</M> induced by <A>aut</A>
via <A>epi</A>, that is, the automorphism of <M>U</M> which maps
<M>g</M><C>^<A>epi</A></C> to
<C>(</C><M>g</M><C>^<A>aut</A>)^<A>epi</A></C>, for <M>g \in G</M>.
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);
Group([ (1,2)(3,4), (1,3)(2,4) ])
gap> epi:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (1,2,3,4), (1,2) ] -> [ f1*f2, f1 ]
gap> aut:=InnerAutomorphism(g,(1,2,3));
^(1,2,3)
gap> InducedAutomorphism(epi,aut);
^f2
]]></Example>
</Description>
</ManSection>


<!-- %%  The code for automorphism groups was designed and implemented by Bettina -->
<!-- %%  Eick and Alexander Hulpke. -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Calculating with Group Automorphisms">
<Heading>Calculating with Group Automorphisms</Heading>

Usually the best way to calculate in a group of automorphisms is to
translate all calculations to an isomorphic group in a representation, for
which better algorithms are available, say a permutation group. This
translation can be done automatically using <Ref Func="NiceMonomorphism"/>.
<P/>
Once a group knows to be a group of automorphisms (this can be achieved
by testing or setting the property <Ref Func="IsGroupOfAutomorphisms"/>),
&GAP; will try itself to find such a nice monomorphism once calculations in
the automorphism group are done.
<P/>
Note that nice homomorphisms inherit down to subgroups, but cannot
necessarily be extended from a subgroup to the whole group. Thus when
working with a group of automorphisms, it can be beneficial to 
enforce calculation of the nice monomorphism for the whole group
(for example by explicitly calling
<Ref Func="Random" Label="for a list or collection"/> and ignoring
the result &ndash;it will be stored internally) at the start of the
calculation.
Otherwise &GAP; might first calculate a nice monomorphism for the subgroup,
only to be forced to calculate a new nice monomorphism for the whole group
later on.
<P/>
If a good domain for a faithful permutation action is known already, a
homomorphism for the action on it can be created using
<Ref Func="NiceMonomorphismAutomGroup"/>.
It might be stored by <C>SetNiceMonomorphism</C>
(see <Ref Func="NiceMonomorphism"/>).
<P/>
Another nice way of representing automorphisms as permutations has been
described in <Cite Key="Sims97"/>.
It is not yet available in &GAP;, a description however can be found
in section
&nbsp;<Ref Sect="Stabilizer Chains for Automorphisms Acting on Enumerators"/>.

<ManSection>
<Func Name="AssignNiceMonomorphismAutomorphismGroup" Arg='autgrp, group'/>

<Description>
computes a nice monomorphism for <A>autgroup</A> acting on <A>group</A>
and stores it as <Ref Attr="NiceMonomorphism"/> value of <A>autgrp</A>.
<P/>
If the centre of <Ref Func="AutomorphismDomain"/> of <A>autgrp</A> is
trivial, the operation will first try to represent all automorphisms by
conjugation (in <A>group</A> or in a natural parent of <A>group</A>).
<P/>
If this fails the operation tries to find a small subset of <A>group</A>
on which the action will be faithful.
<P/>
The operation sets the attribute <Ref Attr="NiceMonomorphism"/>
and does not return a value.
</Description>
</ManSection>

<ManSection>
<Func Name="NiceMonomorphismAutomGroup" Arg='autgrp, elms, elmsgens'/>

<Description>
This function creates a monomorphism for an automorphism group
<A>autgrp</A> of a group by permuting the group elements in the list
<A>elms</A>.
This list must be chosen to yield a faithful representation.
<A>elmsgens</A> is a list of generators which are a subset of
<A>elms</A>.
(They can differ from the group's original generators.)
It does not yet assign it as <Ref Func="NiceMonomorphism"/> value.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Searching for Homomorphisms">
<Heading>Searching for Homomorphisms</Heading>

<Index Subkey="find all">homomorphisms</Index>

<ManSection>
<Func Name="IsomorphismGroups" Arg='G,H'/>

<Description>
computes an isomorphism between the groups <A>G</A> and <A>H</A>
if they are isomorphic and returns <K>fail</K> otherwise.
<P/>
With the existing methods the amount of time needed grows with
the size of a generating system of <A>G</A>. (Thus in particular for
<M>p</M>-groups calculations can be slow.) If you do only need to know
whether groups are isomorphic, you might want to consider
<Ref Func="IdSmallGroup"/> or the random isomorphism test
(see&nbsp;<Ref Func="RandomIsomorphismTest"/>).
<P/>
<Index Subkey="find all">isomorphisms</Index>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,3));;
gap> h:=Group((1,4,6,7)(2,3,5,8), (1,5)(2,6)(3,4)(7,8));;
gap> IsomorphismGroups(g,h);
[ (1,2,3,4), (1,3) ] -> [ (1,4,6,7)(2,3,5,8), (1,2)(3,7)(4,8)(5,6) ]
gap> IsomorphismGroups(g,Group((1,2,3,4),(1,2)));
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AllHomomorphismClasses" Arg='G,H'/>

<Description>
For two groups <A>G</A> and <A>H</A>, this function returns
representatives of all homomorphisms <M><A>G</A> to <A>H</A></M> up to
<A>H</A>-conjugacy.
<Example><![CDATA[
gap> AllHomomorphismClasses(SymmetricGroup(4),SymmetricGroup(3)); 
[ [ (2,3,4), (1,4,3,2) ] -> [ (), () ], 
  [ (2,3,4), (1,4,3,2) ] -> [ (), (1,2) ], 
  [ (2,3,4), (1,4,3,2) ] -> [ (1,2,3), (1,2) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AllHomomorphisms" Arg='G,H'/>
<Func Name="AllEndomorphisms" Arg='G'/>
<Func Name="AllAutomorphisms" Arg='G'/>

<Description>
For two groups <A>G</A> and <A>H</A>, this function returns
all homomorphisms <M><A>G</A> to <A>H</A></M>. Since this number will
grow quickly, <Ref Func="AllHomomorphismClasses"/> should be used in most
cases.
<Ref Func="AllEndomorphisms"/> returns all homomorphisms from
<A>G</A> to itself, 
<Ref Func="AllAutomorphisms"/> returns all bijective endomorphisms.
<Example><![CDATA[
gap> AllHomomorphisms(SymmetricGroup(3),SymmetricGroup(3));
[ [ (1,2,3), (1,2) ] -> [ (), () ], 
  [ (1,2,3), (1,2) ] -> [ (), (1,2) ], 
  [ (1,2,3), (1,2) ] -> [ (), (2,3) ], 
  [ (1,2,3), (1,2) ] -> [ (), (1,3) ], 
  [ (1,2,3), (1,2) ] -> [ (1,2,3), (1,2) ], 
  [ (1,2,3), (1,2) ] -> [ (1,2,3), (2,3) ], 
  [ (1,2,3), (1,2) ] -> [ (1,3,2), (1,2) ], 
  [ (1,2,3), (1,2) ] -> [ (1,2,3), (1,3) ], 
  [ (1,2,3), (1,2) ] -> [ (1,3,2), (1,3) ], 
  [ (1,2,3), (1,2) ] -> [ (1,3,2), (2,3) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GQuotients" Arg='F, G'/>

<Description>
computes all epimorphisms from <A>F</A> onto <A>G</A> up to automorphisms
of <A>G</A>.
This classifies all factor groups of <A>F</A> which are isomorphic to
<A>G</A>.
<P/>
With the existing methods the amount of time needed grows with
the size of a generating system of <A>G</A>. (Thus in particular for
<M>p</M>-groups calculations can be slow.)
<P/>
If the <C>findall</C> option is set to <K>false</K>,
the algorithm will stop once one homomorphism has been found
(this can be faster and might be sufficient if not all homomorphisms
are needed).
<P/>
<Index Subkey="find all">epimorphisms</Index>
<Index Subkey="find all">projections</Index>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> quo:=GQuotients(g,h);
[ [ (1,2,4,3), (1,2,3) ] -> [ (2,3), (1,2,3) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsomorphicSubgroups" Arg='G,H'/>

<Description>
computes all monomorphisms from <A>H</A> into <A>G</A> up to
<A>G</A>-conjugacy of the image groups.
This classifies all <A>G</A>-classes of subgroups of <A>G</A> which
are isomorphic to <A>H</A>.
<P/>
With the existing methods, the amount of time needed grows with
the size of a generating system of <A>G</A>. (Thus in particular for
<M>p</M>-groups calculations can be slow.) A main use of
<Ref Func="IsomorphicSubgroups"/> therefore is to find nonsolvable
subgroups (which often can be generated by 2 elements).
<P/>
(To find <M>p</M>-subgroups it is often faster to compute the subgroup
lattice of the Sylow subgroup and to use <Ref Func="IdGroup"/>
to identify the type of the subgroups.)
<P/>
If the <C>findall</C> option is set to <K>false</K>,
the algorithm will stop once one homomorphism has been found
(this can be faster and might be sufficient if not all homomorphisms are
needed).
<P/>
<Index Subkey="find all">embeddings</Index>
<Index Subkey="find all">monomorphisms</Index>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((3,4),(1,2));;
gap> emb:=IsomorphicSubgroups(g,h);
[ [ (3,4), (1,2) ] -> [ (1,2), (3,4) ], 
  [ (3,4), (1,2) ] -> [ (1,3)(2,4), (1,2)(3,4) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MorClassLoop" Arg='range, classes, params, action'/>

<Description>
This function loops over element tuples taken from <A>classes</A> and
checks these for properties such as generating a given group,
or fulfilling relations.
This can be used to find small generating sets or all types of Morphisms.
The element tuples are used only up to up to inner automorphisms as
all images can be obtained easily from them by conjugation while
running through all of them usually would take too long.
<P/>
<A>range</A> is a group from which these elements are taken.
The classes are given in a list <A>classes</A> which  is a list of records
with the following components.
<List>
<Mark><C>classes</C></Mark>
<Item>
 list of conjugacy classes
</Item>
<Mark><C>representative</C></Mark>
<Item>
 One element in the union of these classes
</Item>
<Mark><C>size</C></Mark>
<Item>
 The sum of the sizes of these classes
</Item>
</List>
<P/>
<A>params</A> is a record containing the following optional components.
<List>
<Mark><C>gens</C></Mark>
<Item>
 generators that are to be mapped (for testing morphisms). The length
 of this list determines the length of element tuples considered.
</Item>
<Mark><C>from</C></Mark>
<Item>
 a preimage group (that contains <C>gens</C>)
</Item>
<Mark><C>to</C></Mark>
<Item>
 image group (which might be smaller than <C>range</C>)
</Item>
<Mark><C>free</C></Mark>
<Item>
 free generators, a list of the same length than the
 generators <C>gens</C>.
</Item>
<Mark><C>rels</C></Mark>
<Item>
 some relations that hold among the generators <C>gens</C>.
 They are given as a list <C>[ word, order ]</C>
 where <C>word</C> is a word in the free generators <C>free</C>.
</Item>
<Mark><C>dom</C></Mark>
<Item>
 a set of elements on which automorphisms act faithfully (used to do
 element tests in partial automorphism groups).
</Item>
<Mark><C>aut</C></Mark>
<Item>
 Subgroup of already known automorphisms.
</Item>
<Mark><C>condition</C></Mark>
<Item>
 A function that will be applied to the homomorphism and must return
<C>true</C> for the homomorphism to be accepted.
</Item>
</List>
<P/>
<A>action</A> is a number whose bit-representation indicates
the requirements which are enforced on the element tuples found,
as follows.
<List>
<Mark>1</Mark>
<Item>
   homomorphism
</Item>
<Mark>2</Mark>
<Item>
   injective
</Item>
<Mark>4</Mark>
<Item>
   surjective
</Item>
<Mark>8</Mark>
<Item>
   find all (otherwise stops after the first find)
</Item>
</List>
If the search is for homomorphisms, the function returns homomorphisms
obtained by mapping the given generators <C>gens</C>
instead of element tuples.
<P/>
The <Q>Morpheus</Q> algorithm used to find homomorphisms is described in
<Cite Key="Hulpke96" Where="Section V.5"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Representations for Group Homomorphisms">
<Heading>Representations for Group Homomorphisms</Heading>

The different representations of group homomorphisms are used to indicate
from what type of group to what type of group they map and thus determine
which methods are used to compute images and preimages.
<P/>
The information in this section is mainly relevant for implementing new
methods and not for using homomorphisms.

<ManSection>
<Filt Name="IsGroupGeneralMappingByImages" Arg='map'
 Type='Representation'/>

<Description>
Representation for mappings from one group to another that are defined
by extending a mapping of group generators homomorphically.
Instead of record components,
the attribute <Ref Attr="MappingGeneratorsImages"/> is
used to store generators and their images.
</Description>
</ManSection>

<ManSection>
<Attr Name="MappingGeneratorsImages" Arg='map'/>

<Description>
This attribute contains a list of length 2, the first entry being a list
of generators of the source of <A>map</A> and the second entry a list of
their images. This attribute is used, for example, by
<Ref Func="GroupHomomorphismByImages"/> to store generators and images.
<!--  <C>MappingGeneratorsImages</C> is permitted to call           -->
<!--  <C>Source</C> and <C>ImagesRepresentative</C>.                -->
</Description>
</ManSection>

<ManSection>
<Filt Name="IsGroupGeneralMappingByAsGroupGeneralMappingByImages"
 Arg='map' Type='Representation'/>

<Description>
Representation for mappings that delegate work on a
<Ref Func="GroupHomomorphismByImages"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPreimagesByAsGroupGeneralMappingByImages" Arg='map'
 Type='Representation'/>

<Description>
Representation for mappings that delegate work for preimages to a
mapping created with <Ref Func="GroupHomomorphismByImages"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPermGroupGeneralMapping" Arg='map' Type='Representation'/>
<Filt Name="IsPermGroupGeneralMappingByImages" Arg='map' Type='Representation'/>
<Filt Name="IsPermGroupHomomorphism" Arg='map' Type='Representation'/>
<Filt Name="IsPermGroupHomomorphismByImages" Arg='map' Type='Representation'/>

<Description>
are the representations for mappings that map from a perm group
</Description>
</ManSection>

<ManSection>
<Filt Name="IsToPermGroupGeneralMappingByImages" Arg='map' Type='Representation'/>
<Filt Name="IsToPermGroupHomomorphismByImages" Arg='map' Type='Representation'/>

<Description>
is the representation for mappings that map to a perm group
</Description>
</ManSection>

<ManSection>
<Filt Name="IsGroupGeneralMappingByPcgs" Arg='map' Type='Representation'/>

<Description>
is the representations for mappings that map a pcgs to images and thus
may use exponents to decompose generators.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPcGroupGeneralMappingByImages" Arg='map' Type='Representation'/>
<Filt Name="IsPcGroupHomomorphismByImages" Arg='map' Type='Representation'/>

<Description>
is the representation for mappings from a pc group
</Description>
</ManSection>

<ManSection>
<Filt Name="IsToPcGroupGeneralMappingByImages" Arg='map' Type='Representation'/>
<Filt Name="IsToPcGroupHomomorphismByImages" Arg='map' Type='Representation'/>

<Description>
is the representation for mappings to a pc group
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFromFpGroupGeneralMappingByImages" Arg='map'
 Type='Representation'/>
<Filt Name="IsFromFpGroupHomomorphismByImages" Arg='map'
 Type='Representation'/>

<Description>
is the representation of mappings from an fp group.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFromFpGroupStdGensGeneralMappingByImages" Arg='map'
 Type='Representation'/>
<Filt Name="IsFromFpGroupStdGensHomomorphismByImages" Arg='map'
 Type='Representation'/>

<Description>
is the representation of total mappings from an fp group that give images of
the standard generators.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grpoper.msk                GAP documentation            Alexander Hulpke -->
<!-- %A                                                          Heiko Theißen -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grpoper.msk,v 1.47 2005/04/30 23:58:53 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Group Actions">
<Heading>Group Actions</Heading>

<Index>group actions</Index>
A <E>group action</E> is a triple <M>(G, \Omega, \mu)</M>,
where <M>G</M> is a group, <M>\Omega</M> a set and
<M>\mu \colon \Omega \times G \rightarrow \Omega</M> a function
that is compatible with the group arithmetic.
We call <M>\Omega</M> the <E>domain</E> of the action.
<P/>
In &GAP;, <M>\Omega</M> can be a duplicate-free collection (an object that
permits access to its elements via the <M>\Omega[n]</M> operation,
for example a list),
it does not need to be sorted (see&nbsp;<Ref Func="IsSet"/>).
<P/>
The acting function <M>\mu</M> is a binary &GAP; function
that returns the image <M>\mu( x, g )</M> for a point
<M>x \in \Omega</M> and a group element <M>g \in G</M>.
<P/>
In &GAP;, groups always act from the right, that is
<M>\mu( \mu( x, g ), h ) = \mu( x, gh )</M>.
<P/>
&GAP; does not test whether the acting function <M>\mu</M> satisfies the
conditions for a group operation but silently assumes that is does.
(If it does not, results are unpredictable.)
<P/>
The first section of this chapter, <Ref Sect="About Group Actions"/>,
describes the various ways how operations for group actions can be called.
<P/>
Functions for several commonly used action are already built into &GAP;.
These are listed in section&nbsp;<Ref Sect="Basic Actions"/>.
<P/>
The sections <Ref Sect="The Permutation Image of an Action"/> and 
<Ref Sect="Action of a group on itself"/> describe homomorphisms and mappings
associated to group actions
as well as the permutation group image of an action.
<P/>
The other sections then describe operations to compute orbits, stabilizers,
as well as properties of actions.
<P/>
Finally section&nbsp;<Ref Sect="External Sets"/> describes the concept of
<Q>external sets</Q> which represent the concept of a <E><M>G</M>-set</E>
and underly the actions mechanism.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="About Group Actions">
<Heading>About Group Actions</Heading>

<Index Subkey="operations syntax">group actions</Index>
The syntax which is used by the operations for group actions is quite
flexible.
For example we can call the operation
<Ref Func="OrbitsDomain" Label="for a group and an action domain"/>
for the orbits of the group <A>G</A> on the domain <A>Omega</A>
in the following ways:
<P/>
<List>
<Mark><C>OrbitsDomain</C><M>( G, \Omega[, \mu] )</M></Mark>
<Item>
  The acting function <M>\mu</M> is optional.
  If it is not given, the built-in action <Ref Func="OnPoints"/>
  (which defines an action via the caret operator <C>^</C>)
  is used as a default.
</Item>
<Mark><C>OrbitsDomain</C><M>( G, \Omega, gens, acts[, \mu] )</M></Mark>
<Item>
  This second version of
  <Ref Func="OrbitsDomain" Label="for a group and an action domain"/>
  permits one to implement an action induced by a homomorphism:
  If the group <M>H</M> acts on <M>\Omega</M> via <M>\mu</M> and
  <M>\varphi \colon G \rightarrow H</M> is a homomorphism,
  <M>G</M> acts on <M>\Omega</M> via the induced action
  <M>\mu'( x, g ) = \mu( x, g^{\varphi} )</M>.
  <P/>
  Here <M>gens</M> must be a set of generators of <M>G</M> and <M>acts</M>
  the images of <M>gens</M> under <M>\varphi</M>.
  <M>\mu</M> is the acting function for <M>H</M>.
  Again, the function <M>\mu</M> is optional
  and <Ref Func="OnPoints"/> is used as a default.
  <P/>
  The advantage of this notation is that &GAP; does not need to construct
  this homomorphism <M>\varphi</M> and the range group <A>H</A> as &GAP;
  objects.
  (If a small group <M>G</M> acts via complicated objects <M>acts</M>
  this otherwise could lead to performance problems.)
  <P/>
  &GAP; does not test whether the mapping <M>gens \mapsto acts</M>
  actually induces a homomorphism
  and the results are unpredictable if this is not the case.
</Item>
<Mark><C>OrbitsDomain</C><M>( extset )</M></Mark>
<Item>
  A third variant is to call the operation with an external set,
  which then provides <M>G</M>, <M>\Omega</M> and <M>\mu</M>.
  You will find more about external sets in
  Section&nbsp;<Ref Sect="External Sets"/>.
</Item>
</List>
<P/>
For operations like <Ref Func="Stabilizer"/> of course the domain must be
replaced by an element of the domain of the action.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Basic Actions">
<Heading>Basic Actions</Heading>

<Index>group actions</Index>
<Index>actions</Index>
<Index>group operations</Index>
&GAP; already provides acting functions for the more common actions of a
group.
For built-in operations such as <Ref Func="Stabilizer"/>
special methods are available for many of these actions.
<P/>
If one needs an action for which no acting function is provided
by the library it can be implemented via a &GAP; function that
conforms to the syntax
<P/>
<C>actfun( omega, g )</C>
<P/>
where <C>omega</C> is an element of the action domain,
<C>g</C> is an element of the acting group,
and the return value is the image of <C>omega</C> under <C>g</C>.
<P/>
For example one could define the following function that acts on pairs of
polynomials via
<Ref Func="OnIndeterminates" Label="as a permutation action"/>:
<Log><![CDATA[
OnIndeterminatesPairs:= function( polypair, g )
  return [ OnIndeterminates( polypair[1], g ),
           OnIndeterminates( polypair[2], g ) ];
end;
]]></Log>
<P/>
Note that this function <E>must</E> implement a group action from the
<E>right</E>.
This is not verified by &GAP; and results are unpredictable otherwise.

<ManSection>
<Func Name="OnPoints" Arg='pnt, g'/>

<Description>
<Index>conjugation</Index>
<Index Subkey="by conjugation">action</Index>
returns <C><A>pnt</A> ^ <A>g</A></C>.
This is for example the action of a permutation group on points,
or the action of a group on its elements via conjugation.
The action of a matrix group on vectors from the right is described by
both <Ref Func="OnPoints"/> and <Ref Func="OnRight"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="OnRight" Arg='pnt, g'/>

<Description>
returns <C><A>pnt</A> * <A>g</A></C>.
This is for example the action of a group on its elements via right
multiplication,
or the action of a group on the cosets of a subgroup.
The action of a matrix group on vectors from the right is described by
both <Ref Func="OnPoints"/> and <Ref Func="OnRight"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="OnLeftInverse" Arg='pnt, g'/>

<Description>
returns <M><A>g</A>^{{-1}}</M> <C>* <A>pnt</A></C>.
Forming the inverse is necessary to make this a proper action,
as in &GAP; groups always act from the right.
<P/>
<Ref Func="OnLeftInverse"/> is used for example in the representation
of a right coset as an external set
(see&nbsp;<Ref Sect="External Sets"/>),
that is, a right coset <M>Ug</M> is an external set for the group
<M>U</M> acting on it via <Ref Func="OnLeftInverse"/>.)
</Description>
</ManSection>

<ManSection>
<Func Name="OnSets" Arg='set, g'/>

<Description>
<Index Subkey="on sets">action</Index>
<Index Subkey="on blocks">action</Index>
Let <A>set</A> be a proper set
(see&nbsp;<Ref Sect="Sorted Lists and Sets"/>).
<Ref Func="OnSets"/> returns the proper set formed by the images
of all points <M>x</M> of <A>set</A> via the action function
<Ref Func="OnPoints"/>, applied to <M>x</M> and <A>g</A>.
<P/>
<Ref Func="OnSets"/> is for example used to compute the action of
a permutation group on blocks.
<P/>
(<Ref Func="OnTuples"/> is an action on lists that preserves the ordering
of entries.)
</Description>
</ManSection>

<ManSection>
<Func Name="OnTuples" Arg='tup, g'/>

<Description>
Let <A>tup</A> be a list.
<Ref Func="OnTuples"/> returns the list formed by the images
of all points <M>x</M> of <A>tup</A> via the action function
<Ref Func="OnPoints"/>, applied to <M>x</M> and <A>g</A>.
<P/>
(<Ref Func="OnSets"/> is an action on lists that additionally sorts
the entries of the result.)
</Description>
</ManSection>

<ManSection>
<Func Name="OnPairs" Arg='tup, g'/>

<Description>
is a special case of <Ref Func="OnTuples"/> for lists <A>tup</A>
of length 2.
</Description>
</ManSection>

<ManSection>
<Func Name="OnSetsSets" Arg='set, g'/>

<Description>
implements the action on sets of sets.
For the special case that the sets are pairwise disjoint,
it is possible to use <Ref Func="OnSetsDisjointSets"/>.
<A>set</A> must be a sorted list whose entries are again sorted lists,
otherwise an error is triggered
(see&nbsp;<Ref Sect="Action on canonical representatives"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="OnSetsDisjointSets" Arg='set, g'/>

<Description>
implements the action on sets of pairwise disjoint sets
(see also&nbsp;<Ref Func="OnSetsSets"/>).
<A>set</A> must be a sorted list whose entries are again sorted lists,
otherwise an error is triggered
(see&nbsp;<Ref Sect="Action on canonical representatives"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="OnSetsTuples" Arg='set, g'/>

<Description>
implements the action on sets of tuples.
<A>set</A> must be a sorted list,
otherwise an error is triggered
(see&nbsp;<Ref Sect="Action on canonical representatives"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="OnTuplesSets" Arg='set, g'/>

<Description>
implements the action on tuples of sets.
<A>set</A> must be a list whose entries are again sorted lists,
otherwise an error is triggered
(see&nbsp;<Ref Sect="Action on canonical representatives"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="OnTuplesTuples" Arg='set, g'/>

<Description>
implements the action on tuples of tuples.
<Example><![CDATA[
gap> g:=Group((1,2,3),(2,3,4));;
gap> Orbit(g,1,OnPoints);
[ 1, 2, 3, 4 ]
gap> Orbit(g,(),OnRight);
[ (), (1,2,3), (2,3,4), (1,3,2), (1,3)(2,4), (1,2)(3,4), (2,4,3), 
  (1,4,2), (1,4,3), (1,3,4), (1,2,4), (1,4)(2,3) ]
gap> Orbit(g,[1,2],OnPairs);
[ [ 1, 2 ], [ 2, 3 ], [ 1, 3 ], [ 3, 1 ], [ 3, 4 ], [ 2, 1 ], 
  [ 1, 4 ], [ 4, 1 ], [ 4, 2 ], [ 3, 2 ], [ 2, 4 ], [ 4, 3 ] ]
gap> Orbit(g,[1,2],OnSets);
[ [ 1, 2 ], [ 2, 3 ], [ 1, 3 ], [ 3, 4 ], [ 1, 4 ], [ 2, 4 ] ]
gap> Orbit(g,[[1,2],[3,4]],OnSetsSets);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 1, 4 ], [ 2, 3 ] ], 
  [ [ 1, 3 ], [ 2, 4 ] ] ]
gap> Orbit(g,[[1,2],[3,4]],OnTuplesSets);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 2, 3 ], [ 1, 4 ] ], 
  [ [ 1, 3 ], [ 2, 4 ] ], [ [ 3, 4 ], [ 1, 2 ] ], 
  [ [ 1, 4 ], [ 2, 3 ] ], [ [ 2, 4 ], [ 1, 3 ] ] ]
gap> Orbit(g,[[1,2],[3,4]],OnSetsTuples);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 1, 4 ], [ 2, 3 ] ], 
  [ [ 1, 3 ], [ 4, 2 ] ], [ [ 2, 4 ], [ 3, 1 ] ], 
  [ [ 2, 1 ], [ 4, 3 ] ], [ [ 3, 2 ], [ 4, 1 ] ] ]
gap> Orbit(g,[[1,2],[3,4]],OnTuplesTuples);
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 2, 3 ], [ 1, 4 ] ], 
  [ [ 1, 3 ], [ 4, 2 ] ], [ [ 3, 1 ], [ 2, 4 ] ], 
  [ [ 3, 4 ], [ 1, 2 ] ], [ [ 2, 1 ], [ 4, 3 ] ], 
  [ [ 1, 4 ], [ 2, 3 ] ], [ [ 4, 1 ], [ 3, 2 ] ], 
  [ [ 4, 2 ], [ 1, 3 ] ], [ [ 3, 2 ], [ 4, 1 ] ], 
  [ [ 2, 4 ], [ 3, 1 ] ], [ [ 4, 3 ], [ 2, 1 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="OnLines" Arg='vec, g'/>

<Description>
Let <A>vec</A> be a <E>normed</E> row vector, that is,
its first nonzero entry is normed to the identity of the relevant field,
see <Ref Func="NormedRowVector"/>.
The function <Ref Func="OnLines"/> returns the row vector obtained from
first multiplying <A>vec</A> from the right with <A>g</A>
(via <Ref Func="OnRight"/>) and then normalizing the resulting row vector
by scalar multiplication from the left.
<P/>
This action corresponds to the projective action of a matrix group
on one-dimensional subspaces.
<P/>
If <A>vec</A> is a zero vector or is not normed then
an error is triggered
(see&nbsp;<Ref Sect="Action on canonical representatives"/>).
<P/>
<Example><![CDATA[
gap> gl:=GL(2,5);;v:=[1,0]*Z(5)^0;
[ Z(5)^0, 0*Z(5) ]
gap> h:=Action(gl,Orbit(gl,v,OnLines),OnLines);
Group([ (2,3,5,6), (1,2,4)(3,6,5) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="OnIndeterminates" Arg='poly, perm'
 Label="as a permutation action"/>

<Description>
A permutation <A>perm</A> acts on the multivariate polynomial <A>poly</A>
by permuting the indeterminates as it permutes points.
<Example><![CDATA[
gap> x:=Indeterminate(Rationals,1);; y:=Indeterminate(Rationals,2);;
gap> OnIndeterminates(x^7*y+x*y^4,(1,17)(2,28));
x_17^7*x_28+x_17*x_28^4
gap> Stabilizer(Group((1,2,3,4),(1,2)),x*y,OnIndeterminates);
Group([ (1,2), (3,4) ])
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="Permuted" Arg='list, perm' Label="as a permutation action"/>

<Description>
The following example demonstrates <Ref Func="Permuted"/> being used
to implement a permutation action on a domain:
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));;
gap> dom:=[ "a", "b", "c" ];;
gap> Orbit(g,dom,Permuted);
[ [ "a", "b", "c" ], [ "c", "a", "b" ], [ "b", "a", "c" ], 
  [ "b", "c", "a" ], [ "a", "c", "b" ], [ "c", "b", "a" ] ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="OnSubspacesByCanonicalBasis" Arg='bas,mat'/>
<Func Name="OnSubspacesByCanonicalBasisConcatenations" Arg='basvec,mat'/>

<Description>
implements the operation of a matrix group on subspaces of a vector
space. <A>bas</A> must be a list of (linearly independent) vectors which
forms a basis of the subspace in Hermite normal form. <A>mat</A> is an
element of the acting matrix group. The function returns a mutable
matrix which gives the basis of the image of the subspace in Hermite
normal form. (In other words: it triangulizes the product of <A>bas</A> with
<A>mat</A>.)
<P/>
<A>bas</A> must be given in Hermite normal form,
otherwise an error is triggered (see&nbsp;<Ref Sect="Action on canonical representatives"/>).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Action on canonical representatives">
<Heading>Action on canonical representatives</Heading>

A variety of action functions assumes that the objects on which it acts are
given in a particular form, for example canonical representatives.
Affected actions are for example <Ref Func="OnSetsSets"/>,
<Ref Func="OnSetsDisjointSets"/>, <Ref Func="OnSetsTuples"/>,
<Ref Func="OnTuplesSets"/>, <Ref Func="OnLines"/> and
<Ref Func="OnSubspacesByCanonicalBasis"/>.
<P/>
If orbit seeds or domain elements are not given in the required form &GAP;
will issue an error message:
<Log><![CDATA[
gap> Orbit(SymmetricGroup(5),[[2,4],[1,3]],OnSetsSets);
Error, Action not well-defined. See the manual section
``Action on canonical representatives''.
]]></Log>
In this case the affected domain elements have to be brought in canonical
form, as documented for the respective action function.
For interactive use this is most easily done by acting with the identity
element of the group.
<P/>
(A similar error could arise if a user-defined action function is used which
actually does not implement an action from the right.)

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Orbits">
<Heading>Orbits</Heading>

If a group <M>G</M> acts on a set <M>\Omega</M>, the set of all images of
<M>x \in \Omega</M> under elements of <M>G</M> is called the
<E>orbit</E> of <M>x</M>.
The set of orbits of <M>G</M> is a partition of <M>\Omega</M>.

<ManSection>
<Oper Name="Orbit" Arg='G[, Omega], pnt[, gens, acts][, act]'/>

<Description>
The orbit of the point <A>pnt</A> is the list of all images of <A>pnt</A>
under the action of the group <A>G</A> w.r.t. the action function
<A>act</A> or <Ref Func="OnPoints"/> if no action function is given.
<P/>
(Note that the arrangement of points in this list is not defined by the
operation.)
<P/>
The orbit of <A>pnt</A> will always contain one element that is
<E>equal</E> to <A>pnt</A>, however for performance reasons
this element is not necessarily <E>identical</E> to <A>pnt</A>,
in particular if <A>pnt</A> is mutable.
<Example><![CDATA[
gap> g:=Group((1,3,2),(2,4,3));;
gap> Orbit(g,1);
[ 1, 3, 2, 4 ]
gap> Orbit(g,[1,2],OnSets);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ], [ 2, 4 ] ]
]]></Example>
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
</Description>
</ManSection>

<ManSection>
<Oper Name="Orbits" Arg='G, seeds[, gens, acts][, act]' Label="operation"/>
<Attr Name="Orbits" Arg='xset' Label="attribute"/>

<Description>
returns a duplicate-free list of the orbits of the elements in
<A>seeds</A> under the action <A>act</A> of <A>G</A> or under
<Ref Func="OnPoints"/> if no action function is given.
<P/>
(Note that the arrangement of orbits or of points within one orbit is
not defined by the operation.)
</Description>
</ManSection>

<ManSection>
<Heading>OrbitsDomain</Heading>
<Oper Name="OrbitsDomain" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group and an action domain"/>
<Attr Name="OrbitsDomain" Arg='xset'
 Label="of an external set"/>

<Description>
returns a list of the orbits of <A>G</A> on the domain <A>Omega</A>
(given as lists) under the action <A>act</A> or under 
<Ref Func="OnPoints"/> if no action function is given.
<P/>
This operation is often faster than
<Ref Func="Orbits" Label="operation"/>.
The domain <A>Omega</A> must be closed under the action of <A>G</A>,
otherwise an error can occur.
<P/>
(Note that the arrangement of orbits or of points within one orbit is
not defined by the operation.)
<Example><![CDATA[
gap> g:=Group((1,3,2),(2,4,3));;
gap> Orbits(g,[1..5]);
[ [ 1, 3, 2, 4 ], [ 5 ] ]
gap> OrbitsDomain(g,Arrangements([1..4],3),OnTuples);
[ [ [ 1, 2, 3 ], [ 3, 1, 2 ], [ 1, 4, 2 ], [ 2, 3, 1 ], [ 2, 1, 4 ], 
      [ 3, 4, 1 ], [ 1, 3, 4 ], [ 4, 2, 1 ], [ 4, 1, 3 ], 
      [ 2, 4, 3 ], [ 3, 2, 4 ], [ 4, 3, 2 ] ], 
  [ [ 1, 2, 4 ], [ 3, 1, 4 ], [ 1, 4, 3 ], [ 2, 3, 4 ], [ 2, 1, 3 ], 
      [ 3, 4, 2 ], [ 1, 3, 2 ], [ 4, 2, 3 ], [ 4, 1, 2 ], 
      [ 2, 4, 1 ], [ 3, 2, 1 ], [ 4, 3, 1 ] ] ]
gap> OrbitsDomain(g,GF(2)^2,[(1,2,3),(1,4)(2,3)],
> [[[Z(2)^0,Z(2)^0],[Z(2)^0,0*Z(2)]],[[Z(2)^0,0*Z(2)],[0*Z(2),Z(2)^0]]]);
[ [ <an immutable GF2 vector of length 2> ], 
  [ <an immutable GF2 vector of length 2>, 
      <an immutable GF2 vector of length 2>, 
      <an immutable GF2 vector of length 2> ] ]
]]></Example>
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
</Description>
</ManSection>

<ManSection>
<Oper Name="OrbitLength" Arg='G, Omega, pnt[, gens, acts][, act]'/>

<Description>
computes the length of the orbit of <A>pnt</A> under 
the action function <A>act</A> or <Ref Func="OnPoints"/> 
if no action function is given.
</Description>
</ManSection>

<ManSection>
<Heading>OrbitLengths</Heading>
<Oper Name="OrbitLengths" Arg='G, seeds[, gens, acts][, act]'
 Label="for a group, a set of seeds, etc."/>
<Attr Name="OrbitLengths" Arg='xset' Label="for an external set"/>

<Description>
computes the lengths of all the orbits of the elements in <A>seeds</A>
under the action <A>act</A> of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Heading>OrbitLengthsDomain</Heading>
<Oper Name="OrbitLengthsDomain" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group and a set of seeds"/>
<Attr Name="OrbitLengthsDomain" Arg='xset' Label="of an external set"/>

<Description>
computes the lengths of all the orbits of <A>G</A> on <A>Omega</A>.
<P/>
This operation is often faster than
<Ref Func="OrbitLengths" Label="for a group, a set of seeds, etc."/>.
The domain <A>Omega</A> must be closed under the action of <A>G</A>,
otherwise an error can occur.
<Example><![CDATA[
gap> g:=Group((1,3,2),(2,4,3));;
gap> OrbitLength(g,[1,2,3,4],OnTuples);
12
gap> OrbitLengths(g,Arrangements([1..4],4),OnTuples);
[ 12, 12 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Stabilizers">
<Heading>Stabilizers</Heading>

<Index>point stabilizer</Index><Index>set stabilizer</Index>
<Index>tuple stabilizer</Index>
The <E>stabilizer</E> of a point <M>x</M> under the action of a group
<M>G</M> is the set of all those elements in <M>G</M> which fix <M>x</M>.

<ManSection>
<Oper Name="OrbitStabilizer" Arg='G[, Omega], pnt[, gens, acts,] act'/>

<Description>
computes the orbit and the stabilizer of <A>pnt</A> simultaneously in a
single orbit-stabilizer algorithm.
<P/>
The stabilizer will have <A>G</A> as its parent.
</Description>
</ManSection>

<ManSection>
<Func Name="Stabilizer" Arg='G[, Omega], pnt[, gens, acts][, act]'/>

<Description>
computes the stabilizer in <A>G</A> of the point <A>pnt</A>,
that is the subgroup of those elements of <A>G</A> that fix <A>pnt</A>.
The stabilizer will have <A>G</A> as its parent.
<Example><![CDATA[
gap> g:=Group((1,3,2),(2,4,3));;
gap> Stabilizer(g,4);
Group([ (1,3,2) ])
]]></Example>
<P/>
The stabilizer of a set or tuple of points can be computed by specifying
an action of sets or tuples of points.
<Example><![CDATA[
gap> Stabilizer(g,[1,2],OnSets);
Group([ (1,2)(3,4) ])
gap> Stabilizer(g,[1,2],OnTuples);
Group(())
gap> OrbitStabilizer(g,[1,2],OnSets);
rec( 
  orbit := [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ], 
      [ 2, 4 ] ], stabilizer := Group([ (1,2)(3,4) ]) )
]]></Example>
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
<P/>
The standard methods for all these actions are an orbit-stabilizer
algorithm. For permutation groups backtrack algorithms are used. For
solvable groups an orbit-stabilizer algorithm for solvable groups, which
uses the fact that the orbits of a normal subgroup form a block system
(see <Cite Key="SOGOS"/>) is used.
</Description>
</ManSection>

<ManSection>
<Func Name="OrbitStabilizerAlgorithm"
 Arg='G, Omega, blist, gens, acts, pntact'/>

<Description>
This operation should not be called by a user. It is documented however
for purposes to extend or maintain the group actions package
(the word <Q>package</Q> here refers to the &GAP; functionality for 
group actions, not to a &GAP; package).
<P/>
<Ref Func="OrbitStabilizerAlgorithm"/> performs an orbit stabilizer
algorithm for the group <A>G</A> acting with the generators <A>gens</A>
via the generator images <A>gens</A> and the group action <A>act</A> on
the element <A>pnt</A>.
(For technical reasons <A>pnt</A> and <A>act</A> are put in one record
with components <C>pnt</C> and <C>act</C> respectively.)
<P/>
The <A>pntact</A> record may carry a component <A>stabsub</A>.
If given, this must be a subgroup stabilizing <E>all</E> points in the
domain and can be used to abbreviate stabilizer calculations.
<P/>
The <A>pntact</A> component also may contain the boolean entry <C>onlystab</C> set
to <K>true</K>. In this case the <C>orbit</C> component may be omitted from the
result.
<P/>
The argument <A>Omega</A> (which may be replaced by <K>false</K> to be ignored) is
the set within which the orbit is computed (once the orbit is the full
domain, the orbit calculation may stop).  If <A>blist</A> is given it must be
a bit list corresponding to <A>Omega</A> in which elements which have been found
already will be <Q>ticked off</Q> with <K>true</K>. (In particular, the entries
for the orbit of <A>pnt</A> still must be all set to <K>false</K>). Again the
remaining action domain (the bits set initially to <K>false</K>) can be
used to stop if the orbit cannot grow any longer.
Another use of the bit list is if <A>Omega</A> is an enumerator which can
determine <Ref Func="PositionCanonical"/> values very quickly.
In this situation it can be
worth to search images not in the orbit found so far, but via their
position in <A>Omega</A> and use a the bit list to keep track whether the
element is in the orbit found so far.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elements with Prescribed Images">
<Heading>Elements with Prescribed Images</Heading>

<Index>transporter</Index>
<ManSection>
<Oper Name="RepresentativeAction"
 Arg='G[, Omega], d, e[, gens, acts][, act]'/>

<Description>
computes an element of <A>G</A> that maps <A>d</A> to <A>e</A> under the
given action and returns <K>fail</K> if no such element exists.
<Example><![CDATA[
gap> g:=Group((1,3,2),(2,4,3));;
gap> RepresentativeAction(g,1,3);
(1,3)(2,4)
gap> RepresentativeAction(g,1,3,OnPoints);
(1,3)(2,4)
gap> RepresentativeAction(g,(1,2,3),(2,4,3));
(1,2,4)
gap> RepresentativeAction(g,(1,2,3),(2,3,4));
fail
gap> RepresentativeAction(g,Group((1,2,3)),Group((2,3,4)));
(1,2,4)
gap>  RepresentativeAction(g,[1,2,3],[1,2,4],OnSets);
(2,4,3)
gap>  RepresentativeAction(g,[1,2,3],[1,2,4],OnTuples);
fail
]]></Example>
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
<P/>
Again the standard method for <Ref Func="RepresentativeAction"/> is
an orbit-stabilizer algorithm,
for permutation groups and standard actions a backtrack algorithm is used.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Permutation Image of an Action">
<Heading>The Permutation Image of an Action</Heading>

When a group <M>G</M> acts on a domain <M>\Omega</M>,
an enumeration of <M>Omega</M> yields a homomorphism from <M>G</M> into
the symmetric group on <M>\{ 1, \ldots, |\Omega| \}</M>.
In &GAP;, the enumeration of <M>\Omega</M> is provided by the
<Ref Func="Enumerator"/> value of <M>\Omega</M>
which of course is <M>\Omega</M> itself if it is a list.
<P/>
For an action homomorphism, the operation <Ref Func="UnderlyingExternalSet"/>
will return the external set on <M>\Omega</M> which affords the action.

<ManSection>
<Heading>ActionHomomorphism</Heading>
<Oper Name="ActionHomomorphism"
 Arg='G, Omega[, gens, acts][, act][, "surjective"]'
 Label="for a group, an action domain, etc."/>
<Attr Name="ActionHomomorphism" Arg='xset[, "surjective"]'
 Label="for an external set"/>
<Attr Name="ActionHomomorphism" Arg='action'
 Label="for an action image"/>

<Description>
computes a homomorphism from <A>G</A> into the symmetric group on
<M>|<A>Omega</A>|</M> points that gives the permutation action of
<A>G</A> on <A>Omega</A>.
<P/>
By default the homomorphism returned by
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>
is not necessarily surjective (its 
<Ref Func="Range" Label="of a general mapping"/> value is the full
symmetric group) to avoid unnecessary computation of the image.
If the optional string argument <C>"surjective"</C> is given,
a surjective homomorphism is created.
<P/>
The third version (which is supported only for &GAP;3 compatibility)
returns the action homomorphism that belongs to the image obtained via
<Ref Func="Action" Label="for a group, an action domain, etc."/>.
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));;
gap> hom:=ActionHomomorphism(g,Arrangements([1..4],3),OnTuples);
<action homomorphism>
gap> Image(hom);
Group(
[ (1,9,13)(2,10,14)(3,7,15)(4,8,16)(5,12,17)(6,11,18)(19,22,23)(20,21,
    24), (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)(13,15)(14,16)(17,18)(19,
    21)(20,22)(23,24) ])
gap> Size(Range(hom));Size(Image(hom));
620448401733239439360000
6
gap> hom:=ActionHomomorphism(g,Arrangements([1..4],3),OnTuples,
> "surjective");;
gap> Size(Range(hom));
6
]]></Example>
<P/>
When acting on a domain, the operation <Ref Func="PositionCanonical"/>
is used to determine the position of elements in the domain.
This can be used to act on a domain given by a list of representatives
for which <Ref Func="PositionCanonical"/> is implemented,
for example the return value of <Ref Func="RightTransversal"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Action" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="Action" Arg='xset'
 Label="for an external set"/>

<Description>
returns the image group of
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>
called with the same parameters.
<P/>
Note that (for compatibility reasons to be able to get the
action homomorphism) this image group internally stores the action
homomorphism.
If <A>G</A> or <A>Omega</A> are extremely big, this can cause memory
problems. In this case compute only generator images and form the image
group yourself.
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
<P/>
<Index>regular action</Index>
The following code shows for example how to create the regular action of a
group.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));;
gap> Action(g,AsList(g),OnRight);
Group([ (1,4,5)(2,3,6), (1,3)(2,4)(5,6) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SparseActionHomomorphism"
 Arg='G, start[, gens, acts][, act]'/>
<Oper Name="SortedSparseActionHomomorphism"
 Arg='G, start[, gens, acts][, act]'/>

<Description>
<Ref Func="SparseActionHomomorphism"/> computes the action homomorphism
(see <Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>)
with arguments <A>G</A>, <M>D</M>, and the optional arguments given,
where <M>D</M> is the union of the <A>G</A>-orbits of all points in
<A>start</A>.
In the <Ref Func="Orbit"/> calls that are used to create <M>D</M>,
again the optional arguments given are entered.)
<P/>
If <A>G</A> acts on a very large domain not surjectively
this may yield a permutation image of
substantially smaller degree than by action on the whole domain.
<P/>
The operation <Ref Func="SparseActionHomomorphism"/> will only use
<Ref Func="\="/> comparisons of points in the orbit.
Therefore it can be used even if no good <Ref Func="\&lt;"/>
comparison method for these points is available.
However the image group will depend on the
generators <A>gens</A> of <A>G</A>.
<P/>
The operation <Ref Func="SortedSparseActionHomomorphism"/> in contrast
will sort the orbit and thus produce an image group which does not
depend on these generators.
<P/>
<Example><![CDATA[
gap> h:=Group(Z(3)*[[[1,1],[0,1]]]);
Group([ [ [ Z(3), Z(3) ], [ 0*Z(3), Z(3) ] ] ])
gap> hom:=ActionHomomorphism(h,GF(3)^2,OnRight);;
gap> Image(hom);
Group([ (2,3)(4,9,6,7,5,8) ])
gap> hom:=SparseActionHomomorphism(h,[Z(3)*[1,0]],OnRight);;
gap> Image(hom);
Group([ (1,2,3,4,5,6) ])
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Action of a group on itself">
<Heading>Action of a group on itself</Heading>

Of particular importance is the action of a group on its elements or cosets
of a subgroup.
These actions can be obtained by using
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>
for a suitable domain (for example a list of subgroups). For the following
(frequently used) types of actions however special (often particularly
efficient) functions are provided.
A special case is the regular action on all elements.

<ManSection>
<Oper Name="FactorCosetAction" Arg='G, U[, N]'/>

<Description>
This command computes the action of the group <A>G</A> on the
right cosets of the subgroup <A>U</A>.
If a normal subgroup <A>N</A> of <A>G</A> is given,
it is stored as kernel of this action.
<Example><![CDATA[
gap> g:=Group((1,2,3,4,5),(1,2));;u:=SylowSubgroup(g,2);;Index(g,u);
15
gap> FactorCosetAction(g,u);
<action epimorphism>
gap> StructureDescription(Range(last));
"S5"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RegularActionHomomorphism" Arg='G'/>

<Description>
returns an isomorphism from <A>G</A> onto the regular permutation
representation of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AbelianSubfactorAction" Arg='G, M, N'/>

<Description>
Let <A>G</A> be a group and <M><A>M</A> \geq <A>N</A></M> be subgroups
of a common parent that are normal under <A>G</A>, such that
the subfactor <M><A>M</A>/<A>N</A></M> is elementary abelian.
The operation <Ref Func="AbelianSubfactorAction"/> returns a list
<C>[ <A>phi</A>, <A>alpha</A>, <A>bas</A> ]</C> where
<A>bas</A> is a list of elements of <A>M</A> which are representatives
for a basis of <M><A>M</A>/<A>N</A></M>,
<A>alpha</A> is a map from <A>M</A> into a <M>n</M>-dimensional row space
over <M>GF(p)</M> where <M>[<A>M</A>:<A>N</A>] = p^n</M> that is the
natural homomorphism of <A>M</A> by <A>N</A> with the quotient
represented as an additive group.
Finally <A>phi</A> is a homomorphism from <A>G</A>
into <M>GL_n(p)</M> that represents the action of <A>G</A> on the factor
<M><A>M</A>/<A>N</A></M>.
<P/>
Note: If only matrices for the action are needed,
<Ref Func="LinearActionLayer"/> might be faster.
<Example><![CDATA[
gap> g:=Group((1,8,10,7,3,5)(2,4,12,9,11,6),
>             (1,9,5,6,3,10)(2,11,12,8,4,7));;
gap> c:=ChiefSeries(g);;List(c,Size);
[ 96, 48, 16, 4, 1 ]
gap> HasElementaryAbelianFactorGroup(c[3],c[4]);
true
gap> SetName(c[3],"my_group");;
gap> a:=AbelianSubfactorAction(g,c[3],c[4]);
[ [ (1,8,10,7,3,5)(2,4,12,9,11,6), (1,9,5,6,3,10)(2,11,12,8,4,7) ] -> 
    [ <an immutable 2x2 matrix over GF2>, 
      <an immutable 2x2 matrix over GF2> ], 
  MappingByFunction( my_group, ( GF(2)^
    2 ), function( e ) ... end, function( r ) ... end ), 
  Pcgs([ (2,9,3,8)(4,11,5,10), (1,6,12,7)(4,10,5,11) ]) ]
gap> mat:=Image(a[1],g);
Group([ <an immutable 2x2 matrix over GF2>, 
  <an immutable 2x2 matrix over GF2> ])
gap> Size(mat);
3
gap> e:=PreImagesRepresentative(a[2],[Z(2),0*Z(2)]);
(2,9,3,8)(4,11,5,10)
gap> e in c[3];e in c[4];
true
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Permutations Induced by Elements and Cycles">
<Heading>Permutations Induced by Elements and Cycles</Heading>

If only the permutation image of a single element is needed, it might not be
worth to create the action homomorphism, the following operations yield the
permutation image and cycles of a single element.

<ManSection>
<Heading>Permutation</Heading>
<Func Name="Permutation" Arg='g, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Func Name="Permutation" Arg='g, xset' Label="for an external set"/>

<Description>
computes the permutation that corresponds to the action of <A>g</A> on
the permutation domain <A>Omega</A>
(a list of objects that are permuted).
If an external set <A>xset</A> is given,
the permutation domain is the <Ref Func="HomeEnumerator"/> value
of this external set (see Section&nbsp;<Ref Sect="External Sets"/>).
Note that the points of the returned permutation refer to the positions 
in <A>Omega</A>, even if <A>Omega</A> itself consists of integers.
<P/>
If <A>g</A> does not leave the domain invariant, or does not map the
domain injectively then <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Oper Name="PermutationCycle" Arg='g, Omega, pnt[, act]'/>

<Description>
computes the permutation that represents the cycle of <A>pnt</A> under
the action of the element <A>g</A>.
<Example><![CDATA[
gap> Permutation([[Z(3),-Z(3)],[Z(3),0*Z(3)]],AsList(GF(3)^2));
(2,7,6)(3,4,8)
gap> Permutation((1,2,3)(4,5)(6,7),[4..7]);
(1,2)(3,4)
gap> PermutationCycle((1,2,3)(4,5)(6,7),[4..7],4);
(1,2)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Cycle" Arg='g, Omega, pnt[, act]'/>

<Description>
returns a list of the points in the cycle of <A>pnt</A> under the action
of the element <A>g</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="CycleLength" Arg='g, Omega, pnt[, act]'/>

<Description>
returns the length of the cycle of <A>pnt</A> under the action of the element
<A>g</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Cycles" Arg='g, Omega[, act]'/>

<Description>
returns a list of the cycles (as lists of points) of the action of the
element <A>g</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="CycleLengths" Arg='g, Omega[, act]'/>

<Description>
returns the lengths of all the cycles under the action of the element
<A>g</A> on <A>Omega</A>.
<Example><![CDATA[
gap> Cycle((1,2,3)(4,5)(6,7),[4..7],4);
[ 4, 5 ]
gap> CycleLength((1,2,3)(4,5)(6,7),[4..7],4);
2
gap> Cycles((1,2,3)(4,5)(6,7),[4..7]);
[ [ 4, 5 ], [ 6, 7 ] ]
gap> CycleLengths((1,2,3)(4,5)(6,7),[4..7]);
[ 2, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>CycleIndex</Heading>
<Func Name="CycleIndex" Arg='g, Omega[, act]'
 Label="for a permutation and an action domain"/>
<Func Name="CycleIndex" Arg='G, Omega[, act]'
 Label="for a permutation group and an action domain"/>

<Description>
The <E>cycle index</E> of a permutation <A>g</A> acting on <A>Omega</A>
is defined as
<Display Mode="M">
z(<A>g</A>) = s_1^{{c_1}} s_2^{{c_2}} \cdots s_n^{{c_n}}
</Display>
where <M>c_k</M> is the number of <M>k</M>-cycles in the cycle
decomposition of <A>g</A> and the <M>s_i</M> are indeterminates.
<P/>
The <E>cycle index</E> of a group <A>G</A> is defined as
<Display Mode="M">
Z(<A>G</A>) = \left( \sum_{{g \in <A>G</A>}} z(g) \right) / |<A>G</A>| .
</Display>
<P/>
The indeterminates used by
<Ref Func="CycleIndex" Label="for a permutation and an action domain"/>
are the indeterminates <M>1</M> to <M>n</M> over the rationals
(see&nbsp;<Ref Func="Indeterminate" Label="for a ring (and a number)"/>).
<P/>
<Example><![CDATA[
gap> g:=TransitiveGroup(6,8);
S_4(6c) = 1/2[2^3]S(3)
gap> CycleIndex(g);
1/24*x_1^6+1/8*x_1^2*x_2^2+1/4*x_1^2*x_4+1/4*x_2^3+1/3*x_3^2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tests for Actions">
<Heading>Tests for Actions</Heading>

<ManSection>
<Heading>IsTransitive</Heading>
<Oper Name="IsTransitive" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Prop Name="IsTransitive" Arg='G'
 Label="for a permutation group"/>
<Prop Name="IsTransitive" Arg='xset'
 Label="for an external set"/>

<Description>
returns <K>true</K> if the action implied by the arguments is transitive,
or <K>false</K> otherwise.
<P/>
<Index>transitive</Index>
We say that a  group <A>G</A> acts <E>transitively</E> on a domain
<M>D</M> if and only if for every pair of points <M>d, e \in D</M>
there is an element <M>g</M> in <A>G</A> such that <M>d^g = e</M>.
<P/>
For permutation groups, the syntax <C>IsTransitive(<A>G</A>)</C> is also
permitted and tests whether the group is transitive on the points moved
by it, that is the group <M>\langle (2,3,4),(2,3) \rangle</M>
is transitive (on 3 points).
</Description>
</ManSection>

<ManSection>
<Heading>Transitivity</Heading>
<Oper Name="Transitivity" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group and an action domain"/>
<Attr Name="Transitivity" Arg='xset' Label="for an external set"/>

<Description>
returns the degree <M>k</M> (a non-negative integer) of transitivity of
the action implied by the arguments,
i.e. the largest integer <M>k</M> such that the action is
<M>k</M>-transitive.
If the action is not transitive <C>0</C> is returned.
<P/>
An action is <E><M>k</M>-transitive</E> if every <M>k</M>-tuple of points
can be mapped simultaneously to every other <M>k</M>-tuple.
<Example><![CDATA[
gap> g:=Group((1,3,2),(2,4,3));;
gap> IsTransitive(g,[1..5]);
false
gap> Transitivity(g,[1..4]);
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>RankAction</Heading>
<Oper Name="RankAction" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="RankAction" Arg='xset'
 Label="for an external set"/>

<Description>
returns the rank of a transitive action, i.e. the number of orbits of
the point stabilizer.
<Example><![CDATA[
gap> RankAction(g,Combinations([1..4],2),OnSets);
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>IsSemiRegular</Heading>
<Oper Name="IsSemiRegular" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Prop Name="IsSemiRegular" Arg='xset'
 Label="for an external set"/>

<Description>
returns <K>true</K> if the action implied by the arguments is
semiregular, or <K>false</K> otherwise.
<P/>
<Index>semiregular</Index>
An action is <E>semiregular</E> is the stabilizer of each point is the
identity.
</Description>
</ManSection>

<ManSection>
<Heading>IsRegular</Heading>
<Oper Name="IsRegular" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Prop Name="IsRegular" Arg='xset'
 Label="for an external set"/>

<Description>
returns <K>true</K> if the action implied by the arguments is regular, or
<K>false</K> otherwise.
<P/>
<Index>regular</Index>
An action is <E>regular</E> if it is both semiregular
(see&nbsp;<Ref Func="IsSemiRegular" Label="for a group, an action domain, etc."/>)
and transitive
(see&nbsp;<Ref Prop="IsTransitive" Label="for a group, an action domain, etc."/>).
In this case every point <A>pnt</A> of <A>Omega</A> defines a one-to-one
correspondence between <A>G</A> and <A>Omega</A>.
<Example><![CDATA[
gap> IsSemiRegular(g,Arrangements([1..4],3),OnTuples);
true
gap> IsRegular(g,Arrangements([1..4],3),OnTuples);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Earns</Heading>
<Oper Name="Earns" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="Earns" Arg='xset'
 Label="for an external set"/>

<Description>
returns a list of the elementary abelian regular
(when acting on <A>Omega</A>) normal subgroups of <A>G</A>.
<P/>
At the moment only methods for a primitive group <A>G</A> are implemented.
</Description>
</ManSection>

<ManSection>
<Heading>IsPrimitive</Heading>
<Oper Name="IsPrimitive" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Prop Name="IsPrimitive" Arg='xset'
 Label="for an external set"/>

<Description>
returns <K>true</K> if the action implied by the arguments is primitive,
or <K>false</K> otherwise.
<P/>
<Index>primitive</Index>
An action is <E>primitive</E> if it is transitive and the action admits
no nontrivial block systems. See&nbsp;<Ref Sect="Block Systems"/>.
<Example><![CDATA[
gap> IsPrimitive(g,Orbit(g,(1,2)(3,4)));
true
]]></Example>
</Description>
</ManSection>

<!-- %\declaration{IsFixpointFree} -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Block Systems">
<Heading>Block Systems</Heading>

A <E>block system</E> (system of imprimitivity) for the action of a group
<M>G</M> on an action domain <M>\Omega</M>
is a partition of <M>\Omega</M> which &ndash;as a partition&ndash;
remains invariant under the action of <M>G</M>.

<ManSection>
<Heading>Blocks</Heading>
<Oper Name="Blocks" Arg='G, Omega[, seed][, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="Blocks" Arg='xset[, seed]'
 Label="for an external set"/>

<Description>
computes a block system for the action.
If <A>seed</A> is not given and the action is imprimitive,
a minimal nontrivial block system will be found.
If <A>seed</A> is given, a block system in which <A>seed</A>
is the subset of one block is computed.
The action must be transitive.
<Example><![CDATA[
gap> g:=TransitiveGroup(8,3);
E(8)=2[x]2[x]2
gap> Blocks(g,[1..8]);
[ [ 1, 8 ], [ 2, 3 ], [ 4, 5 ], [ 6, 7 ] ]
gap> Blocks(g,[1..8],[1,4]);
[ [ 1, 4 ], [ 2, 7 ], [ 3, 6 ], [ 5, 8 ] ]
]]></Example>
<P/>
(See Section&nbsp;<Ref Sect="Basic Actions"/>
for information about specific actions.)
</Description>
</ManSection>

<ManSection>
<Heading>MaximalBlocks</Heading>
<Oper Name="MaximalBlocks" Arg='G, Omega[, seed][, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="MaximalBlocks" Arg='xset[, seed]'
 Label="for an external set"/>

<Description>
returns a block system that is maximal (i.e., blocks are maximal with
respect to inclusion) for the action of <A>G</A> on <A>Omega</A>.
If <A>seed</A> is given, a block system is computed in which <A>seed</A>
is a subset of one block.
<Example><![CDATA[
gap> MaximalBlocks(g,[1..8]);
[ [ 1, 2, 3, 8 ], [ 4, 5, 6, 7 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>RepresentativesMinimalBlocks</Heading>
<Oper Name="RepresentativesMinimalBlocks"
 Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="RepresentativesMinimalBlocks" Arg='xset'
 Label="for an external set"/>

<Description>
computes a list of block representatives for all minimal (i.e blocks are
minimal with respect to inclusion) nontrivial block systems for the
action. 
<Example><![CDATA[
gap> RepresentativesMinimalBlocks(g,[1..8]);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 1, 7 ], 
  [ 1, 8 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AllBlocks" Arg='G'/>

<Description>
computes a list of representatives of all block systems for a
permutation group <A>G</A> acting transitively on the points moved by the
group.
<Example><![CDATA[
gap> AllBlocks(g);
[ [ 1, 8 ], [ 1, 2, 3, 8 ], [ 1, 4, 5, 8 ], [ 1, 6, 7, 8 ], [ 1, 3 ], 
  [ 1, 3, 5, 7 ], [ 1, 3, 4, 6 ], [ 1, 5 ], [ 1, 2, 5, 6 ], [ 1, 2 ], 
  [ 1, 2, 4, 7 ], [ 1, 4 ], [ 1, 7 ], [ 1, 6 ] ]
]]></Example>
<P/>
The stabilizer of a block can be computed via the action
<Ref Func="OnSets"/>:
<P/>
<Example><![CDATA[
gap> Stabilizer(g,[1,8],OnSets);
Group([ (1,8)(2,3)(4,5)(6,7) ])
]]></Example>
<P/>
If <C>bs</C> is a partition of the action domain, given as a set of sets,
the stabilizer under the action <Ref Func="OnSetsDisjointSets"/> returns
the largest subgroup which preserves <C>bs</C> as a block system.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4,5,6,7,8),(1,2));;
gap> bs:=[[1,2,3,4],[5,6,7,8]];;
gap> Stabilizer(g,bs,OnSetsDisjointSets);
Group([ (6,7), (5,6), (5,8), (2,3), (3,4)(5,7), (1,4), 
  (1,5,4,8)(2,6,3,7) ])
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="External Sets">
<Heading>External Sets</Heading>

<Index Key="G-sets"><M>G</M>-sets</Index>
When considering group actions,
sometimes the concept of a <E><M>G</M>-set</E> is used.
This is a set <M>\Omega</M> endowed with an action of <M>G</M>.
The elements of the <M>G</M>-set are the same as those of <M>\Omega</M>,
however concepts like equality and equivalence of <M>G</M>-sets do not only
consider the underlying domain <M>\Omega</M> but the group action as well.
<P/>
This concept is implemented in &GAP; via <E>external sets</E>.
<P/>
The constituents of an external set are stored in the attributes
<Ref Func="ActingDomain"/>, <Ref Func="FunctionAction"/> and
<Ref Func="HomeEnumerator"/>.
<P/>
Most operations for actions are applicable as an attribute for an external
set.
<P/>
The most prominent external subsets are orbits,
see <Ref Func="ExternalOrbit"/>.
<P/>
Many subsets of a group, such as conjugacy classes or cosets
(see&nbsp;<Ref Func="ConjugacyClass"/> and <Ref Func="RightCoset"/>)
are implemented as external orbits.
<P/>
External sets also are implicitly underlying action homomorphisms,
see <Ref Func="UnderlyingExternalSet"/>
and <Ref Func="SurjectiveActionHomomorphismAttr"/>.

<ManSection>
<Filt Name="IsExternalSet" Arg='obj' Type='Category'/>

<Description>
An <E>external set</E> specifies a group action
<M>\mu: \Omega \times G \mapsto \Omega</M> of a group <M>G</M>
on a domain <M>\Omega</M>. The external set knows the group,
the domain and the actual acting function.
Mathematically, an external set is the set&nbsp;<M>\Omega</M>,
which is endowed with the action of a group <M>G</M> via the group action
<M>\mu</M>.
For this reason &GAP; treats an external set as a domain whose elements
are the  elements of <M>\Omega</M>.
An external set is always a union of orbits.
Currently the domain&nbsp;<M>\Omega</M> must always be finite.
If <M>\Omega</M> is not a list,
an enumerator for <M>\Omega</M> is automatically chosen,
see <Ref Func="Enumerator"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExternalSet" Arg='G, Omega[, gens, acts][, act]'/>

<Description>
creates the external set for the action <A>act</A> of <A>G</A> on <A>Omega</A>.
<A>Omega</A> can be either a proper set, or a domain which is represented as
described in <Ref Sect="Domains"/> and <Ref Chap="Collections"/>, or (to use
less memory but with a slower performance) an enumerator 
(see <Ref Attr="Enumerator"/> ) of this domain.
<Example><![CDATA[
gap> g:=Group((1,2,3),(2,3,4));;
gap> e:=ExternalSet(g,[1..4]);
<xset:[ 1, 2, 3, 4 ]>
gap> e:=ExternalSet(g,g,OnRight);
<xset:[ (), (2,3,4), (2,4,3), (1,2)(3,4), (1,2,3), (1,2,4), (1,3,2), 
  (1,3,4), (1,3)(2,4), (1,4,2), (1,4,3), (1,4)(2,3) ]>
gap> Orbits(e);
[ [ (), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3), (2,4,3), (1,4,2), 
      (1,2,3), (1,3,4), (2,3,4), (1,3,2), (1,4,3), (1,2,4) ] ]
]]></Example>

</Description>
</ManSection>

<ManSection>
<Attr Name="ActingDomain" Arg='xset'/>

<Description>
This attribute returns the group with which the external set <A>xset</A> was
defined.
</Description>
</ManSection>

<ManSection>
<Attr Name="FunctionAction" Arg='xset'/>

<Description>
is the acting function with which the external set <A>xset</A> was
defined.
</Description>
</ManSection>

<ManSection>
<Attr Name="HomeEnumerator" Arg='xset'/>

<Description>
returns an enumerator of the action domain with which the external set
<A>xset</A> was defined.
For external subsets, this is in general different from the
<Ref Func="Enumerator"/> value of <A>xset</A>,
which enumerates only the subset.
<Example><![CDATA[
gap> ActingDomain(e);
Group([ (1,2,3), (2,3,4) ])
gap> FunctionAction(e)=OnRight;
true
gap> HomeEnumerator(e);
[ (), (2,3,4), (2,4,3), (1,2)(3,4), (1,2,3), (1,2,4), (1,3,2), 
  (1,3,4), (1,3)(2,4), (1,4,2), (1,4,3), (1,4)(2,3) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsExternalSubset" Arg='obj' Type='Representation'/>

<Description>
An external subset is the restriction  of an external  set to a subset
of the domain (which must be invariant under the action). It is again an
external set.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExternalSubset" Arg='G,xset,start,[gens,acts,]act'/>

<Description>
constructs the external subset of <A>xset</A> on the union of orbits of the
points in <A>start</A>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsExternalOrbit" Arg='obj' Type='Representation'/>

<Description>
An external orbit is an external subset consisting of one orbit.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExternalOrbit" Arg='G, Omega, pnt, [gens,acts,] act'/>

<Description>
constructs the external subset on the orbit of <A>pnt</A>. The
<Ref Func="Representative"/> value of this external set is <A>pnt</A>.
<Example><![CDATA[
gap> e:=ExternalOrbit(g,g,(1,2,3));
(1,2,3)^G
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="StabilizerOfExternalSet" Arg='xset'/>

<Description>
computes the stabilizer of the <Ref Func="Representative"/> value of
the external set <A>xset</A>.
The stabilizer will have the acting group of <A>xset</A> as its parent.
<Example><![CDATA[
gap> Representative(e);
(1,2,3)
gap> StabilizerOfExternalSet(e);
Group([ (1,2,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>ExternalOrbits</Heading>
<Oper Name="ExternalOrbits" Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="ExternalOrbits" Arg='xset'
 Label="for an external set"/>

<Description>
computes a list of external orbits that give the orbits of <A>G</A>.
<Example><![CDATA[
gap> ExternalOrbits(g,AsList(g));
[ ()^G, (2,3,4)^G, (2,4,3)^G, (1,2)(3,4)^G ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>ExternalOrbitsStabilizers</Heading>
<Oper Name="ExternalOrbitsStabilizers"
 Arg='G, Omega[, gens, acts][, act]'
 Label="for a group, an action domain, etc."/>
<Attr Name="ExternalOrbitsStabilizers" Arg='xset'
 Label="for an external set"/>

<Description>
In addition to
<Ref Func="ExternalOrbits" Label="for a group, an action domain, etc."/>,
this operation also computes the stabilizers of the representatives of
the external orbits at the same time.
(This can be quicker than computing the
<Ref Func="ExternalOrbits" Label="for a group, an action domain, etc."/>
value first and the stabilizers afterwards.)
<Example><![CDATA[
gap> e:=ExternalOrbitsStabilizers(g,AsList(g));
[ ()^G, (2,3,4)^G, (2,4,3)^G, (1,2)(3,4)^G ]
gap> HasStabilizerOfExternalSet(e[3]);
true
gap> StabilizerOfExternalSet(e[3]);
Group([ (2,4,3) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CanonicalRepresentativeOfExternalSet" Arg='xset'/>

<Description>
The canonical representative of an external set <A>xset</A> may only
depend on the defining attributes <A>G</A>, <A>Omega</A>, <A>act</A>
of <A>xset</A> and (in the case of external subsets)
<C>Enumerator( <A>xset</A> )</C>.
It must <E>not</E> depend, e.g., on the representative of an external
orbit.
&GAP; does not know methods for arbitrary external sets to compute a
canonical representative,
see <Ref Func="CanonicalRepresentativeDeterminatorOfExternalSet"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CanonicalRepresentativeDeterminatorOfExternalSet" Arg='xset'/>

<Description>
returns a function that takes as its arguments the acting group and a
point.
This function returns a list of length 1 or 3,
the first entry being the canonical representative and the other entries
(if bound) being the stabilizer of the canonical representative and a
conjugating element, respectively.
An external set is only guaranteed to be able to compute a canonical
representative if it has a
<Ref Func="CanonicalRepresentativeDeterminatorOfExternalSet"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ActorOfExternalSet" Arg='xset'/>

<Description>
returns an element mapping <C>Representative(<A>xset</A>)</C> to
<C>CanonicalRepresentativeOfExternalSet(<A>xset</A>)</C> under the given
action.
<Example><![CDATA[
gap> u:=Subgroup(g,[(1,2,3)]);;
gap> e:=RightCoset(u,(1,2)(3,4));;
gap> CanonicalRepresentativeOfExternalSet(e);
(2,4,3)
gap> ActorOfExternalSet(e);
(1,3,2)
gap> FunctionAction(e)((1,2)(3,4),last);
(2,4,3)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingExternalSet" Arg='acthom'/>

<Description>
The underlying set of an action homomorphism <A>acthom</A> is
the external set on which it was defined.
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));;
gap> hom:=ActionHomomorphism(g,Arrangements([1..4],3),OnTuples);;
gap> s:=UnderlyingExternalSet(hom);
<xset:[[ 1, 2, 3 ],[ 1, 2, 4 ],[ 1, 3, 2 ],[ 1, 3, 4 ],[ 1, 4, 2 ],
[ 1, 4, 3 ],[ 2, 1, 3 ],[ 2, 1, 4 ],[ 2, 3, 1 ],[ 2, 3, 4 ],
[ 2, 4, 1 ],[ 2, 4, 3 ],[ 3, 1, 2 ],[ 3, 1, 4 ],[ 3, 2, 1 ], ...]>
gap> Print(s,"\n");
[ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 2 ], [ 1, 3, 4 ], [ 1, 4, 2 ], 
  [ 1, 4, 3 ], [ 2, 1, 3 ], [ 2, 1, 4 ], [ 2, 3, 1 ], [ 2, 3, 4 ], 
  [ 2, 4, 1 ], [ 2, 4, 3 ], [ 3, 1, 2 ], [ 3, 1, 4 ], [ 3, 2, 1 ], 
  [ 3, 2, 4 ], [ 3, 4, 1 ], [ 3, 4, 2 ], [ 4, 1, 2 ], [ 4, 1, 3 ], 
  [ 4, 2, 1 ], [ 4, 2, 3 ], [ 4, 3, 1 ], [ 4, 3, 2 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SurjectiveActionHomomorphismAttr" Arg='xset'/>

<Description>
returns an action homomorphism for the external set <A>xset</A>
which is surjective.
(As the <Ref Func="Image" Label="set of images of the source of a general mapping"/>
value of this homomorphism has to be computed
to obtain the range, this may take substantially longer
than <Ref Func="ActionHomomorphism" Label="for an external set"/>.)
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  permutat.msk                GAP documentation            Martin Schönert -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: permutat.msk,v 1.15 2002/04/15 10:02:33 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Permutations">
<Heading>Permutations</Heading>

&GAP; offers a data type <E>permutation</E> to describe the elements
of permutation groups.
<P/>
The points on which permutations in &GAP; act are the positive
integers up to a certain architecture dependent limit,
and the image of a point <M>i</M> under a permutation <M>p</M> is written
<M>i^p</M>, which is expressed as <M>i</M><C>^</C><M>p</M> in &GAP;.
(This action is also implemented by the function <Ref Func="OnPoints"/>.)
If <M>i</M><C>^</C><M>p</M> is different from <M>i</M>,
we say that <M>i</M> is <E>moved</E> by&nbsp;<M>p</M>,
otherwise it is <E>fixed</E>.
Permutations in &GAP; are  entered and displayed in cycle notation,
such as <C>(1,2,3)(4,5)</C>.
<P/>
The preimage of the point <M>i</M> under the permutation <M>p</M> can be
computed as <M>i</M><C>/</C><M>p</M>,
without constructing the inverse of <M>p</M>.
<P/>
For arithmetic operations for permutations and their precedence,
see&nbsp;<Ref Sect="Arithmetic Operations for Elements"/>.
<P/>
In the names of the &GAP; functions that deal with permutations,
the word <Q>Permutation</Q> is usually abbreviated to <Q>Perm</Q>,
to save typing.
For example,
the category test function for permutations is <Ref Func="IsPerm"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsPerm">
<Heading>IsPerm (Filter)</Heading>

Internally, &GAP; stores a permutation as a list of the <M>d</M> images
of the integers <M>1, \ldots, d</M>, where the <Q>internal degree</Q>
<M>d</M> is the largest integer moved by the permutation or bigger.
When a permutation is read in in cycle notation, <M>d</M> is always set
to the largest moved integer, but a bigger <M>d</M> can result from a
multiplication of two permutations, because the product is not shortened
if it fixes&nbsp;<M>d</M>.
The images are stored all as <M>16</M>-bit integers or all as
<M>32</M>-bit integers, depending on whether <M>d \leq 65536</M> or not.
For example, if <M>m\geq 65536</M>, the permutation 
<M>(1, 2, \ldots, m)</M> has internal degree <M>d=m</M> and takes
<M>4m</M> bytes of memory for storage. But --- since the internal degree
is not reduced  --- this
means that the identity permutation <C>()</C> calculated as
<M>(1, 2, \ldots, m) * (1, 2, \ldots, m)^{{-1}}</M> also
takes <M>4m</M> bytes of storage.
It can take even more because the internal list has sometimes room for
more than <M>d</M> images.
<P/>
The operation <Ref Func="RestrictedPerm"/> reduces the storage degree of
its result and therefore can be used to save memory if intermediate
calculations in large degree result in a small degree result.
<P/>
Permutations do not belong to a specific group.
That means that one can work with permutations without defining
a permutation group that contains them.
<P/>
<Example><![CDATA[
gap> (1,2,3);
(1,2,3)
gap> (1,2,3) * (2,3,4);
(1,3)(2,4)
gap> 17^(2,5,17,9,8);
9
gap> OnPoints(17,(2,5,17,9,8));
9
]]></Example>
<P/>
The operation <Ref Func="Permuted"/> can be used to permute the entries
of a list according to a permutation.

<ManSection>
<Filt Name="IsPerm" Arg='obj' Type='Category'/>

<Description>
Each <E>permutation</E> in &GAP; lies in the category
<Ref Func="IsPerm"/>.
Basic operations for permutations are
<Ref Func="LargestMovedPoint" Label="for a permutation"/>,
multiplication of two permutations via <C>*</C>,
and exponentiation <C>^</C> with first argument a positive integer
<M>i</M> and second argument a permutation <M>\pi</M>,
the result being the image <M>i^{\pi}</M> of the point <M>i</M>
under <M>\pi</M>.
<!-- other arith. ops.?-->
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPermCollection" Arg='obj' Type='Category'/>
<Filt Name="IsPermCollColl" Arg='obj' Type='Category'/>

<Description>
are the categories for collections of permutations and collections of
collections of permutations, respectively.
</Description>
</ManSection>

<ManSection>
<Var Name="PermutationsFamily"/>

<Description>
is the family of all permutations.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Permutations">
<Heading>Comparison of Permutations</Heading>

<ManSection>
<Meth Name="\=" Arg='p1, p2' Label="for permutations"/>
<Meth Name="\&lt;" Arg='p1, p2' Label="for permutations"/>

<Description>
<Index Subkey="for permutations">equality test</Index>
<Index Subkey="for permutations">precedence test</Index>
Two permutations are equal if they move the same points and all these points
have the same images under both permutations.
<P/>
The permutation <A>p1</A> is smaller than <A>p2</A>
if <A>p1</A> <M>\neq</M> <A>p2</A>
and <M>i^{{<A>p1</A>}} &lt; i^{{<A>p2</A>}}</M>,
where <M>i</M> is the smallest point with
<M>i^{{<A>p1</A>}} \neq i^{{<A>p2</A>}}</M>.
Therefore the identity permutation is the smallest permutation,
see also Section&nbsp;<Ref Sect="Comparison Operations for Elements"/>.
<P/>
Permutations can be compared with certain other &GAP; objects,
see&nbsp;<Ref Sect="Comparisons"/> for the details.
<P/>
<Example><![CDATA[
gap> (1,2,3) = (2,3,1);
true
gap> (1,2,3) * (2,3,4) = (1,3)(2,4);
true
gap> (1,2,3) < (1,3,2);      # 1^(1,2,3) = 2 < 3 = 1^(1,3,2)
true
gap> (1,3,2,4) < (1,3,4,2);  # 2^(1,3,2,4) = 4 > 1 = 2^(1,3,4,2)
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DistancePerms" Arg="perm1, perm2"/>

<Description>
returns the number of points for which <A>perm1</A> and <A>perm2</A> 
have different images. This should always produce the same result as
<C>NrMovePoints(<A>perm1</A>/<A>perm2</A>)</C> but some methods may be
much faster than this form, since no new permutation needs to be created.
</Description>
</ManSection>

<ManSection>
<Func Name="SmallestGeneratorPerm" Arg='perm'/>

<Description>
is the smallest permutation that generates the same cyclic group
as the permutation <A>perm</A>.
This is very efficient, even when <A>perm</A> has large order.
<Example><![CDATA[
gap> SmallestGeneratorPerm( (1,4,3,2) );
(1,2,3,4)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Moved Points of Permutations">
<Heading>Moved Points of Permutations</Heading>

<ManSection>
<Attr Name="SmallestMovedPoint" Arg='perm' Label="for a permutation"/>
<Attr Name="SmallestMovedPoint" Arg='C'
 Label="for a list or collection of permutations"/>

<Description>
is the smallest positive integer that is moved by <A>perm</A>
if such an integer exists, and <Ref Var="infinity"/> if
<A>perm</A> is the identity.
For <A>C</A> a collection or list of permutations,
the smallest value of
<Ref Func="SmallestMovedPoint" Label="for a permutation"/> for the
elements of <A>C</A> is returned
(and <Ref Var="infinity"/> if <A>C</A> is empty).
</Description>
</ManSection>

<ManSection>
<Attr Name="LargestMovedPoint" Arg='perm' Label="for a permutation"/>
<Attr Name="LargestMovedPoint" Arg='C'
 Label="for a list or collection of permutations"/>

<Description>
For a permutation <A>perm</A>, this attribute contains
the largest positive integer which is moved by <A>perm</A>
if such an integer exists, and <C>0</C> if <A>perm</A> is the identity.
For <A>C</A> a collection or list of permutations,
the largest value of
<Ref Func="LargestMovedPoint" Label="for a permutation"/> for the
elements of <A>C</A> is returned (and <C>0</C> if <A>C</A> is empty).
</Description>
</ManSection>

<ManSection>
<Attr Name="MovedPoints" Arg='perm' Label="for a permutation"/>
<Attr Name="MovedPoints" Arg='C'
 Label="for a list or collection of permutations"/>

<Description>
is the proper set of the positive integers moved by at least one
permutation in the collection <A>C</A>, respectively by the permutation
<A>perm</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="NrMovedPoints" Arg='perm' Label="for a permutation"/>
<Attr Name="NrMovedPoints" Arg='C'
 Label="for a list or collection of permutations"/>

<Description>
is the number of positive integers that are moved by <A>perm</A>,
respectively by at least one element in the collection <A>C</A>.
(The actual moved points are returned by
<Ref Func="MovedPoints" Label="for a permutation"/>.)
<Example><![CDATA[
gap> SmallestMovedPointPerm((4,5,6)(7,2,8));
2
gap> LargestMovedPointPerm((4,5,6)(7,2,8));
8
gap> NrMovedPointsPerm((4,5,6)(7,2,8));
6
gap> MovedPoints([(2,3,4),(7,6,3),(5,47)]);
[ 2, 3, 4, 5, 6, 7, 47 ]
gap> NrMovedPoints([(2,3,4),(7,6,3),(5,47)]);
7
gap> SmallestMovedPoint([(2,3,4),(7,6,3),(5,47)]);
2
gap> LargestMovedPoint([(2,3,4),(7,6,3),(5,47)]);
47
gap> LargestMovedPoint([()]);
0
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sign and Cycle Structure">
<Heading>Sign and Cycle Structure</Heading>

<ManSection>
<Attr Name="SignPerm" Arg='perm'/>

<Description>
The <E>sign</E> of a permutation <A>perm</A> is defined as <M>(-1)^k</M>
where <M>k</M> is the number of cycles of <A>perm</A> of even length.
<P/>
The sign is a homomorphism from the symmetric group onto the
multiplicative  group <M>\{ +1, -1 \}</M>,
the kernel of which is the alternating group.
</Description>
</ManSection>

<ManSection>
<Attr Name="CycleStructurePerm" Arg='perm'/>

<Description>
is the cycle structure (i.e. the numbers of cycles of different lengths)
of the permutation <A>perm</A>.
This is encoded in a list <M>l</M> in the following form:
The <M>i</M>-th entry of <M>l</M> contains the number of cycles of
<A>perm</A> of length <M>i+1</M>.
If <A>perm</A> contains no cycles of length <M>i+1</M> it is not
bound.
Cycles of length 1 are ignored.
<Example><![CDATA[
gap> SignPerm((1,2,3)(4,5));
-1
gap> CycleStructurePerm((1,2,3)(4,5,9,7,8));
[ , 1,, 1 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Permutations">
<Heading>Creating Permutations</Heading>

<ManSection>
<Func Name="ListPerm" Arg='perm[, length]'/>

<Description>
is a list <M>l</M> that contains the images of the positive integers
under the permutation <A>perm</A>.
That means that
<M>l</M><C>[</C><M>i</M><C>]</C> <M>= i</M><C>^</C><A>perm</A>,
where <M>i</M> lies between 1
and the largest point moved by <A>perm</A>
(see&nbsp;<Ref Func="LargestMovedPoint" Label="for a permutation"/>).
<P/>
An optional second argument specifies the length of the desired list.
</Description>
</ManSection>

<ManSection>
<Func Name="PermList" Arg='list'/>

<Description>
is the permutation <M>\pi</M> that moves points as described by the
list <A>list</A>.
That means that <M>i^{\pi} =</M> <A>list</A><C>[</C><M>i</M><C>]</C> if
<M>i</M> lies between <M>1</M> and the length of <A>list</A>,
and <M>i^{\pi} = i</M> if <M>i</M> is
larger than the length of the list <A>list</A>.
<Ref Func="PermList"/> will return <K>fail</K> 
if <A>list</A> does not define a permutation,
i.e., if <A>list</A> is not dense,
or if <A>list</A> contains a positive integer twice,
or if <A>list</A> contains an
integer not in the range <C>[ 1 .. Length( <A>list</A> ) ]</C>.
If <A>list</A> contains non-integer entries an error is raised.
</Description>
</ManSection>

<ManSection>
<Func Name="MappingPermListList" Arg='src, dst'/>

<Description>
Let <A>src</A> and <A>dst</A> be lists of positive integers of the same
length, such that neither may contain an element twice.
<Ref Func="MappingPermListList"/> returns a permutation <M>\pi</M> such
that <A>src</A><C>[</C><M>i</M><C>]^</C><M>\pi =</M>
<A>dst</A><C>[</C><M>i</M><C>]</C>.
The permutation <M>\pi</M> fixes all points larger than the maximum of
the entries in <A>src</A> and <A>dst</A>.
If there are several such permutations, it is not specified which of them
<Ref Func="MappingPermListList"/> returns.
</Description>
</ManSection>

<ManSection>
<Oper Name="RestrictedPerm" Arg='perm, list'/>
<Oper Name="RestrictedPermNC" Arg='perm, list'/>

<Description>
<Ref Func="RestrictedPerm"/> returns the new permutation
that acts on the points in the list <A>list</A> in the same way as
the permutation <A>perm</A>,
and that fixes those points that are not in <A>list</A>. The resulting
permutation is stored internally of degree given by the maximal entry of
<A>list</A>.
<A>list</A> must be a list of positive integers such that for each
<M>i</M> in <A>list</A> the image <M>i</M><C>^</C><A>perm</A> is also in
<A>list</A>,
i.e., <A>list</A> must be the union of cycles of <A>perm</A>.
<P/>
<Ref Func="RestrictedPermNC"/> does not check whether <A>list</A>
is a union of cycles.
<P/>
<Example><![CDATA[
gap> ListPerm((3,4,5));
[ 1, 2, 4, 5, 3 ]
gap> PermList([1,2,4,5,3]);
(3,4,5)
gap> MappingPermListList([2,5,1,6],[7,12,8,2]);
(1,8,5,12,11,10,9,6,2,7,4,3)
gap> RestrictedPerm((1,2)(3,4),[3..5]);
(3,4)
]]></Example>
</Description>
</ManSection>


<ManSection>
  <Oper Name="AsPermutation" Arg="f"/>
  <Returns>A permutation or <K>fail</K>.</Returns>
  <Description>
    Partial permutations and transformations which define permutations
    (mathematically) can be converted into &GAP; permutations using
    <C>AsPermutation</C>; see Chapters <Ref Chap="Transformations"/> and 
    <Ref Chap="Partial permutations"/> for more details about transformations
    and partial permutations.

    <List>
      <Mark>for partial permutations</Mark>
      <Item>
        If the partial permutation <A>f</A> is a permutation of its image, then
        <C>AsPermutation</C> returns this permutation.  If <A>f</A> does not
        permute its image, then <K>fail</K> is returned. <P/>
      </Item>
    
      <Mark>for transformations</Mark>
      <Item>
        A transformation is a permutation if and only if its rank equals its
        degree. If a transformation in &GAP; is a permutation, then
        <C>AsPermutation</C> returns this permutation.  If <A>f</A> is not a
        permutation, then <K>fail</K> is returned. 
      </Item>
    </List>

    The function 
    <Ref Func="Permutation" Label="for a group, an action domain, etc."/> can
    also be used to convert partial permutations and transformations into
    permutations where appropriate.
    <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
> [ 2, 7, 9, 4, 1, 10, 5, 6, 3, 8 ] );
(1,2,7,5)(3,9)(4)(6,10,8)
gap> AsPermutation(f);
(1,2,7,5)(3,9)(6,10,8)
gap> f:= PartialPerm( [ 1, 2, 3, 4, 5, 7, 8 ], [ 5, 3, 8, 1, 9, 4, 10 ] );
[2,3,8,10][7,4,1,5,9]
gap> AsPermutation(f);
fail
gap> f:=Transformation( [ 5, 8, 3, 5, 8, 6, 2, 2, 7, 8 ] );;
gap> AsPermutation(f);
fail  
gap> f:=Transformation( [ 1, 3, 6, 6, 2, 10, 2, 3, 10, 5 ] );;
gap> AsPermutation(f);
fail
gap> f:=Transformation( [ 2, 7, 9, 4, 1, 10, 5, 6, 3, 8 ] );
Transformation( [ 2, 7, 9, 4, 1, 10, 5, 6, 3, 8 ] )
gap> AsPermutation(f);
(1,2,7,5)(3,9)(6,10,8)</Example>
    </Description>
  </ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grpperm.msk                 GAP documentation            Alexander Hulpke -->
<!-- %A                                                           Heiko Theißen -->
<!-- %A                                                           Ákos Seress -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grpperm.msk,v 1.39 2003/10/28 04:55:03 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Permutation Groups">
<Heading>Permutation Groups</Heading>

<!-- %%  The code for the computation and verification stabilizer chains, for -->
<!-- %%  composition series and the radical is due to \Ákos Seress. -->
<!-- %%  Heiko Theißen wrote the backtrack routines which are used to compute for -->
<!-- %%  example centralizers, normalizers and conjugating elements. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsPermGroup">
<Heading>IsPermGroup (Filter)</Heading>

<ManSection>
<Filt Name="IsPermGroup" Arg='obj' Type='Category'/>

<Description>
A permutation group is a group of permutations on a finite set
<M>\Omega</M> of positive integers.
&GAP; does <E>not</E> require the user to specify the operation domain
<M>\Omega</M> when a permutation group is defined.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
]]></Example>
<P/>
Permutation groups are groups and therefore all operations for groups
(see Chapter&nbsp;<Ref Chap="Groups"/>) can be applied to them.
In many cases special methods are installed for permutation groups
that make computations more effective.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Natural Action">
<Heading>The Natural Action</Heading>

The functions
<Ref Func="MovedPoints" Label="for a list or collection of permutations"/>,
<Ref Func="NrMovedPoints" Label="for a list or collection of permutations"/>,
<Ref Func="LargestMovedPoint" Label="for a list or collection of permutations"/>,
and
<Ref Func="SmallestMovedPoint" Label="for a list or collection of permutations"/>
are defined for arbitrary collections of
permutations (see&nbsp;<Ref Sect="Moved Points of Permutations"/>),
in particular they can be applied to permutation groups.
<Example><![CDATA[
gap> g:= Group( (2,3,5,6), (2,3) );;
gap> MovedPoints( g );  NrMovedPoints( g );
[ 2, 3, 5, 6 ]
4
gap> LargestMovedPoint( g );  SmallestMovedPoint( g );
6
2
]]></Example>
<P/>
The action of a permutation group on the positive integers is a group
action (via the acting function <Ref Func="OnPoints"/>).
Therefore all action functions can be applied
(see the Chapter&nbsp;<Ref Chap="Group Actions"/>),
for example <Ref Func="Orbit"/>, <Ref Func="Stabilizer"/>,
<Ref Func="Blocks" Label="for a group, an action domain, etc."/>,
<Ref Func="IsTransitive" Label="for a group, an action domain, etc."/>,
<Ref Func="IsPrimitive" Label="for a group, an action domain, etc."/>.
<P/>
If one has a list of group generators and is interested in the moved points
(see above) or orbits, it may be useful to avoid the explicit construction
of the group for efficiency reasons.
For the special case of the action of permutations on positive integers
via <C>^</C>,
the functions <Ref Func="OrbitPerms"/> and <Ref Func="OrbitsPerms"/>
are provided for this purpose.
<P/>
Similarly, several functions concerning the natural action of
permutation groups address stabilizer chains
(see&nbsp;<Ref Sect="Stabilizer Chains"/>)
rather than permutation groups themselves,
for example <Ref Func="BaseStabChain"/>.

<ManSection>
<Func Name="OrbitPerms" Arg='perms, pnt'/>

<Description>
returns the orbit of the positive integer <A>pnt</A>
under the group generated by the permutations in the list <A>perms</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="OrbitsPerms" Arg='perms, D'/>

<Description>
returns the list of orbits of the positive integers in the list <A>D</A>
under the group generated by the permutations in the list <A>perms</A>.
<Example><![CDATA[
gap> OrbitPerms( [ (1,2,3)(4,5), (3,6) ], 1 );
[ 1, 2, 3, 6 ]
gap> OrbitsPerms( [ (1,2,3)(4,5), (3,6) ], [ 1 .. 6 ] );
[ [ 1, 2, 3, 6 ], [ 4, 5 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Computing a Permutation Representation">
<Heading>Computing a Permutation Representation</Heading>

<ManSection>
<Attr Name="IsomorphismPermGroup" Arg='G'/>

<Description>
returns an isomorphism from the group <A>G</A> onto a permutation group
which is isomorphic to <A>G</A>.
The method will select a suitable permutation representation.
<Example><![CDATA[
gap> g:=SmallGroup(24,12);
<pc group of size 24 with 4 generators>
gap> iso:=IsomorphismPermGroup(g);
<action isomorphism>
gap> Image(iso,g.3*g.4);
(1,12)(2,16)(3,19)(4,5)(6,22)(7,8)(9,23)(10,11)(13,24)(14,15)(17,
18)(20,21)
]]></Example>
<P/>
In many cases the permutation representation constructed by
<Ref Func="IsomorphismPermGroup"/> is regular.
</Description>
</ManSection>

<ManSection>
<Func Name="SmallerDegreePermutationRepresentation" Arg='G'/>

<Description>
Let <A>G</A> be a permutation group that acts transitively
on its moved points.
<Ref Func="SmallerDegreePermutationRepresentation"/> tries to find a
faithful permutation representation of smaller degree.
The result is a group homomorphism onto a permutation group,
in the worst case this is the identity mapping on <A>G</A>.
<P/>
If the <C>cheap</C> option is given, the function only tries to reduce
to orbits or actions on blocks, otherwise also actions on cosets of
random subgroups are tried.
<P/>
Note that the result is not guaranteed to be a faithful permutation
representation of smallest degree,
or of smallest degree among the transitive permutation representations
of <A>G</A>.
Using &GAP; interactively, one might be able to choose subgroups
of small index for which the cores intersect trivially;
in this case, the actions on the cosets of these subgroups give rise to
an intransitive permutation representation
the degree of which may be smaller than the original degree.
<P/>
The methods used might involve the use of random elements and the
permutation representation (or even the degree of the representation) is
not guaranteed to be the same for different calls of
<Ref Func="SmallerDegreePermutationRepresentation"/>.
<P/>
If the option cheap is given less work is spent on trying to get a small
degree representation, if the value of this option is set to the string 
"skip" the identity mapping is returned. (This is useful if a function
called internally might try a degree reduction.)
<P/>
<Example><![CDATA[
gap> image:= Image( iso );;  NrMovedPoints( image );
24
gap> small:= SmallerDegreePermutationRepresentation( image );;
gap> Image( small );
Group([ (2,3), (2,3,4), (1,2)(3,4), (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>


<Example><![CDATA[
gap> p:=Group((1,2,3,4,5,6),(1,2));;p:=Action(p,AsList(p),OnRight);;
gap> Length(MovedPoints(p));
720
gap> q:=SmallerDegreePermutationRepresentation(p);;
gap> NrMovedPoints(Image(q));
6
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Symmetric and Alternating Groups">
<Heading>Symmetric and Alternating Groups</Heading>

The commands <Ref Func="SymmetricGroup" Label="for a degree"/> and
<Ref Func="AlternatingGroup" Label="for a degree"/>
(see Section&nbsp;<Ref Sect="Basic Groups"/>)
construct symmetric and alternating permutation groups.
&GAP; can also detect whether a given permutation group is a symmetric
or alternating group on the set of its moved points;
if so then the group is called a <E>natural</E> symmetric or alternating
group, respectively.
<P/>
The functions <Ref Func="IsSymmetricGroup"/> and
<Ref Func="IsAlternatingGroup"/> can be used to check whether a given group
(not necessarily a permutation group)
is isomorphic to a symmetric or alternating group.
<P/>

<ManSection>
<Prop Name="IsNaturalSymmetricGroup" Arg='group'/>
<Prop Name="IsNaturalAlternatingGroup" Arg='group'/>

<Description>
A group is a natural symmetric or alternating group if it is
a permutation group acting as symmetric or alternating group,
respectively, on its moved points.
<P/>
For groups that are known to be natural symmetric or natural alternating
groups, very efficient methods for computing membership,
conjugacy classes, Sylow subgroups etc.&nbsp;are used.
<P/>
<Example><![CDATA[
gap> g:=Group((1,5,7,8,99),(1,99,13,72));;
gap> IsNaturalSymmetricGroup(g);
true
gap> g;
Sym( [ 1, 5, 7, 8, 13, 72, 99 ] )
gap> IsNaturalSymmetricGroup( Group( (1,2)(4,5), (1,2,3)(4,5,6) ) );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSymmetricGroup" Arg='group'/>

<Description>
is <K>true</K> if the group <A>group</A> is isomorphic to a
symmetric group.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAlternatingGroup" Arg='group'/>

<Description>
is <K>true</K> if the group <A>group</A> is isomorphic to a
alternating group.
</Description>
</ManSection>

<ManSection>
<Attr Name="SymmetricParentGroup" Arg='grp'/>

<Description>
For a permutation group <A>grp</A> this function returns the symmetric
group that moves the same points as <A>grp</A> does.
<Example><![CDATA[
gap> SymmetricParentGroup( Group( (1,2), (4,5), (7,8,9) ) );
Sym( [ 1, 2, 4, 5, 7, 8, 9 ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Primitive Groups">
<Heading>Primitive Groups</Heading>

<ManSection>
<Attr Name="ONanScottType" Arg='G'/>

<Description>
returns the type of a primitive permutation group <A>G</A>,
according to the O'Nan-Scott classification.
The labelling of the different types is not consistent in the literature,
we use the following identifications. The two-letter code given is the
name of the type as used by Praeger.
<List>
<Mark>1</Mark>
<Item>
 Affine. (HA)
</Item>
<Mark>2</Mark>
<Item>
 Almost simple. (AS)
</Item>
<Mark>3a</Mark>
<Item>
 Diagonal, Socle consists of two normal subgroups. (HS)
</Item>
<Mark>3b</Mark>
<Item>
 Diagonal, Socle is minimal normal. (SD)
</Item>
<Mark>4a</Mark>
<Item>
 Product action with the first factor primitive of type 3a. (HC)
</Item>
<Mark>4b</Mark>
<Item>
 Product action with the first factor primitive of type 3b. (CD)
</Item>
<Mark>4c</Mark>
<Item>
 Product action with the first factor primitive of type 2. (PA)
</Item>
<Mark>5</Mark>
<Item>
 Twisted wreath product (TW)
</Item>
</List>
See <Cite Key="EickHulpke01"/> for correspondence to other labellings used
in the literature.
As it can contain letters, the type is returned as a string.
<P/>
If <A>G</A> is not a permutation group or does not act primitively on the
points moved by it, the result is undefined.
</Description>
</ManSection>

<ManSection>
<Attr Name="SocleTypePrimitiveGroup" Arg='G'/>

<Description>
returns the socle type of the primitive permutation group <A>G</A>.
The socle of a primitive group is the direct product of isomorphic simple
groups,
therefore the type is indicated by a record with components
<C>series</C>, <C>parameter</C> (both as described under
<Ref Func="IsomorphismTypeInfoFiniteSimpleGroup" Label="for a group"/>),
and <C>width</C> for the number of direct factors.
<P/>
If <A>G</A> does not have a faithful primitive action,
the result is undefined.
<Example><![CDATA[
gap> g:=AlternatingGroup(5);;
gap> h:=DirectProduct(g,g);;
gap> p:=List([1,2],i->Projection(h,i));;
gap> ac:=Action(h,AsList(g),
> function(g,h) return Image(p[1],h)^-1*g*Image(p[2],h);end);;
gap> Size(ac);NrMovedPoints(ac);IsPrimitive(ac,[1..60]);
3600
60
true
gap> ONanScottType(ac);
"3a"
gap> SocleTypePrimitiveGroup(ac);
rec( 
  name := "A(5) ~ A(1,4) = L(2,4) ~ B(1,4) = O(3,4) ~ C(1,4) = S(2,4) \
~ 2A(1,4) = U(2,4) ~ A(1,5) = L(2,5) ~ B(1,5) = O(3,5) ~ C(1,5) = S(2,\
5) ~ 2A(1,5) = U(2,5)", parameter := 5, series := "A", width := 2 )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Stabilizer Chains">
<Heading>Stabilizer Chains</Heading>

Many of the algorithms for permutation groups use a <E>stabilizer chain</E>
of the group.
The concepts of stabilizer chains, <E>bases</E>,
and <E>strong generating sets</E> were
introduced by Charles Sims in&nbsp;<Cite Key="Sim70"/>. An extensive account
of basic algorithms together with asymptotic runtime analysis can be found in
reference&nbsp;<Cite Key="Seress2003" Where="Chapter 4"/>.
A further discussion of base change is given in
section&nbsp;<Ref Sect="Generalized Conjugation Technique"/>.
<P/>
Let <M>B = [ b_1, \ldots, b_n ]</M> be a list of points,
<M>G^{(1)} = G</M> and <M>G^{{(i+1)}} = Stab_{{G^{(i)}}}(b_i)</M>,
such that <M>G^{(n+1)} = \{ () \}</M>.
Then the list <M>[ b_1, \ldots, b_n ]</M> is called a <E>base</E> of <M>G</M>,
the points <M>b_i</M> are called <E>base points</E>.
A set <M>S</M> of generators for <M>G</M> satisfying the condition
<M>\langle S \cap G^{(i)} \rangle = G^{(i)}</M> for each
<M>1 \leq i \leq n</M>,
is called a <E>strong generating set</E> (SGS) of <M>G</M>.
(More precisely we ought to say that it is a SGS of <M>G</M> <E>relative</E>
to <M>B</M>).
The chain of subgroups <M>G^{(i)}</M> of <M>G</M> itself is
called the <E>stabilizer chain</E> of <M>G</M> relative to <M>B</M>.
<P/>
Since <M>[ b_1, \ldots, b_n ]</M>, where <M>n</M> is the degree of <M>G</M>
and <M>b_i</M> are the moved points of <M>G</M>,
certainly is a base for <M>G</M> there exists a base for
each permutation group.
The number of points in a base is called the <E>length</E> of the base.
A base <M>B</M> is called <E>reduced</E> if there exists no <M>i</M>
such that <M>G^{(i)} = G^{(i+1)}</M>.
(This however does not imply that no subset of <M>B</M> could also serve
as a base.)
Note that different reduced bases for one permutation group <M>G</M>
may have different lengths.
For example, the irreducible degree <M>416</M> permutation representation
of the Chevalley Group <M>G_2(4)</M> possesses reduced bases of lengths
<M>5</M> and <M>7</M>.
<P/>
Let <M>R^{(i)}</M> be a right transversal of <M>G^{(i+1)}</M> in
<M>G^{(i)}</M>, i.e. a set of right coset representatives of the cosets of
<M>G^{(i+1)}</M> in <M>G^{(i)}</M>.
Then each element <M>g</M> of <M>G</M> has a unique representation as a
product of the form <M>g = r_n \ldots r_1</M> with <M>r_i \in R^{(i)}</M>.
The cosets of <M>G^{(i+1)}</M> in <M>G^{(i)}</M> are in bijective
correspondence with the points in <M>O^{(i)} := b_i^{{G^{(i)}}}</M>.
So we could represent a transversal as a list <M>T</M> such that <M>T[p]</M>
is a representative of the coset corresponding to the point
<M>p \in O^{(i)}</M>,
i.e., an element of <M>G^{(i)}</M> that takes <M>b_i</M> to <M>p</M>.
(Note that such a list has holes in all positions corresponding to points
not contained in <M>O^{(i)}</M>.)
<P/>
This approach however will store many different permutations as coset
representatives which can be a problem if the degree <M>n</M> gets bigger.
Our goal therefore is to store as few different permutations as possible such
that we can still reconstruct each representative in <M>R^{(i)}</M>,
and from them the elements in <M>G</M>.
A <E>factorized inverse transversal</E> <M>T</M> is a list
where <M>T[p]</M> is a generator of <M>G^{(i)}</M> such that
<M>p^{{T[p]}}</M> is a point that lies earlier in <M>O^{(i)}</M> than
<M>p</M> (note that we consider <M>O^{(i)}</M> as a list, not as a set).
If we assume inductively that we know an element <M>r \in G^{(i)}</M>
that takes <M>b_i</M> to <M>p^{{T[p]}}</M>,
then <M>r T[p]^{{-1}}</M> is an element in <M>G^{(i)}</M> that takes
<M>b_i</M> to <M>p</M>.
&GAP; uses such factorized inverse transversals.
<P/>
Another name for a factorized inverse transversal is a <E>Schreier tree</E>.
The vertices of the tree are the points in <M>O^{(i)}</M>,
and the root of the tree is <M>b_i</M>.
The edges are defined as the ordered pairs <M>(p, p^{{T[p]}})</M>,
for <M>p \in O^{(i)} \setminus \{ b_i \}</M>. The edge <M>(p, p^{{T[p]}})</M>
is labelled with the generator <M>T[p]</M>, and the product of edge labels
along the unique path from <M>p</M> to <M>b_i</M> is the inverse of the
transversal element carrying <M>b_i</M> to <M>p</M>.
<P/>
Before we describe the construction of stabilizer chains
in&nbsp;<Ref Sect="Construction of Stabilizer Chains"/>,
we explain in&nbsp;<Ref Sect="Randomized Methods for Permutation Groups"/>
the idea of using non-deterministic algorithms;
this is necessary for understanding the options available for the
construction of stabilizer chains.
After that, in&nbsp;<Ref Sect="Stabilizer Chain Records"/> it is explained
how a stabilizer chain is stored in &GAP;,
<Ref Sect="Operations for Stabilizer Chains"/> lists operations for stabilizer
chains,
and&nbsp;<Ref Sect="Low Level Routines to Modify and Create Stabilizer Chains"/>
lists low level routines for manipulating stabilizer chains.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Randomized Methods for Permutation Groups">
<Heading>Randomized Methods for Permutation Groups</Heading>

<Index Subkey="random">Schreier-Sims</Index>
For most computations with permutation groups,
it is crucial to construct stabilizer chains efficiently.
Sims's original construction in <Cite Key="Sim70"/> is deterministic,
and is called the Schreier-Sims algorithm,
because it is based on Schreier's Lemma (<Cite Key="Hall" Where="p. 96"/>):
given <M>K = \langle S \rangle</M>
and a transversal <M>T</M> for <M>K</M> mod <M>L</M>, one can obtain
<M>|S||T|</M> generators for <M>L</M>. This lemma is applied recursively,
with consecutive point stabilizers <M>G^{(i)}</M> and <M>G^{(i+1)}</M>
playing the role of <M>K</M> and <M>L</M>.
<P/>
In permutation groups of large degree, the number of Schreier generators
to be processed becomes too large, and the deterministic Schreier-Sims
algorithm becomes impractical. Therefore, &GAP; uses randomized
algorithms. The method selection process, which is quite different
from Version 3, works the following way.
<P/>
If a group acts on not more than a hundred points,
Sims's original deterministic algorithm is applied. In groups of
degree greater than hundred, a heuristic algorithm based
on ideas in <Cite Key="BCFS91"/> constructs a stabilizer chain.
This construction is complemented by a
verify-routine that either proves the correctness of the stabilizer chain
or causes the extension of the chain to a correct one.
The user can influence the verification process by setting
the value of the record component <C>random</C>
(cf.&nbsp;<Ref Sect="Construction of Stabilizer Chains"/>).
<P/>
If the <C>random</C> value equals <M>1000</M> then a slight extension of an
unpublished method of Sims is used.
The outcome of this verification process is always correct.
The user also can prescribe any integer <M>x</M>, <M>1 \leq x \leq 999</M>
as the value of <C>random</C>. In this case, a randomized verification
process from <Cite Key="BCFS91"/> is applied, and the result of the
stabilizer chain construction is guaranteed to be correct with probability
at least <M>x/1000</M>. The practical performance of the algorithm is
much better than the theoretical guarantee.
<P/>
If the stabilizer chain is not correct then the elements in the
product of transversals <M>R^{(m)} R^{(m-1)} \cdots R^{(1)}</M> constitute a
proper subset of the group <M>G</M> in question.
This means that a membership test with this stabilizer chain
returns <K>false</K> for
all elements that are not in <M>G</M>,
but it may also return <K>false</K> for some elements of <M>G</M>;
in other words, the result <K>true</K> of a membership test is always correct,
whereas the result <K>false</K> may be incorrect.
<P/>
The construction and verification phases are separated because
there are situations where the verification step can be omitted;
if one happens to know the order of the group in advance then the
randomized construction of the stabilizer chain stops
as soon as the product of the lengths of the basic orbits
of the chain equals the group order, and the chain will be correct
(see the <C>size</C> option of the
<Ref Func="StabChain" Label="for a group (and a record)"/> command).
<P/>
Although the worst case running time is roughly quadratic for
Sims's verification and roughly linear for the randomized one,
in most examples the running time of the stabilizer chain
construction with <C>random</C> value <M>1000</M>
(i.e., guaranteed correct output)
is about the same as the running time of randomized verification
with guarantee of at least <M>90</M> percent correctness.
Therefore, we suggest to use the default value <C>random</C> <M>= 1000</M>.
Possible uses of <C>random</C> values less than <M>1000</M> are
when one has to run through a large collection
of subgroups, and a low value of random is used to choose quickly
a candidate for more thorough examination; another use is when
the user suspects that the quadratic bottleneck of the guaranteed
correct verification is hit.
<P/>
We will give two examples to illustrate these ideas.
<P/>
<Example><![CDATA[
gap> h:= SL(4,7);;
gap> o:= Orbit( h, [1,0,0,0]*Z(7)^0, OnLines );;
gap> op:= Action( h, o, OnLines );;
gap> NrMovedPoints( op );
400
]]></Example>
<P/>
We created a permutation group on <M>400</M> points.
First we compute a guaranteed correct stabilizer chain
(see&nbsp;<Ref Func="StabChain" Label="for a group (and a record)"/>).
<P/>
<Log><![CDATA[
gap> h:= Group( GeneratorsOfGroup( op ) );;
gap> StabChain( h );;  time;
1120
gap> Size( h );
2317591180800
]]></Log>
<P/>
Now randomized verification will be used.
We require that the result is guaranteed correct with probability
<M>90</M> percent.
This means that if we would do this calculation many times over,
&GAP; would <E>guarantee</E> that in least <M>90</M> percent of all
calculations the result is correct.
In fact the results are much better than the guarantee,
but we cannot promise that this will really happen.
(For the meaning of the <C>random</C> component in the second argument of
<Ref Func="StabChain" Label="for a group (and a record)"/>.)
<P/>
First the group is created anew.
<P/>
<Log><![CDATA[
gap> h:= Group( GeneratorsOfGroup( op ) );;
gap> StabChain( h, rec( random:= 900 ) );;  time;
1410
gap> Size( h );
2317591180800
]]></Log>
<P/>
The result is still correct, and the running time is actually somewhat
slower.
If you give the algorithm additional information so that it can check
its results,
things become faster and the result is guaranteed to be correct.
<P/>
<Log><![CDATA[
gap> h:=Group( GeneratorsOfGroup( op ) );;
gap> SetSize( h, 2317591180800 );
gap> StabChain( h );;  time;
170
]]></Log>
<P/>
The second example gives a typical group when the verification
with <C>random</C> value <M>1000</M> is slow. The problem is that the group
has a stabilizer subgroup <M>G^{(i)}</M> such that the fundamental
orbit <M>O^{(i)}</M> is split into a lot of orbits when we stabilize
<M>b_i</M> and one additional point of <M>O^{(i)}</M>.
<P/>
<Log><![CDATA[
gap> p1:=PermList(Concatenation([401],[1..400]));;
gap> p2:=PermList(List([1..400],i->(i*20 mod 401)));;
gap> d:=DirectProduct(Group(p1,p2),SymmetricGroup(5));;
gap> h:=Group(GeneratorsOfGroup(d));;
gap> StabChain(h);;time;Size(h);
1030
192480
gap> h:=Group(GeneratorsOfGroup(d));;
gap> StabChain(h,rec(random:=900));;time;Size(h);
570
192480
]]></Log>
<P/>
When stabilizer chains of a group <M>G</M> are created
with <C>random</C> value less than <M>1000</M>,
this is noted in the group <M>G</M>,
by setting of the record component <C>random</C>
in the value of the attribute <Ref Func="StabChainOptions"/>
for <M>G</M>.
As errors induced by the random methods might propagate,
any group or homomorphism created from <M>G</M> inherits a <C>random</C>
component in its <Ref Func="StabChainOptions"/> value from the corresponding
component for <M>G</M>.
<P/>
A lot of algorithms dealing with permutation groups use randomized
methods; however, if the initial stabilizer chain construction
for a group is correct, these further methods will provide
guaranteed correct output.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Construction of Stabilizer Chains">
<Heading>Construction of Stabilizer Chains</Heading>

<ManSection>
<Func Name="StabChain" Arg='G[, options]'
 Label="for a group (and a record)"/>
<Func Name="StabChain" Arg='G, base'
 Label="for a group and a base"/>
<Oper Name="StabChainOp" Arg='G, options'/>
<Attr Name="StabChainMutable" Arg='G'
 Label="for a group"/>
<Attr Name="StabChainMutable" Arg='permhomom'
 Label="for a homomorphism"/>
<Attr Name="StabChainImmutable" Arg='G'/>

<Description>
These commands compute a stabilizer chain for the permutation group
<A>G</A>;
additionally, <Ref Attr="StabChainMutable" Label="for a homomorphism"/>
is also an attribute for the group homomorphism <A>permhomom</A>
whose source is a permutation group.
<P/>
(The mathematical background of stabilizer chains is sketched
in&nbsp;<Ref Sect="Stabilizer Chains"/>,
more information about the objects representing stabilizer chains
in &GAP; can be found in&nbsp;<Ref Sect="Stabilizer Chain Records"/>.)
<P/>
<Ref Oper="StabChainOp"/> is an operation with two arguments <A>G</A> and
<A>options</A>,
the latter being a record which controls some aspects of the computation
of a stabilizer chain (see below);
<Ref Oper="StabChainOp"/> returns a <E>mutable</E> stabilizer chain.
<Ref Attr="StabChainMutable" Label="for a group"/> is a <E>mutable</E>
attribute for groups or homomorphisms,
its default method for groups is to call <Ref Oper="StabChainOp"/> with
empty options record.
<Ref Attr="StabChainImmutable"/> is an attribute with <E>immutable</E>
values;
its default method dispatches to
<Ref Attr="StabChainMutable" Label="for a group"/>.
<P/>
<Ref Func="StabChain" Label="for a group (and a record)"/> is a function
with first argument a permutation group <A>G</A>,
and optionally a record <A>options</A> as second argument.
If the value of <Ref Attr="StabChainImmutable"/> for <A>G</A>
is already known and if this stabilizer chain matches the requirements
of <A>options</A>,
<Ref Func="StabChain" Label="for a group (and a record)"/> simply returns
this stored stabilizer chain.
Otherwise <Ref Func="StabChain" Label="for a group (and a record)"/>
calls <Ref Oper="StabChainOp"/> and returns an immutable copy of the
result;
additionally, this chain is stored as <Ref Attr="StabChainImmutable"/>
value for <A>G</A>.
If no <A>options</A> argument is given, its components default
to the global variable <Ref Var="DefaultStabChainOptions"/>.
If <A>base</A> is a list of positive integers,
the version <C>StabChain( <A>G</A>, <A>base</A> )</C> defaults to
<C>StabChain( <A>G</A>, rec( base:= <A>base</A> ) )</C>.
<P/>
If given, <A>options</A> is a record whose components specify properties
of the desired stabilizer chain or which may help the algorithm.
Default values for all of them can be given in the global variable
<Ref Var="DefaultStabChainOptions"/>.
The following options are supported.
<List>
<Mark><C>base</C> (default an empty list)</Mark>
<Item>
    A list of points, through which the resulting stabilizer chain
    shall run.
    For the base <M>B</M> of the resulting stabilizer chain <A>S</A>
    this means the following.
    If the <C>reduced</C> component of <A>options</A> is <K>true</K> then
    those points of <C>base</C> with nontrivial basic orbits form the
    initial segment of <M>B</M>, if the <C>reduced</C> component is
    <K>false</K> then <C>base</C> itself is the initial segment of
    <M>B</M>.
    Repeated occurrences of points in <C>base</C> are ignored.
    If a stabilizer chain for <A>G</A> is already known then the
    stabilizer chain is computed via a base change.
</Item>
<Mark><C>knownBase</C> (no default value)</Mark>
<Item>
    A list of points which is known to be a base for the group.
    Such a known base makes it easier to test whether a permutation
    given as a word in terms of a set of generators is the identity,
    since it suffices to map the known base with each factor
    consecutively, rather than multiplying the whole permutations
    (which would mean to map every point).
    This speeds up the Schreier-Sims algorithm which is used when a new
    stabilizer chain is constructed;
    it will not affect a base change, however.
    The component <C>knownBase</C> bears no relation to the <C>base</C>
    component, you may specify a known base <C>knownBase</C> and a
    desired base <C>base</C> independently.
</Item>
<Mark><C>reduced</C> (default <K>true</K>)</Mark>
<Item>
    If this is <K>true</K> the resulting stabilizer chain <A>S</A> is
    reduced, i.e., the case  <M>G^{(i)} = G^{(i+1)}</M> does not occur.
    Setting <C>reduced</C> to <K>false</K> makes sense only if
    the component <C>base</C> (see above) is also set;
    in this case all points of <C>base</C> will occur in the base
    <M>B</M> of <A>S</A>, even if they have trivial basic orbits.
    Note that if <C>base</C> is just an initial segment of <M>B</M>,
    the basic orbits of the points in <M>B \setminus </M><C>base</C>
    are always nontrivial.
</Item>
<Mark><C>tryPcgs</C> (default <K>true</K>)</Mark>
<Item>
    If this is <K>true</K> and either the degree is at most <M>100</M>
    or the group is known to be solvable, &GAP; will first try to
    construct a pcgs (see Chapter&nbsp;<Ref Chap="Polycyclic Groups"/>)
    for <A>G</A> which will succeed and implicitly construct a
    stabilizer chain if <A>G</A> is solvable.
    If <A>G</A> turns out non-solvable, one of the other methods will be
    used.
    This solvability check is comparatively fast, even if it fails,
    and it can save a lot of time if <A>G</A> is solvable.
</Item>
<Mark><C>random</C> (default <C>1000</C>)</Mark>
<Item>
    If the value is less than&nbsp;<M>1000</M>,
    the resulting chain is correct with probability
    at least&nbsp;<C>random</C><M> / 1000</M>.
    The <C>random</C> option is explained in more detail
    in&nbsp;<Ref Sect="Randomized Methods for Permutation Groups"/>.
</Item>
<Mark><C>size</C> (default <C>Size(<A>G</A>)</C> if this is known,
        i.e., if <C>HasSize(<A>G</A>)</C> is <K>true</K>)</Mark>
<Item>
    If this component is present, its value is assumed to be the order
    of the group <A>G</A>.
    This information can be used to prove that a non-deterministically
    constructed stabilizer chain is correct.
    In this case, &GAP; does a non-deterministic construction until the
    size is correct.
</Item>
<Mark><C>limit</C> (default <C>Size(Parent(<A>G</A>))</C> or
         <C>StabChainOptions(Parent(<A>G</A>)).limit</C>
         if it is present)</Mark>
<Item>
    If this component is present, it must be greater than or equal to
    the order of <A>G</A>.
    The stabilizer chain construction stops if size <C>limit</C> is
    reached.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Attr Name="StabChainOptions" Arg='G'/>

<Description>
is a record that stores the options with which the stabilizer chain
stored in <Ref Attr="StabChainImmutable"/> has been computed
(see&nbsp;<Ref Func="StabChain" Label="for a group (and a record)"/>
for the options that are supported).
</Description>
</ManSection>

<ManSection>
<Var Name="DefaultStabChainOptions"/>

<Description>
are the options for
<Ref Func="StabChain" Label="for a group (and a record)"/> which are set
as default.
</Description>
</ManSection>

<ManSection>
<Func Name="StabChainBaseStrongGenerators" Arg='base, sgs, one'/>

<Description>
Let <A>base</A> be a base for a permutation group <M>G</M>, and let
<A>sgs</A> be a strong generating set for <M>G</M> with respect to
<A>base</A>; <A>one</A> must be the appropriate identity element of
<M>G</M> (see <Ref Oper="One"/>, in most cases this will be <C>()</C>).
This function constructs a stabilizer chain without the need to find
Schreier generators;
so this is much faster than the other algorithms.
</Description>
</ManSection>

<ManSection>
<Attr Name="MinimalStabChain" Arg='G'/>

<Description>
returns the reduced stabilizer chain corresponding to the base
<M>[ 1, 2, 3, 4, \ldots ]</M>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Stabilizer Chain Records">
<Heading>Stabilizer Chain Records</Heading>

If a permutation group has a stabilizer chain,
this is stored as a recursive structure.
This structure is itself a record&nbsp;<A>S</A> and it has
<List>
<Mark>(1)</Mark>
<Item>
  components that provide information about one level&nbsp;<M>G^{(i)}</M>
  of the stabilizer chain (which we call the <Q>current stabilizer</Q>) and
</Item>
<Mark>(2)</Mark>
<Item>
  a component <C>stabilizer</C> that holds another such record, namely the
  stabilizer chain of the next stabilizer&nbsp;<M>G^{(i+1)}</M>.
</Item>
</List>
<P/>
This gives a recursive structure where the <Q>outermost</Q> record
representing the <Q>topmost</Q> stabilizer is bound to
the group record component <C>stabChain</C> and has the components
explained below.
Note: Since the structure is recursive, <E>never print a stabilizer chain!</E>
(Unless you want to exercise the scrolling capabilities of your terminal.)
<List>
<Mark><C>identity</C> </Mark>
<Item>
        the identity element of the current stabilizer.
</Item>
<Mark><C>labels</C> </Mark>
<Item>
        a list of permutations which contains labels for the Schreier tree
        of  the current stabilizer,  i.e., it contains
        elements for the factorized
        inverse transversal.  The  first entry  in this list  is
        always the  <C>identity</C>.
        Note that &GAP; tries to arrange things so that the <C>labels</C>
        components are identical (i.e., the same &GAP; object)
        in every stabilizer of the chain;
        thus the <C>labels</C> of a stabilizer do not necessarily all lie
        in the this stabilizer (but see <C>genlabels</C> below).
</Item>
<Mark><C>genlabels</C> </Mark>
<Item>
        a list of integers indexing some of the permutations in the
        <C>labels</C> component. The    <C>labels</C> addressed in this   way
        form a generating set for the current stabilizer. If the
        <C>genlabels</C> component is empty,  the rest of the stabilizer chain
        represents  the trivial subgroup, and  can be ignored, e.g., when
        calculating the size.
</Item>
<Mark><C>generators</C> </Mark>
<Item>
        a list of generators for the current stabilizer. Usually, it is
        <C>labels{ genlabels }</C>.
</Item>
<Mark><C>orbit</C> </Mark>
<Item>
        the vertices of  the Schreier tree,  which  form the basic  orbit
        <M>b_i^{{G^{(i)}}}</M>, ordered in such a way that the base point 
        <M>b_i</M> is in the first position in the orbit.
</Item>
<Mark><C>transversal</C></Mark>
<Item>
  The factorized inverse transversal found during the orbit algorithm.
  The element <M>g</M> stored at <C>transversal</C><M>[i]</M> will map
  <M>i</M> to another point <M>j</M> that in the Schreier tree is closer to
  the base point.
  By iterated application (<C>transversal</C><M>[j]</M> and so on) eventually
  the base point is reached and an element that maps <M>i</M> to the base
  point found as product.
</Item>
<Mark><C>translabels</C></Mark>
<Item>
  An index list such that 
  <C>transversal</C><M>[j] =</M>
  <C>labels</C><M>[</M> <C>translabels</C><M>[j] ]</M>.
  This list takes up comparatively little memory and is used to speed
  up base changes.
</Item>
<Mark><C>stabilizer</C> </Mark>
<Item>
  If the current stabilizer is not yet the trivial group,
  the stabilizer chain continues with the stabilizer of the current
  base point, which is again represented as a record with components
  <C>labels</C>, <C>identity</C>, <C>genlabels</C>, <C>generators</C>,
  <C>orbit</C>, <C>translabels</C>, <C>transversal</C> (and perhaps
  <C>stabilizer</C>).
  This record is bound to the <C>stabilizer</C> component of the current
  stabilizer.
  The last member of a stabilizer chain is recognized by the fact that it has
  no <C>stabilizer</C> component bound.
</Item>
</List>
It is possible that different stabilizer  chains share the same record as
one of their iterated <C>stabilizer</C> components.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> StabChain(g);
<stabilizer chain record, Base [ 1, 2, 3 ], Orbit length 4, Size: 24>
gap> BaseOfGroup(g);
[ 1, 2, 3 ]
gap> StabChainOptions(g);
rec( random := 1000 )
gap> DefaultStabChainOptions;
rec( random := 1000, reduced := true, tryPcgs := true )
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Stabilizer Chains">
<Heading>Operations for Stabilizer Chains</Heading>

<ManSection>
<Func Name="BaseStabChain" Arg='S'/>

<Description>
returns the base belonging to the stabilizer chain <A>S</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="BaseOfGroup" Arg='G'/>

<Description>
returns a base of the permutation group <A>G</A>.
There is <E>no</E> guarantee that a stabilizer chain stored in <A>G</A>
corresponds to this base!
</Description>
</ManSection>

<ManSection>
<Func Name="SizeStabChain" Arg='S'/>

<Description>
returns the product of the orbit lengths in the stabilizer chain
<A>S</A>, that is, the order of the group described by <A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="StrongGeneratorsStabChain" Arg='S'/>

<Description>
returns a strong generating set corresponding to the stabilizer chain
<A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="GroupStabChain" Arg='[G,] S'/>

<Description>
constructs a permutation group with stabilizer chain <A>S</A>, i.e.,
a group with generators <C>Generators( <A>S</A>  )</C> to which <A>S</A>
is assigned as component <C>stabChain</C>.
If the  optional argument <A>G</A> is given, the result will have the
parent <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="OrbitStabChain" Arg='S, pnt'/>

<Description>
returns the orbit of <A>pnt</A> under the group described by the
stabilizer chain <A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="IndicesStabChain" Arg='S'/>

<Description>
returns a list of the indices of the stabilizers in the stabilizer
chain <A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="ListStabChain" Arg='S'/>

<Description>
returns a list that contains at position <M>i</M> the stabilizer of the
first <M>i-1</M> base points in the stabilizer chain <A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="ElementsStabChain" Arg='S'/>

<Description>
returns a list of all elements of the group described by the stabilizer
chain <A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="IteratorStabChain" Arg='S'/>

<Description>
returns an iterator for the elments of the group described by the
stabilizer chain <A>S</A>.

The elements of the group <A>G</A> are produced by iterating through
all base images in turn, and in the ordering induced by the base. For
more details see&nbsp;<Ref Sect="Stabilizer Chains"/>
</Description>
</ManSection>

<ManSection>
<Func Name="InverseRepresentative" Arg='S, pnt'/>

<Description>
calculates the transversal element which maps <A>pnt</A> back to the base
point of <A>S</A>.  It just runs back through the Schreier tree from
<A>pnt</A> to the root and multiplies the labels along the way.
</Description>
</ManSection>

<ManSection>
<Func Name="SiftedPermutation" Arg='S, g'/>

<Description>
sifts the permutation <A>g</A> through the stabilizer chain <A>S</A>
and returns the result after the last step.
<P/>
The element <A>g</A> is sifted as follows: <A>g</A> is replaced by
<C><A>g</A>
* InverseRepresentative( <A>S</A>, <A>S</A>.orbit[1]^<A>g</A> )</C>,
then <A>S</A> is replaced by <C><A>S</A>.stabilizer</C> and this process
is repeated until <A>S</A> is trivial
or <C><A>S</A>.orbit[1]^<A>g</A></C> is not in the basic orbit
<C><A>S</A>.orbit</C>.
The remainder <A>g</A> is returned, it is the identity permutation if and
only if the original <A>g</A> is in the group <M>G</M> described by
the original&nbsp;<A>S</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MinimalElementCosetStabChain" Arg='S, g'/>

<Description>
Let <M>G</M> be the group described by the stabilizer chain <A>S</A>.
This function returns a permutation <M>h</M> such that
<M>G <A>g</A> = G h</M>
(that is, <M><A>g</A> / h \in G</M>) and with the additional property that
the list of images under <M>h</M> of the base belonging to <A>S</A> is
minimal w.r.t.&nbsp;lexicographical ordering.
</Description>
</ManSection>

<ManSection>
<Func Name="LargestElementStabChain" Arg='S, id'/>

<Description>
Let <M>G</M> be the group described by the stabilizer chain <A>S</A>.
This function returns the element <M>h \in G</M> with the property that
the list of images under <M>h</M> of the base belonging to <A>S</A> is
maximal w.r.t.&nbsp;lexicographical ordering.
The second argument must be an identity element (used to start the
recursion).
</Description>
</ManSection>

<ManSection>
<Func Name="ApproximateSuborbitsStabilizerPermGroup" Arg='G, pnt'/>

<Description>
returns an approximation of the orbits of <C>Stabilizer( <A>G</A>, <A>pnt</A> )</C>
on all points of the orbit <C>Orbit( <A>G</A>, <A>pnt</A> )</C>,
without computing the full point stabilizer;
As not all Schreier generators are used,
the result may represent the orbits of only a subgroup of the point
stabilizer.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Low Level Routines to Modify and Create Stabilizer Chains">
<Heading>Low Level Routines to Modify and Create Stabilizer Chains</Heading>

These operations modify a stabilizer chain or obtain new chains with
specific properties. They are rather technical and should only be used if
such low-level routines are deliberately required. (For all functions in
this section the parameter <A>S</A> is a stabilizer chain.)

<ManSection>
<Func Name="CopyStabChain" Arg='S'/>

<Description>
This function returns a copy of the stabilizer chain <A>S</A>
that has no mutable object (list or record) in common with <A>S</A>.
The <C>labels</C> components of the result are possibly shared by several
levels, but superfluous labels are removed.
(An entry in <C>labels</C> is superfluous if it does not occur among the
<C>genlabels</C> or <C>translabels</C> on any of the levels which share
that <C>labels</C> component.)
<P/>
This is useful for stabiliser sub-chains that have been obtained as
the (iterated) <C>stabilizer</C> component of a bigger chain.
</Description>
</ManSection>

<ManSection>
<Func Name="CopyOptionsDefaults" Arg='G, options'/>

<Description>
sets components in a stabilizer chain options record <A>options</A>
according to what is known about the group <A>G</A>.
This can be used to obtain a new stabilizer chain for <A>G</A> quickly.
</Description>
</ManSection>

<ManSection>
<Func Name="ChangeStabChain" Arg='S, base[, reduced]'/>

<Description>
changes or reduces a stabilizer chain <A>S</A> to be adapted to the base
<A>base</A>.
The optional argument <A>reduced</A> is interpreted as follows.
<List>
<Mark><C>reduced = </C><K>false</K> : </Mark>
<Item>
    change the stabilizer chain, do not reduce it,
</Item>
<Mark><C>reduced = </C><K>true</K> : </Mark>
<Item>
    change the stabilizer chain, reduce it.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="ExtendStabChain" Arg='S, base'/>

<Description>
extends the stabilizer chain <A>S</A> so that it corresponds to base
<A>base</A>.
The original base of <A>S</A> must be a subset of <A>base</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="ReduceStabChain" Arg='S'/>

<Description>
changes the stabilizer chain <A>S</A> to a reduced stabilizer chain by
eliminating trivial steps.
</Description>
</ManSection>

<!-- %%declaration{ConjugateStabChain} -->
<ManSection>
<Func Name="RemoveStabChain" Arg='S'/>

<Description>
<A>S</A> must be a stabilizer record in a stabilizer chain.
This chain then is cut off at <A>S</A> by changing the entries in
<A>S</A>.  This can be used to remove trailing trivial steps.
</Description>
</ManSection>

<ManSection>
<Func Name="EmptyStabChain" Arg='labels, id[, pnt]'/>

<Description>
constructs a stabilizer chain for the trivial group with
<C>identity</C> value equal to<A>id</A> and
<C>labels = </C><M>\{ <A>id</A> \} \cup</M> <A>labels</A>
(but of course with <C>genlabels</C> and <C>generators</C> values an
empty list).
If the optional third argument <A>pnt</A> is present, the only stabilizer
of the chain is initialized with the one-point basic orbit
<C>[ <A>pnt</A> ]</C> and with <C>translabels</C> and <C>transversal</C>
components.
</Description>
</ManSection>

<ManSection>
<Func Name="InsertTrivialStabilizer" Arg='S, pnt'/>

<Description>
<Ref Func="InsertTrivialStabilizer"/> initializes the current stabilizer
with <A>pnt</A> as <Ref Func="EmptyStabChain"/> did,
but assigns the original <A>S</A> to the new
<C><A>S</A>.stabilizer</C> component, such that  a new level with trivial
basic orbit (but identical <C>labels</C> and <C>ShallowCopy</C>ed
<C>genlabels</C> and <C>generators</C>) is inserted.
This function should be used only if <A>pnt</A> really is fixed by the
generators of <A>S</A>, because then new generators can be added and the
orbit and transversal at the same time extended with
<Ref Func="AddGeneratorsExtendSchreierTree"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="IsFixedStabilizer" Arg='S, pnt'/>

<Description>
returns <K>true</K> if <A>pnt</A> is fixed by all generators of <A>S</A>
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Func Name="AddGeneratorsExtendSchreierTree" Arg='S, new'/>

<Description>
adds the elements in <A>new</A> to the list of generators of <A>S</A>
and at the same time extends the orbit and transversal.
This is the only legal way to extend a Schreier tree
(because this involves careful handling of the tree components).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Backtrack">
<Heading>Backtrack</Heading>

A main use for stabilizer chains is in backtrack algorithms for permutation
groups. &GAP; implements a partition-backtrack algorithm as described in
<Cite Key="Leon91"/> and refined in <Cite Key="Theissen97"/>.
<P/>
<ManSection>
<Func Name="SubgroupProperty" Arg='G, Pr[, L ]'/>

<Description>
<A>Pr</A> must be a one-argument function that returns <K>true</K> or
<K>false</K> for elements of the group <A>G</A>,
and the subset of elements of <A>G</A> that fulfill <A>Pr</A> must
be a subgroup. (<E>If the latter is not true the result of this operation
is unpredictable!</E>) This command computes this subgroup.
The optional argument <A>L</A> must be a subgroup of the set of all
elements in <A>G</A> fulfilling <A>Pr</A> and can be given if known
in order to speed up the calculation.
</Description>
</ManSection>

<ManSection>
<Func Name="ElementProperty" Arg='G, Pr[, L[, R]]'/>

<Description>
<Ref Func="ElementProperty"/> returns an element <M>\pi</M> of the
permutation group <A>G</A> such that the one-argument function <A>Pr</A>
returns <K>true</K> for <M>\pi</M>.
It returns <K>fail</K> if no such element exists in <A>G</A>.
The optional arguments <A>L</A> and <A>R</A> are subgroups of <A>G</A>
such that the property <A>Pr</A> has the same value for all elements in
the cosets <A>L</A> <M>g</M> and <M>g</M> <A>R</A>, respectively,
with <M>g \in <A>G</A></M>.
<P/>
A typical example of using the optional subgroups <A>L</A> and <A>R</A>
is the conjugacy test for elements <M>a</M> and <M>b</M> for which one
can set <A>L</A><M>:= C_{<A>G</A>}(a)</M> and
<A>R</A><M>:= C_{<A>G</A>}(b)</M>.
<P/>
<Example><![CDATA[
gap> propfun:= el -> (1,2,3)^el in [ (1,2,3), (1,3,2) ];;
gap> SubgroupProperty( g, propfun, Subgroup( g, [ (1,2,3) ] ) );
Group([ (1,2,3), (2,3) ])
gap> ElementProperty( g, el -> Order( el ) = 2 );
(2,4)
]]></Example>
<P/>
Chapter&nbsp;<Ref Chap="Permutations"/> describes special operations to
construct permutations in the symmetric group without using backtrack
constructions.
<P/>
Backtrack routines are also called by the methods for permutation groups
that compute centralizers, normalizers, intersections,
conjugating elements as well as stabilizers for the operations of a
permutation group via <Ref Func="OnPoints"/>, <Ref Func="OnSets"/>,
<Ref Func="OnTuples"/> and <Ref Func="OnSetsSets"/>.
Some of these methods use more specific refinements than
<Ref Func="SubgroupProperty"/> or <Ref Func="ElementProperty"/>.
For the definition of refinements, and how one can define refinements,
see Section&nbsp;<Ref Sect="The General Backtrack Algorithm with Ordered Partitions"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="TwoClosure" Arg='G'/>

<Description>
The <E>2-closure</E> of a transitive permutation group <A>G</A> on
<M>n</M> points is the largest subgroup of the symmetric group <M>S_n</M>
which has the same orbits on sets of ordered pairs of points as the group
<A>G</A> has.
It also can be interpreted as the stabilizer of the orbital graphs of
<A>G</A>.
<Example><![CDATA[
gap> TwoClosure(Group((1,2,3),(2,3,4)));
Sym( [ 1 .. 4 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoBckt"/>

<Description>
is the info class for the partition backtrack routines.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Working with large degree permutation groups">
<Heading>Working with large degree permutation groups</Heading>

Permutation groups of large degree (usually at least a few <M>10000</M>)
can pose a challenge to the heuristics used in the algorithms for
permutation groups.
This section lists a few useful tricks that may speed up calculations with
such large groups enormously.
<P/>
The first aspect concerns solvable groups: A lot of calculations (including
an initial stabilizer chain computation thanks to the algorithm from
<Cite Key="Sims90b"/>) are faster if a permutation group is known to be
solvable.
On the other hand, proving nonsolvability can be expensive for higher
degrees. Therefore &GAP; will automatically test a permutation group for
solvability, only if the degree is not exceeding <M>100</M>.
(See also the <C>tryPcgs</C> component of <Ref Func="StabChainOptions"/>.)
It is therefore beneficial to tell a group of larger degree, which is known
to be solvable, that it is, using <C>SetIsSolvableGroup(<A>G</A>,true)</C>.
<P/>
The second aspect concerns memory usage.
A permutation on more than <M>65536</M> points requires <M>4</M> bytes per
point for storing.
So permutations on <M>256000</M> points require roughly 1MB of storage
per permutation. Just storing the
permutations required for a stabilizer chain might already go beyond the
available memory, in particular if the base is not very short. In such a
situation it can be useful, to replace the permutations by straight line
program elements (see&nbsp;<Ref Sect="Straight Line Program Elements"/>).
<P/>
The following code gives an example of usage:
We create a group of degree <M>231000</M>.
Using straight line program elements,
one can compute a stabilizer chain in about <M>200</M> MB of memory.
<P/>
<!-- % don't attempt to run this example through the manual checker - it takes -->
<!-- % <E>ages</E> to run and <E>lots</E> of memory! -->
<!-- % besides the input data is not given ... -->
<Log><![CDATA[
gap> Read("largeperms"); # read generators from file
gap> gens:=StraightLineProgGens(permutationlist);;
gap> g:=Group(gens);
<permutation group with 5 generators>
gap> # use random algorithm (faster, but result is monte carlo)
gap> StabChainOptions(g).random:=1;;
gap> Size(g); # enforce computation of a stabilizer chain
3529698298145066075557232833758234188056080273649172207877011796336000
]]></Log>
<P/>
Without straight line program elements, the same calculation runs into
memory problems after a while even with 512MB of workspace:
<Log><![CDATA[
gap> h:=Group(permutationlist);
<permutation group with 5 generators>
gap> StabChainOptions(h).random:=1;;
gap> Size(h);
exceeded the permitted memory (`-o' command line option) at
mlimit := 1; called from
SCRMakeStabStrong( S.stabilizer, [ g ], param, orbits, where, basesize,
 base, correct, missing, false ); called from
 SCRMakeStabStrong( S.stabilizer, [ g ], param, orbits, where, basesize,
...
]]></Log>
<P/>
The advantage in memory usage however is paid for in runtime: Comparisons of
elements become much more expensive. One can avoid some of the related
problems by registering a known base with the straight line program elements
(see&nbsp;<Ref Func="StraightLineProgGens"/>).
In this case element comparison will only
compare the images of the given base points.
If we are planning to do extensive calculations with the group, it can even
be worth to recreate it with straight line program elements knowing a
previously computed base:
<P/>
<Log><![CDATA[
gap> # get the base we computed already
gap> bas:=BaseStabChain(StabChainMutable(g));
[ 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
...
  2530, 2533, 2554, 2563, 2569 ]
gap> gens:=StraightLineProgGens(permutationlist,bas);;
gap> g:=Group(gens);;
gap> SetSize(g,
> 3529698298145066075557232833758234188056080273649172207877011796336000);
gap> Random(g);; # enforce computation of a stabilizer chain
]]></Log>
<P/>
As we know already base and size, this second stabilizer chain calculation
is much faster than the first one and takes less memory.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grpmat.msk                  GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grpmat.msk,v 1.18 2002/04/15 10:02:29 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Matrix Groups">
<Heading>Matrix Groups</Heading>

Matrix groups are groups generated by invertible square matrices.
<P/>
In the following example we temporarily increase the line length limit from
its default value 80 to 83 in order to get a nicer output format.
<P/>
<Example><![CDATA[
gap> m1 := [ [ Z(3)^0, Z(3)^0,   Z(3) ],
>            [   Z(3), 0*Z(3),   Z(3) ],
>            [ 0*Z(3),   Z(3), 0*Z(3) ] ];;
gap> m2 := [ [   Z(3),   Z(3), Z(3)^0 ],
>            [   Z(3), 0*Z(3),   Z(3) ],
>            [ Z(3)^0, 0*Z(3),   Z(3) ] ];;
gap> m := Group( m1, m2 );
Group(
[ 
  [ [ Z(3)^0, Z(3)^0, Z(3) ], [ Z(3), 0*Z(3), Z(3) ], 
      [ 0*Z(3), Z(3), 0*Z(3) ] ], 
  [ [ Z(3), Z(3), Z(3)^0 ], [ Z(3), 0*Z(3), Z(3) ], 
      [ Z(3)^0, 0*Z(3), Z(3) ] ] ])
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsMatrixGroup">
<Heading>IsMatrixGroup (Filter)</Heading>

For most operations, &GAP; only provides methods for finite matrix groups.
Many calculations in finite matrix groups are done via so-called
<Q>nice monomorphisms</Q> (see Section <Ref Sect="Nice Monomorphisms"/>)
that represent a faithful action on vectors.

<ManSection>
<Filt Name="IsMatrixGroup" Arg='grp' Type='Category'/>

<Description>
The category of matrix groups.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties for Matrix Groups">
<Heading>Attributes and Properties for Matrix Groups</Heading>

<ManSection>
<Attr Name="DimensionOfMatrixGroup" Arg='mat-grp'/>

<Description>
The dimension of the matrix group.
</Description>
</ManSection>

<ManSection>
<Attr Name="DefaultFieldOfMatrixGroup" Arg='mat-grp'/>

<Description>
Is a field containing all the matrix entries. It is not guaranteed to be
the smallest field with this property.
</Description>
</ManSection>

<ManSection>
<Attr Name="FieldOfMatrixGroup" Arg='matgrp'/>

<Description>
The smallest field containing all the matrix entries of all elements
of the matrix group <A>matgrp</A>.
As the calculation of this can be hard, this should only be used if one
<E>really</E> needs the smallest field,
use <Ref Func="DefaultFieldOfMatrixGroup"/> to get (for example)
the characteristic.
<Example><![CDATA[
gap> DimensionOfMatrixGroup(m);
3
gap> DefaultFieldOfMatrixGroup(m);
GF(3)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TransposedMatrixGroup" Arg='matgrp'/>

<Description>
returns the transpose of the matrix group <A>matgrp</A>. The transpose of
the transpose of <A>matgrp</A> is identical to <A>matgrp</A>. 
<Example><![CDATA[
gap> G := Group( [[0,-1],[1,0]] );
Group([ [ [ 0, -1 ], [ 1, 0 ] ] ])
gap> T := TransposedMatrixGroup( G );
Group([ [ [ 0, 1 ], [ -1, 0 ] ] ])
gap> IsIdenticalObj( G, TransposedMatrixGroup( T ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFFEMatrixGroup" Arg='G' Type='Category'/>

<Description>
tests whether all matrices in <A>G</A> have finite field element entries.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Actions of Matrix Groups">
<Heading>Actions of Matrix Groups</Heading>
                                                                                
The basic operations for groups are described
in Chapter&nbsp;<Ref Chap="Group Actions"/>,
special actions for <E>matrix</E> groups mentioned there are
<Ref Func="OnLines"/>, <Ref Func="OnRight"/>,
and <Ref Func="OnSubspacesByCanonicalBasis"/>.
<!-- what about acting directly on subspace objects via <C>OnRight</C>? -->
<P/>
For subtleties concerning multiplication from the left or from the
right,
see&nbsp;<Ref Sect="Acting OnRight and OnLeft"/>.

<ManSection>
<Func Name="ProjectiveActionOnFullSpace" Arg='G, F, n'/>

<Description>
Let <A>G</A> be a group of <A>n</A> by <A>n</A> matrices over a field
contained in the finite field <A>F</A>.
<!-- why is <A>n</A> an argument?-->
<!-- (it should be read off from the group!)-->
<Ref Func="ProjectiveActionOnFullSpace"/> returns the image of the
projective action of <A>G</A> on the full row space
<M><A>F</A>^{<A>n</A>}</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveActionHomomorphismMatrixGroup" Arg='G'/>

<Description>
returns an action homomorphism for a faithful projective action of
<A>G</A> on the underlying vector space.
(Note: The action is not necessarily on the full space,
if a smaller subset can be found on which the action is faithful.)
</Description>
</ManSection>

<ManSection>
<Func Name="BlowUpIsomorphism" Arg='matgrp, B'/>

<Description>
For a matrix group <A>matgrp</A> and a basis <A>B</A> of a field
extension <M>L / K</M>, say, such that the entries of all matrices in
<A>matgrp</A> lie in <M>L</M>,
<Ref Func="BlowUpIsomorphism"/> returns the isomorphism with source
<A>matgrp</A> that is defined by mapping the matrix <M>A</M> to
<C>BlownUpMat</C><M>( A, <A>B</A> )</M>,
see&nbsp;<Ref Func="BlownUpMat"/>.
<Example><![CDATA[
gap> g:= GL(2,4);;
gap> B:= CanonicalBasis( GF(4) );;  BasisVectors( B );
[ Z(2)^0, Z(2^2) ]
gap> iso:= BlowUpIsomorphism( g, B );;
gap> Display( Image( iso, [ [ Z(4), Z(2) ], [ 0*Z(2), Z(4)^2 ] ] ) );
 . 1 1 .
 1 1 . 1
 . . 1 1
 . . 1 .
gap> img:= Image( iso, g );
<matrix group with 2 generators>
gap> Index( GL(4,2), img );
112
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="GL and SL">
<Heading>GL and SL</Heading>

(See also section&nbsp;<Ref Sect="Classical Groups"/>.)

<ManSection>
<Prop Name="IsGeneralLinearGroup" Arg='grp'/>
<Prop Name="IsGL" Arg='grp'/>

<Description>
The General Linear group is the group of all invertible matrices over a
ring. This property tests, whether a group is isomorphic to a General
Linear group. (Note that currently only a few trivial methods are
available for this operation. We hope to improve this in the future.)
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNaturalGL" Arg='matgrp'/>

<Description>
This property tests, whether a matrix group is the General Linear group
in the right dimension over the (smallest) ring which contains all
entries of its elements. (Currently, only a trivial test that computes
the order of the group is available.)
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSpecialLinearGroup" Arg='grp'/>
<Prop Name="IsSL" Arg='grp'/>

<Description>
The Special Linear group is the group of all invertible matrices over a
ring, whose determinant is equal to 1. This property tests, whether a
group is isomorphic to a Special Linear group. (Note that currently 
only a few trivial methods are available for this operation. We hope 
to improve this in the future.)
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNaturalSL" Arg='matgrp'/>

<Description>
This property tests, whether a matrix group is the Special Linear group
in the right dimension over the (smallest) ring which contains all
entries of its elements. (Currently, only a trivial test that computes
the order of the group is available.)
<Example><![CDATA[
gap> IsNaturalGL(m);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSubgroupSL" Arg='matgrp'/>

<Description>
This property tests, whether a matrix group is a subgroup of the Special
Linear group in the right dimension over the (smallest) ring which
contains all entries of its elements.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Invariant Forms">
<Heading>Invariant Forms</Heading>

<ManSection>
<Attr Name="InvariantBilinearForm" Arg='matgrp'/>

<Description>
This attribute describes a bilinear form that is invariant under the
matrix group <A>matgrp</A>.
The form is given by a record with the component <C>matrix</C>
which is a matrix <M>F</M> such that for every generator <M>g</M> of
<A>matgrp</A> the equation <M>g \cdot F \cdot g^{tr} = F</M> holds.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFullSubgroupGLorSLRespectingBilinearForm" Arg='matgrp'/>

<Description>
This property tests, whether a matrix group <A>matgrp</A> is the full
subgroup of GL or SL (the property <Ref Func="IsSubgroupSL"/> determines
which it is) respecting the form stored as the value of
<Ref Func="InvariantBilinearForm"/> for <A>matgrp</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="InvariantSesquilinearForm" Arg='matgrp'/>

<Description>
This attribute describes a sesquilinear form that is invariant under the
matrix group <A>matgrp</A> over the field <M>F</M> with <M>q^2</M>
elements, say.
The form is given by a record with the component <C>matrix</C>
which is is a matrix <M>M</M> such that for every generator <M>g</M> of
<A>matgrp</A>
the equation <M>g \cdot M \cdot (g^{tr})^f = M</M> holds,
where <M>f</M> is the automorphism of <M>F</M> that raises each element
to its <M>q</M>-th power.
(<M>f</M> can be obtained as a power of the
<Ref Func="FrobeniusAutomorphism"/> value of <M>F</M>.)
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFullSubgroupGLorSLRespectingSesquilinearForm" Arg='matgrp'/>

<Description>
This property tests, whether a matrix group <A>matgrp</A> is the full
subgroup of GL or SL (the property <Ref Func="IsSubgroupSL"/> determines
which it is) respecting the form stored as the value of
<Ref Func="InvariantSesquilinearForm"/> for <A>matgrp</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="InvariantQuadraticForm" Arg='matgrp'/>

<Description>
For a matrix group <A>matgrp</A>, <Ref Func="InvariantQuadraticForm"/>
returns a record containing at least the component <C>matrix</C>
whose value is a matrix <M>Q</M>.
The quadratic form <M>q</M> on the natural vector space <M>V</M> on which
<A>matgrp</A> acts is given by <M>q(v) = v Q v^{tr}</M>,
and the invariance under <A>matgrp</A> is given by the equation
<M>q(v) = q(v M)</M> for all <M>v \in V</M> and <M>M</M> in
<A>matgrp</A>.
(Note that the invariance of <M>q</M> does <E>not</E> imply that the
matrix <M>Q</M> is invariant under <A>matgrp</A>.)
<P/>
<M>q</M> is defined relative to an invariant symmetric bilinear form
<M>f</M> (see&nbsp;<Ref Func="InvariantBilinearForm"/>),
via the equation
<M>q(\lambda x + \mu y) =
\lambda^2 q(x) + \lambda \mu f(x,y) + \mu^2 q(y)</M>,
see <Cite Key="CCN85" Where="Chapter 3.4"/>.
If <M>f</M> is represented by the matrix <M>F</M> then this implies
<M>F = Q + Q^{tr}</M>.
In characteristic different from <M>2</M>, we have <M>q(x) = f(x,x)/2</M>,
so <M>Q</M> can be chosen as the strictly upper triangular part of
<M>F</M> plus half of the diagonal part of <M>F</M>.
In characteristic <M>2</M>, <M>F</M> does not determine <M>Q</M>
but still <M>Q</M> can be chosen as an upper (or lower) triangular matrix.
<P/>
Whenever the <Ref Func="InvariantQuadraticForm"/> value is set in a
matrix group then also the <Ref Func="InvariantBilinearForm"/> value
can be accessed,
and the two values are compatible in the above sense.
<!-- So wouldn't it be natural to store the inv. bilinear form in the-->
<!-- record of the invariant quadratic form?-->
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFullSubgroupGLorSLRespectingQuadraticForm" Arg='matgrp'/>

<Description>
This property tests, whether the matrix group <A>matgrp</A> is the full
subgroup of GL or SL (the property <Ref Func="IsSubgroupSL"/> determines
which it is) respecting the <Ref Func="InvariantQuadraticForm"/> value
of <A>matgrp</A>.
<Example><![CDATA[
gap> g:= Sp( 2, 3 );;
gap> m:= InvariantBilinearForm( g ).matrix;
[ [ 0*Z(3), Z(3)^0 ], [ Z(3), 0*Z(3) ] ]
gap> [ 0, 1 ] * m * [ 1, -1 ];           # evaluate the bilinear form
Z(3)
gap> IsFullSubgroupGLorSLRespectingBilinearForm( g );
true
gap> g:= SU( 2, 4 );;
gap> m:= InvariantSesquilinearForm( g ).matrix;
[ [ 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2) ] ]
gap> [ 0, 1 ] * m * [ 1, 1 ];            # evaluate the bilinear form
Z(2)^0
gap> IsFullSubgroupGLorSLRespectingSesquilinearForm( g );
true
gap> g:= GO( 1, 2, 3 );;
gap> m:= InvariantBilinearForm( g ).matrix;
[ [ 0*Z(3), Z(3)^0 ], [ Z(3)^0, 0*Z(3) ] ]
gap> [ 0, 1 ] * m * [ 1, 1 ];            # evaluate the bilinear form
Z(3)^0
gap> q:= InvariantQuadraticForm( g ).matrix;
[ [ 0*Z(3), Z(3)^0 ], [ 0*Z(3), 0*Z(3) ] ]
gap> [ 0, 1 ] * q * [ 0, 1 ];            # evaluate the quadratic form
0*Z(3)
gap> IsFullSubgroupGLorSLRespectingQuadraticForm( g );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Matrix Groups in Characteristic 0">
<Heading>Matrix Groups in Characteristic 0</Heading>

Most of the functions described in this and the following section have
implementations which use functions from the &GAP; package
<Package>Carat</Package>.
If <Package>Carat</Package> is not installed or not compiled,
no suitable methods are available.

<ManSection>
<Filt Name="IsCyclotomicMatrixGroup" Arg='G' Type='Category'/>

<Description>
tests whether all matrices in <A>G</A> have cyclotomic entries.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsRationalMatrixGroup" Arg='G'/>

<Description>
tests whether all matrices in <A>G</A> have rational entries.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsIntegerMatrixGroup" Arg='G'/>

<Description>
tests whether all matrices in <A>G</A> have integer entries.
<!--  Not <C>IsIntegralMatrixGroup</C> to avoid confusion with matrix groups of-->
<!--  integral cyclotomic numbers. -->
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNaturalGLnZ" Arg='G'/>

<Description>
tests whether <A>G</A> is <M>GL_n(&ZZ;)</M> in its natural representation
by <M>n \times n</M> integer matrices.
(The dimension <M>n</M> will be read off the generating matrices.)
<Example><![CDATA[
gap> IsNaturalGLnZ( GL( 2, Integers ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNaturalSLnZ" Arg='G'/>

<Description>
tests whether <A>G</A> is <M>SL_n(&ZZ;)</M> in its natural representation
by <M>n \times n</M> integer matrices.
(The dimension <M>n</M> will be read off the generating matrices.)
<Example><![CDATA[
gap> IsNaturalSLnZ( SL( 2, Integers ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="InvariantLattice" Arg='G'/>

<Description>
returns a matrix <M>B</M>, whose rows form a basis of a
<M>&ZZ;</M>-lattice that is invariant under the rational matrix group
<A>G</A> acting from the right.
It returns <K>fail</K> if the group is not unimodular. The columns of the
inverse of <M>B</M> span a <M>&ZZ;</M>-lattice invariant under <A>G</A>
acting from  the left.
</Description>
</ManSection>

<ManSection>
<Attr Name="NormalizerInGLnZ" Arg='G'/>

<Description>
is an attribute used to store the normalizer of <A>G</A> in
<M>GL_n(&ZZ;)</M>, where <A>G</A> is an integer matrix group of dimension
<A>n</A>. This attribute
is used by <C>Normalizer( GL( n, Integers ), G )</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CentralizerInGLnZ" Arg='G'/>

<Description>
is an attribute used to store the centralizer of <A>G</A> in
<M>GL_n(&ZZ;)</M>, where <A>G</A> is an integer matrix group of dimension
<A>n</A>. This attribute
is used by <C>Centralizer( GL( n, Integers ), G )</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ZClassRepsQClass" Arg='G'/>

<Description>
The conjugacy class in <M>GL_n(&QQ;)</M> of the finite integer matrix
group <A>G</A> splits into finitely many conjugacy classes in
<M>GL_n(&ZZ;)</M>.
<C>ZClassRepsQClass( <A>G</A> )</C> returns representative groups for these.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsBravaisGroup" Arg='G'/>

<Description>
test whether <A>G</A> coincides with its Bravais group
(see <Ref Func="BravaisGroup"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="BravaisGroup" Arg='G'/>

<Description>
returns the Bravais group of a finite integer matrix group <A>G</A>.
If <M>C</M> is the cone of positive definite quadratic forms <M>Q</M>
invariant under <M>g \mapsto g Q g^{tr}</M> for all <M>g \in <A>G</A></M>,
then the Bravais group of <A>G</A> is the maximal subgroup of
<M>GL_n(&ZZ;)</M> leaving the forms in that same cone invariant.
Alternatively, the Bravais group of <A>G</A>
can also be defined with respect to the action <M>g \mapsto g^{tr} Q g</M>
on positive definite quadratic forms <M>Q</M>. This latter definition
is appropriate for groups <A>G</A> acting from the right on row vectors,
whereas the former definition is appropriate for groups acting from
the left on column vectors. Both definitions yield the same
Bravais group.
</Description>
</ManSection>

<ManSection>
<Attr Name="BravaisSubgroups" Arg='G'/>

<Description>
returns the subgroups of the Bravais group of <A>G</A>, which are
themselves Bravais groups.
</Description>
</ManSection>

<ManSection>
<Attr Name="BravaisSupergroups" Arg='G'/>

<Description>
returns the subgroups of <M>GL_n(&ZZ;)</M> that contain the Bravais group
of <A>G</A> and are Bravais groups themselves.
</Description>
</ManSection>

<ManSection>
<Attr Name="NormalizerInGLnZBravaisGroup" Arg='G'/>

<Description>
returns the normalizer of the Bravais group of <A>G</A> in the
appropriate <M>GL_n(&ZZ;)</M>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Acting OnRight and OnLeft">
<Heading>Acting OnRight and OnLeft</Heading>

In &GAP;, matrices by convention act on row vectors from the right,
whereas in crystallography the convention is to act on column vectors
from the left. The definition of certain algebraic objects important
in crystallography implicitly depends on which action is assumed.
This holds true in particular for quadratic forms invariant under
a matrix group. In a similar way, the representation of affine
crystallographic groups, as they are provided by the &GAP; package
<Package>CrystGap</Package>, depends on which action is assumed.
Crystallographers are used to the action from the left,
whereas the action from the right is the natural one for &GAP;.
For this reason, a number of functions which are important in
crystallography, and whose result depends on which action is assumed,
are provided in two versions,
one for the usual action from the right, and one for the
crystallographic action from the left.
<P/>
For every such function, this fact is explicitly mentioned.
The naming scheme is as follows: If <C>SomeThing</C> is such a function,
there will be functions <C>SomeThingOnRight</C> and <C>SomeThingOnLeft</C>,
assuming action from the right and from the left, respectively.
In addition, there is a generic function <C>SomeThing</C>, which returns
either the result of <C>SomeThingOnRight</C> or <C>SomeThingOnLeft</C>,
depending on the global variable <Ref Var="CrystGroupDefaultAction"/>.

<ManSection>
<Var Name="CrystGroupDefaultAction"/>

<Description>
can have either of the two values <C>RightAction</C> and <C>LeftAction</C>.
The initial value is <C>RightAction</C>. For functions which have
variants OnRight and OnLeft, this variable determines which
variant is returned by the generic form. The value of
<Ref Var="CrystGroupDefaultAction"/> can be changed with with the
function <Ref Func="SetCrystGroupDefaultAction"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="SetCrystGroupDefaultAction" Arg='action'/>

<Description>
allows one to set the value of the global variable
<Ref Var="CrystGroupDefaultAction"/>.
Only the arguments <C>RightAction</C> and <C>LeftAction</C> are allowed.
Initially, the value of <Ref Var="CrystGroupDefaultAction"/> is
<C>RightAction</C>.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  pcgs.msk                    GAP documentation            Alexander Hulpke -->
<!-- %A                                                               Bettina Eick -->
<!-- %% -->
<!-- %A  @(#)<M>Id: pcgs.msk,v 1.33 2003/01/30 17:23:11 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Polycyclic Groups">
<Heading>Polycyclic Groups</Heading>

A group <A>G</A> is <E>polycyclic</E> if there exists a subnormal series
<M>G = C_1 > C_2 > \ldots > C_n > C_{{n+1}} = \{ 1 \}</M>
with cyclic factors. Such a series is called <E>pc series</E> of <A>G</A>.
<P/>
Every polycyclic group is solvable and every finite solvable group
is polycyclic. However, there are infinite solvable groups which
are not polycyclic.
<P/>
In &GAP; there exists a large number of methods for polycyclic groups
which are based upon the polycyclic structure of these groups. These
methods are usually very efficient, especially for groups which are
given by a pc-presentation (see chapter <Ref Chap="Pc Groups"/>), and can 
be applied to many types of groups. Hence &GAP; tries to use them 
whenever possible, for example, for permutation groups and matrix 
groups over finite fields that are known to be polycyclic 
(the only exception is the representation as finitely presented group 
for which the polycyclic methods cannot be used in general).
<P/>
At the current state of implementations the &GAP; library contains 
methods to compute with finite polycyclic groups, while the &GAP; 
package <Package>Polycyclic</Package> by Bettina Eick and Werner Nickel 
allows also computations with infinite polycyclic groups which are given 
by a pc-presentation.
<P/>
<!-- %%  Most of the methods for polycyclic groups are due to Frank Celler, Bettina -->
<!-- %%  Eick, Alexander Hulpke and Werner Nickel. The methods to consider a solvable -->
<!-- %%  permutation group as a polycyclic group are due to Heiko Theißen. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Polycyclic Generating Systems">
<Heading>Polycyclic Generating Systems</Heading>

Let <A>G</A> be a polycyclic group with a pc series as above.  A
<E>polycyclic generating sequence</E> (<E>pcgs</E> for short) of <A>G</A> is a
sequence <M>P := (g_1, \ldots, g_n)</M> of elements of <A>G</A> such that
<M>C_i = \langle C_{{i+1}}, g_i \rangle</M> for <M>1 \leq i \leq n</M>.
Note that each polycyclic group has a pcgs, but except for very
small groups, a pcgs is not unique.
<P/>
For each index <M>i</M> the subsequence of elements <M>(g_i, \ldots, g_n)</M>
forms a pcgs of the subgroup <M>C_i</M>. In particular, these <E>tails</E>
generate the subgroups of the pc series and hence we say that
the pc series is <E>determined</E> by <M>P</M>.
<P/>
Let <M>r_i</M> be the index of <M>C_{{i+1}}</M> in <M>C_i</M> which is either
a finite positive number or infinity. Then <M>r_i</M> is the order of
<M>g_i C_{{i+1}}</M> and we call the resulting list of indices the
<E>relative orders</E> of the pcgs <A>P</A>.
<P/>
Moreover, with respect to a given pcgs <M>(g_1, \ldots, g_n)</M> each
element <A>g</A> of <A>G</A> can be represented in a unique
way as a product <M>g = g_1^{{e_1}} \cdot g_2^{{e_2}} \cdots g_n^{{e_n}}</M>
with exponents <M>e_i \in \{0, \ldots, r_i-1\}</M>, if <M>r_i</M> is finite,
and <M>e_i \in &ZZ;</M> otherwise.
Words of this form are called <E>normal words</E> or <E>words in normal form</E>.
Then the integer vector <M>[ e_1, \ldots, e_n ]</M> is called the
<E>exponent vector</E> of the element <M>g</M>. Furthermore, the smallest
index <M>k</M> such that <M>e_k \neq 0</M> is called the <E>depth</E> of <A>g</A> and
<M>e_k</M> is the <E>leading exponent</E> of <A>g</A>.
<P/>
For many applications we have to assume that each of the relative orders
<M>r_i</M> is either a prime or infinity. This is equivalent to saying that
there are no trivial factors in the pc series and the finite factors of the
pc series are maximal refined.
Then we obtain that <M>r_i</M> is the order of <M>g C_{{i+1}}</M> for all
elements <M>g</M> in <M>C_i \setminus C_{{i+1}}</M> and we call
<M>r_i</M> the <E>relative order</E> of the element <M>g</M>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Computing a Pcgs">
<Heading>Computing a Pcgs</Heading>

Suppose a group <A>G</A> is given; for example, let <A>G</A> be a permutation
or matrix group. Then we can ask &GAP; to compute a pcgs of this group.
If <A>G</A> is not polycyclic, the result will be <K>fail</K>.
<P/>
Note that these methods can only be applied if <A>G</A> is not given
as finitely presented group. For finitely presented groups one
can try to compute a pcgs via the polycyclic quotient methods,
see <Ref Sect="Quotient Methods"/>.
<P/>
Note also that a pcgs behaves like a list.

<ManSection>
<Attr Name="Pcgs" Arg='G'/>

<Description>
returns a pcgs for the group <A>G</A>. 
If <A>grp</A> is not polycyclic it returns <K>fail</K> <E>and this result
is not  stored as attribute value</E>,
in particular in this case the filter <C>HasPcgs</C> is <E>not</E> set
for <A>G</A>!
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPcgs" Arg='obj' Type='Category'/>

<Description>
The category of pcgs. 
<Example><![CDATA[
gap> G := Group((1,2,3,4),(1,2));;
gap> p := Pcgs(G);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
gap> IsPcgs( p );
true
gap> p[1];
(3,4)
gap> G := Group((1,2,3,4,5),(1,2));;
gap> Pcgs(G);
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CanEasilyComputePcgs" Arg='grp'/>

<Description>
This filter indicates whether it is possible to compute a pcgs for
<A>grp</A> cheaply.
Clearly, <A>grp</A> must be polycyclic in this case.
However, not for every polycyclic group there is a method to compute a
pcgs at low costs.
This filter is used in the method selection mainly.
Note that this filter may change its value from <K>false</K> to
<K>true</K>. 

<Example><![CDATA[
gap> G := Group( (1,2,3,4),(1,2) );
Group([ (1,2,3,4), (1,2) ])
gap> CanEasilyComputePcgs(G);
false
gap> Pcgs(G);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
gap> CanEasilyComputePcgs(G);
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Defining a Pcgs Yourself">
<Heading>Defining a Pcgs Yourself</Heading>

In a number of situations it might be useful to supply a pcgs to a group.
<P/>
Note that the elementary operations for such a pcgs might be rather
inefficient, since &GAP; has to use generic methods in this case.
It might be helpful to supply the relative orders of the self-defined
pcgs as well by <C>SetRelativeOrder</C>.
See also&nbsp;<Ref Func="IsPrimeOrdersPcgs"/>.

<ManSection>
<Oper Name="PcgsByPcSequence" Arg='fam, pcs'/>
<Oper Name="PcgsByPcSequenceNC" Arg='fam, pcs'/>

<Description>
constructs a pcgs for the elements family <A>fam</A> from the elements in
the list <A>pcs</A>. The elements must lie in the family <A>fam</A>.
<Ref Oper="PcgsByPcSequence"/> and its <C>NC</C> variant will always
create a new pcgs which is not induced by any other pcgs 
(cf. <Ref Oper="InducedPcgsByPcSequence"/>).
<Example><![CDATA[
gap> fam := FamilyObj( (1,2) );; # the family of permutations
gap> p := PcgsByPcSequence( fam, [(1,2),(1,2,3)] );
Pcgs([ (1,2), (1,2,3) ])
gap> RelativeOrders(p);
[ 2, 3 ]
gap> ExponentsOfPcElement( p, (1,3,2) );
[ 0, 2 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elementary Operations for a Pcgs">
<Heading>Elementary Operations for a Pcgs</Heading>

<ManSection>
<Attr Name="RelativeOrders" Arg='pcgs'/>

<Description>
<Index Subkey="of a pcgs" Key="RelativeOrders">
<C>RelativeOrders</C></Index>
returns the list of relative orders of the pcgs <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFiniteOrdersPcgs" Arg='pcgs'/>

<Description>
tests whether the relative orders of <A>pcgs</A> are all finite.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPrimeOrdersPcgs" Arg='pcgs'/>

<Description>
tests whether the relative orders of <A>pcgs</A> are prime numbers. 
Many algorithms require a pcgs to have this property.
The operation&nbsp;<Ref Func="IsomorphismRefinedPcGroup"/>
can be of help here.
</Description>
</ManSection>

<ManSection>
<Attr Name="PcSeries" Arg='pcgs'/>

<Description>
returns the subnormal series determined by <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GroupOfPcgs" Arg='pcgs'/>

<Description>
The group generated by <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="OneOfPcgs" Arg='pcgs'/>

<Description>
The identity of the group generated by <A>pcgs</A>.
<Example><![CDATA[
gap> G := Group( (1,2,3,4),(1,2) );; p := Pcgs(G);;
gap> RelativeOrders(p);
[ 2, 3, 2, 2 ]
gap> IsFiniteOrdersPcgs(p);
true
gap> IsPrimeOrdersPcgs(p);
true
gap> PcSeries(p);
[ Group([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group([ (1,3)(2,4) ]), Group(()) 
 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elementary Operations for a Pcgs and an Element">
<Heading>Elementary Operations for a Pcgs and an Element</Heading>

<ManSection>
<Oper Name="RelativeOrderOfPcElement" Arg='pcgs, elm'/>

<Description>
The relative order of <A>elm</A> with respect to the prime order pcgs
<A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentOfPcElement" Arg='pcgs, elm, pos'/>

<Description>
returns the <A>pos</A>-th exponent of <A>elm</A> with respect to
<A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentsOfPcElement" Arg='pcgs, elm[, posran]'/>

<Description>
returns the exponents of <A>elm</A> with respect to <A>pcgs</A>.
The three argument version returns the exponents in the positions
given in <A>posran</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="DepthOfPcElement" Arg='pcgs, elm'/>

<Description>
returns the depth of the element <A>elm</A> with respect to <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LeadingExponentOfPcElement" Arg='pcgs, elm'/>

<Description>
returns the leading exponent of <A>elm</A> with respect to <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="PcElementByExponents" Arg='pcgs, list'/>
<Oper Name="PcElementByExponentsNC" Arg='pcgs[, basisind], list'/>

<Description>
returns the element corresponding to the exponent vector <A>list</A>
with respect to <A>pcgs</A>.
The exponents in <A>list</A> must be in the range of permissible
exponents for <A>pcgs</A>.
<E>It is not guaranteed that <Ref Func="PcElementByExponents"/> will
reduce the exponents modulo the relative orders</E>.
(You should use the operation <Ref Func="LinearCombinationPcgs"/>
for this purpose.)
The <C>NC</C> version does not check that the lengths of the lists
fit together and does not check the exponent range.
<P/>
The three argument version gives exponents only w.r.t. the generators
in <A>pcgs</A> indexed by <A>basisind</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LinearCombinationPcgs" Arg='pcgs, list[, one]'/>

<Description>
returns the product <M>\prod_i <A>pcgs</A>[i]^{{<A>list</A>[i]}}</M>.
In contrast to <Ref Func="PcElementByExponents"/> this permits negative
exponents.
<A>pcgs</A> might be a list of group elements.
In this case, an appropriate identity element
<A>one</A> must be given.
<A>list</A> can be empty.
<Example><![CDATA[
gap> G := Group( (1,2,3,4),(1,2) );; P := Pcgs(G);;
gap> g := PcElementByExponents(P, [0,1,1,1]);
(1,2,3)
gap> ExponentsOfPcElement(P, g);
[ 0, 1, 1, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SiftedPcElement" Arg='pcgs, elm'/>

<Description>
sifts <A>elm</A> through <A>pcgs</A>, reducing it if the depth is the
same as the depth of one of the generators in <A>pcgs</A>.
Thus the identity is returned if <A>elm</A> lies in the group generated
by <A>pcgs</A>.
<A>pcgs</A> must be an induced pcgs (see section 
<Ref Sect="Subgroups of Polycyclic Groups - Induced Pcgs"/>) 
and <A>elm</A> must lie in the span of the parent of <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="CanonicalPcElement" Arg='ipcgs, elm'/>

<Description>
reduces <A>elm</A> at the induces pcgs <A>ipcgs</A> such that the
exponents of the reduced result <A>r</A> are zero at the depths
for which there are generators in <A>ipcgs</A>.
Elements, whose quotient lies in the group generated by
<A>ipcgs</A> yield the same canonical element.
</Description>
</ManSection>

<ManSection>
<Oper Name="ReducedPcElement" Arg='pcgs, x, y'/>

<Description>
reduces the element <A>x</A> by dividing off (from the left) a power of
<A>y</A> such that the leading coefficient of the result with respect to
<A>pcgs</A> becomes zero.
The elements <A>x</A> and <A>y</A> therefore have to have the same depth.
</Description>
</ManSection>

<ManSection>
<Oper Name="CleanedTailPcElement" Arg='pcgs, elm, dep'/>

<Description>
returns an element in the span of <A>pcgs</A> whose exponents for indices
<M>1</M> to <M><A>dep</A>-1</M> with respect to <A>pcgs</A> are the same
as those of <A>elm</A>, the remaining exponents are undefined.
This can be used to obtain more
<Q>simple</Q> elements if only representatives in a factor are required,
see&nbsp;<Ref Sect="Factor Groups of Polycyclic Groups - Modulo Pcgs"/>.
<P/>
The difference to <Ref Func="HeadPcElementByNumber"/>
is that this function is guaranteed to zero out trailing
coefficients while <Ref Oper="CleanedTailPcElement"/> will only do this
if it can be done cheaply.
</Description>
</ManSection>

<ManSection>
<Oper Name="HeadPcElementByNumber" Arg='pcgs, elm, dep'/>

<Description>
returns an element in the span of <A>pcgs</A> whose exponents for indices
<M>1</M> to <A>dep</A><M>-1</M> with respect to <A>pcgs</A> are the same
as those of <A>elm</A>, the remaining exponents are zero.
This can be used to obtain more
<Q>simple</Q> elements if only representatives in a factor are required.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Exponents of Special Products">
<Heading>Exponents of Special Products</Heading>

There are certain products of elements whose exponents are used often within
algorithms, and which might be obtained more easily than by computing the
product first and to obtain its exponents afterwards. The operations in this
section provide a way to obtain such exponent vectors directly.
<P/>
(The circumstances under which these operations give a speedup depend very
much on the pcgs and the representation of elements that is used. So the
following operations are not guaranteed to give a speedup in every case,
however the default methods are not slower than to compute the exponents of
a product and thus these operations should <E>always</E> be used if applicable.)
<P/>
The second class are exponents of products of the generators which make up
the pcgs.
If the pcgs used is a family pcgs (see <Ref Func="FamilyPcgs"/>) then
these exponents can be looked up and do not need to be computed.

<ManSection>
<Oper Name="ExponentsConjugateLayer" Arg='mpcgs, elm, e'/>

<Description>
Computes the exponents of <A>elm</A><C>^</C><A>e</A> with respect to
<A>mpcgs</A>; <A>elm</A> must be in the span of <A>mpcgs</A>,
<A>e</A> a pc element in the span of the
parent pcgs of <A>mpcgs</A> and <A>mpcgs</A> must be the modulo pcgs for
an abelian layer. (This is the usual case when acting on a chief
factor). In this case if <A>mpcgs</A> is induced by the family pcgs (see
section <Ref Sect="Subgroups of Polycyclic Groups - Induced Pcgs"/>), 
the exponents can be computed directly by looking up exponents without
having to compute in the group and having to collect a potential tail.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentsOfRelativePower" Arg='pcgs, i'/>

<Description>
For <M>p = <A>pcgs</A>[<A>i</A>]</M> this function returns the
exponent vector with respect to <A>pcgs</A> of the element <M>p^e</M>
where <M>e</M> is the relative order of <A>p</A> in <A>pcgs</A>.
For the family pcgs or pcgs induced by it (see section 
<Ref Sect="Subgroups of Polycyclic Groups - Induced Pcgs"/>), this 
might be faster than computing the element and computing its exponent 
vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentsOfConjugate" Arg='pcgs, i, j'/>

<Description>
returns the exponents of
<C><A>pcgs</A>[<A>i</A>]^<A>pcgs</A>[<A>j</A>]</C> with respect to
<A>pcgs</A>. For the family pcgs or pcgs induced by it (see section 
<Ref Sect="Subgroups of Polycyclic Groups - Induced Pcgs"/>), this 
might be faster than computing the element and computing its exponent 
vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExponentsOfCommutator" Arg='pcgs, i, j'/>

<Description>
returns the exponents of the commutator
<C>Comm( </C><M><A>pcgs</A>[<A>i</A>], <A>pcgs</A>[<A>j</A>]</M><C> )</C>
with respect to <A>pcgs</A>. For the family pcgs or pcgs induced by it,
(see section <Ref Sect="Subgroups of Polycyclic Groups - Induced Pcgs"/>),
this might be faster than computing the element and computing its
exponent vector.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroups of Polycyclic Groups - Induced Pcgs">
<Heading>Subgroups of Polycyclic Groups - Induced Pcgs</Heading>

Let <A>U</A> be a subgroup of <A>G</A> and let <A>P</A> be a pcgs of <A>G</A> as above such
that <A>P</A> determines the subnormal series
<M>G = C_1 > \ldots > C_{{n+1}} = \{ 1 \}</M>.
Then the series of subgroups <M>U \cap C_i</M> is a subnormal series
of <A>U</A> with cyclic or trivial factors. Hence, if we choose an element
<M>u_{{i_j}} \in (U \cap C_{{i_j}}) \setminus (U \cap C_{{i_j+1}})</M>
whenever this factor is non-trivial, then we obtain a pcgs
<M>Q = (u_{{i_1}}, \ldots, u_{{i_m}})</M> of <M>U</M>.
We say that <M>Q</M> is an <E>induced pcgs</E> with respect to <A>P</A>.
The pcgs <A>P</A> is the <E>parent pcgs</E> to the induced pcgs <A>Q</A>.
<P/>
Note that the pcgs <M>Q</M> is induced with respect to <A>P</A> if and only
if the matrix of exponent vectors of the elements <M>u_{{i_j}}</M> with
respect to <A>P</A> is in upper triangular form. Thus <M>Q</M> is not unique in
general.
<P/>
In particular, the elements of an induced pcgs do <E>not necessarily</E> have
leading coefficient 1 relative to the inducing pcgs. The attribute
<Ref Func="LeadCoeffsIGS"/> holds the leading coefficients in case
they have to be renormed in an algorithm.
<P/>
Each induced pcgs is a pcgs and hence allows all elementary operations
for pcgs. On the other hand each pcgs could be transformed into an
induced pcgs for the group defined by the pcgs, but note that an
arbitrary pcgs is in general not an induced pcgs for technical reasons.
<P/>
An induced pcgs is <Q>compatible</Q> with its parent,
see <Ref Func="ParentPcgs"/>.
<P/>
In <Cite Key="SOGOS"/> a <Q>non-commutative Gauss</Q> algorithm is
described to compute an induced pcgs of a subgroup <A>U</A>  from a
generating set of <A>U</A>.
For calling this in &GAP;, see <Ref Subsect="InducedPcgs"/> to
<Ref Subsect="ExtendedPcgs"/>.
<P/>
To create a subgroup generated by an induced pcgs such that the
induced pcgs gets stored automatically, use <Ref Func="SubgroupByPcgs"/>.

<ManSection>
<Filt Name="IsInducedPcgs" Arg='pcgs' Type='Category'/>

<Description>
The category of induced pcgs. This a subcategory of pcgs.
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedPcgsByPcSequence" Arg='pcgs, pcs'/>
<Oper Name="InducedPcgsByPcSequenceNC" Arg='pcgs, pcs[, depths]'/>

<Description>
If <A>pcs</A> is a list of elements that form an induced pcgs
with respect to <A>pcgs</A> this operation returns an induced pcgs
with these elements.
<P/>
In the third version, the depths of <A>pcs</A> with respect to
<A>pcgs</A> can be given (they are computed anew otherwise).
</Description>
</ManSection>

<ManSection>
<Attr Name="ParentPcgs" Arg='pcgs'/>

<Description>
returns the pcgs by which <A>pcgs</A> was induced.
If <A>pcgs</A> was not induced, it simply returns <A>pcgs</A>.
<Example><![CDATA[
gap> G := Group( (1,2,3,4),(1,2) );;
gap> P := Pcgs(G);;
gap> K := InducedPcgsByPcSequence( P, [(1,2,3,4),(1,3)(2,4)] );
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
gap> ParentPcgs( K );
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
gap> IsInducedPcgs( K );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedPcgs" Arg='pcgs, grp'/>

<Description>
computes a pcgs for <A>grp</A> which is induced by <A>pcgs</A>.
If <A>pcgs</A> has a parent pcgs,
then the result is induced with respect to this parent pcgs.
<P/>
<Ref Func="InducedPcgs"/> is a wrapper function only.
Therefore, methods for computing computing an induced pcgs
should be installed for the operation <C>InducedPcgsOp</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedPcgsByGenerators" Arg='pcgs, gens'/>
<Oper Name="InducedPcgsByGeneratorsNC" Arg='pcgs, gens'/>

<Description>
returns an induced pcgs with respect to <A>pcgs</A>
for the subgroup generated by <A>gens</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedPcgsByPcSequenceAndGenerators" Arg='pcgs, ind, gens'/>

<Description>
returns an induced pcgs with respect to <A>pcgs</A> of the subgroup
generated by <A>ind</A> and <A>gens</A>.
Here <A>ind</A> must be an induced pcgs with respect to
<A>pcgs</A> (or a list of group elements that form such an igs)
and it will be used as initial sequence for the computation.

<Example><![CDATA[
gap> G := Group( (1,2,3,4),(1,2) );;  P := Pcgs(G);;
gap> I := InducedPcgsByGenerators( P, [(1,2,3,4)] );
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
gap> J := InducedPcgsByPcSequenceAndGenerators( P, I, [(1,2)] );
Pcgs([ (1,2,3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LeadCoeffsIGS" Arg='igs'/>

<Description>
This attribute is used to store leading coefficients with respect to the
parent pcgs. the <A>i</A>-th entry &ndash;if bound&ndash; is the leading
exponent of the element of <A>igs</A> that has depth <A>i</A> in the
parent.
(It cannot be assigned to a component in the object created by
<Ref Func="InducedPcgsByPcSequenceNC"/> as the
permutation group methods call it from within the postprocessing,
before this postprocessing however no coefficients may be computed.)
</Description>
</ManSection>

<ManSection>
<Oper Name="ExtendedPcgs" Arg='N, gens'/>

<Description>
extends the pcgs <A>N</A> (induced w.r.t. <A>home</A>) to a new
induced pcgs by prepending <A>gens</A>.
No checks are performed that this really yields an induced pcgs.
</Description>
</ManSection>

<ManSection>
<Oper Name="SubgroupByPcgs" Arg='G, pcgs'/>

<Description>
returns a subgroup of <A>G</A> generated by the elements of <A>pcgs</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroups of Polycyclic Groups - Canonical Pcgs">
<Heading>Subgroups of Polycyclic Groups &ndash; Canonical Pcgs</Heading>

The induced pcgs <A>Q</A> of <A>U</A> is called <E>canonical</E> if the matrix
of exponent vectors contains normed vectors only and above each
leading entry in the matrix there are 0's only.  The canonical pcgs
of <A>U</A> with respect to <A>P</A> is unique and hence such pcgs can be used
to compare subgroups.

<ManSection>
<Prop Name="IsCanonicalPcgs" Arg='pcgs'/>

<Description>
An induced pcgs is canonical if the matrix of the exponent vectors of
the elements of <A>pcgs</A> with respect to the <Ref Func="ParentPcgs"/>
value of <A>pcgs</A> is in Hermite normal form
(see <Cite Key="SOGOS"/>). While a subgroup can have various
induced pcgs with respect to a parent pcgs a canonical pcgs is unique.
</Description>
</ManSection>

<ManSection>
<Attr Name="CanonicalPcgs" Arg='pcgs'/>

<Description>
returns the canonical pcgs corresponding to the induced pcgs <A>pcgs</A>.
<Example><![CDATA[
gap> G := Group((1,2,3,4),(5,6,7));
Group([ (1,2,3,4), (5,6,7) ])
gap> P := Pcgs(G);
Pcgs([ (5,6,7), (1,2,3,4), (1,3)(2,4) ])
gap> I := InducedPcgsByPcSequence(P, [(5,6,7)*(1,3)(2,4),(1,3)(2,4)] );
Pcgs([ (1,3)(2,4)(5,6,7), (1,3)(2,4) ])
gap> CanonicalPcgs(I);
Pcgs([ (5,6,7), (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Factor Groups of Polycyclic Groups - Modulo Pcgs">
<Heading>Factor Groups of Polycyclic Groups &ndash; Modulo Pcgs</Heading>

Let <A>N</A> be a normal subgroup of <A>G</A> such that <A>G/N</A> is polycyclic
with pcgs <M>(h_1 N, \ldots, h_r N)</M>. Then we call the sequence of
preimages <M>(h_1, \ldots h_r)</M> a <E>modulo pcgs</E> of <A>G/N</A>.
<A>G</A> is called the <E>numerator</E> of the modulo pcgs and <A>N</A> is the
<E>denominator</E> of the modulo pcgs.
<P/>
Modulo pcgs are often used to facilitate efficient computations with
factor groups, since they allow computations with factor groups without
formally defining the factor group at all.
<P/>
All elementary operations of pcgs,
see Sections <Ref Sect="Elementary Operations for a Pcgs"/> and
<Ref Sect="Elementary Operations for a Pcgs and an Element"/>,
apply to modulo pcgs as well. However, it is in general not possible to
compute induced pcgs with respect to a modulo pcgs.
<P/>
Two more elementary operations for modulo pcgs are
<Ref Func="NumeratorOfModuloPcgs"/> and
<Ref Func="DenominatorOfModuloPcgs"/>.

<ManSection>
<Oper Name="ModuloPcgs" Arg='G, N'/>

<Description>
returns a modulo pcgs for the factor <M><A>G</A>/<A>N</A></M> which must
be solvable, which <A>N</A> may be insolvable.
<Ref Func="ModuloPcgs"/> will return <E>a</E> pcgs for the factor,
there is no guarantee that it will be <Q>compatible</Q> with any other
pcgs.
If this is required, the <K>mod</K> operator must be used on
induced pcgs, see <Ref Meth="\mod" Label="for two pcgs"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsModuloPcgs" Arg='obj' Type='Category'/>

<Description>
The category of modulo pcgs. Note that each pcgs is a modulo pcgs for
the trivial subgroup. 
</Description>
</ManSection>

<ManSection>
<Attr Name="NumeratorOfModuloPcgs" Arg='pcgs'/>

<Description>
returns a generating set for the numerator of the modulo pcgs
<A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="DenominatorOfModuloPcgs" Arg='pcgs'/>

<Description>
returns a generating set for the denominator of the modulo pcgs
<A>pcgs</A>.

<Example><![CDATA[
gap> G := Group( (1,2,3,4,5),(1,2) );
Group([ (1,2,3,4,5), (1,2) ])
gap> P := ModuloPcgs(G, DerivedSubgroup(G) );
Pcgs([ (4,5) ])
gap> NumeratorOfModuloPcgs(P);
[ (1,2,3,4,5), (1,2) ]
gap> DenominatorOfModuloPcgs(P);
[ (1,3,2), (2,4,3), (2,3)(4,5) ]
gap> RelativeOrders(P);
[ 2 ]
gap> ExponentsOfPcElement( P, (1,2,3,4,5) );
[ 0 ]
gap> ExponentsOfPcElement( P, (4,5) );
[ 1 ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Meth Name="\mod" Arg='P, I' Label="for two pcgs"/>

<Description>
Modulo Pcgs can also be built from compatible induced pcgs.
Let <M>G</M> be a group with pcgs <A>P</A> and let <A>I</A> be
an induced pcgs of a normal subgroup <M>N</M> of <M>G</M>.
(Respectively: <A>P</A> and <A>I</A> are both induced
with respect to the <E>same</E> Pcgs.)
Then we can compute a modulo pcgs of <M>G</M> mod <M>N</M> by
<P/>
<A>P</A> <K>mod</K> <A>I</A>
<P/>
Note that in this case we obtain the advantage that the values of
<Ref Func="NumeratorOfModuloPcgs"/> and <Ref Func="DenominatorOfModuloPcgs"/>
are just <A>P</A> and <A>I</A>, respectively, and hence are unique.
<P/>
The resulting modulo pcgs will consist of a subset of <A>P</A> and will be
<Q>compatible</Q> with <A>P</A> (or its parent).
<P/>
<Example><![CDATA[
gap> G := Group((1,2,3,4));;
gap> P := Pcgs(G);
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
gap> I := InducedPcgsByGenerators(P, [(1,3)(2,4)]);
Pcgs([ (1,3)(2,4) ])
gap> M := P mod I;
[ (1,2,3,4) ]
gap> NumeratorOfModuloPcgs(M);
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
gap> DenominatorOfModuloPcgs(M);
Pcgs([ (1,3)(2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CorrespondingGeneratorsByModuloPcgs" Arg='mpcgs, imgs'/>

<Description>
Let <A>mpcgs</A> be a modulo pcgs for a factor of a group <M>G</M>
and let <M>U</M> be a subgroup of <M>G</M> generated by <A>imgs</A>
such that <M>U</M> covers the factor for the modulo pcgs.
Then this function computes elements in <M>U</M> corresponding to the
generators of the modulo pcgs.
<P/>
Note that the computation of induced generating sets is not possible
for some modulo pcgs.
</Description>
</ManSection>

<ManSection>
<Oper Name="CanonicalPcgsByGeneratorsWithImages" Arg='pcgs, gens, imgs'/>

<Description>
computes a canonical, <A>pcgs</A>-induced pcgs for the span of
<A>gens</A> and simultaneously does the same transformations on
<A>imgs</A>, preserving thus a correspondence between <A>gens</A> and
<A>imgs</A>.
This operation is used to represent homomorphisms from a pc group.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Factor Groups of Polycyclic Groups in their Own Representation">
<Heading>Factor Groups of Polycyclic Groups in their Own Representation</Heading>

If substantial calculations are done in a factor it might be worth still to
construct the factor group in its own representation (for example by
calling <Ref Func="PcGroupWithPcgs"/> on a modulo pcgs.
<P/>
The following functions are intended for working with factor groups
obtained by factoring out the tail of a pcgs.
They provide a way to map elements or induced pcgs quickly in the factor
(respectively to take preimages) without the need to construct a
homomorphism.
<P/>
The setup is always a pcgs <A>pcgs</A> of <A>G</A> and a pcgs
<A>fpcgs</A> of a factor group <M>H = <A>G</A>/<A>N</A></M>
which corresponds to a head of <A>pcgs</A>.
<P/>
No tests for validity of the input are performed.

<ManSection>
<Func Name="ProjectedPcElement" Arg='pcgs, fpcgs, elm'/>

<Description>
returns the image in <A>H</A> of an element <A>elm</A> of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectedInducedPcgs" Arg='pcgs, fpcgs, ipcgs'/>

<Description>
<A>ipcgs</A> must be an induced pcgs with respect to <A>pcgs</A>.
This operation returns an induced pcgs with respect to <A>fpcgs</A>
consisting of the nontrivial images of <A>ipcgs</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="LiftedPcElement" Arg='pcgs, fpcgs, elm'/>

<Description>
returns a preimage in <A>G</A> of an element <A>elm</A> of <A>H</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="LiftedInducedPcgs" Arg='pcgs, fpcgs, ipcgs, ker'/>

<Description>
<A>ipcgs</A> must be an induced pcgs with respect to <A>fpcgs</A>.
This operation returns an induced pcgs with respect to <A>pcgs</A>
consisting of the preimages of <A>ipcgs</A>,
appended by the elements in <A>ker</A> (assuming
there is a bijection of <A>pcgs</A> mod <A>ker</A> to <A>fpcgs</A>).
<A>ker</A> might be a simple element list.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Pcgs and Normal Series">
<Heading>Pcgs and Normal Series</Heading>

By definition, a pcgs determines a pc series of its underlying group.
However, in many applications it will be necessary that this pc series
refines a normal series with certain properties; for example, a normal
series with abelian factors.
<P/>
There are functions in &GAP; to compute a pcgs through a normal series
with elementary abelian factors, a central series or the lower p-central
series. See also Section <Ref Sect="Special Pcgs"/> for a more explicit possibility.

<ManSection>
<Prop Name="IsPcgsElementaryAbelianSeries" Arg='pcgs'/>

<Description>
returns <K>true</K> if the pcgs <A>pcgs</A> refines an elementary abelian
series.
<Ref Func="IndicesEANormalSteps"/> then gives the indices in the Pcgs,
at which the subgroups of this series start. 
</Description>
</ManSection>

<ManSection>
<Attr Name="PcgsElementaryAbelianSeries" Arg='G' Label="for a group"/>
<Attr Name="PcgsElementaryAbelianSeries" Arg='list'
 Label="for a list of normal subgroups"/>

<Description>
computes a pcgs for <A>G</A> that refines an elementary abelian series.
<Ref Func="IndicesEANormalSteps"/> gives the indices in the pcgs,
at which the normal subgroups of this series start.
The second variant returns a pcgs that runs through the normal subgroups
in the list <A>list</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesEANormalSteps" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a series of normal
subgroups with elementary abelian factors (for example from calling
<Ref Func="PcgsElementaryAbelianSeries" Label="for a group"/>)
Then <Ref Func="IndicesEANormalSteps"/> returns a sorted list of
integers, indicating the tails of <A>pcgs</A> which generate these normal
subgroup of <A>G</A>.
If <M>i</M> is an element of this list, <M>(g_i, \ldots, g_n)</M>
is a normal subgroup of <A>G</A>.  The list always starts with <M>1</M>
and ends with <M>n+1</M>.
(These indices form <E>one</E> series with elementary abelian
subfactors, not necessarily the most refined one.)
<P/>
The attribute <Ref Func="EANormalSeriesByPcgs"/> returns the actual
series of subgroups.
<P/>
For arbitrary pcgs not obtained as belonging to a special series such a
set of indices not necessarily exists,
and <Ref Func="IndicesEANormalSteps"/> is not
guaranteed to work in this situation.
<P/>
Typically, <Ref Func="IndicesEANormalSteps"/> is set by
<Ref Func="PcgsElementaryAbelianSeries" Label="for a group"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="EANormalSeriesByPcgs" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a series of normal
subgroups with elementary abelian factors (for example from calling
<Ref Func="PcgsElementaryAbelianSeries" Label="for a group"/>).
This attribute returns the actual series of normal subgroups,
corresponding to <Ref Func="IndicesEANormalSteps"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPcgsCentralSeries" Arg='pcgs'/>

<Description>
returns <K>true</K> if the pcgs <A>pcgs</A> refines an central elementary
abelian series.
<Ref Func="IndicesCentralNormalSteps"/> then gives the indices in the
pcgs, at which the subgroups of this series start. 
</Description>
</ManSection>

<ManSection>
<Attr Name="PcgsCentralSeries" Arg='G'/>

<Description>
computes a pcgs for <A>G</A> that refines a central elementary abelian
series.
<Ref Func="IndicesCentralNormalSteps"/> gives the indices in the pcgs,
at which the normal subgroups of this series start.
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesCentralNormalSteps" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a series of normal
subgroups with central elementary abelian factors
(for example from calling <Ref Func="PcgsCentralSeries"/>).
Then <Ref Func="IndicesCentralNormalSteps"/> returns a sorted list of
integers, indicating the tails of <A>pcgs</A> which generate these normal
subgroups of <A>G</A>.
If <M>i</M> is an element of this list, <M>(g_i, \ldots, g_n)</M>
is a normal subgroup of <A>G</A>.
The list always starts with <M>1</M> and ends with <M>n+1</M>.
(These indices form <E>one</E> series with central elementary abelian
subfactors, not necessarily the most refined one.)
<P/>
The attribute <Ref Func="CentralNormalSeriesByPcgs"/> returns the actual
series of subgroups.
<P/>
For arbitrary pcgs not obtained as belonging to a special series such a
set of indices not necessarily exists,
and <Ref Func="IndicesCentralNormalSteps"/>
is not guaranteed to work in this situation.
<P/>
Typically, <Ref Func="IndicesCentralNormalSteps"/> is set by
<Ref Func="PcgsCentralSeries"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CentralNormalSeriesByPcgs" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a series of normal
subgroups with central elementary abelian factors (for example from
calling <Ref Func="PcgsCentralSeries"/>).
This attribute returns the actual series of normal subgroups,
corresponding to <Ref Func="IndicesCentralNormalSteps"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPcgsPCentralSeriesPGroup" Arg='pcgs'/>

<Description>
returns <K>true</K> if the pcgs <A>pcgs</A> refines a <M>p</M>-central
elementary abelian series for a <M>p</M>-group.
<Ref Func="IndicesPCentralNormalStepsPGroup"/> then gives the indices in
the pcgs, at which the subgroups of this series start. 
</Description>
</ManSection>

<ManSection>
<Attr Name="PcgsPCentralSeriesPGroup" Arg='G'/>

<Description>
computes a pcgs for the <M>p</M>-group <A>G</A> that refines a
<M>p</M>-central elementary abelian series.
<Ref Func="IndicesPCentralNormalStepsPGroup"/> gives the
indices in the pcgs, at which the normal subgroups of this series start.
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesPCentralNormalStepsPGroup" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a series of normal
subgroups with <M>p</M>-central elementary abelian factors
(for example from calling <Ref Func="PcgsPCentralSeriesPGroup"/>).
Then <Ref Func="IndicesPCentralNormalStepsPGroup"/> returns a sorted list
of integers, indicating the tails of <A>pcgs</A> which generate these
normal subgroups of <A>G</A>.
If <M>i</M> is an element of this list, <M>(g_i, \ldots, g_n)</M>
is a normal subgroup of <A>G</A>.
The list always starts with <M>1</M> and ends with <M>n+1</M>.
(These indices form <E>one</E> series with central elementary abelian
subfactors, not necessarily the most refined one.)
<P/>
The attribute <Ref Func="PCentralNormalSeriesByPcgsPGroup"/> returns the
actual series of subgroups.
<P/>
For arbitrary pcgs not obtained as belonging to a special series such a
set of indices not necessarily exists, and
<Ref Func="IndicesPCentralNormalStepsPGroup"/>
is not guaranteed to work in this situation.
<P/>
Typically, <Ref Func="IndicesPCentralNormalStepsPGroup"/> is set by
<Ref Func="PcgsPCentralSeriesPGroup"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="PCentralNormalSeriesByPcgsPGroup" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a series of normal
subgroups with <M>p</M>-central elementary abelian factors
(for example from calling <Ref Func="PcgsPCentralSeriesPGroup"/>).
This attribute returns the actual series of normal subgroups,
corresponding to <Ref Func="IndicesPCentralNormalStepsPGroup"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPcgsChiefSeries" Arg='pcgs'/>

<Description>
returns <K>true</K> if the pcgs <A>pcgs</A> refines a chief series.
<Ref Func="IndicesChiefNormalSteps"/> then gives the indices in the pcgs,
at which the subgroups of this series start. 
</Description>
</ManSection>

<ManSection>
<Attr Name="PcgsChiefSeries" Arg='G'/>

<Description>
computes a pcgs for <A>G</A> that refines a chief series.
<Ref Func="IndicesChiefNormalSteps"/> gives the indices in the pcgs,
at which the normal subgroups of this series start.
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesChiefNormalSteps" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a chief series
for example from calling <Ref Func="PcgsChiefSeries"/>).
Then <Ref Func="IndicesChiefNormalSteps"/> returns a sorted list of
integers, indicating the tails of <A>pcgs</A> which generate these normal
subgroups of <A>G</A>.
If <M>i</M> is an element of this list, <M>(g_i, \ldots, g_n)</M>
is a normal subgroup of <A>G</A>.
The list always starts with <M>1</M> and ends with <M>n+1</M>.
(These indices form <E>one</E> series with elementary abelian
subfactors, not necessarily the most refined one.)
<P/>
The attribute <Ref Func="ChiefNormalSeriesByPcgs"/> returns the actual
series of subgroups.
<P/>
For arbitrary pcgs not obtained as belonging to a special series such a
set of indices not necessarily exists,
and <Ref Func="IndicesChiefNormalSteps"/> is not
guaranteed to work in this situation.
<P/>
Typically, <Ref Func="IndicesChiefNormalSteps"/> is set by
<Ref Func="PcgsChiefSeries"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ChiefNormalSeriesByPcgs" Arg='pcgs'/>

<Description>
Let <A>pcgs</A> be a pcgs obtained as corresponding to a chief series
(for example from calling
<Ref Func="PcgsChiefSeries"/>). This attribute returns the actual series
of normal subgroups,
corresponding to <Ref Func="IndicesChiefNormalSteps"/>.

<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> p:=PcgsElementaryAbelianSeries(g);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
gap> IndicesEANormalSteps(p);
[ 1, 2, 3, 5 ]
gap> g:=Group((1,2,3,4),(1,5)(2,6)(3,7)(4,8));;
gap> p:=PcgsCentralSeries(g);
Pcgs([ (1,5)(2,6)(3,7)(4,8), (5,6,7,8), (5,7)(6,8), 
  (1,4,3,2)(5,6,7,8), (1,3)(2,4)(5,7)(6,8) ])
gap> IndicesCentralNormalSteps(p);
[ 1, 2, 4, 5, 6 ]
gap> q:=PcgsPCentralSeriesPGroup(g);
Pcgs([ (1,5)(2,6)(3,7)(4,8), (5,6,7,8), (5,7)(6,8), 
  (1,4,3,2)(5,6,7,8), (1,3)(2,4)(5,7)(6,8) ])
gap> IndicesPCentralNormalStepsPGroup(q);
[ 1, 3, 5, 6 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesNormalSteps" Arg='pcgs'/>

<Description>
returns the indices of <E>all</E> steps in the pc series,
which are normal in the group defined by the pcgs.
<P/>
(In general, this function yields a slower performance than the more
specialized index functions for elementary abelian series etc.)
</Description>
</ManSection>

<ManSection>
<Attr Name="NormalSeriesByPcgs" Arg='pcgs'/>

<Description>
returns the subgroups the pc series, which are normal in
the group defined by the pcgs.
<P/>
(In general, this function yields a slower performance than the more
specialized index functions for elementary abelian series etc.)
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sum and Intersection of Pcgs">
<Heading>Sum and Intersection of Pcgs</Heading>

<!-- %eclaration{SumPcgs} -->
<!-- %eclaration{IntersectionSumPcgs} -->
<!-- %eclaration{NormalIntersectionPcgs} -->
<ManSection>
<Oper Name="SumFactorizationFunctionPcgs"
 Arg='parentpcgs, n, u, kerpcgs'/>

<Description>
computes the sum and intersection of the lists <A>n</A> and <A>u</A> whose
elements form modulo pcgs induced by <A>parentpcgs</A> for two subgroups
modulo a kernel given by <A>kerpcgs</A>.
If <A>kerpcgs</A> is a tail if the <A>parent-pcgs</A> it is sufficient
to give the starting depth,
this can be more efficient than to construct an explicit pcgs.
The factor group modulo <A>kerpcgs</A> generated by <A>n</A> must be
elementary abelian and normal under <A>u</A>.
<P/>
The function returns a record with components
<List>
<Mark><C>sum</C></Mark>
<Item>
  elements that form a modulo pcgs for the span of both subgroups.
</Item>
<Mark><C>intersection</C></Mark>
<Item>
  elements that form a modulo pcgs for the intersection of
  both subgroups.
</Item>
<Mark><C>factorization</C></Mark>
<Item>
  a function that returns for an element <A>x</A> in the span
  of <C>sum</C> a record with components <C>u</C> and <C>n</C>
  that give its decomposition.
</Item>
</List>
<P/>
The record components <C>sum</C> and <C>intersection</C> are <E>not</E>
pcgs but only lists of pc elements (to avoid unnecessary creation of
induced pcgs).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Special Pcgs">
<Heading>Special Pcgs</Heading>

In short, a special pcgs is a pcgs which has particularly nice properties,
for example it always refines an elementary abelian series, for <M>p</M>-groups
it even refines a central series. These nice properties permit particularly
efficient algorithms.
<P/>
Let <A>G</A> be a finite polycyclic group. A <E>special pcgs</E> of <A>G</A> is a pcgs
which is closely related to a Hall system and the maximal subgroups of <A>G</A>.
These pcgs have been introduced by C. R. Leedham-Green who also gave an
algorithm to compute them. Improvements to this algorithm
<!-- %%  and the &GAP; implementation -->
are due to Bettina Eick.  For a more detailed account of
their definition the reader is referred to <Cite Key="Eick97"/>
<P/>
To introduce the definition of special pcgs we first need to define
the <E>LG-series</E> and <E>head complements</E> of a finite polycyclic group <A>G</A>.
Let <M>G = G_1 > G_2 > \ldots G_m > G_{{m+1}} = \{ 1 \}</M> be the lower
nilpotent series of <M>G</M>; that is, <M>G_i</M> is the smallest normal
subgroup of <M>G_{{i-1}}</M> with nilpotent factor. To obtain the LG-series
of <A>G</A> we need to refine this series.
Thus consider a factor <M>F_i := G_i / G_{{i+1}}</M>.
Since <M>F_i</M> is finite nilpotent, it is a direct
product of its Sylow subgroups, say <M>F_i = P_{{i,1}} \cdots P_{{i,r_i}}</M>.
For each Sylow <M>p_j</M>-subgroup <M>P_{{i,j}}</M> we can consider its
lower <M>p_j</M>-central series. To obtain a characteristic central series
with elementary abelian factors of <M>F_i</M> we loop over its Sylow subgroups.
Each time we consider <M>P_{{i,j}}</M> in this process we take the next step of
its lower <M>p_j</M>-central series into the series of <M>F_i</M>. If there
is no next step, then we just skip the consideration of <M>P_{{i,j}}</M>.
Note that the second term of the lower <M>p</M>-central series of a <M>p</M>-group
is in fact its Frattini subgroup. Thus the Frattini subgroup of <M>F_i</M>
is contained in the computed series of this group. We denote the
Frattini subgroup of <M>F_i = G_i / G_{{i+1}}</M> by <M>G_i^* / G_{{i+1}}</M>.
<P/>
The factors <M>G_i / G_i^*</M> are called the heads of <M>G</M>, while the
(possibly trivial) factors <M>G_i^* / G_{{i+1}}</M> are the tails of <M>G</M>.
A head complement of <M>G</M> is a subgroup <M>U</M> of <M>G</M> such that
<M>U / G_i^*</M>
is a complement to the head <M>G_i / G_i^*</M> in <M>G / G_i^*</M>
for some <M>i</M>.
<P/>
Now we are able to define a special pcgs of <A>G</A>. It is a pcgs of <A>G</A>
with three additional properties. First, the pc series determined
by the pcgs refines the LG-series of <A>G</A>. Second, a special pcgs
<E>exhibits</E> a Hall system of the group <A>G</A>; that is, for each set of
primes <M>\pi</M> the elements of the pcgs with relative order in <M>\pi</M>
form a pcgs of a Hall <M>\pi</M>-subgroup in a Hall system of <A>G</A>.
Third, a special pcgs exhibits a head complement for each head
of <A>G</A>.
<P/>
To record information about the LG-series with the special pcgs
we define the <E>LGWeights</E> of the special pcgs. These weights are
a list which contains a weight <M>w</M> for each elements <M>g</M> of the
special pcgs. Such a weight <M>w</M> represents the smallest subgroup of
the LG-series containing <M>g</M>.
<P/>
Since the LG-series is defined in terms of the lower nilpotent
series, Sylow subgroups of the factors and lower
<M>p</M>-central series of the Sylow subgroup, the weight <M>w</M> is a
triple. More precisely, <M>g</M> is contained in the <M>w[1]</M>th term
<M>U</M> of the lower nilpotent series of <A>G</A>, but not in the next smaller
one <M>V</M>. Then <M>w[3]</M> is a prime such that <M>g V</M> is contained in the
Sylow <M>w[3]</M>-subgroup <M>P/V</M> of <M>U/V</M>. Moreover, <M>gV</M> is contained in
the <M>w[2]</M>th term of the lower <M>p</M>-central series of <M>P/V</M>.
<P/>
There are two more attributes of a special pcgs containing
information about the LG-series: the list <E>LGLayers</E> and the
list <E>LGFirst</E>. The list of layers corresponds to the elements
of the special pcgs and denotes the layer of the LG-series in
which an element lies. The list LGFirst corresponds to the
LG-series and gives the number of the first element in the
special pcgs of the corresponding subgroup.

<ManSection>
<Prop Name="IsSpecialPcgs" Arg='obj'/>

<Description>
tests whether <A>obj</A> is a special pcgs.
</Description>
</ManSection>

<ManSection>
<Heading>SpecialPcgs</Heading>
<Attr Name="SpecialPcgs" Arg='pcgs' Label="for a pcgs"/>
<Attr Name="SpecialPcgs" Arg='G' Label="for a group"/>

<Description>
computes a special pcgs for the group defined by <A>pcgs</A> or for
<A>G</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="LGWeights" Arg='pcgs'/>

<Description>
returns the LGWeights of the special pcgs <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="LGLayers" Arg='pcgs'/>

<Description>
returns the layers of the special pcgs <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="LGFirst" Arg='pcgs'/>

<Description>
returns the first indices for each layer of the special pcgs <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="LGLength" Arg='G'/>

<Description>
returns the length of the LG-series of the group <A>G</A>,
if <A>G</A> is  solvable, and <K>fail</K> otherwise.

<Example><![CDATA[
gap> G := SmallGroup( 96, 220 );
<pc group of size 96 with 6 generators>
gap> spec := SpecialPcgs( G );
Pcgs([ f1, f2, f3, f4, f5, f6 ])
gap> LGWeights(spec);
[ [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 3 ], 
  [ 1, 2, 2 ] ]
gap> LGLayers(spec);
[ 1, 1, 1, 1, 2, 3 ]
gap> LGFirst(spec);
[ 1, 5, 6, 7 ]
gap> LGLength( G );
3
gap> p := SpecialPcgs( Pcgs( SmallGroup( 96, 120 ) ) );
Pcgs([ f1, f2, f3, f4, f5, f6 ])
gap> LGWeights(p);
[ [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 2, 2 ], [ 1, 3, 2 ], 
  [ 2, 1, 3 ] ]
]]></Example>
<P/>
Thus the first group, <C>SmallGroup(96, 220)</C>, has a lower nilpotent
series of length <M>1</M>; that is, the group is nilpotent.
It is a direct product of its Sylow subgroups.
Moreover the Sylow <M>2</M>-subgroup is generated by the elements
<C>f1, f2, f3, f4, f6</C>,
and the Sylow <M>3</M>-subgroup is generated by <C>f5</C>.
The lower <M>2</M>-central series of the Sylow <M>2</M>-subgroup
has length <M>2</M> and the second subgroup in this series is generated
by <C>f6</C>.
<P/>
The second group, <C>SmallGroup(96, 120)</C>, has a lower nilpotent
series of length <M>2</M> and hence is not nilpotent.
The second subgroup in this series is just the Sylow <M>3</M>-subgroup
and it is generated by <C>f6</C>.
The subgroup generated by <C>f1</C>, <M>\ldots</M>, <C>f5</C> is a
Sylow <M>2</M>-subgroup of the group and also a head complement to the
second head of the group.
Its lower <M>2</M>-central series has length <M>2</M>.
<P/>
In this example the <Ref Func="FamilyPcgs"/> value of the groups used
was a special pcgs, but this is not necessarily the case.
For performance reasons it can be worth to enforce this,
see&nbsp;<Ref Func="IsomorphismSpecialPcGroup"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsInducedPcgsWrtSpecialPcgs" Arg='pcgs'/>

<Description>
tests whether <A>pcgs</A> is induced with respect to a special pcgs.
</Description>
</ManSection>

<ManSection>
<Attr Name="InducedPcgsWrtSpecialPcgs" Arg='G'/>

<Description>
computes an induced pcgs with respect to the special pcgs of the
parent of <A>G</A>.
<P/>
<Ref Func="InducedPcgsWrtSpecialPcgs"/> will return a pcgs induced by
<E>a</E> special pcgs (which might differ from the one you had in mind).
If you need an induced pcgs compatible with a <E>given</E> special pcgs
use <Ref Func="InducedPcgs"/> for this special pcgs.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Action on Subfactors Defined by a Pcgs">
<Heading>Action on Subfactors Defined by a Pcgs</Heading>

When working with a polycyclic group, one often needs to compute matrix
operations of the group on a factor of the group.
For this purpose there are the functions described in
<Ref Subsect="VectorSpaceByPcgsOfElementaryAbelianGroup"/> to
<Ref Subsect="LinearActionLayer"/>.
<P/>
In certain situations, for example within the computation of conjugacy
classes of finite soluble groups as described in <Cite Key="MeckyNeubueser89"/>,
affine actions of groups are required. For this purpose we introduce
the functions <Ref Func="AffineAction"/> and
<Ref Func="AffineActionLayer"/>.

<ManSection>
<Func Name="VectorSpaceByPcgsOfElementaryAbelianGroup" Arg='mpcgs, fld'/>

<Description>
returns the vector space over <A>fld</A> corresponding to the modulo pcgs
<A>mpcgs</A>.
Note that <A>mpcgs</A> has to define an elementary abelian <M>p</M>-group
where <M>p</M> is the characteristic of <A>fld</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LinearAction" Arg='gens, basisvectors, linear'/>
<Oper Name="LinearOperation" Arg='gens, basisvectors, linear'/>

<Description>
returns a list of matrices, one for each element of <A>gens</A>, which
corresponds to the matrix action of the elements in <A>gens</A> on the
basis <A>basisvectors</A> via <A>linear</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="LinearActionLayer" Arg='G, gens, pcgs'/>
<Func Name="LinearOperationLayer" Arg='G, gens, pcgs'/>

<Description>
returns a list of matrices, one for each element of <A>gens</A>,
which corresponds to the matrix action of <A>G</A> on the vector space
corresponding to the modulo pcgs <A>pcgs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AffineAction" Arg='gens, basisvectors, linear, transl'/>

<Description>
return a list of matrices, one for each element of <A>gens</A>, which
corresponds to the affine action of the elements in <A>gens</A> on the
basis <A>basisvectors</A> via <A>linear</A> with translation
<A>transl</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="AffineActionLayer" Arg='G, gens, pcgs, transl'/>

<Description>
returns a list of matrices, one for each element of <A>gens</A>,
which corresponds to the affine action of <A>G</A> on the vector space
corresponding to the modulo pcgs <A>pcgs</A> with translation
<A>transl</A>.
<Example><![CDATA[
gap> G := SmallGroup( 96, 51 );
<pc group of size 96 with 6 generators>
gap> spec := SpecialPcgs( G );
Pcgs([ f1, f2, f3, f4, f5, f6 ])
gap> LGWeights( spec );
[ [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 2 ], [ 1, 2, 2 ], 
  [ 1, 3, 2 ] ]
gap> mpcgs := InducedPcgsByPcSequence( spec, spec{[4,5,6]} );
Pcgs([ f4, f5, f6 ])
gap> npcgs := InducedPcgsByPcSequence( spec, spec{[6]} );
Pcgs([ f6 ])
gap> modu := mpcgs mod npcgs;
[ f4, f5 ]
gap> mat:=LinearActionLayer( G, spec{[1,2,3]}, modu );
[ <an immutable 2x2 matrix over GF2>, 
  <an immutable 2x2 matrix over GF2>, 
  <an immutable 2x2 matrix over GF2> ]
gap> Print( mat, "\n" );
[ [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ], 
  [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ], 
  [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Orbit Stabilizer Methods for Polycyclic Groups">
<Heading>Orbit Stabilizer Methods for Polycyclic Groups</Heading>

If a pcgs <A>pcgs</A> is known for a group <A>G</A>, then orbits and stabilizers
can be computed by a special method which is particularly efficient.
Note that within this function only the elements in <A>pcgs</A> and the
relative orders of <A>pcgs</A> are needed. Hence this function works effectively
even if the elementary operations for <A>pcgs</A> are slow.

<ManSection>
<Func Name="StabilizerPcgs" Arg='pcgs, pnt[, acts][, act]'/>

<Description>
computes the stabilizer in the group generated by <A>pcgs</A> of the
point <A>pnt</A>.
If given, <A>acts</A> are elements by which <A>pcgs</A> acts,
<A>act</A> is the acting function.
This function returns a pcgs for the stabilizer which is induced by the
<C>ParentPcgs</C> of <A>pcgs</A>, that is it is compatible
with <A>pcgs</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="Pcgs_OrbitStabilizer" Arg='pcgs,domain,pnt,oprs,opr'/>

<Description>
runs a solvable group orbit-stabilizer algorithm on <A>pnt</A> with
<A>pcgs</A> acting via the images <A>oprs</A> and the operation function
<A>opr</A>.
The domain <A>domain</A> can be used to speed up search,
if it is not known, <K>false</K> can be given instead.
The function
returns a record with components <C>orbit</C>, <C>stabpcgs</C> and
<C>lengths</C>, the
latter indicating the lengths of the orbit whenever it got extended.
This can be used to recompute transversal elements.
This function should be used only inside algorithms when speed is
essential.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations which have Special Methods for Groups with Pcgs">
<Heading>Operations which have Special Methods for Groups with Pcgs</Heading>

<Index Key="IsNilpotent" Subkey="for groups with pcgs"><C>IsNilpotent</C></Index>
<Index Key="IsSupersolvable" Subkey="for groups with pcgs"><C>IsSupersolvable</C></Index>
<Index Key="Size" Subkey="for groups with pcgs"><C>Size</C></Index>
<Index Key="CompositionSeries" Subkey="for groups with pcgs"><C>CompositionSeries</C></Index>
<Index Key="ConjugacyClasses" Subkey="for groups with pcgs"><C>ConjugacyClasses</C></Index>
<Index Key="Centralizer" Subkey="for groups with pcgs"><C>Centralizer</C></Index>
<Index Key="FrattiniSubgroup" Subkey="for groups with pcgs"><C>FrattiniSubgroup</C></Index>
<Index Key="PrefrattiniSubgroup" Subkey="for groups with pcgs"><C>PrefrattiniSubgroup</C></Index>
<Index Key="MaximalSubgroups" Subkey="for groups with pcgs"><C>MaximalSubgroups</C></Index>
<Index Key="HallSystem" Subkey="for groups with pcgs"><C>HallSystem</C></Index>
<Index Key="MinimalGeneratingSet" Subkey="for groups with pcgs"><C>MinimalGeneratingSet</C></Index>
<Index Key="Centre" Subkey="for groups with pcgs"><C>Centre</C></Index>
<Index Key="Intersection" Subkey="for groups with pcgs"><C>Intersection</C></Index>
<Index Key="AutomorphismGroup" Subkey="for groups with pcgs"><C>AutomorphismGroup</C></Index>
<Index Key="IrreducibleModules" Subkey="for groups with pcgs"><C>IrreducibleModules</C></Index>
For the following operations there are special methods for groups with
pcgs installed:
<P/>
<Ref Func="IsNilpotentGroup"/>,
<Ref Func="IsSupersolvableGroup"/>,
<Ref Func="Size"/>,
<Ref Func="CompositionSeries"/>, 
<Ref Func="ConjugacyClasses" Label="attribute"/>,
<Ref Func="Centralizer" Label="for a magma and an element"/>,
<Ref Func="FrattiniSubgroup"/>,
<Ref Func="PrefrattiniSubgroup"/>,
<Ref Func="MaximalSubgroups"/> and related operations,
<Ref Func="HallSystem"/> and related operations,
<Ref Func="MinimalGeneratingSet"/>,
<Ref Func="Centre"/>,
<Ref Func="Intersection" Label="for various collections"/>,
<Ref Func="AutomorphismGroup"/>, 
<Ref Func="IrreducibleModules"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Conjugacy Classes in Solvable Groups">
<Heading>Conjugacy Classes in Solvable Groups</Heading>

There are a variety of algorithms to compute conjugacy classes and
centralizers in solvable groups via epimorphic images
(<Cite Key="FelschNeubueser79"/>, <Cite Key="MeckyNeubueser89"/>,
<Cite Key="Theissen93"/>).
Usually these are only invoked as methods, but it is possible to access the
algorithm directly.
<P/>
<ManSection>
<Func Name="ClassesSolvableGroup" Arg='G, mode[, opt]'/>

<Description>
computes conjugacy classes and centralizers in solvable groups. <A>G</A> is
the acting group. <A>mode</A> indicates the type of the calculation:
<P/>
0 Conjugacy classes
<P/>
4 Conjugacy test for the two elements in <A>opt</A><C>.candidates</C>
<P/>
In mode 0 the function returns a list of records containing components
<A>representative</A> and <A>centralizer</A>.
In mode 4 it returns a conjugating element.
<P/>
The optional record <A>opt</A> may contain the following components
that will affect the algorithm's behaviour:
<P/>
<List>
<Mark><C>pcgs</C></Mark>
<Item>
is a pcgs that will be used for the calculation.
The attribute <Ref Func="EANormalSeriesByPcgs"/> must return an
appropriate series of normal subgroups with elementary abelian factors
among them. The algorithm will step down this series.
In the case of
the calculation of rational classes, it must be a pcgs refining a
central series.
</Item>
<Mark><C>candidates</C></Mark>
<Item>
is a list of elements for which canonical representatives
are to be computed or for which a conjugacy test is performed. They must
be given in mode 4. In mode 0 a list of classes corresponding to
<C>candidates</C> is returned (which may contain duplicates). The
<C>representative</C>s chosen are canonical with respect to <C>pcgs</C>.
The records returned also contain components <C>operator</C>
such that
<C>candidate ^ operator = representative</C>.
</Item>
<Mark><C>consider</C></Mark>
<Item>
is a function <C>consider( fhome, rep, cenp, K, L )</C>. Here
<C>fhome</C> is a home pcgs for the factor group <M>F</M> in which the
calculation currently takes place,
<C>rep</C> is an element of the factor and <C>cenp</C> is a
pcgs for the centralizer of <C>rep</C> modulo <C>K</C>.
In mode 0, when lifting from <M>F</M>/<C>K</C> to <M>F</M>/<C>L</C>
(note: for efficiency reasons, <M>F</M> can be different from <A>G</A> or
<C>L</C> might be not trivial) this function is called
before performing the actual lifting and only those representatives for
which it returns <K>true</K> are passed to the next level.
This permits for example the calculation of only those classes
with small centralizers or classes of restricted orders.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="CentralizerSizeLimitConsiderFunction" Arg='sz'/>

<Description>
returns a function (with arguments <C>fhome</C>, <C>rep</C>, <C>cen</C>,
<C>K</C>, <C>L</C>)
that can be used in <Ref Func="ClassesSolvableGroup"/> as the
<C>consider</C> component of the options record.
It will restrict the lifting to those classes,
for which the size of the centralizer (in the factor) is at most
<A>sz</A>.
<P/>
See also <Ref Func="SubgroupsSolvableGroup"/>.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grppc.msk                   GAP documentation            Alexander Hulpke -->
<!-- %A                                                               Bettina Eick -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grppc.msk,v 1.42 2005/03/07 09:20:56 werner Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Pc Groups">
<Heading>Pc Groups</Heading>

<!-- % -->
<!-- % Wunsch von Herrn Neubueser: PrintPcPresentation -->
<!-- % -->
Pc groups are polycyclic groups that use the polycyclic presentation for
element arithmetic. This presentation gives them a <Q>natural</Q> pcgs,
the <Ref Func="FamilyPcgs"/> with respect to which pcgs operations as
described in chapter&nbsp;<Ref Chap="Polycyclic Groups"/> are
particularly efficient.
<P/>
Let <M>G</M> be a polycyclic group with pcgs <M>P = (g_1, \ldots, g_n)</M>
and corresponding relative orders <M>(r_1, \ldots, r_n)</M>. Recall that the
<M>r_i</M> are positive integers or infinity and let <M>I</M> be the set of
indices <M>i</M> with <M>r_i</M> a positive integer.
Then <M>G</M> has a finite presentation on the generators
<M>g_1, \ldots, g_n</M> with relations of the following form.
<Table Align="lcl">
<Row>
  <Item><M>g_i^{{r_i}}</M></Item>
  <Item>=</Item>
  <Item><M>g_{{i+1}}^{a(i,i,i+1)} \cdots g_n^{a(i,i,n)}</M></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>for <M>1 \leq i \leq n</M> and <M>i \in I</M></Item>
</Row>
<Row>
  <Item><M>g_i^{{-1}} g_j g_i</M></Item>
  <Item>=</Item>
  <Item><M>g_{{i+1}}^{a(i,j,i+1)} \cdots g_n^{a(i,j,n)}</M></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>for <M>1 \leq i &lt; j \leq n</M></Item>
</Row>
</Table>
For infinite groups we need additionally
<Table Align="lcl">
<Row>
  <Item><M>g_i^{{-1}} g_j^{{-1}} g_i</M></Item>
  <Item>=</Item>
  <Item><M>g_{{i+1}}^{b(i,j,i+1)} \cdots g_n^{b(i,j,n)}</M></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>for <M>1 \leq i &lt; j \leq n</M> and <M>j \not \in I</M></Item>
</Row>
<Row>
  <Item><M>g_i g_j g_i^{{-1}}</M></Item>
  <Item>=</Item>
  <Item><M>g_{{i+1}}^{c(i,j,i+1)} \cdots g_n^{c(i,j,n)}</M></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>for <M>1 \leq i &lt; j \leq n</M> and <M>i \not \in I</M></Item>
</Row>
<Row>
  <Item><M>g_i g_j^{{-1}} g_i^{{-1}}</M></Item>
  <Item>=</Item>
  <Item><M>g_{{i+1}}^{d(i,j,i+1)} \cdots g_n^{d(i,j,n)}</M></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>for <M>1 \leq i &lt; j \leq n</M> and <M>i, j, \not \in I</M></Item>
</Row>
</Table>
Here the right hand sides are assumed to be words in normal
form; that is, for <M>k \in I</M> we have for all exponents
<M>0 \leq a(i,j,k), b(i,j,k), c(i,j,k), d(i,j,k) &lt; r_k</M>.
<P/>
A finite presentation of this type is called a <E>power-conjugate
presentation</E> and a <E>pc group</E> is a polycyclic group defined
by a power-conjugate presentation. Instead of conjugates we could
just as well work with commutators and then the presentation would
be called a <E>power-commutator</E> presentation. Both types of presentation
are abbreviated as <E>pc presentation</E>.
Note that a pc presentation is a rewriting system.
<P/>
Clearly, whenever a group <M>G</M> with pcgs <M>P</M> is given, then we can
write down the corresponding pc presentation. On the other hand,
one may just write down a presentation on <M>n</M> abstract generators
<M>g_1, \ldots, g_n</M> with relations of the above form and define a
group <M>H</M> by this.
Then the subgroups <M>C_i = \langle g_i, \ldots, g_n \rangle</M> of <M>H</M>
form a subnormal series whose factors are cyclic or trivial.
In the case that all factors are non-trivial,
we say that the pc presentation of <M>H</M> is <E>confluent</E>.
Note that &GAP;&nbsp;4 can only work correctly with pc groups defined by a
confluent pc presentation.
<P/>
At the current state of implementations the &GAP; library contains 
methods to compute with finite polycyclic groups, while the &GAP; 
package <Package>Polycyclic</Package> by Bettina Eick and Werner Nickel 
allows also computations with infinite polycyclic groups which are given 
by a pc-presentation.
<P/>
<!-- %%  The Pc groups were designed and implemented by Frank Celler and -->
<!-- %%  Werner Nickel, the code for Two-Cohomology and Extensions is due to -->
<!-- %%  Bettina Eick who also wrote the Random Isomorphism test together with Hans -->
<!-- %%  Ulrich Besche. -->

Algorithms for pc groups use the methods for polycyclic groups described in
chapter&nbsp;<Ref Chap="Polycyclic Groups"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The family pcgs">
<Heading>The family pcgs</Heading>

Clearly, the generators of a power-conjugate presentation of
a pc group <M>G</M> form a pcgs of the pc group. This pcgs is called
the <E>family pcgs</E>.

<ManSection>
<Attr Name="FamilyPcgs" Arg='grp'/>

<Description>
returns a <Q>natural</Q> pcgs of a pc group <A>grp</A> 
(with respect to which pcgs operations as described in 
Chapter&nbsp;<Ref Chap="Polycyclic Groups"/> are particularly 
efficient).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFamilyPcgs" Arg='pcgs'/>

<Description>
specifies whether the pcgs is a <Ref Attr="FamilyPcgs"/> of a pc group.
</Description>
</ManSection>

<ManSection>
<Attr Name="InducedPcgsWrtFamilyPcgs" Arg='grp'/>

<Description>
returns the pcgs which induced with respect to a family pcgs
(see <Ref Prop="IsParentPcgsFamilyPcgs"/> for further details).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsParentPcgsFamilyPcgs" Arg='pcgs'/>

<Description>
This property indicates that the pcgs <A>pcgs</A> is induced with respect
to a family pcgs.
<P/>
This property is needed to distinguish between different independent 
polycyclic generating sequences which a pc group may have, since
the elementary operations for a non-family pcgs may not be as efficient 
as the elementary operations for the family pcgs.
<P/>
This can have a significant influence on the performance of algorithms
for polycyclic groups.
Many algorithms require a pcgs that corresponds to an
elementary abelian series
(see&nbsp;<Ref Func="PcgsElementaryAbelianSeries" Label="for a group"/>)
or even a special pcgs (see&nbsp;<Ref Sect="Special Pcgs"/>).
If the family pcgs has the required
properties, it will be used for these purposes, if not &GAP; has to work
with respect to a new pcgs which is <E>not</E> the family pcgs and thus
takes longer for elementary calculations like
<Ref Func="ExponentsOfPcElement"/>.
<P/>
Therefore, if the family pcgs chosen for arithmetic is not of importance
it might be worth to <E>change</E> to another, nicer, pcgs to speed up
calculations.
This can be achieved, for example, by using the 
<Ref Func="Range" Label="of a general mapping"/> value
of the isomorphism obtained by <Ref Func="IsomorphismSpecialPcGroup"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elements of pc groups">
<Heading>Elements of pc groups</Heading>

<ManSection>
<Heading>Comparison of elements of pc groups</Heading>
<Meth Name="\=" Arg='pcword1, pcword2' Label="for pcwords"/>
<Meth Name="\&lt;" Arg='pcword1, pcword2' Label="for pcwords"/>

<Description>
<Index Subkey="for pcwords">equality</Index>
<Index Subkey="for pcwords">smaller</Index>
The elements of a pc group <M>G</M> are always represented as words
in normal form with respect to the family pcgs of <M>G</M>.
Thus it is straightforward to compare elements of a pc group,
since this boils down to a mere comparison of exponent vectors
with respect to the family pcgs. In particular, the word problem
is efficiently solvable in pc groups.
</Description>
</ManSection>

<ManSection>
<Heading>Arithmetic operations for elements of pc groups</Heading>
<Meth Name="\*" Arg='pcword1, pcword2' Label="for pcwords"/>
<Meth Name="Inverse" Arg='pcword' Label="for a pcword"/>

<Description>
However, multiplication and inversion of elements in pc groups
is not as straightforward as in arbitrary finitely presented groups
where a simple concatenation or reversion of the corresponding
words is sufficient (but one cannot solve the word problem).
<P/>
To multiply two elements in a pc group, we
first concatenate the corresponding words and then use an algorithm
called <E>collection</E> to transform the new word into a word in normal
form.
<P/>
<Example><![CDATA[
gap> g := FamilyPcgs( SmallGroup( 24, 12 ) );
Pcgs([ f1, f2, f3, f4 ])
gap> g[4] * g[1];
f1*f3
gap> (g[2] * g[3])^-1;
f2^2*f3*f4
]]></Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Pc groups versus fp groups">
<Heading>Pc groups versus fp groups</Heading>

In theory pc groups are finitely presented groups.  In practice the
arithmetic in pc groups is different from the arithmetic in fp
groups. Thus for technical reasons the pc groups in &GAP; do not form
a subcategory of the fp groups and hence the methods for fp groups
cannot be applied to pc groups in general.

<ManSection>
<Filt Name="IsPcGroup" Arg='G' Type='Category'/>

<Description>
tests whether <A>G</A> is a pc group.
<Example><![CDATA[
gap> G := SmallGroup( 24, 12 );
<pc group of size 24 with 4 generators>
gap> IsPcGroup( G );
true
gap> IsFpGroup( G );
false
]]></Example>
</Description>
</ManSection>



<ManSection>
<Func Name="IsomorphismFpGroupByPcgs" Arg='pcgs, str'/>

<Description>
It is possible to convert a pc group to a fp group in &GAP;.
The function <Ref Func="IsomorphismFpGroupByPcgs"/> computes the
power-commutator presentation defined by <A>pcgs</A>.
The string <A>str</A> can be used to give a name to the generators
of the fp group.
<P/>
<Example><![CDATA[
gap> p := FamilyPcgs( SmallGroup( 24, 12 ) );
Pcgs([ f1, f2, f3, f4 ])
gap> iso := IsomorphismFpGroupByPcgs( p, "g" );
[ f1, f2, f3, f4 ] -> [ g1, g2, g3, g4 ]
gap> F := Image( iso );
<fp group of size 24 on the generators [ g1, g2, g3, g4 ]>
gap> RelatorsOfFpGroup( F );
[ g1^2, g2^-1*g1^-1*g2*g1*g2^-1, g3^-1*g1^-1*g3*g1*g4^-1*g3^-1, 
  g4^-1*g1^-1*g4*g1*g4^-1*g3^-1, g2^3, g3^-1*g2^-1*g3*g2*g4^-1*g3^-1, 
  g4^-1*g2^-1*g4*g2*g3^-1, g3^2, g4^-1*g3^-1*g4*g3, g4^2 ]
]]></Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Pc Groups">
<Heading>Constructing Pc Groups</Heading>

If necessary, you can supply &GAP; with a pc presentation by hand.
(Although this is the most tedious way to input a pc group.)
Note that the pc presentation has to be confluent in order to
work with the pc group in &GAP;.
<P/>
(If you have already a suitable pcgs in another representation, use
<Ref Func="PcGroupWithPcgs"/>, see below.)
<P/>
One way is to define a finitely presented group with a
pc presentation in &GAP; and then convert this presentation
into a pc group, see <Ref Func="PcGroupFpGroup"/>.
Note that this does not work for arbitrary presentations of polycyclic
groups, see Chapter <Ref Sect="Quotient Methods"/> for further information.
<P/>
Another way is to create and manipulate a collector of a pc group by hand
and to use it to define a pc group.
&GAP; provides different collectors for different collecting strategies;
at the moment, there are two collectors to choose from:
the single collector for finite pc groups (see <Ref Func="SingleCollector"/>)
and the combinatorial collector for finite <M>p</M>-groups.
See <Cite Key="Sims94"/> for further information on collecting strategies.
<P/>
A collector is initialized with an underlying free group
and the relative orders of the pc series. Then one adds the right
hand sides of the power and the commutator or conjugate relations one by
one. Note that omitted relators are assumed to be trivial.
<P/>
For performance reasons it is beneficial to enforce a <Q>syllable</Q>
representation in the free group
(see&nbsp;<Ref Sect="Representations for Associative Words"/>).
<P/>
Note that in the end, the collector has to be converted to a group,
see <Ref Func="GroupByRws"/>.
<P/>
With these methods a pc group with arbitrary defining pcgs can be
constructed. However, for almost all applications within &GAP; we need
to have a pc group whose defining pcgs is a prime order pcgs,
see <Ref Func="IsomorphismRefinedPcGroup"/> and <Ref Func="RefinedPcGroup"/>.

<ManSection>
<Func Name="PcGroupFpGroup" Arg='G'/>

<Description>
creates a pc group <A>P</A> from an fp group
(see Chapter <Ref Chap="Finitely Presented Groups"/>) <A>G</A>
whose presentation is polycyclic. The resulting group <A>P</A>
has generators corresponding to the generators of <A>G</A>.
They are printed in the same way as generators of <A>G</A>,
but they lie in a different family.
If the pc presentation of <A>G</A> is not confluent,
an error message occurs.
<P/>
<Example><![CDATA[
gap> F := FreeGroup(IsSyllableWordsFamily,"a","b","c","d");;
gap> a := F.1;; b := F.2;; c := F.3;; d := F.4;;
gap> rels := [a^2, b^3, c^2, d^2, Comm(b,a)/b, Comm(c,a)/d, Comm(d,a),
>             Comm(c,b)/(c*d), Comm(d,b)/c, Comm(d,c)];
[ a^2, b^3, c^2, d^2, b^-1*a^-1*b*a*b^-1, c^-1*a^-1*c*a*d^-1, 
  d^-1*a^-1*d*a, c^-1*b^-1*c*b*d^-1*c^-1, d^-1*b^-1*d*b*c^-1, 
  d^-1*c^-1*d*c ]
gap> G := F / rels;
<fp group on the generators [ a, b, c, d ]>
gap> H := PcGroupFpGroup( G );
<pc group of size 24 with 4 generators>
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="SingleCollector" Arg='fgrp, relorders'/>
<Func Name="CombinatorialCollector" Arg='fgrp, relorders'/>

<Description>
initializes a single collector or a combinatorial collector,
where <A>fgrp</A> must be a free group and <A>relorders</A> must be a list
of the relative orders of the pc series.
<P/>
A combinatorial collector can only be set up for a finite <M>p</M>-group.
Here, the relative orders <A>relorders</A> must all be equal and a prime.
</Description>
</ManSection>

<ManSection>
<Func Name="SetConjugate" Arg='coll, j, i, w'/>

<Description>
Let <M>f_1, \ldots, f_n</M> be the generators of the underlying free group
of the collector <A>coll</A>.
<P/>
For <A>i</A> <M>&lt;</M> <A>j</A>,
<Ref Func="SetConjugate"/> sets the conjugate <M>f_j^{{f_i}}</M> to equal
<A>w</A>, which is assumed to be a word in <M>f_{{i+1}}, \ldots, f_n</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="SetCommutator" Arg='coll, j, i, w'/>

<Description>
Let <M>f_1, \ldots, f_n</M> be the generators of the underlying free group
of the collector <A>coll</A>.
<P/>
For <A>i</A> <M>&lt;</M> <A>j</A>,
<Ref Func="SetCommutator"/> sets the commutator of <M>f_j</M> and <M>f_i</M>
to equal <A>w</A>, which is assumed to be a word in
<M>f_{{i+1}}, \ldots, f_n</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="SetPower" Arg='coll, i, w'/>

<Description>
Let <M>f_1, \ldots, f_n</M> be the generators of the underlying free group
of the collector <A>coll</A>,
and let <M>r_i</M> be the corresponding relative orders.
<P/>
<Ref Func="SetPower"/> sets the power <M>f_i^{{r_i}}</M> to equal <A>w</A>,
which is assumed to be a word in <M>f_{{i+1}}, \ldots, f_n</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="GroupByRws" Arg='coll'/>
<Func Name="GroupByRwsNC" Arg='coll'/>

<Description>
creates a group from a rewriting system. In the first version it
is checked whether the rewriting system is confluent, in the second
version this is assumed to be true.
</Description>
</ManSection>

<ManSection>
<Func Name="IsConfluent" Arg='G' Label="for pc groups"/>

<Description>
checks whether the pc group <A>G</A> has been built from a collector with
a confluent power-commutator presentation.
<P/>
<Example><![CDATA[
gap> F := FreeGroup(IsSyllableWordsFamily, 2 );;
gap> coll1 := SingleCollector( F, [2,3] );
<<single collector, 8 Bits>>
gap> SetConjugate( coll1, 2, 1, F.2 );
gap> SetPower( coll1, 1, F.2 );
gap> G1 := GroupByRws( coll1 );
<pc group of size 6 with 2 generators>
gap> IsConfluent(G1);
true
gap> IsAbelian(G1);
true
gap> coll2 := SingleCollector( F, [2,3] );
<<single collector, 8 Bits>>
gap> SetConjugate( coll2, 2, 1, F.2^2 );
gap> G2 := GroupByRws( coll2 );
<pc group of size 6 with 2 generators>
gap> IsAbelian(G2);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismRefinedPcGroup" Arg='G'/>

<Description>
<Index Subkey="pc group">isomorphic</Index>
returns an isomorphism from <A>G</A> onto an isomorphic pc group
whose family pcgs is a prime order pcgs.
</Description>
</ManSection>

<ManSection>
<Attr Name="RefinedPcGroup" Arg='G'/>

<Description>
returns the range of the <Ref Func="IsomorphismRefinedPcGroup"/> value of
<A>G</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Computing Pc Groups">
<Heading>Computing Pc Groups</Heading>

Another possibility to get a pc group in &GAP; is to convert a
polycyclic group given by some other representation to a pc group.
For finitely presented groups there are various quotient methods
available. For all other types of groups one can use the following
functions.

<ManSection>
<Attr Name="PcGroupWithPcgs" Arg='mpcgs'/>

<Description>
creates a new pc group <A>G</A> whose family pcgs is isomorphic to the
(modulo) pcgs <A>mpcgs</A>.
<Example><![CDATA[
gap> G := Group( (1,2,3), (3,4,1) );;
gap> PcGroupWithPcgs( Pcgs(G) );
<pc group of size 12 with 3 generators>
]]></Example>
<P/>
If a pcgs is only given by a list of pc elements,
<Ref Func="PcgsByPcSequence"/> can be used:
<Example><![CDATA[
gap> G:=Group((1,2,3,4),(1,2));;
gap> p:=PcgsByPcSequence(FamilyObj(One(G)),
> [ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
gap> PcGroupWithPcgs(p);
<pc group of size 24 with 4 generators>
gap> G := SymmetricGroup( 5 );
Sym( [ 1 .. 5 ] )
gap> H := Subgroup( G, [(1,2,3,4,5), (3,4,5)] );
Group([ (1,2,3,4,5), (3,4,5) ])
gap> modu := ModuloPcgs( G, H );
Pcgs([ (4,5) ])
gap> PcGroupWithPcgs(modu);
<pc group of size 2 with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismPcGroup" Arg='G'/>

<Description>
<Index Subkey="pc group">isomorphic</Index>
returns an isomorphism from <A>G</A> onto an isomorphic pc group.
The series chosen for this pc representation depends on
the method chosen.
<A>G</A> must be a polycyclic group of any kind, for example a solvable
permutation group.
<Example><![CDATA[
gap> G := Group( (1,2,3), (3,4,1) );;
gap> iso := IsomorphismPcGroup( G );
Pcgs([ (2,4,3), (1,2)(3,4), (1,3)(2,4) ]) -> [ f1, f2, f3 ]
gap> H := Image( iso );
Group([ f1, f2, f3 ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismSpecialPcGroup" Arg='G'/>

<Description>
returns an isomorphism from <A>G</A> onto an isomorphic pc group
whose family pcgs is a special pcgs.
(This can be beneficial to the runtime of calculations.)
<A>G</A> may be a polycyclic group of any kind, for example a solvable
permutation group.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Saving a Pc Group">
<Heading>Saving a Pc Group</Heading>

As printing a polycyclic group does not display the presentation,
one cannot simply print a pc group to a file to save it. For this
purpose we need the following function.

<ManSection>
<Func Name="GapInputPcGroup" Arg='grp, string'/>

<Description>
<Example><![CDATA[
gap> G := SmallGroup( 24, 12 );
<pc group of size 24 with 4 generators>
gap> PrintTo( "save", GapInputPcGroup( G, "H" ) );
gap> Read( "save" );
#I A group of order 24 has been defined.
#I It is called H
gap> H = G;
false
gap> IdSmallGroup( H ) = IdSmallGroup( G );
true
gap> RemoveFile( "save" );;
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Pc Groups">
<Heading>Operations for Pc Groups</Heading>

All the operations described in Chapters <Ref Chap="Groups"/>
and <Ref Chap="Polycyclic Groups"/> apply to a pc group.
Nearly all methods for pc groups are
methods for groups with pcgs as described
in Chapter <Ref Chap="Polycyclic Groups"/>.
The only method with is special for pc groups is a method
to compute intersections of subgroups, since here a pcgs of a parent
group is needed and this can only by guaranteed within pc groups.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="2-Cohomology and Extensions">
<Heading><M>2</M>-Cohomology and Extensions</Heading>

One of the most interesting applications of pc groups is the possibility
to compute with extensions of these groups by elementary abelian groups;
that is, <M>H</M> is an extension of <M>G</M> by <M>M</M>,
if there exists a normal subgroup <M>N</M> in <M>H</M> which is isomorphic
to <M>M</M> such that <M>H/N</M> is isomorphic to <M>G</M>.
<P/>
Pc groups are particularly suited for such applications, since the
<M>2</M>-cohomology can be computed efficiently for such groups and,
moreover, extensions of pc groups by elementary abelian groups can
be represented as pc groups again.
<P/>
To define the elementary abelian group <M>M</M> together with an action of
<M>G</M> on <M>M</M> we consider <M>M</M> as a MeatAxe module for <M>G</M>
over a finite field (section&nbsp;<Ref Func="IrreducibleModules"/>
describes functions that can be used to obtain certain modules).
For further information on meataxe modules see Chapter
<Ref Chap="The MeatAxe"/>.
Note that the matrices defining the module must correspond to the pcgs
of the group <A>G</A>.
<P/>
There exists an action of the subgroup of <E>compatible pairs</E> in
<M>Aut(G) \times Aut(M)</M> which acts on the second cohomology group,
see <Ref Func="CompatiblePairs"/>.
<M>2</M>-cocycles which lie in the same orbit under this action define
isomorphic extensions of <M>G</M>. However, there may be isomorphic
extensions of <M>G</M> corresponding to cocycles in different orbits.
<P/>
See also the &GAP; package <Package>GrpConst</Package> by Hans Ulrich Besche
and Bettina Eick that contains methods to construct up to isomorphism 
the groups of a given order.
<P/>
Finally we note that for the computation of split extensions it is not
necessary that <A>M</A> must correspond to an elementary abelian group. Here
it is possible to construct split extensions of arbitrary pc groups,
see <Ref Func="SplitExtensions"/>.

<ManSection>
<Oper Name="TwoCoboundaries" Arg='G, M'/>

<Description>
returns the group of <M>2</M>-coboundaries of a pc group <A>G</A> by the
<A>G</A>-module <A>M</A>.
The generators of <A>M</A> must correspond to the <Ref Func="Pcgs"/>
value of <A>G</A>.
The group of coboundaries is given as vector space over the field
underlying <A>M</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="TwoCocycles" Arg='G, M'/>

<Description>
returns the <M>2</M>-cocycles of a pc group <A>G</A> by the
<A>G</A>-module <A>M</A>. 
The generators of <A>M</A> must correspond to the <Ref Func="Pcgs"/>
value of <A>G</A>. The operation
returns a list of vectors over the field underlying <A>M</A> and the 
additive group generated by these vectors is the group of
<M>2</M>-cocyles.
</Description>
</ManSection>

<ManSection>
<Oper Name="TwoCohomology" Arg='G, M'/>

<Description>
returns a record defining the second cohomology group as factor space of 
the space of cocycles by the space of coboundaries.
<A>G</A> must be a pc group and the generators of <A>M</A> must
correspond to the pcgs of <A>G</A>.
<Example><![CDATA[
gap> G := SmallGroup( 4, 2 );
<pc group of size 4 with 2 generators>
gap> mats := List( Pcgs( G ), x -> IdentityMat( 1, GF(2) ) );
[ [ <a GF2 vector of length 1> ], [ <a GF2 vector of length 1> ] ]
gap> M := GModuleByMats( mats, GF(2) );
rec( IsOverFiniteField := true, dimension := 1, field := GF(2), 
  generators := [ <an immutable 1x1 matrix over GF2>, 
      <an immutable 1x1 matrix over GF2> ], isMTXModule := true )
gap> TwoCoboundaries( G, M );
[  ]
gap> TwoCocycles( G, M );
[ [ Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0 ] ]
gap> cc := TwoCohomology( G, M );;
gap> cc.cohom;
<linear mapping by matrix, <vector space of dimension 3 over GF(
2)> -> ( GF(2)^3 )>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Extensions" Arg='G, M'/>

<Description>
returns all extensions of <A>G</A> by the <A>G</A>-module <A>M</A>
up to equivalence as pc groups.
</Description>
</ManSection>

<ManSection>
<Oper Name="Extension" Arg='G, M, c'/>
<Oper Name="ExtensionNC" Arg='G, M, c'/>

<Description>
returns the extension of <A>G</A> by the <A>G</A>-module <A>M</A>
via the cocycle <A>c</A> as pc groups.
The <C>NC</C> version does not check the resulting group for consistence.
</Description>
</ManSection>


<ManSection>
<Func Name="SplitExtension" Arg='G, M'/>

<Description>
returns the split extension of <A>G</A> by the <A>G</A>-module <A>M</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="ModuleOfExtension" Arg='E'/>

<Description>
returns the module of an extension <A>E</A> of <A>G</A> by <A>M</A>.
This is the normal subgroup of <A>E</A> which corresponds to <A>M</A>.
<P/>
<Example><![CDATA[
gap> G := SmallGroup( 4, 2 );;
gap> mats := List( Pcgs( G ), x -> IdentityMat( 1, GF(2) ) );;
gap> M := GModuleByMats( mats, GF(2) );;
gap> co := TwoCocycles( G, M );;
gap> Extension( G, M, co[2] );
<pc group of size 8 with 3 generators>
gap> SplitExtension( G, M );
<pc group of size 8 with 3 generators>
gap> Extensions( G, M );
[ <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators> ]
gap> List(last, IdSmallGroup);
[ [ 8, 5 ], [ 8, 2 ], [ 8, 3 ], [ 8, 3 ], [ 8, 2 ], [ 8, 2 ], 
  [ 8, 3 ], [ 8, 4 ] ]
]]></Example>
<P/>
Note that the extensions returned by <Ref Func="Extensions"/> are computed
up to equivalence, but not up to isomorphism.
</Description>
</ManSection>

<ManSection>
<Func Name="CompatiblePairs" Arg='G, M[, D]'/>

<Description>
returns the group of compatible pairs of the group <A>G</A> with the 
<A>G</A>-module <A>M</A> as subgroup of the direct product
Aut(<A>G</A>) <M>\times</M> Aut(<A>M</A>).
Here Aut(<A>M</A>) is considered as subgroup of a general linear group.
The optional argument <A>D</A> should be a subgroup of
Aut(<A>G</A>) <M>\times</M> Aut(<A>M</A>).
If it is given, then only the compatible pairs in <A>D</A> are computed.
</Description>
</ManSection>

<ManSection>
<Oper Name="ExtensionRepresentatives" Arg='G, M, P'/>

<Description>
returns all extensions of <A>G</A> by the <A>G</A>-module <A>M</A> up to
equivalence under action of <A>P</A> where <A>P</A> has to be a subgroup
of the group of compatible pairs of <A>G</A> with <A>M</A>.
<Example><![CDATA[
gap> G := SmallGroup( 4, 2 );;
gap> mats := List( Pcgs( G ), x -> IdentityMat( 1, GF(2) ) );;
gap> M := GModuleByMats( mats, GF(2) );;
gap> A := AutomorphismGroup( G );;
gap> B := GL( 1, 2 );;
gap> D := DirectProduct( A, B );
<group of size 6 with 4 generators>
gap> P := CompatiblePairs( G, M, D );
<group of size 6 with 2 generators>
gap> ExtensionRepresentatives( G, M, P );
[ <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators> ]
gap> Extensions( G, M );
[ <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators> ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="SplitExtensions" Arg='G, aut, N'/>

<Description>
returns the split extensions of the pc group <A>G</A> by the pc group
<A>N</A>.
<A>aut</A> should be a homomorphism from <A>G</A> into Aut(<A>N</A>).
<P/>
In the following example we construct the holomorph of <M>Q_8</M> as split
extension of <M>Q_8</M> by <M>S_4</M>.
<P/>
<Example><![CDATA[
gap> N := SmallGroup( 8, 4 );
<pc group of size 8 with 3 generators>
gap> IsAbelian( N );
false
gap> A := AutomorphismGroup( N );
<group of size 24 with 4 generators>
gap> iso := IsomorphismPcGroup( A );
CompositionMapping( Pcgs([ (2,6,5,3), (1,3,5)(2,4,6), (2,5)(3,6), 
  (1,4)(3,6) ]) -> [ f1, f2, f3, f4 ], <action isomorphism> )
gap> H := Image( iso );
Group([ f1, f2, f3, f4 ])
gap> G := Subgroup( H, Pcgs(H){[1,2]} );
Group([ f1, f2 ])
gap> inv := InverseGeneralMapping( iso );
[ f1*f2, f2^2*f3, f4, f3 ] -> 
[ Pcgs([ f1, f2, f3 ]) -> [ f1*f2, f2, f3 ], 
  Pcgs([ f1, f2, f3 ]) -> [ f2, f1*f2, f3 ], 
  Pcgs([ f1, f2, f3 ]) -> [ f1*f3, f2, f3 ], 
  Pcgs([ f1, f2, f3 ]) -> [ f1, f2*f3, f3 ] ]
gap> K := SplitExtension( G, inv, N );
<pc group of size 192 with 7 generators>
]]></Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coding a Pc Presentation">
<Heading>Coding a Pc Presentation</Heading>

If one wants to store a large number of pc groups, then it can be useful
to store them in a compressed format, since pc presentations can be
space consuming. Here we introduce a method to code and decode pc
presentations by integers. To decode a given code the size of the
underlying pc group is needed as well. For the full definition and
the coding and decoding
procedures see <Cite Key="BescheEick98"/>. This method is used with the small
groups library, see Section <Ref Sect="Small Groups"/>.

<ManSection>
<Func Name="CodePcgs" Arg='pcgs'/>

<Description>
returns the code corresponding to <A>pcgs</A>.
<Example><![CDATA[
gap> G := CyclicGroup(512);;
gap> p := Pcgs( G );;
gap> CodePcgs( p );  
162895587718739690298008513020159
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CodePcGroup" Arg='G'/>

<Description>
returns the code for a pcgs of <A>G</A>.
<Example><![CDATA[
gap> G := DihedralGroup(512);;
gap> CodePcGroup( G );       
2940208627577393070560341803949986912431725641726
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PcGroupCode" Arg='code, size'/>

<Description>
returns a pc group of size <A>size</A> corresponding to <A>code</A>.
The argument <A>code</A> must be a valid code for a pcgs,
otherwise anything may happen.
Valid codes are usually obtained by one of the functions
<Ref Func="CodePcgs"/> or <Ref Func="CodePcGroup"/>.
<Example><![CDATA[
gap> G := SmallGroup( 24, 12 );;
gap> p := Pcgs( G );;
gap> code := CodePcgs( p );
5790338948
gap> H := PcGroupCode( code, 24 );
<pc group of size 24 with 4 generators>
gap> map := GroupHomomorphismByImages( G, H, p, FamilyPcgs(H) );
Pcgs([ f1, f2, f3, f4 ]) -> Pcgs([ f1, f2, f3, f4 ])
gap> IsBijective(map);
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Random Isomorphism Testing">
<Heading>Random Isomorphism Testing</Heading>

The generic isomorphism test for groups may be applied to pc groups
as well. However, this test is often quite time consuming. Here we
describe another method to test isomorphism by a probabilistic approach.

<ManSection>
<Func Name="RandomIsomorphismTest" Arg='coderecs, n'/>

<Description>
The first argument is a list <A>coderecs</A> containing records describing 
groups, and the second argument is a non-negative integer <A>n</A>.
<P/>
The test returns a sublist of <A>coderecs</A> where isomorphic copies 
detected by the probabilistic test have been removed.
<P/>
The list <A>coderecs</A> should contain records with two components,
<C>code</C> and <C>order</C>, describing a group via 
<C>PcGroupCode( code, order )</C> (see <Ref Func="PcGroupCode"/>).
<P/>
The integer <A>n</A> gives a certain amount of control over the 
probability to detect all isomorphisms. If it is <M>0</M>, then nothing 
will be done at all. The larger <A>n</A> is, the larger is the probability
of finding all isomorphisms. However, due to the underlying method we can
not guarantee that the algorithm finds all isomorphisms, no matter how
large <A>n</A> is.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grpfp.msk                   GAP documentation            Alexander Hulpke -->
<!-- %%                                                             Volkmar Felsch -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grpfp.msk,v 1.84 2006/03/08 14:50:04 jjm Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Finitely Presented Groups">
<Heading>Finitely Presented Groups</Heading>

A <E>finitely presented group</E> (in short: FpGroup) is a group generated by
a finite set of <E>abstract generators</E> subject to a finite set of
<E>relations</E> that these generators satisfy.
Every finite group can be represented as a finitely presented group,
though in almost all cases it is computationally much more efficient to work
in another representation (even the regular permutation representation).
<P/>
Finitely presented groups are obtained by factoring a free group by a set
of relators. Their elements know about this presentation and compare
accordingly.
<P/>
So to create a finitely presented group you first have to generate a free
group (see&nbsp;<Ref Func="FreeGroup" Label="for given rank"/> for details).
Then a list of relators is constructed as words in the generators of the
free group and is factored out to obtain the finitely presented group.
Its generators <E>are</E> the images of the free generators.
So for example to create the group
<Display Mode="M">
\langle a, b \mid a^2, b^3, (a b)^5 \rangle
</Display>
you can use the following commands:
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );;
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
]]></Example>
<P/>
Note that you cannot call the generators by their names. These names are
not variables, but just display figures. So, if you want to access the
generators by their names, you first have to introduce the respective
variables and to assign the generators to them.
<P/>
<Example><![CDATA[
gap> Unbind(a);
gap> GeneratorsOfGroup( g );
[ a, b ]
gap> a;
Error, Variable: 'a' must have a value
gap> a := g.1;; b := g.2;; # assign variables
gap> GeneratorsOfGroup( g );
[ a, b ]
gap> a in f;
false
gap> a in g;
true
]]></Example>
<P/>
To relieve you of the tedium of typing the above assignments,
<E>when working interactively</E>,
there is the function <Ref Func="AssignGeneratorVariables"/>.
<P/>
Note that the generators of the free group are different from the
generators of the FpGroup (even though they are displayed by the same
names). That means that words in the generators of the free group are not
elements of the finitely presented group. Vice versa elements of the
FpGroup are not words.
<P/>
<Example><![CDATA[
gap> a*b = b*a;
false
gap> (b^2*a*b)^2 = a^0;
true
]]></Example>
<P/>
Such calculations comparing elements of an FpGroup may run into problems:
There exist finitely
presented groups for which no algorithm exists (it is known that no such
algorithm can exist) that will tell for two arbitrary words in the
generators whether the corresponding elements in the FpGroup are equal.
<P/>
Therefore the methods used by &GAP; to compute in finitely
presented groups may run into warning errors, run out of memory or run
forever. If the FpGroup is (by theory) known to be finite the
algorithms are guaranteed to terminate (if there is sufficient memory
available), but the time needed for the calculation cannot be bounded a
priori. See <Ref Sect="Coset Tables and Coset Enumeration"/> and 
<Ref Sect="Testing Finiteness of Finitely Presented Groups"/>.
<P/>
<Example><![CDATA[
gap> (b^2*a*b)^2;
(b^2*a*b)^2
gap> a^0;
<identity ...>
]]></Example>
<P/>
A consequence of our convention is that elements of finitely presented
groups are not printed in a unique way.
See also <Ref Func="SetReducedMultiplication"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsSubgroupFpGroup">
<Heading>IsSubgroupFpGroup and IsFpGroup</Heading>

<ManSection>
<Filt Name="IsSubgroupFpGroup" Arg='H' Type='Category'/>

<Description>
returns <K>true</K> if <A>H</A> is a finitely presented group
or a subgroup of a finitely presented group.
</Description>
</ManSection>

<ManSection>
<Func Name="IsFpGroup" Arg='G'/>

<Description>
is a synonym for
<C>IsSubgroupFpGroup(<A>G</A>) and IsGroupOfFamily(<A>G</A>)</C>.
<P/>
Free groups are a special case of finitely presented groups,
namely finitely presented groups with no relators.
<Example><![CDATA[
gap> g:=FreeGroup(2);
<free group on the generators [ f1, f2 ]>
gap> IsFpGroup(g);
true
gap> h:=CyclicGroup(2);
<pc group of size 2 with 1 generators>
gap> IsFpGroup(h);
false
]]></Example>
<P/>
Another special case are groups given by polycyclic presentations.
&GAP; uses a special representation for these groups which is created
in a different way.
See chapter <Ref Chap="Pc Groups"/> for details.
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoFpGroup"/>

<Description>
The info class for functions dealing with finitely presented groups is
<Ref InfoClass="InfoFpGroup"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Finitely Presented Groups">
<Heading>Creating Finitely Presented Groups</Heading>

<ManSection>
<Meth Name="\/" Arg="F, rels"
 Label="for a free group and a list of elements"/>

<Description>
<Index Subkey="for finitely presented groups">quotient</Index>
creates a finitely presented group given by the presentation
<M>\langle gens \mid <A>rels</A> \rangle</M>
where <M>gens</M> are the free generators of the free group <A>F</A>.
Note that relations are entered as <E>relators</E>, i.e., as words in the
generators of the free group.  To enter an equation use the quotient
operator, i.e., for the relation <M>a^b = ab</M> one has to enter
<M>a^b / (a b)</M>.
<P/>
The same result is obtained with the infix operator <C>/</C>,
i.e., as <A>F</A> <C>/</C> <A>rels</A>.
<P/>
<Example><![CDATA[
gap> f := FreeGroup( 3 );;
gap> f / [ f.1^4, f.2^3, f.3^5, f.1*f.2*f.3 ];
<fp group on the generators [ f1, f2, f3 ]>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FactorGroupFpGroupByRels" Arg='G, elts'/>

<Description>
returns the factor group <A>G</A>/<M>N</M> of <A>G</A> by
the normal closure <M>N</M> of <A>elts</A>
where <A>elts</A> is expected to be a list of elements of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="ParseRelators" Arg='gens, rels'/>

<Description>
Will translate a list of relations as given in print, e.g.
<M>x y^2 = (x y^3 x)^2 xy = yzx</M> into relators.
<A>gens</A> must be a list of generators of a free group,
each being displayed by a single letter.
<A>rels</A> is a string that lists a sequence of equalities.
These must be written in the letters which are the names of
the generators in <A>gens</A>.
Change of upper/lower case is interpreted to indicate inverses.
<P/>
<Example><![CDATA[
gap> f:=FreeGroup("x","y","z");;
gap> AssignGeneratorVariables(f);
#I  Assigned the global variables [ x, y, z ]
gap> r:=ParseRelators([x,y,z],
> "x^2 = y^5 = z^3 = (xyxyxy^4)^2 = (xz)^2 = (y^2z)^2 = 1");
[ x^2, y^5, z^3, (x*z)^2, (y^2*z)^2, ((x*y)^3*y^3)^2 ]
gap> g:=f/r;
<fp group on the generators [ x, y, z ]>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="StringFactorizationWord" Arg='w'/>

<Description>
returns a string that expresses a given word <A>w</A> in compact form
written as a string. Inverses are expressed by changing the upper/lower
case of the generators, recurring expressions are written as products.
<Example><![CDATA[
gap> StringFactorizationWord(z^-1*x*y*y*y*x*x*y*y*y*x*y^-1*x);
"Z(xy3x)2Yx"
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Elements of Finitely Presented Groups">
<Heading>Comparison of Elements of Finitely Presented Groups</Heading>

<ManSection>
<Meth Name="\=" Arg="a, b" Label="for two elements in a f.p. group"/>

<Description>
<Index Subkey="elements of finitely presented groups">equality</Index>
Two elements of a finitely presented group are equal if they are equal in
this group. Nevertheless they may be represented as different words in the
generators. Because of the fundamental problems mentioned in the
introduction to this chapter such a test may take very long and cannot be
guaranteed to finish.
<P/>
The method employed by &GAP; for such an equality test use the underlying
finitely presented group. First (unless this group is known to be infinite)
&GAP; tries to find a faithful permutation representation by a bounded
Todd-Coxeter.
If this fails, a Knuth-Bendix
(see <Ref Sect="Rewriting Systems and the Knuth-Bendix Procedure"/>)
is attempted and the words are compared via their normal form.
<P/>
If only elements in a subgroup are to be tested for equality it thus can be
useful to translate the problem in a new finitely presented group by
rewriting (see <Ref Func="IsomorphismFpGroup"/>);
<P/>
The equality test of elements underlies many <Q>basic</Q> calculations,
such as the order of an element,
and the same type of problems can arise there.
In some cases, working with rewriting systems can still help to solve the
problem.
The <Package>kbmag</Package> package provides such functionality,
see the package manual for further details.
</Description>
</ManSection>


<ManSection>
<Meth Name="\&lt;" Arg="a, b" Label="for two elements in a f.p. group"/>

<Description>
<Index Subkey="elements of finitely presented groups">smaller</Index>
Compared with equality testing,
problems get even worse when trying to compute a total ordering on the
elements of a finitely presented group. As any ordering that is guaranteed
to be reproducible in different runs of &GAP; or even with different groups
given by syntactically equal presentations would be prohibitively expensive
to implement, the ordering of elements is depending on a method chosen by
&GAP; and not guaranteed to stay the same when repeating the construction
of an FpGroup. The only guarantee given for the <C>&lt;</C>
ordering for such elements is that it will stay the same for one family
during its lifetime.
The attribute <Ref Func="FpElmComparisonMethod"/> is used to obtain
a comparison function for a family of FpGroup elements.
</Description>
</ManSection>

<ManSection>
<Attr Name="FpElmComparisonMethod" Arg='fam'/>

<Description>
If <A>fam</A> is the elements family of a finitely presented group this
attribute returns a function <C>smaller(<A>left</A>, <A>right</A>)</C>
that will be used to compare elements in <A>fam</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="SetReducedMultiplication" Arg='obj'/>

<Description>
For an FpGroup <A>obj</A>, an element <A>obj</A> of it or the family
<A>obj</A> of its elements,
this function will force immediate reduction when multiplying, keeping
words short at extra cost per multiplication.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Preimages in the Free Group">
<Heading>Preimages in the Free Group</Heading>

<ManSection>
<Attr Name="FreeGroupOfFpGroup" Arg='G'/>

<Description>
returns the underlying free group for the finitely presented group
<A>G</A>.
This is the group generated by the free generators provided by the
<Ref Func="FreeGeneratorsOfFpGroup"/> value of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="FreeGeneratorsOfFpGroup" Arg='G'/>
<Oper Name="FreeGeneratorsOfWholeGroup" Arg='U'/>

<Description>
<Ref Func="FreeGeneratorsOfFpGroup"/> returns the underlying free
generators corresponding to the generators of the finitely presented
group <A>G</A> which must be a full FpGroup.
<P/>
<Ref Func="FreeGeneratorsOfWholeGroup"/> also works for subgroups of an
FpGroup and returns the free generators of the full group that defines
the family.
</Description>
</ManSection>

<ManSection>
<Attr Name="RelatorsOfFpGroup" Arg='G'/>

<Description>
returns the relators of the finitely presented group <A>G</A> as words
in the free generators provided by the
<Ref Func="FreeGeneratorsOfFpGroup"/> value of <A>G</A>.
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );;
gap> g := f / [ f.1^5, f.2^2, f.1^f.2*f.1 ];
<fp group on the generators [ a, b ]>
gap> Size( g );
10
gap> FreeGroupOfFpGroup( g ) = f;
true
gap> FreeGeneratorsOfFpGroup( g );
[ a, b ]
gap> RelatorsOfFpGroup( g );
[ a^5, b^2, b^-1*a*b*a ]
]]></Example>
<P/>
Note that these attributes are only available for the <E>full</E>
finitely presented group.
It is possible (for example by using <Ref Func="Subgroup"/>) to
construct a subgroup of index <M>1</M> which is not identical to the
whole group.
The latter one can be obtained in this situation via
<Ref Func="Parent"/>.
<P/>
Elements of a finitely presented group are not words, but are represented
using a word from the free group as representative. The following two
commands obtain this representative, respectively create an element in the
finitely presented group.
</Description>
</ManSection>



<ManSection>
<Func Name="UnderlyingElement" Arg='elm' Label="fp group elements"/>

<Description>
Let <A>elm</A> be an element of a group whose elements are represented as
words with further properties.
Then <Ref Func="UnderlyingElement" Label="fp group elements"/> returns
the word from the free group that is used as a representative for <A>elm</A>.
<P/>
<Example><![CDATA[
gap> w := g.1*g.2;
a*b
gap> IsWord( w );
false
gap> ue := UnderlyingElement( w );
a*b
gap> IsWord( ue );
true
]]></Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="ElementOfFpGroup" Arg='fam, word'/>

<Description>
If <A>fam</A> is the elements family of a finitely presented group
and <A>word</A> is a word in the free generators underlying this
finitely presented group, this operation creates the element with the
representative <A>word</A> in the free group.
<Example><![CDATA[
gap> ge := ElementOfFpGroup( FamilyObj( g.1 ), f.1*f.2 );
a*b
gap> ge in f;
false
gap> ge in g;
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Finitely Presented Groups">
<Heading>Operations for Finitely Presented Groups</Heading>

Finitely presented groups are groups and so all operations for groups should
be applicable to them (though not necessarily efficient methods are
available).
Most methods for finitely presented groups rely on coset enumeration.
See&nbsp;<Ref Sect="Coset Tables and Coset Enumeration"/> for details.
<P/>
The command <Ref Func="IsomorphismPermGroup"/> can be used to obtain
a faithful permutation representation,
if such a representation of small degree exists.
(Otherwise it might run very long or fail.)
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );
<free group on the generators [ a, b ]>
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
gap> h := IsomorphismPermGroup( g );
[ a, b ] -> [ (1,2)(4,5), (2,3,4) ]
gap> u:=Subgroup(g,[g.1*g.2]);;rt:=RightTransversal(g,u);
RightTransversal(<fp group of size 60 on the generators 
[ a, b ]>,Group([ a*b ]))
gap> Image(ActionHomomorphism(g,rt,OnRight));
Group([ (1,2)(3,4)(5,7)(6,8)(9,10)(11,12), 
  (1,3,2)(4,5,6)(7,8,9)(10,11,12) ])
]]></Example>


<ManSection>
<Meth Name="PseudoRandom" Arg='F:radius:=l'
 Label="for finitely presented groups"/>

<Description>
The default algorithm for <Ref Func="PseudoRandom"/>
makes little sense for finitely presented or free groups,
as it produces words that are extremely long.
<P/>
By specifying the option <C>radius</C>,
instead elements are taken as words in the generators of <A>F</A>
in the ball of radius <A>l</A> with equal distribution in the free group.
<P/>
<Log><![CDATA[
gap> PseudoRandom(g:radius:=20);
a^3*b^2*a^-2*b^-1*a*b^-4*a*b^-1*a*b^-4
]]></Log>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coset Tables and Coset Enumeration">
<Heading>Coset Tables and Coset Enumeration</Heading>

Coset enumeration (see <Cite Key="Neu82"/> for an explanation) is one of the
fundamental tools for the examination of finitely presented groups.
This section describes &GAP; functions that can be used to invoke a coset
enumeration.
<P/>
Note that in addition to the built-in coset enumerator there is the &GAP;
package <Package>ACE</Package>.
Moreover, &GAP; provides an interactive Todd-Coxeter
in the &GAP; package <Package>ITC</Package>
which is based on the <Package>XGAP</Package> package.

<ManSection>
<Oper Name="CosetTable" Arg='G, H'/>

<Description>
returns the coset table of the finitely presented group <A>G</A>
on the cosets of the subgroup <A>H</A>.
<P/>
Basically a coset table is the permutation representation of the finitely
presented group on the cosets of a subgroup  (which need  not be faithful
if the subgroup has a nontrivial  core).  Most  of  the set theoretic and
group functions use the regular representation of <A>G</A>,
i.e., the coset table of <A>G</A> over the trivial subgroup.
<P/>
The coset table is returned as a list of lists. For each generator of
<A>G</A> and its inverse the table contains a generator list. A generator
list is simply a list of integers.
If <M>l</M> is the generator list for the generator <M>g</M> and if
<M>l[i] = j</M> then generator <M>g</M> takes the coset
<M>i</M> to the coset <M>j</M> by multiplication from the right.
Thus the permutation representation of <A>G</A> on the cosets of <A>H</A>
is obtained by applying <Ref Func="PermList"/> to each generator list.
<P/>
The coset table is standard (see below).
<P/>
For finitely presented groups, a coset table is computed by a
Todd-Coxeter coset enumeration.
Note that you may influence the performance of that enumeration by
changing the values of the global variables
<Ref Var="CosetTableDefaultLimit"/> and
<Ref Var="CosetTableDefaultMaxLimit"/> described below and that the
options described under <Ref Func="CosetTableFromGensAndRels"/> are
recognized.
<P/>
<Example><![CDATA[
gap> tab := CosetTable(g, Subgroup(g, [ g.1, g.2*g.1*g.2*g.1*g.2^-1 ]));
[ [ 1, 4, 5, 2, 3 ], [ 1, 4, 5, 2, 3 ], [ 2, 3, 1, 4, 5 ], 
  [ 3, 1, 2, 4, 5 ] ]
gap> List( last, PermList );
[ (2,4)(3,5), (2,4)(3,5), (1,2,3), (1,3,2) ]
gap> PrintArray( TransposedMat( tab ) );
[ [  1,  1,  2,  3 ],
  [  4,  4,  3,  1 ],
  [  5,  5,  1,  2 ],
  [  2,  2,  4,  4 ],
  [  3,  3,  5,  5 ] ]
]]></Example>
<P/>
The last printout in the preceding example provides the coset table in
the form in which it is usually used in hand calculations:
The rows correspond to the cosets, the columns correspond to the
generators and their inverses in the ordering
<M>g_1, g_1^{{-1}}, g_2, g_2^{{-1}}</M>.
(See section&nbsp;<Ref Sect="Standardization of coset tables"/>
for a description on the way the numbers are assigned.)
</Description>
</ManSection>

<ManSection>
<Func Name="TracedCosetFpGroup" Arg='tab, word, pt'/>

<Description>
Traces the coset number <A>pt</A> under the word <A>word</A> through the
coset table <A>tab</A>.
(Note: <A>word</A> must be in the free group, use
<Ref Func="UnderlyingElement" Label="fp group elements"/> if in doubt.)
<Example><![CDATA[
gap> TracedCosetFpGroup(tab,UnderlyingElement(g.1),2);
4
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="FactorCosetAction" Arg='G, H' Label="for fp groups"/>

<Description>
returns the action of <A>G</A> on the cosets of its subgroup <A>H</A>.
<P/>
<Example><![CDATA[
gap> u := Subgroup( g, [ g.1, g.1^g.2 ] );
Group([ a, b^-1*a*b ])
gap> FactorCosetAction( g, u );
[ a, b ] -> [ (2,4)(5,6), (1,2,3)(4,5,6) ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="CosetTableBySubgroup" Arg='G, H'/>

<Description>
returns a coset table for the action of <A>G</A> on the cosets of
<A>H</A>.
The columns of the table correspond to the
<Ref Func="GeneratorsOfGroup"/> value of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="CosetTableFromGensAndRels" Arg='fgens, grels, fsgens'/>

<Description>
<Index Key="TCENUM"><C>TCENUM</C></Index>
<Index Key="GAPTCENUM"><C>GAPTCENUM</C></Index>
is an internal function which is called by the functions
<Ref Func="CosetTable"/>, <Ref Func="CosetTableInWholeGroup"/>
and others.
It is, in fact, the proper working horse that performs a Todd-Coxeter
coset enumeration.
<A>fgens</A> must be a set of free generators and <A>grels</A> a set
of relators in these generators. <A>fsgens</A> are subgroup generators
expressed as words in these generators. The function returns a coset
table with respect to <A>fgens</A>.
<P/>
<Ref Func="CosetTableFromGensAndRels"/> will call
<C>TCENUM.CosetTableFromGensAndRels</C>.
This makes it possible to replace the built-in coset enumerator with
another one by assigning <C>TCENUM</C> to another record.
<P/>
The library version which is used by default performs a standard Felsch
strategy coset enumeration. You can call this function explicitly as
<C>GAPTCENUM.CosetTableFromGensAndRels</C> even if other coset enumerators
are installed.
<P/>
The expected parameters are
<List>
<Mark><A>fgens</A></Mark>
<Item>
generators of the free group <A>F</A>
</Item>
<Mark><A>grels</A></Mark>
<Item>
relators as words in <A>F</A>
</Item>
<Mark><A>fsgens</A></Mark>
<Item>
subgroup generators as words in <A>F</A>.
</Item>
</List>
<P/>
<Ref Func="CosetTableFromGensAndRels"/> processes two options (see
chapter&nbsp;<Ref Chap="Options Stack"/>): 
<List>
<Mark><C>max</C></Mark>
<Item>
  The limit of the number of cosets to be defined. If the
  enumeration does not finish with this number of cosets, an error is
  raised and the user is asked whether she wants to continue. The
  default value is the value given in the variable
  <C>CosetTableDefaultMaxLimit</C>. (Due to the algorithm the actual
  limit used can be a bit higher than the number given.)
</Item>
<Mark><C>silent</C></Mark>
<Item>
  If set to <K>true</K> the algorithm will not raise the error
  mentioned under option <C>max</C> but silently return <K>fail</K>.
  This can be useful if an enumeration is only wanted unless it becomes
  too big.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Var Name="CosetTableDefaultMaxLimit"/>

<Description>
is the default limit for the number of cosets allowed in a coset
enumeration.
<P/>
A coset enumeration will not finish if the subgroup does not have finite
index, and even if it has it may take many more intermediate cosets than
the actual index of the subgroup is. To avoid a coset enumeration
<Q>running away</Q> therefore &GAP; has a <Q>safety stop</Q> built in.
This is controlled by the global variable
<Ref Var="CosetTableDefaultMaxLimit"/>.
<P/>
If this number of cosets is reached, &GAP; will issue an error message
and prompt the user to either continue the calculation or to stop it.
The default value is <M>4096000</M>.
<P/>
See also the description of the options to
<Ref Func="CosetTableFromGensAndRels"/>.
<P/>
<Log><![CDATA[
gap> f := FreeGroup( "a", "b" );;
gap> u := Subgroup( f, [ f.2 ] );
Group([ b ])
gap> Index( f, u );
Error, the coset enumeration has defined more than 4096000 cosets
 called from
TCENUM.CosetTableFromGensAndRels( fgens, grels, fsgens ) called from
CosetTableFromGensAndRels( fgens, grels, fsgens ) called from
TryCosetTableInWholeGroup( H ) called from
CosetTableInWholeGroup( H ) called from
IndexInWholeGroup( H ) called from
...
Entering break read-eval-print loop ...
type 'return;' if you want to continue with a new limit of 8192000 cosets,
type 'quit;' if you want to quit the coset enumeration,
type 'maxlimit := 0; return;' in order to continue without a limit
brk> quit;
]]></Log>
<P/>
At this point, a <K>break</K>-loop
(see Section&nbsp;<Ref Sect="Break Loops"/>) has been entered.
The line beginning <C>Error</C> tells you why this occurred.
The next seven lines occur if <Ref Func="OnBreak"/> has its default value
<Ref Func="Where"/>.
They explain, in this case,
how &GAP; came to be doing a coset enumeration.
Then you are given a number of options of how to escape the
<K>break</K>-loop:
you can either continue the calculation with a larger
number of permitted cosets, stop the calculation if you don't
expect the enumeration to finish (like in the example above), or continue
without a limit on the number of cosets. (Choosing the first option will,
of course, land you back in a <K>break</K>-loop. Try it!)
<P/>
Setting <Ref Var="CosetTableDefaultMaxLimit"/>
(or the <C>max</C> option value, for any function that invokes a coset
enumeration) to <Ref Var="infinity"/> (or to <M>0</M>) will force all
coset enumerations to continue until
they either get a result or exhaust the whole available space.
For example, each of the following two inputs
<P/>
<Listing><![CDATA[
gap> CosetTableDefaultMaxLimit := 0;;
gap> Index( f, u );
]]></Listing>
<P/>
or
<P/>
<Listing><![CDATA[
gap> Index( f, u : max := 0 );
]]></Listing>
<P/>
have essentially the same effect as choosing the third option
(typing: <C>maxlimit := 0; return;</C>) at the <C>brk></C> prompt above
(instead of <C>quit;</C>).
</Description>
</ManSection>

<ManSection>
<Var Name="CosetTableDefaultLimit"/>

<Description>
is the default number of cosets with which any coset table is
initialized before doing a coset enumeration.
<P/>
The function performing this coset enumeration will automatically extend
the table whenever necessary (as long as the number of cosets does not
exceed the value of <Ref Var="CosetTableDefaultMaxLimit"/>),
but this is an expensive operation. Thus, if you change the value of
<Ref Var="CosetTableDefaultLimit"/>, you should set it to a number of
cosets that you expect to be sufficient for your subsequent
coset enumerations.
On the other hand, if you make it too large, your job will unnecessarily
waste a lot of space.
<P/>
The default value of <Ref Var="CosetTableDefaultLimit"/> is <M>1000</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="MostFrequentGeneratorFpGroup" Arg='G'/>

<Description>
is an internal function which is used in some applications of coset
table methods. It returns the first of those generators of the given
finitely presented group <A>G</A> which occur most frequently in the
relators.
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesInvolutaryGenerators" Arg='G'/>

<Description>
returns the indices of those generators of the finitely presented group
<A>G</A> which are known to be involutions. This knowledge is used by
internal functions to improve the performance of coset enumerations.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Standardization of coset tables">
<Heading>Standardization of coset tables</Heading>

For any two coset numbers <M>i</M> and <M>j</M> with <M>i &lt; j</M>
the first occurrence of <M>i</M> in a coset table precedes
the first occurrence of <M>j</M> with respect to
the usual row-wise ordering of the table entries. Following the notation of
Charles Sims' book on computation with finitely presented groups
<Cite Key="Sims94"/> we call such a table a <E>standard coset table</E>.
<P/>
The table entries which contain the first occurrences of the coset numbers
<M>i &gt; 1</M> recursively provide for each <M>i</M> a representative of the
corresponding coset in form of a unique word <M>w_i</M> in the generators and
inverse generators of <M>G</M>.
The first coset (which is <M>H</M> itself) can be represented by
the empty word <M>w_1</M>. A coset table is standard if and only
if the words <M>w_1, w_2, \ldots</M> are length-plus-lexicographic ordered
(as defined in <Cite Key="Sims94"/>), for short: <E>lenlex</E>.
<P/>
This standardization of coset tables is
different from that used in &GAP; versions 4.2 and earlier. Before
that, we ignored the columns that correspond to inverse generators and
hence only considered words in the generators of <M>G</M>. We call
this older ordering the <E>semilenlex</E> standard as it 
also applies to the case of semigroups where no inverses of the generators are known.
<P/>
We changed our default from the semilenlex standard to the lenlex
standard to be consistent with <Cite Key="Sims94"/>. However, the
semilenlex standardisation remains available and the convention used
for all implicit standardisations can be selected by setting the value of the global variable
<Ref Var="CosetTableStandard"/> to either <C>"lenlex"</C> or
<C>"semilenlex"</C>.

Independent of the current value of <Ref Var="CosetTableStandard"/>
you can  standardize (or restandardize) a coset table at any
time using <Ref Func="StandardizeTable"/>.

<ManSection>
<Var Name="CosetTableStandard"/>

<Description>
specifies the definition of a <E>standard coset table</E>. It is used
whenever coset tables or augmented coset tables are created. Its value
may be <C>"lenlex"</C> or <C>"semilenlex"</C>.
If it is <C>"lenlex"</C> coset tables will be standardized using
all their columns as defined in Charles Sims' book
(this is the new default standard of &GAP;). If it is <C>"semilenlex"</C>
they will be standardized using only their generator columns (this was
the original &GAP; standard).
The default value of <Ref Var="CosetTableStandard"/> is <C>"lenlex"</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="StandardizeTable" Arg='table, standard'/>

<Description>
standardizes the given coset table <A>table</A>. The second argument is
optional. It defines the standard to be used, its values may be
<C>"lenlex"</C> or <C>"semilenlex"</C> specifying the new or the old
convention, respectively.
If no value for the parameter <A>standard</A> is provided the
function will use the global variable <Ref Var="CosetTableStandard"/>
instead.
Note that the function alters the given table, it does not create a copy.
<Example><![CDATA[
gap> StandardizeTable( tab, "semilenlex" );
gap> PrintArray( TransposedMat( tab ) );
[ [  1,  1,  2,  4 ],
  [  3,  3,  4,  1 ],
  [  2,  2,  3,  3 ],
  [  5,  5,  1,  2 ],
  [  4,  4,  5,  5 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coset tables for subgroups in the whole group">
<Heading>Coset tables for subgroups in the whole group</Heading>

<ManSection>
<Attr Name="CosetTableInWholeGroup" Arg='H'/>
<Oper Name="TryCosetTableInWholeGroup" Arg='H'/>

<Description>
is equivalent to <C>CosetTable(<A>G</A>,<A>H</A>)</C> where <A>G</A> is
the (unique)  finitely presented group such that <A>H</A> is a subgroup
of <A>G</A>.
It overrides a <C>silent</C> option
(see&nbsp;<Ref Func="CosetTableFromGensAndRels"/>) with <K>false</K>.
<P/>
The variant <Ref Func="TryCosetTableInWholeGroup"/> does not override the
<C>silent</C> option with <K>false</K> in case a coset table is only
wanted if not too expensive.
It will store a result that is not <K>fail</K> in the attribute
<Ref Func="CosetTableInWholeGroup"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="SubgroupOfWholeGroupByCosetTable" Arg='fpfam, tab'/>

<Description>
takes a family <A>fpfam</A> of an FpGroup and a coset table <A>tab</A>
and returns the subgroup of <A>fpfam</A><C>!.wholeGroup</C> defined by
this coset table.
See also&nbsp;<Ref Func="CosetTableBySubgroup"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Augmented Coset Tables and Rewriting">
<Heading>Augmented Coset Tables and Rewriting</Heading>

<ManSection>
<Oper Name="AugmentedCosetTableInWholeGroup" Arg='H[, gens]'/>

<Description>
For a subgroup <A>H</A> of a finitely presented group, this function
returns an augmented coset table.
If a generator set <A>gens</A> is given, it is
guaranteed that <A>gens</A> will be a subset of the primary and secondary
subgroup generators of this coset table.
<P/>
It is mutable so we are permitted to add further entries. However
existing entries may not be changed. Any entries added however should
correspond to the subgroup only and not to an homomorphism.
</Description>
</ManSection>

<ManSection>
<Func Name="AugmentedCosetTableMtc" Arg='G, H, type, string'/>

<Description>
is an internal function used by the subgroup presentation functions
described in <Ref Sect="Subgroup Presentations"/>.
It applies a Modified Todd-Coxeter coset representative enumeration to
construct an augmented coset table
(see <Ref Sect="Subgroup Presentations"/>) for the given subgroup
<A>H</A> of <A>G</A>.
The subgroup generators will be named <A>string</A><C>1</C>,
<A>string</A><C>2</C>, <M>\ldots</M>.
<P/>
The function accepts the options <C>max</C> and <C>silent</C>
as described for the function <Ref Func="CosetTableFromGensAndRels"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="AugmentedCosetTableRrs" Arg='G, table, type, string'/>

<Description>
is an internal function used by the subgroup presentation functions
described in <Ref Sect="Subgroup Presentations"/>.
It applies the Reduced Reidemeister-Schreier
method to construct an augmented coset table for the subgroup of <A>G</A>
which is defined by the given coset table <A>table</A>.
The new subgroup generators will be named <A>string</A><C>1</C>,
<A>string</A><C>2</C>, <M>\ldots</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="RewriteWord" Arg='aug, word'/>

<Description>
<Ref Func="RewriteWord"/> rewrites <A>word</A> (which must be a word in
the underlying free group with respect to which the augmented coset table
<A>aug</A> is given) in the subgroup generators given by the augmented
coset table <A>aug</A>.
It returns a Tietze-type word (i.e.&nbsp;a list of integers),
referring to the primary and secondary generators of <A>aug</A>.
<P/>
If <A>word</A> is not contained in the subgroup, <K>fail</K> is returned.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Low Index Subgroups">
<Heading>Low Index Subgroups</Heading>

<ManSection>
<Oper Name="LowIndexSubgroupsFpGroupIterator"
 Arg='G[, H], index[, excluded]'/>
<Oper Name="LowIndexSubgroupsFpGroup" Arg='G[, H], index[, excluded]'/>

<Description>
<Index Subkey="for low index subgroups">iterator</Index>
These functions compute representatives of the conjugacy classes of
subgroups of the finitely presented group <A>G</A> that contain the
subgroup <A>H</A> of <A>G</A> and that have index less than or equal to
<A>index</A>.
<P/>
<Ref Func="LowIndexSubgroupsFpGroupIterator"/> returns an iterator
(see&nbsp;<Ref Sect="Iterators"/>)
that can be used to run over these subgroups,
and <Ref Func="LowIndexSubgroupsFpGroup"/> returns the list of these
subgroups.
If one is interested only in one or a few subgroups up to a given index
then preferably the iterator should be used.
<P/>
If the optional argument <A>excluded</A> has been specified, then it is
expected to be a list of words in the free generators of the underlying
free group of <A>G</A>, and <Ref Func="LowIndexSubgroupsFpGroup"/>
returns only those subgroups of index at most <A>index</A> that contain
<A>H</A>, but do not contain any conjugate of any of the group elements
defined by these words.
<P/>
If not given, <A>H</A> defaults to the trivial subgroup.
<P/>
The algorithm used finds the requested subgroups
by systematically running through a tree of all potential coset tables
of <A>G</A> of length at most <A>index</A> (where it skips all branches
of that tree for which it knows in advance that they cannot provide new
classes of such subgroups).
The time required to do this depends, of course, on the presentation of
<A>G</A>, but in general it will grow exponentially with
the value of <A>index</A>. So you should be careful with the choice of
<A>index</A>.
<Example><![CDATA[
gap> li:=LowIndexSubgroupsFpGroup( g, TrivialSubgroup( g ), 10 );
[ Group(<fp, no generators known>), Group(<fp, no generators known>), 
  Group(<fp, no generators known>), Group(<fp, no generators known>) ]
]]></Example>
<P/>
By default, the algorithm computes no generating sets for the subgroups.
This can be enforced with <Ref Func="GeneratorsOfGroup"/>:
<Example><![CDATA[
gap> GeneratorsOfGroup(li[2]);
[ a, b*a*b^-1 ]
]]></Example>
<P/>
If we are interested just in one (proper) subgroup of index at most
<M>10</M>, we can use the function that returns an iterator.
The first subgroup found is the group itself,
except if a list of excluded elements is entered (see below),
so we look at the second subgroup.
<P/>
<Example><![CDATA[
gap> iter:= LowIndexSubgroupsFpGroupIterator( g, 10 );;
gap> s1:= NextIterator( iter );;  Index( g, s1 );
1
gap> IsDoneIterator( iter );
false
gap> s2:= NextIterator( iter );;  s2 = li[2];
true
]]></Example>
<P/>
As an example for an application of the optional parameter
<A>excluded</A>, we
compute all conjugacy classes of torsion free subgroups of index at most
<M>24</M> in the group <M>G =
\langle x,y,z \mid x^2, y^4, z^3, (xy)^3, (yz)^2, (xz)^3 \rangle</M>.
It is know from theory that each torsion element of this
group is conjugate to a power of <M>x</M>, <M>y</M>, <M>z</M>, <M>xy</M>,
<M>xz</M>, or <M>yz</M>.
(Note that this includes conjugates of <M>y^2</M>.)
<P/>
<Example><![CDATA[
gap> F := FreeGroup( "x", "y", "z" );;
gap> x := F.1;; y := F.2;; z := F.3;;
gap> G := F / [ x^2, y^4, z^3, (x*y)^3, (y*z)^2, (x*z)^3 ];;
gap> torsion := [ x, y, y^2, z, x*y, x*z, y*z ];;
gap> SetInfoLevel( InfoFpGroup, 2 );
gap> lis := LowIndexSubgroupsFpGroup(G, TrivialSubgroup(G), 24, torsion);;
#I  LowIndexSubgroupsFpGroup called
#I   class 1 of index 24 and length 8
#I   class 2 of index 24 and length 24
#I   class 3 of index 24 and length 24
#I   class 4 of index 24 and length 24
#I   class 5 of index 24 and length 24
#I  LowIndexSubgroupsFpGroup done. Found 5 classes
gap> SetInfoLevel( InfoFpGroup, 0 );
]]></Example>
<P/>
If a particular image group is desired, the operation
<Ref Func="GQuotients"/>
(see&nbsp;<Ref Sect="Quotient Methods"/>) can be useful as well.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Converting Groups to Finitely Presented Groups">
<Heading>Converting Groups to Finitely Presented Groups</Heading>

<ManSection>
<Attr Name="IsomorphismFpGroup" Arg='G'/>

<Description>
returns an isomorphism from the given finite group <A>G</A> to a finitely
presented group isomorphic to <A>G</A>.
The function first <E>chooses a set of generators of <A>G</A></E>
and then computes a presentation in terms of these generators.
<Example><![CDATA[
gap> g := Group( (2,3,4,5), (1,2,5) );;
gap> iso := IsomorphismFpGroup( g );
[ (4,5), (1,2,3,4,5), (1,3,2,4,5) ] -> [ F1, F2, F3 ]
gap> fp := Image( iso );
<fp group on the generators [ F1, F2, F3 ]>
gap> RelatorsOfFpGroup( fp );
[ F1^2, F1^-1*F2*F1*F2^-1*F3*F2^-2, F1^-1*F3*F1*F2*F3^-1*F2*F3*F2^-1, 
  F2^5*F3^-5, F2^5*(F3^-1*F2^-1)^2, (F2^-2*F3^2)^2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismFpGroupByGenerators" Arg='G,gens[,string]'/>
<Attr Name="IsomorphismFpGroupByGeneratorsNC" Arg='G,gens,string'/>

<Description>
returns an isomorphism from a finite group <A>G</A>
to a finitely presented group <A>F</A> isomorphic to <A>G</A>.
The generators of <A>F</A> correspond to the
<E>generators of <A>G</A> given in the list <A>gens</A></E>.
   If <A>string</A> is given it is used to name the generators of the
finitely presented group.
<P/>
The <C>NC</C> version will avoid testing whether the elements in
<A>gens</A> generate <A>G</A>.
<Example><![CDATA[
gap> SetInfoLevel( InfoFpGroup, 1 );
gap> iso := IsomorphismFpGroupByGenerators( g, [ (1,2), (1,2,3,4,5) ] );
#I  the image group has 2 gens and 5 rels of total length 39
[ (1,2), (1,2,3,4,5) ] -> [ F1, F2 ]
gap> fp := Image( iso );
<fp group of size 120 on the generators [ F1, F2 ]>
gap> RelatorsOfFpGroup( fp );
[ F1^2, F2^5, (F2^-1*F1)^4, (F2^-1*F1*F2*F1)^3, (F2^2*F1*F2^-2*F1)^2 ]
]]></Example>
<P/>
The main task of the function
<Ref Func="IsomorphismFpGroupByGenerators"/> is to find a presentation of
<A>G</A> in the provided generators <A>gens</A>.
In the case of a permutation group <A>G</A> it does this by first
constructing a stabilizer chain of <A>G</A> and then it works through
that chain from the bottom to the top, recursively computing a
presentation for each of the involved stabilizers.
The method used is essentially an implementation of John Cannon's
multi-stage relations-finding algorithm as described in
<Cite Key="Neu82"/> (see also <Cite Key="Can73"/> for a more graph
theoretical description).
Moreover, it makes heavy use of Tietze transformations in each stage to
avoid an explosion of the total length of the relators.
<P/>
Note that because of the random methods involved in the construction of
the stabilizer chain the resulting presentations of <A>G</A> will in
general be different for repeated calls with the same arguments.
<P/>
<Example><![CDATA[
gap> M12 := MathieuGroup( 12 );
Group([ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6), 
  (1,12)(2,11)(3,6)(4,8)(5,9)(7,10) ])
gap> gens := GeneratorsOfGroup( M12 );;
gap> iso := IsomorphismFpGroupByGenerators( M12, gens );;
#I  the image group has 3 gens and 23 rels of total length 628
gap> iso := IsomorphismFpGroupByGenerators( M12, gens );;
#I  the image group has 3 gens and 23 rels of total length 569
]]></Example>
<P/>
Also in the case of a permutation group <A>G</A>, the function
<Ref Func="IsomorphismFpGroupByGenerators"/> supports the option
<C>method</C> that can be used to modify the strategy.
The option <C>method</C> may take the following values.
<P/>
<List>
<Mark><C>method := "regular"</C></Mark>
<Item>
  This may be specified for groups of small size, up to <M>10^5</M> say.
  It implies that the function first constructs a regular representation
  <A>R</A> of <A>G</A> and then a presentation of <A>R</A>.
  In general, this presentation will be much more concise than the
  default one, but the price is the time needed for the construction of
  <A>R</A>.
</Item>
<Mark><C>method := [ "regular", bound ]</C></Mark>
<Item>
  This is a refinement of the previous possibility.
  In this case, <C>bound</C> should be an integer, and if so the method
  <C>"regular"</C> as described above is applied to the largest
  stabilizer in the stabilizer chain of <A>G</A> whose size does not
  exceed the given bound and then the multi-stage algorithm is used to
  work through the chain from that subgroup to the top.
</Item>
<Mark><C>method := "fast"</C></Mark>
<Item>
  This chooses an alternative method which essentially is a kind of
  multi-stage algorithm for a stabilizer chain of <A>G</A> but does not
  make any attempt do reduce the number of relators as it is done in
  Cannon's algorithm or to reduce their total length.
  Hence it is often much faster than the default method, but the total
  length of the resulting presentation may be huge.
</Item>
<Mark><C>method := "default"</C></Mark>
<Item>
  This simply means that the default method shall be used, which is the
  case if the option <C>method</C> is not given a value.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> iso := IsomorphismFpGroupByGenerators( M12, gens : 
>                                           method := "regular" );;
#I  the image group has 3 gens and 11 rels of total length 92
gap> iso := IsomorphismFpGroupByGenerators( M12, gens : 
>                                           method := "fast" );;
#I  the image group has 3 gens and 178 rels of total length 4001
]]></Example>
<P/>
Though the option <C>method := "regular"</C> is only checked in the case
of a permutation group it also affects the performance and the results of
the function <Ref Func="IsomorphismFpGroupByGenerators"/> for other
groups, e. g. for matrix groups.
This happens because, for these groups, the function first calls the
function <Ref Func="NiceMonomorphism"/> to get a bijective action
homomorphism from <A>G</A> to a suitable permutation group,
<M>P</M> say, and then, recursively, calls itself for the group <M>P</M>
so that now the option becomes relevant.
<P/>
<Example><![CDATA[
gap> G := ImfMatrixGroup( 5, 1, 3 );
ImfMatrixGroup(5,1,3)
gap> gens := GeneratorsOfGroup( G );
[ [ [ -1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
      [ -1, -1, -1, -1, 2 ], [ -1, 0, 0, 0, 1 ] ], 
  [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
      [ 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 1 ] ] ]
gap> iso := IsomorphismFpGroupByGenerators( G, gens );;
#I  the image group has 2 gens and 9 rels of total length 112
gap> iso := IsomorphismFpGroupByGenerators( G, gens : 
>                                           method := "regular");;
#I  the image group has 2 gens and 6 rels of total length 56
gap> SetInfoLevel( InfoFpGroup, 0 );
gap> iso;
<composed isomorphism:[ [ [ -1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, \
0, 0, 1, 0 ], [ -1, -1, -1, -1, 2 ], [ -1, 0, 0, 0, 1 ] ], [ [ 0, 1, 0\
, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], [ 1, 0, 0, 0, 0 ], [ 0\
, 0, 0, 0, 1 ] ] ]->[ F1, F2 ]>
gap> ConstituentsCompositionMapping(iso);
[ <action isomorphism>, 
  [ (2,3,4)(5,6)(8,9,10), (1,2,3,5)(6,7,8,9) ] -> [ F1, F2 ] ]
]]></Example>
<P/>
Since &GAP; cannot decompose elements of a matrix group into generators,
the resulting isomorphism is stored as a composition of a (faithful)
permutation action on vectors and a homomorphism from the permutation image
to the finitely presented group. In such a situation the constituent
mappings can be obtained via <Ref Func="ConstituentsCompositionMapping"/>
as separate &GAP; objects.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="New Presentations and Presentations for Subgroups">
<Heading>New Presentations and Presentations for Subgroups</Heading>

<Index Key="IsomorphismFpGroup" Subkey="for subgroups of fp groups">
<C>IsomorphismFpGroup</C></Index>
<Ref Func="IsomorphismFpGroup"/> is also used to compute
a new finitely presented group that is isomorphic to the given subgroup
of a finitely presented group.
(This is typically the only method to compute with subgroups of a finitely
presented group.)
<P/>
<Example><![CDATA[
gap> f:=FreeGroup(2);;
gap> g:=f/[f.1^2,f.2^3,(f.1*f.2)^5];
<fp group on the generators [ f1, f2 ]>
gap> u:=Subgroup(g,[g.1*g.2]);
Group([ f1*f2 ])
gap> hom:=IsomorphismFpGroup(u);
[ <[ [ 1, 1 ] ]|f2^-1*f1^-1> ] -> [ F1 ]
gap> new:=Range(hom);
<fp group on the generators [ F1 ]>
gap> List(GeneratorsOfGroup(new),i->PreImagesRepresentative(hom,i));
[ <[ [ 1, 1 ] ]|f2^-1*f1^-1> ]
]]></Example>
<P/>
When working with such homomorphisms, some subgroup elements are expressed
as extremely long words in the group generators. Therefore the underlying
words of subgroup
generators stored in the isomorphism (as obtained by
<Ref Attr="MappingGeneratorsImages"/> and displayed when
<Ref Func="View"/>ing the homomorphism)
as well as preimages under the homomorphism are stored in the form of
straight line program elements
(see&nbsp;<Ref Sect="Straight Line Program Elements"/>). These will
behave like ordinary words and no extra treatment should be necessary.
<P/>
<Example><![CDATA[
gap> r:=Range(hom).1^10;
F1^10
gap> p:=PreImagesRepresentative(hom,r);
<[ [ 1, 10 ] ]|(f2^-1*f1^-1)^10>
]]></Example>

If desired, it also is possible to convert these underlying words using
<Ref Func="EvalStraightLineProgElm"/>:

<Example><![CDATA[
gap> r:=EvalStraightLineProgElm(UnderlyingElement(p));
(f2^-1*f1^-1)^10
gap> p:=ElementOfFpGroup(FamilyObj(p),r);
(f2^-1*f1^-1)^10
]]></Example>
<P/>
(If you are only interested in a finitely presented group isomorphic to
the given subgroup but not in the isomorphism,
you may also use the functions
<Ref Func="PresentationViaCosetTable"/> and <Ref Func="FpGroupPresentation"/>
(see <Ref Sect="Creating Presentations"/>).)
<P/>
Homomorphisms can also be used to obtain an isomorphic finitely presented
group with a (hopefully) simpler presentation.
<P/>
<ManSection>
<Attr Name="IsomorphismSimplifiedFpGroup" Arg='G'/>

<Description>
applies Tietze transformations to a copy of the presentation of the
given finitely presented group <A>G</A> in order to reduce it
with respect to the number of generators, the number of relators,
and the relator lengths.
<P/>
The operation returns an isomorphism with source <A>G</A>, range a group
<A>H</A> isomorphic to <A>G</A>, so that the presentation of <A>H</A> has
been simplified using Tietze transformations.
<Example><![CDATA[
gap> f:=FreeGroup(3);;
gap> g:=f/[f.1^2,f.2^3,(f.1*f.2)^5,f.1/f.3];
<fp group on the generators [ f1, f2, f3 ]>
gap> hom:=IsomorphismSimplifiedFpGroup(g);
[ f1, f2, f3 ] -> [ f1, f2, f1 ]
gap> Range(hom);
<fp group on the generators [ f1, f2 ]>
gap> RelatorsOfFpGroup(Range(hom));
[ f1^2, f2^3, (f1*f2)^5 ]
gap> RelatorsOfFpGroup(g);
[ f1^2, f2^3, (f1*f2)^5, f1*f3^-1 ]
]]></Example>
<P/>
<Ref Func="IsomorphismSimplifiedFpGroup"/> uses Tietze transformations
to simplify the presentation, see <Ref Sect="SimplifiedFpGroup"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Preimages under Homomorphisms from an FpGroup">
<Heading>Preimages under Homomorphisms from an FpGroup</Heading>

For some subgroups of a finitely presented group the number of
subgroup generators increases with the index of the subgroup. However often
these generators are not needed at all for further calculations, but what is
needed is the action of the cosets of the subgroup. This gives the image of
the subgroup in a finite quotient and this finite quotient can be used to
calculate normalizers, closures, intersections and so
forth&nbsp;<Cite Key="HulpkeQuot"/>.
<P/>
The same applies for subgroups that are obtained as preimages under
homomorphisms.

<ManSection>
<Func Name="SubgroupOfWholeGroupByQuotientSubgroup" Arg='fpfam, Q, U'/>

<Description>
takes a FpGroup family <A>fpfam</A>, a finitely generated group <A>Q</A>
such that the fp generators of <A>fpfam</A> can be mapped by an
epimorphism <M>phi</M> onto the <Ref Func="GeneratorsOfGroup"/> value
of <A>Q</A>, and a subgroup <A>U</A> of <A>Q</A>.
It returns the subgroup of <A>fpfam</A><C>!.wholeGroup</C> which is
the full preimage of <A>U</A> under <M>phi</M>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsSubgroupOfWholeGroupByQuotientRep" Arg='G'
 Type='Representation'/>

<Description>
is the representation for subgroups of an FpGroup, given by a quotient
subgroup. The components <A>G</A><C>!.quot</C> and <A>G</A><C>!.sub</C>
hold quotient, respectively subgroup.
</Description>
</ManSection>

<ManSection>
<Attr Name="AsSubgroupOfWholeGroupByQuotient" Arg='U'/>

<Description>
returns the same subgroup in the representation
<Ref Func="AsSubgroupOfWholeGroupByQuotient"/>.
<P/>
See also <Ref Func="SubgroupOfWholeGroupByCosetTable"/>
and <Ref Func="CosetTableBySubgroup"/>.
<P/>
This technique is used by &GAP; for example to represent the derived
subgroup, which is obtained from the quotient <M>G/G'</M>.
<Example><![CDATA[
gap> f:=FreeGroup(2);;g:=f/[f.1^6,f.2^6,(f.1*f.2)^6];;
gap> d:=DerivedSubgroup(g);
Group(<fp, no generators known>)
gap> Index(g,d);
36
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DefiningQuotientHomomorphism" Arg='U'/>

<Description>
if <A>U</A> is a subgroup in quotient representation
(<Ref Func="IsSubgroupOfWholeGroupByQuotientRep"/>),
this function returns the
defining homomorphism from the whole group to <A>U</A><C>!.quot</C>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Quotient Methods">
<Heading>Quotient Methods</Heading>

An important class of algorithms for finitely presented groups are the
<E>quotient algorithms</E> which compute quotient groups of a given finitely
presented group. There are algorithms for epimorphisms onto abelian groups,
<M>p</M>-groups and solvable groups.
(The <Q>low index</Q> algorithm
&ndash;<Ref Func="LowIndexSubgroupsFpGroup"/>&ndash;
can be considered as well as an algorithm that produces permutation group
quotients.)
<P/>
<Ref Func="MaximalAbelianQuotient"/>,
as defined for general groups, returns the largest abelian
quotient of the given group.

<Example><![CDATA[
gap> f:=FreeGroup(2);;fp:=f/[f.1^6,f.2^6,(f.1*f.2)^12];
<fp group on the generators [ f1, f2 ]>
gap> hom:=MaximalAbelianQuotient(fp);
[ f1, f2 ] -> [ f1, f3 ]
gap> Size(Image(hom));
36
]]></Example>

<ManSection>
<Func Name="PQuotient" Arg='F, p[, c][, logord][, ctype]'/>

<Description>
computes a factor <A>p</A>-group of a finitely presented group <A>F</A>
in form  of a quotient system.
The quotient system can be converted into an epimorphism from <A>F</A>
onto the <A>p</A>-group computed by the function
<Ref Func="EpimorphismQuotientSystem"/>. 
<P/>
For a group <M>G</M> define the exponent-<M>p</M> central series of
<M>G</M> inductively by <M>{\cal P}_1(G) = G</M> and
<M>{\cal P}_{{i+1}}(G) = [{\cal P}_i(G),G]{\cal P}_{{i+1}}(G)^p</M>.
The factor groups modulo the terms of the lower
exponent-<M>p</M> central series are <M>p</M>-groups.
The group <M>G</M> has <M>p</M>-class
<M>c</M> if <M>{\cal P}_c(G) \neq {\cal P}_{{c+1}}(G) = 1</M>. 
<P/>
The algorithm computes successive quotients modulo the terms of the
exponent-<M>p</M> central series of <A>F</A>.
If the parameter <A>c</A> is present,
then the factor group modulo the <M>(c+1)</M>-th term of the
exponent-<M>p</M> central series of <A>F</A> is returned.
If <A>c</A> is not present, then the algorithm attempts to compute the
largest factor <A>p</A>-group of <A>F</A>.
In case <A>F</A> does not have a largest factor <A>p</A>-group,
the algorithm will not terminate.
<P/>
By default the algorithm computes only with factor groups of order at
most <M>p^{256}</M>. If the parameter <A>logord</A> is present, it will
compute with factor groups of order at most <M>p^{<A>logord</A>}</M>.
If this parameter is specified, then the parameter <A>c</A> must also be
given.  The present
implementation produces an error message if the order of a
<M>p</M>-quotient exceeds <M>p^{256}</M> or <M>p^{<A>logord</A>}</M>,
respectively.
Note that the order of intermediate <M>p</M>-groups may be larger than
the final order of a <M>p</M>-quotient.
<P/>
The parameter <A>ctype</A> determines the type of collector that is used
for computations within the factor <A>p</A>-group.
<A>ctype</A> must either be <C>"single"</C> in which case a simple
collector from the left is used or <C>"combinatorial"</C> in which case
a combinatorial collector from the left is used. 
</Description>
</ManSection>

<ManSection>
<Oper Name="EpimorphismQuotientSystem" Arg='quotsys'/>

<Description>
For a quotient system <A>quotsys</A> obtained from the function
<Ref Func="PQuotient"/>, this operation returns an epimorphism
<M><A>F</A> \rightarrow <A>P</A></M> where <M><A>F</A></M> is the
finitely presented group of which <A>quotsys</A> is a quotient system and
<M><A>P</A></M> is a pc group isomorphic to the quotient of <A>F</A>
determined by <A>quotsys</A>.
<P/>
Different calls to this operation will create different groups <A>P</A>,
each with its own family.
<P/>
<Example><![CDATA[
gap> PQuotient( FreeGroup(2), 5, 10, 1024, "combinatorial" );
<5-quotient system of 5-class 10 with 520 generators>
gap> phi := EpimorphismQuotientSystem( last );
[ f1, f2 ] -> [ a1, a2 ]
gap> Collected( Factors( Size( Image( phi ) ) ) );
[ [ 5, 520 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EpimorphismPGroup" Arg='fpgrp, p[, cl]'/>

<Description>
computes an epimorphism from the finitely presented group <A>fpgrp</A> to
the largest <M>p</M>-group of <M>p</M>-class <A>cl</A> which is
a quotient of <A>fpgrp</A>.
If <A>cl</A> is omitted, the largest finite <M>p</M>-group quotient
(of <M>p</M>-class up to <M>1000</M>) is determined.
<P/>
<Example><![CDATA[
gap> hom:=EpimorphismPGroup(fp,2);
[ f1, f2 ] -> [ a1, a2 ]
gap> Size(Image(hom));
8
gap> hom:=EpimorphismPGroup(fp,3,7);
[ f1, f2 ] -> [ a1, a2 ]
gap> Size(Image(hom));
6561
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="EpimorphismNilpotentQuotient" Arg='fpgrp[, n]'/>

<Description>
returns an epimorphism on the class <A>n</A> finite nilpotent quotient of
the finitely presented group <A>fpgrp</A>.
If <A>n</A> is omitted, the largest finite nilpotent quotient
(of <M>p</M>-class up to <M>1000</M>) is taken.
<P/>
<Example><![CDATA[
gap> hom:=EpimorphismNilpotentQuotient(fp,7);
[ f1, f2 ] -> [ f1*f4, f2*f5 ]
gap> Size(Image(hom));
52488
]]></Example>
<P/>
A related operation which is also applicable to finitely presented groups is
<Ref Func="GQuotients"/>, which computes all epimorphisms from a
(finitely presented) group <A>F</A> onto a given (finite) group <A>G</A>.
<P/>
<Example><![CDATA[
gap> GQuotients(fp,Group((1,2,3),(1,2)));
[ [ f1, f2 ] -> [ (1,2), (2,3) ], [ f1, f2 ] -> [ (2,3), (1,2,3) ], 
  [ f1, f2 ] -> [ (1,2,3), (2,3) ] ]
]]></Example>
</Description>
</ManSection>

<Heading>SolvableQuotient</Heading>
<ManSection>
<Func Name="SolvableQuotient" Arg='F, size'
 Label="for a f.p. group and a size"/>
<Func Name="SolvableQuotient" Arg='F, primes'
 Label="for a f.p. group and a list of primes"/>
<Func Name="SolvableQuotient" Arg='F, tuples'
 Label="for a f.p. group and a list of tuples"/>
<Func Name="SQ" Arg='F, ...' Label="synonym of SolvableQuotient"/>

<Description>
This routine calls the solvable quotient algorithm for a finitely
presented group <A>F</A>.
The quotient to be found can be specified in the following ways:
Specifying an integer <A>size</A> finds a quotient of size up
to <A>size</A> (if such large quotients exist).
Specifying a list of primes in <A>primes</A> finds the largest quotient
involving the given primes.
Finally <A>tuples</A> can be used to prescribe a chief series.
<P/>
<Ref Func="SQ" Label="synonym of SolvableQuotient"/> can be used as a
synonym for
<Ref Func="SolvableQuotient" Label="for a f.p. group and a size"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="EpimorphismSolvableQuotient" Arg='F, param'/>

<Description>
computes an epimorphism from the finitely presented group <A>fpgrp</A>
to the largest solvable quotient given by <A>param</A> (specified as in 
<Ref Func="SolvableQuotient" Label="for a f.p. group and a size"/>).
<P/>
<Example><![CDATA[
gap> f := FreeGroup( "a", "b", "c", "d" );;
gap> fp := f / [ f.1^2, f.2^2, f.3^2, f.4^2, f.1*f.2*f.1*f.2*f.1*f.2,
>  f.2*f.3*f.2*f.3*f.2*f.3*f.2*f.3, f.3*f.4*f.3*f.4*f.3*f.4,
> f.1^-1*f.3^-1*f.1*f.3, f.1^-1*f.4^-1*f.1*f.4,
> f.2^-1*f.4^-1*f.2*f.4 ];;
gap> hom:=EpimorphismSolvableQuotient(fp,300);Size(Image(hom));
[ a, b, c, d ] -> [ f1*f2, f1*f2, f2*f3, f2 ]
12
gap> hom:=EpimorphismSolvableQuotient(fp,[2,3]);Size(Image(hom));
[ a, b, c, d ] -> [ f1*f2*f4, f1*f2*f6*f8, f2*f3, f2 ]
1152
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LargerQuotientBySubgroupAbelianization" Arg='hom, U'/>

<Description>
Let <A>hom</A> a homomorphism from a finitely presented group <M>G</M>
to a finite group <M>H</M> and <M><A>U</A>\le H</M>. This function will -- if it
exists -- return a subgroup <M>S\le<A>G</A></M>, such that the core of
<M>S</M> is properly
contained in the kernel of <A>hom</A> as well as in <M>V'</M>, where <M>V</M> is the
pre-image of <A>U</A> under <A>hom</A>.  Thus <M>S</M> exposes a larger quotient
of <M>G</M>.
If no such subgroup exists, <A>fail</A> is returned.
<Example><![CDATA[
gap> f:=FreeGroup("x","y","z");;
gap> g:=f/ParseRelators(f,"x^3=y^3=z^5=(xyx^2y^2)^2=(xz)^2=(yz^3)^2=1");
<fp group on the generators [ x, y, z ]>
gap> l:=LowIndexSubgroupsFpGroup(g,6);;
gap> List(l,IndexInWholeGroup);
[ 1, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6 ]
gap> q:=DefiningQuotientHomomorphism(l[6]);;p:=Image(q);Size(p);
Group([ (4,5,6), (1,2,3)(4,6,5), (2,4,6,3,5) ])
360
gap> s:=LargerQuotientBySubgroupAbelianization(q,SylowSubgroup(p,3)); 
Group(<fp, no generators known>)
gap> Size(Image(DefiningQuotientHomomorphism(s))); 
193273528320
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Abelian Invariants for Subgroups">
<Heading>Abelian Invariants for Subgroups</Heading>

Using variations of coset enumeration it is possible to compute the abelian
invariants of a subgroup of a finitely presented group without computing a
complete presentation for the subgroup in the first place.
Typically, the operation <Ref Func="AbelianInvariants"/> when called for
subgroups should automatically take care of this,
but in case you want to have further control about the methods used,
the following operations might be of use.

<ManSection>
<Func Name="AbelianInvariantsSubgroupFpGroup" Arg='G,H'/>

<Description>
<Ref Func="AbelianInvariantsSubgroupFpGroup"/> is a synonym for
<Ref Func="AbelianInvariantsSubgroupFpGroupRrs"
Label="for a group and a coset table"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="AbelianInvariantsSubgroupFpGroupMtc" Arg='G, H'/>

<Description>
uses the Modified Todd-Coxeter method to compute the abelian
invariants of a subgroup <A>H</A> of a finitely presented group <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Heading>AbelianInvariantsSubgroupFpGroupRrs</Heading>
<Func Name="AbelianInvariantsSubgroupFpGroupRrs" Arg='G, H'
 Label="for two groups"/>
<Func Name="AbelianInvariantsSubgroupFpGroupRrs" Arg='G, table'
 Label="for a group and a coset table"/>

<Description>
uses the Reduced Reidemeister-Schreier method to compute the abelian
invariants of a subgroup <A>H</A> of a finitely presented group <A>G</A>.
<P/>
Alternatively to the subgroup <A>H</A>, its coset table <A>table</A> in
<A>G</A> may be given as second argument.
</Description>
</ManSection>

<ManSection>
<Func Name="AbelianInvariantsNormalClosureFpGroup" Arg='G, H'/>

<Description>
<Ref Func="AbelianInvariantsNormalClosureFpGroup"/> is a synonym for
<Ref Func="AbelianInvariantsNormalClosureFpGroupRrs"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="AbelianInvariantsNormalClosureFpGroupRrs" Arg='G, H'/>

<Description>
uses the Reduced Reidemeister-Schreier method to compute the abelian
invariants of the normal closure of a subgroup <A>H</A> of a finitely
presented group <A>G</A>.
See <Ref Sect="Subgroup Presentations"/> for details on the different
strategies.
<P/>
The following example shows a calculation for the Coxeter group
<M>B_1</M>.
This calculation and a similar one for <M>B_0</M> have been used
to prove that <M>B_1' / B_1'' \cong Z_2^9 \times Z^3</M> and
<M>B_0' / B_0'' \cong Z_2^{91} \times Z^{27}</M> as stated in
in <Cite Key="FJNT95" Where="Proposition 5"/>.
<P/>
<Example><![CDATA[
gap> # Define the Coxeter group E1.
gap> F := FreeGroup( "x1", "x2", "x3", "x4", "x5" );
<free group on the generators [ x1, x2, x3, x4, x5 ]>
gap> x1 := F.1;; x2 := F.2;; x3 := F.3;; x4 := F.4;; x5 := F.5;;
gap> rels := [ x1^2, x2^2, x3^2, x4^2, x5^2,
>  (x1 * x3)^2, (x2 * x4)^2, (x1 * x2)^3, (x2 * x3)^3, (x3 * x4)^3,
>  (x4 * x1)^3, (x1 * x5)^3, (x2 * x5)^2, (x3 * x5)^3, (x4 * x5)^2,
>  (x1 * x2 * x3 * x4 * x3 * x2)^2 ];;
gap> E1 := F / rels;
<fp group on the generators [ x1, x2, x3, x4, x5 ]>
gap> x1 := E1.1;; x2 := E1.2;; x3 := E1.3;; x4 := E1.4;; x5 := E1.5;;
gap> # Get normal subgroup generators for B1.
gap> H := Subgroup( E1, [ x5 * x2^-1, x5 * x4^-1 ] );;
gap> # Compute the abelian invariants of B1/B1'.
gap> A := AbelianInvariantsNormalClosureFpGroup( E1, H );
[ 2, 2, 2, 2, 2, 2, 2, 2 ]
gap> # Compute a presentation for B1.
gap> P := PresentationNormalClosure( E1, H );
<presentation with 18 gens and 46 rels of total length 132>
gap> SimplifyPresentation( P );
#I  there are 8 generators and 30 relators of total length 148
gap> B1 := FpGroupPresentation( P );
<fp group on the generators [ _x1, _x2, _x3, _x4, _x6, _x7, _x8, _x11 
 ]>
gap> # Compute normal subgroup generators for B1'.
gap> gens := GeneratorsOfGroup( B1 );;
gap> numgens := Length( gens );;
gap> comms := [ ];;
gap> for i in [ 1 .. numgens - 1 ] do
>     for j in [i+1 .. numgens ] do
>         Add( comms, Comm( gens[i], gens[j] ) );
>     od;
> od;
gap> # Compute the abelian invariants of B1'/B1".
gap> K := Subgroup( B1, comms );;
gap> A := AbelianInvariantsNormalClosureFpGroup( B1, K );
[ 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Testing Finiteness of Finitely Presented Groups">
<Heading>Testing Finiteness of Finitely Presented Groups</Heading>

As a consequence of the algorithmic insolvabilities mentioned in the
introduction to this chapter, there cannot be a general method that will
test whether a given finitely presented group is actually finite. 
<P/>
Therefore testing the finiteness of a finitely presented group
can be problematic.
What &GAP; actually does upon a call of <Ref Func="IsFinite"/>
(or if it is &ndash;probably implicitly&ndash; asked for a faithful
permutation representation)
is to test whether it can find (via coset enumeration) a
cyclic subgroup of finite index. If it can, it rewrites the presentation to
this subgroup. Since the subgroup is cyclic, its size can be checked easily
from the resulting presentation, the size of the whole group is the product
of the index and the subgroup size.  Since however no bound for the index of
such a subgroup (if any exist) is known, such a test might continue
unsuccessfully until memory is exhausted.
<P/>
On the other hand, a couple of methods exist, that might prove that a group
is infinite. Again, none is guaranteed to work in every case:
<P/>
The first method is to find (for example via the low index algorithm,
see&nbsp;<Ref Func="LowIndexSubgroupsFpGroup"/>) a subgroup <M>U</M>
such that <M>[U:U']</M> is infinite.
If <M>U</M> has finite index, this can be checked by
<Ref Func="IsInfiniteAbelianizationGroup"/>.
<P/>
Note that this test has been done traditionally by checking the
<Ref Func="AbelianInvariants"/>
(see section&nbsp;<Ref Sect="Abelian Invariants for Subgroups"/>)
of <M>U</M>,
<Ref Func="IsInfiniteAbelianizationGroup"/> does a
similar calculation but stops as soon as it is known whether <M>0</M> is an
invariant without computing the actual values. This can be notably faster.
<P/>
Another method is based on <M>p</M>-group quotients,
see <Ref Func="NewmanInfinityCriterion"/>.

<ManSection>
<Attr Name="IsInfiniteAbelianizationGroup" Arg='G'/>

<Description>
<Index Subkey="for groups" Key="IsInfiniteAbelianizationGroup">
<C>IsInfiniteAbelianizationGroup</C></Index>
returns true if the commutator factor group <M><A>G</A>/<A>G</A>'</M> is
infinite. This might be done without computing the full structure of the
commutator factor group.
</Description>
</ManSection>

<ManSection>
<Func Name="NewmanInfinityCriterion" Arg='G, p'/>

<Description>
Let <A>G</A> be a finitely presented group and <A>p</A> a prime that
divides the order of the commutator factor group of <A>G</A>.
This function applies an infinity criterion due to M. F.&nbsp;Newman
<Cite Key="New90"/> to <A>G</A>.
(See <Cite Key="Joh97" Where="chapter 16"/> for a more explicit
description.)
It returns <K>true</K>
if the criterion succeeds in proving that <A>G</A> is infinite and
<K>fail</K> otherwise.
<P/>
Note that the criterion uses the number of generators and
relations in the presentation of <A>G</A>.
Reduction of the presentation via Tietze transformations
(<Ref Func="IsomorphismSimplifiedFpGroup"/>) therefore might
produce an isomorphic group, for which the criterion will work better.
<Example><![CDATA[
gap> g:=FibonacciGroup(2,9);
<fp group on the generators [ f1, f2, f3, f4, f5, f6, f7, f8, f9 ]>
gap> hom:=EpimorphismNilpotentQuotient(g,2);;
gap> k:=Kernel(hom);;
gap> Index(g,k);
152
gap> AbelianInvariants(k);
[ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ]
gap> NewmanInfinityCriterion(Kernel(hom),5);
true
]]></Example>
<P/>
This proves that the subgroup <C>k</C>
(and thus the whole group <C>g</C>) is infinite.
(This is the original example from&nbsp;<Cite Key="New90"/>.)
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  pres.msk                   GAP documentation             Volkmar Felsch -->
<!-- %A                                                           Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: pres.msk,v 1.24 2003/10/28 04:55:03 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Presentations and Tietze Transformations">
<Heading>Presentations and Tietze Transformations</Heading>

A finite presentation describes a group, but usually there is a multitude of
presentations that describe isomorphic groups. Therefore a presentation in
&GAP; is different from a finitely presented group though there are ways to
translate between both.
<P/>
An important feature of presentations is that they can be modified (see
sections <Ref Sect="Changing Presentations"/>
to <Ref Sect="Tietze Transformations that introduce new Generators"/>).
<P/>
<!-- %%  The code for presentations was designed and implemented by Volkmar Felsch. -->
If you only want to get new presentations for subgroups of a finitely
presented group (and do not want to manipulate presentations yourself),
chances are that the operation <Ref Func="IsomorphismFpGroup"/> already does
what you want
(see&nbsp;<Ref Sect="New Presentations and Presentations for Subgroups"/>).


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Presentations">
<Heading>Creating Presentations</Heading>

Most of the functions creating presentations and all functions performing
Tietze transformations on them sort the relators by increasing lengths.
The function <Ref Func="PresentationFpGroup"/> is an exception because it is
intended to reflect the relators that were used to define the involved
f. p. group.
You may use the command <Ref Func="TzSort"/> to sort the presentation.

<ManSection>
<Func Name="PresentationFpGroup" Arg='G [,printlevel]'/>

<Description>
creates a presentation, i. e., a Tietze object, for the given finitely
presented group <A>G</A>. This presentation will be exactly as the
presentation of <A>G</A> and <E>no</E> initial Tietze transformations
are applied to it.
<P/>
The  optional <A>printlevel</A> parameter can be used to restrict or to
extend the amount of output provided by Tietze transformation
commands when being applied to the created presentation.  The
default value 1 is designed  for  interactive  use  and  implies
explicit  messages  to  be displayed  by most of  these  commands. A
<A>printlevel</A> value of  0 will suppress these messages, whereas a
<A>printlevel</A>  value of 2  will enforce some additional output.
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );
<free group on the generators [ a, b ]>
gap> g := f / [ f.1^3, f.2^2, (f.1*f.2)^3 ];
<fp group on the generators [ a, b ]>
gap> p := PresentationFpGroup( g );
<presentation with 2 gens and 3 rels of total length 11>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzSort" Arg='P'/>

<Description>
sorts the relators of the given presentation <A>P</A> by increasing
lengths.
There is no particular ordering defined for the relators of equal length.
Note that <Ref Func="TzSort"/> does not return a new object.
It changes the given presentation.
</Description>
</ManSection>

<ManSection>
<Func Name="GeneratorsOfPresentation" Arg='P'/>

<Description>
returns a list of free generators that is a shallow copy
(see <Ref Func="ShallowCopy"/>) of the current
generators of the presentation <A>P</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="FpGroupPresentation" Arg='P [,nam]'/>

<Description>
constructs an f. p. group as defined by the given Tietze
presentation <A>P</A>.
<Example><![CDATA[
gap> h := FpGroupPresentation( p );
<fp group on the generators [ a, b ]>
gap> h = g;
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PresentationViaCosetTable" Arg='G[, F, words]'/>

<Description>
constructs a presentation for a given concrete finite group.
It applies the relations finding algorithm which has been described in
<Cite Key="Can73"/> and <Cite Key="Neu82"/>.
It automatically applies Tietze transformations to the presentation
found.
<P/>
If only a group <A>G</A> has been specified, the single stage algorithm
is applied.
<P/>
The operation <Ref Func="IsomorphismFpGroup"/> in contrast uses a
multiple-stage algorithm using a chief series and stabilizer chains.
It usually should be used rather than
<Ref Func="PresentationViaCosetTable"/>.
(It does not apply Tietze transformations automatically.)
<P/>
If the two stage algorithm is to be used,
<Ref Func="PresentationViaCosetTable"/> expects a subgroup <A>H</A> of
<A>G</A> to be provided in form of two additional arguments <A>F</A> and
<A>words</A>, where <A>F</A> is a free group with the same number
of generators as <A>G</A>, and <A>words</A> is a list of words in the
generators of <A>F</A> which supply a list of generators of <A>H</A> if
they are evaluated as words in the corresponding generators of <A>G</A>.
<Example><![CDATA[
gap> G := GeneralLinearGroup( 2, 7 );
GL(2,7)
gap> GeneratorsOfGroup( G );
[ [ [ Z(7), 0*Z(7) ], [ 0*Z(7), Z(7)^0 ] ], 
  [ [ Z(7)^3, Z(7)^0 ], [ Z(7)^3, 0*Z(7) ] ] ]
gap> Size( G );
2016
gap> P := PresentationViaCosetTable( G );
<presentation with 2 gens and 5 rels of total length 46>
gap> TzPrintRelators( P );
#I  1. f2^3
#I  2. f1^6
#I  3. (f1^-1*f2^-1)^6
#I  4. f1*f2*f1^-1*f2^-1*f1*f2^-1*f1^-1*f2*f1*f2^-1*f1^-1*f2^-1
#I  5. f1^-3*f2*f1*f2*(f1^-1*f2^-1)^2*f1^-2*f2
]]></Example>
<P/>
The two stage algorithm saves an essential amount of space by
constructing two coset tables of lengths <M>|H|</M> and <M>|G|/|H|</M>
instead of just one coset table of length <M>|G|</M>.
The next example shows an application
of this option in the case of a subgroup of size 7920 and index 12 in a
permutation group of size 95040.
<P/>
<Example><![CDATA[
gap> M12 := Group( [ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6),
> (1,12)(2,11)(3,6)(4,8)(5,9)(7,10) ], () );;
gap> F := FreeGroup( "a", "b", "c" );
<free group on the generators [ a, b, c ]>
gap> words := [ F.1, F.2 ];
[ a, b ]
gap> P := PresentationViaCosetTable( M12, F, words );
<presentation with 3 gens and 10 rels of total length 97>
gap> G := FpGroupPresentation( P );
<fp group on the generators [ a, b, c ]>
gap> RelatorsOfFpGroup( G );
[ c^2, b^4, (a*c)^3, (a*b^-2)^3, a^11, 
  a^2*b*a^-2*b^-1*(b^-1*a)^2*a*b^-1, (a*(b*a^-1)^2*b^-1)^2, 
  a^2*b*a^2*b^-2*a^-1*b*(a^-1*b^-1)^2, 
  (a*b)^2*a^2*b^-1*a^-1*b^-1*a*c*b*c, a^2*(a^2*b)^2*a^-2*c*a*b*a^-1*c 
 ]
]]></Example>
<P/>
Before it is returned, the resulting presentation is being simplified by
appropriate calls of the function <Ref Func="SimplifyPresentation"/>
(see <Ref Sect="Tietze Transformations"/>),
but without allowing any eliminations of generators.
This restriction guarantees that we get a bijection between the list of
generators of <A>G</A> and the list of generators in the presentation.
Hence, if the generators of <A>G</A> are redundant and if you don't care
for the bijection, you may get a shorter presentation by calling the
function <Ref Func="SimplifyPresentation"/>,
now without this restriction, once more yourself.
<P/>
<Example><![CDATA[
gap> H := Group(
> [ (2,5,3), (2,7,5), (1,8,4), (1,8,6), (4,8,6), (3,5,7) ], () );;
gap> P := PresentationViaCosetTable( H );
<presentation with 6 gens and 12 rels of total length 42>
gap> SimplifyPresentation( P );
#I  there are 4 generators and 10 relators of total length 36
]]></Example>
<P/>
If you apply the function <Ref Func="FpGroupPresentation"/> to the
resulting presentation you will get a finitely presented group isomorphic
to <A>G</A>.
Note, however, that the function <Ref Func="IsomorphismFpGroup"/>
is recommended for this purpose.
</Description>
</ManSection>

<ManSection>
<Func Name="SimplifiedFpGroup" Arg='G'/>

<Description>
applies Tietze transformations to a copy of the presentation of the
given finitely presented group <A>G</A> in order to reduce it
with respect to the number of generators, the number of relators,
and the relator lengths.
<P/>
<Ref Func="SimplifiedFpGroup"/> returns a group isomorphic to
the given one  with a presentation which has been tried to simplify
via Tietze transformations.
<P/>
If the connection to the original group is important, then the operation
<Ref Func="IsomorphismSimplifiedFpGroup"/> should be used instead.
<P/>
<Example><![CDATA[
gap> F6 := FreeGroup( 6, "G" );;
gap> G := F6 / [ F6.1^2, F6.2^2, F6.4*F6.6^-1, F6.5^2, F6.6^2,
> F6.1*F6.2^-1*F6.3, F6.1*F6.5*F6.3^-1, F6.2*F6.4^-1*F6.3,
> F6.3*F6.4*F6.5^-1, F6.1*F6.6*F6.3^-2, F6.3^4 ];;
gap> H := SimplifiedFpGroup( G );
<fp group on the generators [ G1, G3 ]>
gap> RelatorsOfFpGroup( H );
[ G1^2, (G1*G3^-1)^2, G3^4 ]
]]></Example>
<P/>
In fact, the command
<P/>
<Log><![CDATA[
H := SimplifiedFpGroup( G );
]]></Log>
<P/>
is an abbreviation of the command sequence
<P/>
<Log><![CDATA[
P := PresentationFpGroup( G, 0 );;
SimplifyPresentation( P );
H := FpGroupPresentation( P );
]]></Log>
<P/>
which applies a rather simple-minded strategy of Tietze transformations
to the intermediate presentation <A>P</A>.
If, for some concrete group, the resulting presentation is unsatisfying,
then you should try a more sophisticated, interactive use of the
available Tietze transformation commands
(see <Ref Sect="Tietze Transformations"/>).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroup Presentations">
<Heading>Subgroup Presentations</Heading>

<Index>Schreier</Index>
<ManSection>
<Func Name="PresentationSubgroup" Arg='G, H[, string]'/>

<Description>
<Ref Func="PresentationSubgroup"/> is a synonym for
<Ref Func="PresentationSubgroupRrs"
Label="for a group and a coset table (and a string)"/>.
</Description>
</ManSection>

<ManSection>
<Heading>PresentationSubgroupRrs</Heading>
<Func Name="PresentationSubgroupRrs" Arg='G, H[, string]'
 Label="for two groups (and a string)"/>
<Func Name="PresentationSubgroupRrs" Arg='G, table[, string]'
 Label="for a group and a coset table (and a string)"/>

<Description>
uses the  Reduced Reidemeister-Schreier method to compute a presentation
<A>P</A>, say, for a subgroup <A>H</A> of a finitely presented group
<A>G</A>.
The generators in the resulting presentation will be named
<A>string</A><C>1</C>, <A>string</A><C>2</C>, <M>\ldots</M>,
the default string is <C>"_x"</C>.
You may access the <M>i</M>-th of these generators by
<A>P</A><C>!.</C><M>i</M>.
<P/>
Alternatively to the subgroup <A>H</A>,
its coset table <A>table</A> in <A>G</A> may be given as second argument.
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );;
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
gap> g1 := Size( g );
60
gap> u := Subgroup( g, [ g.1, g.1^g.2 ] );
Group([ a, b^-1*a*b ])
gap> p := PresentationSubgroup( g, u, "g" );
<presentation with 3 gens and 4 rels of total length 12>
gap> gens := GeneratorsOfPresentation( p );
[ g1, g2, g3 ]
gap> TzPrintRelators( p );
#I  1. g1^2
#I  2. g2^2
#I  3. g3*g2*g1
#I  4. g3^5
]]></Example>
<P/>
Note that you cannot call the generators by their names. These names are
not variables, but just display figures. So, if you want to access the
generators by their names, you first will have to introduce the respective
variables and to assign the generators to them.
<P/>
<Example><![CDATA[
gap> gens[1] = g1;
false
gap> g1;
60
gap> g1 := gens[1];; g2 := gens[2];; g3 := gens[3];;
gap> g1;
g1
]]></Example>
<P/>
The Reduced Reidemeister-Schreier algorithm is a modification of the
Reidemeister-Schreier algorithm of George Havas <Cite Key="Hav74b"/>.
It was proposed by Joachim Neubüser and first implemented in 1986 by
Andrea Lucchini and Volkmar Felsch in the SPAS system
<Cite Key="Spa89"/>.
Like the Reidemeister-Schreier algorithm of George Havas, it needs only
the presentation of <A>G</A> and a coset table of <A>H</A> in <A>G</A>
to construct a presentation of <A>H</A>.
<P/>
Whenever you call the command <Ref Func="PresentationSubgroupRrs"
Label="for a group and a coset table (and a string)"/>,
it first obtains a coset table of <A>H</A> in <A>G</A> if not given.
Next, a set of generators of <A>H</A> is determined by reconstructing the
coset table and introducing in that process as many Schreier generators
of <A>H</A> in <A>G</A> as are needed to do a Felsch strategy coset
enumeration without any coincidences.
(In general, though containing redundant generators, this set will be
much smaller than the set of all Schreier generators.
That is why we call the method the <E>Reduced</E> Reidemeister-Schreier.)
<P/>
After having constructed this set of <E>primary subgroup generators</E>,
say, the coset table is extended to an <E>augmented coset table</E> which
describes the action of the group generators on coset representatives,
i.e., on elements instead of cosets.
For this purpose, suitable words in the (primary) subgroup generators
have to be associated to the coset table entries.
In order to keep the lengths of these words short, additional
<E>secondary subgroup generators</E> are introduced as abbreviations of
subwords. Their number may be large.
<P/>
Finally, a Reidemeister rewriting process is used to get defining
relators for <A>H</A> from the relators of <A>G</A>.
As the resulting presentation of <A>H</A> is a presentation on primary
<E>and</E> secondary generators, in general you will have to simplify it
by appropriate Tietze transformations
(see <Ref Sect="Tietze Transformations"/>) or by the command
<Ref Func="DecodeTree"/> before you can use it. Therefore it is
returned in the form of a presentation, <A>P</A> say.
<P/>
Compared with the Modified Todd-Coxeter method described below, the
Reduced Reidemeister-Schreier method (as well as Havas' original
Reidemeister-Schreier program) has the advantage that it does not require
generators of <A>H</A> to be given if a coset table of <A>H</A> in
<A>G</A> is known.
This provides a possibility to compute a presentation of the normal
closure of a given subgroup
(see <Ref Func="PresentationNormalClosureRrs"/>).
<P/>
For certain applications you may be interested in getting not only just a
presentation for <A>H</A>, but also a relation between the involved
generators of <A>H</A> and the generators of <A>G</A>.
The subgroup generators in the presentation
are sorted such that the primary generators precede the secondary ones.
Moreover, for each secondary subgroup generator there is a relator in the
presentation which expresses this generator as a word in preceding ones.
Hence, all we need in addition is a list of words in the generators of
<A>G</A> which express the primary subgroup generators.
In fact, such a list is provided in the attribute
<Ref Func="PrimaryGeneratorWords"/> of the resulting presentation.
</Description>
</ManSection>

<ManSection>
<Attr Name="PrimaryGeneratorWords" Arg='P'/>

<Description>
is an attribute of the presentation <A>P</A> which holds a list of words
in the associated group generators (of the underlying free group) which
express the primary subgroup generators of <A>P</A>.
<Example><![CDATA[
gap> PrimaryGeneratorWords( p );
[ a, b^-1*a*b ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PresentationSubgroupMtc" Arg='G, H[, string][, print level]'/>

<Description>
uses the Modified Todd-Coxeter coset representative enumeration method
to compute a presentation <M>P</M>, say, for a subgroup <A>H</A> of a
finitely presented group <A>G</A>.
The presentation returned is in generators corresponding to the
generators of <A>H</A>. The generators in the resulting
presentation will be named <A>string</A><C>1</C>, <A>string</A><C>2</C>,
<M>\ldots</M>, the default string is <C>"_x"</C>.
You may access the <M>i</M>-th of these generators by
<M>P</M><C>!.</C><M>i</M>.
<P/>
The default print level is <M>1</M>.
If the print level is set to <M>0</M>, then the printout of the
implicitly called function <Ref Func="DecodeTree"/> will be suppressed.
<Example><![CDATA[
gap> p := PresentationSubgroupMtc( g, u );
#I  there are 3 generators and 4 relators of total length 12
#I  there are 2 generators and 3 relators of total length 14
<presentation with 2 gens and 3 rels of total length 14>
]]></Example>
<P/>
The so called Modified Todd-Coxeter method was proposed, in slightly
different forms, by Nathan S.&nbsp;Mendelsohn and
William O.&nbsp;J.&nbsp;Moser in 1966.
Moser's method was proved in <Cite Key="BC76"/>.
It has been generalized to cover a broad spectrum of different versions
(see the survey <Cite Key="Neu82"/>).
<P/>
The <E>Modified Todd-Coxeter</E> method performs an enumeration of coset
representatives. It proceeds like an ordinary coset enumeration (see
<Ref Sect="Coset Tables and Coset Enumeration"/>),
but as the product of a coset
representative by a group generator or its inverse need not be a coset
representative itself, the Modified Todd-Coxeter has to store a kind of
correction element for each coset table entry. Hence it builds up a so
called <E>augmented coset table</E> of <A>H</A> in <A>G</A> consisting of
the ordinary coset table and a second table in parallel which contains
the associated subgroup elements.
<P/>
Theoretically, these subgroup elements could be expressed as words in the
given generators of <A>H</A>, but in general these words tend to become
unmanageable because of their enormous lengths. Therefore, a highly
redundant list of subgroup generators is built up starting from the given
(<Q>primary</Q>) generators of <A>H</A> and adding additional
(<Q>secondary</Q>) generators which are defined as abbreviations of
suitable words of length two in the preceding generators such that each
of the subgroup elements in the augmented coset table can be expressed as
a word of length at most one in the resulting
(primary <E>and</E> secondary) subgroup generators.
<P/>
Then a rewriting process (which is essentially a kind of Reidemeister
rewriting process) is used to get relators for <A>H</A> from the defining
relators of <A>G</A>.
<P/>
The resulting presentation involves all the primary, but not all the
secondary generators of <A>H</A>.
In fact, it contains only those secondary generators which explicitly
occur in the augmented coset table.
If we extended this presentation by those secondary generators which are
not yet contained in it as additional generators, and by the definitions
of all secondary generators as additional relators, we would get a
presentation of <A>H</A>, but, in general,
we would end up with a large number of generators and relators.
<P/>
On the other hand, if we avoid this extension, the current presentation
will not necessarily define <A>H</A> although we have used the same
rewriting process which in the case of the
<Ref Func="PresentationSubgroupRrs"
Label="for a group and a coset table (and a string)"/> command computes
a defining set of relators for <A>H</A> from an augmented coset table
and defining relators of <A>G</A>.
The different behaviour here is caused by the fact that coincidences may
have occurred in the Modified Todd-Coxeter coset enumeration.
<P/>
To overcome this problem without extending the presentation by all
secondary generators, the <Ref Func="PresentationSubgroupMtc"/> command
applies the so called <E>decoding tree</E> algorithm which provides a
more economical approach.
The reader is strongly recommended to carefully read section
<Ref Sect="sect:DecodeTree"/> where this algorithm is described in more
detail.
Here we will only mention that this procedure may add a lot of
intermediate generators and relators (and even change the isomorphism
type) in a process which in fact eliminates all
secondary generators from the presentation and hence finally provides
a presentation of <A>H</A> on the primary, i.e., the originally given,
generators of <A>H</A>. This is a remarkable advantage of the command
<Ref Func="PresentationSubgroupMtc"/> compared to the command
<Ref Func="PresentationSubgroupRrs"
Label="for a group and a coset table (and a string)"/>.
But note that, for some particular subgroup <A>H</A>, the Reduced
Reidemeister-Schreier method might quite well produce a more concise
presentation.
<P/>
The resulting presentation is returned in the form of a presentation,
<M>P</M> say.
<P/>
As the function <Ref Func="PresentationSubgroupRrs"
Label="for a group and a coset table (and a string)"/> described above
(see there for details),
the function <Ref Func="PresentationSubgroupMtc"/> returns a list of the
primary subgroup generators of <A>H</A> in the attribute
<Ref Func="PrimaryGeneratorWords"/> of <M>P</M>.
In fact, this list is not very exciting here
because it is just a shallow copy of the value of
<Ref Func="GeneratorsOfPresentation"/> of <A>H</A>, however it is
needed to guarantee a certain consistency between the results of the
different functions for computing subgroup presentations.
<P/>
Though the decoding tree routine already involves a lot of Tietze
transformations, we recommend that you try to further simplify the
resulting presentation by appropriate Tietze transformations
(see <Ref Sect="Tietze Transformations"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="PresentationNormalClosureRrs" Arg='G, H[, string]'/>

<Description>
uses the Reduced Reidemeister-Schreier method to compute a presentation
<M>P</M>, say, for the normal closure of a subgroup <A>H</A> of a
finitely presented group <A>G</A>.
The generators in the resulting presentation will be named
<A>string</A><C>1</C>, <A>string</A><C>2</C>, <M>\ldots</M>,
the default string is <C>"_x"</C>.
You may access the <M>i</M>-th of these generators by
<M>P</M><C>!.</C><M>i</M>. 
</Description>
</ManSection>

<ManSection>
<Func Name="PresentationNormalClosure" Arg='G,H[,string]'/>

<Description>
<Ref Func="PresentationNormalClosure"/> is a synonym for
<Ref Func="PresentationNormalClosureRrs"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Relators in a Presentation">
<Heading>Relators in a Presentation</Heading>

In order to speed up the Tietze transformation routines,
each relator in a presentation is internally represented by a
list of positive or negative generator numbers, i.e., each factor of the
proper &GAP; word is represented by the position number of the
corresponding generator with respect to the current list of generators,
or by the respective negative number, if the factor is the inverse of a
generator. Note that the numbering of the generators in Tietze words is
always relative to a generator list and bears no relation to the internal
numbering of generators in a family of associative words.

<ManSection>
<Func Name="TietzeWordAbstractWord" Arg='word, fgens'/>

<Description>
assumes <A>fgens</A> to be a list of free group generators
and <A>word</A> to be an abstract word in these generators.
It converts <A>word</A> into a Tietze word,
i. e., a list of positive or negative generator numbers.
<P/>
This function simply calls <Ref Func="LetterRepAssocWord"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="AbstractWordTietzeWord" Arg='word, fgens'/>

<Description>
assumes  <A>fgens</A>  to be  a list  of  free group
generators and  <A>word</A> to be a Tietze word in these generators,
i. e., a list of positive or negative generator numbers.
It converts <A>word</A> to an abstract word.
<P/>
This function simply calls <Ref Func="AssocWordByLetterRep"/>.
<Example><![CDATA[
gap> F := FreeGroup( "a", "b", "c" ,"d");
<free group on the generators [ a, b, c, d ]>
gap> tzword := TietzeWordAbstractWord(
> Comm(F.4,F.2) * (F.3^2 * F.2)^-1, GeneratorsOfGroup( F ){[2,3,4]} );
[ -3, -1, 3, -2, -2 ]
gap> AbstractWordTietzeWord( tzword, GeneratorsOfGroup( F ){[2,3,4]} );
d^-1*b^-1*d*c^-2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Printing Presentations">
<Heading>Printing Presentations</Heading>

Whenever you create a presentation <M>P</M>, say, or assign it to a variable,
&GAP; will respond by printing <M>P</M>.
However, as <M>P</M> may contain a lot of generators and many relators
of large length, it would be annoying if the standard print facilities
displayed all this information in detail.
So they restrict the printout to just one line of text containing the number
of generators, the number of relators, and the total length of all relators
of <M>P</M>. As compensation, &GAP; offers some special print commands which
display various details of a presentation.

Note that there is also a function <Ref Func="TzPrintOptions"/>.
It is described in Section <Ref Sect="Tietze Options"/>.

<ManSection>
<Func Name="TzPrintGenerators" Arg='P[, list]'/>

<Description>
prints the generators of the given Tietze presentation <A>P</A> together
with the number of their occurrences in the relators. The optional second
argument can be used to specify the numbers of the generators to be
printed. Default: all generators are printed.
<Example><![CDATA[
gap> G := Group( [ (1,2,3,4,5), (2,3,5,4), (1,6)(3,4) ], () );
Group([ (1,2,3,4,5), (2,3,5,4), (1,6)(3,4) ])
gap> P := PresentationViaCosetTable( G );
<presentation with 3 gens and 6 rels of total length 28>
gap> TzPrintGenerators( P );
#I  1.  f1   11 occurrences
#I  2.  f2   10 occurrences
#I  3.  f3   7 occurrences   involution
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintRelators" Arg='P[, list]'/>

<Description>
prints the relators of the given  Tietze presentation <A>P</A>.
The optional second argument <A>list</A> can be used to specify the
numbers of the relators to be printed.
Default: all relators are printed.
<Example><![CDATA[
gap> TzPrintRelators( P );
#I  1. f3^2
#I  2. f2^4
#I  3. (f2^-1*f3)^2
#I  4. f1^5
#I  5. f1^2*f2*f1*f2^-1
#I  6. f1^-1*f3*f1*f3*f1^-1*f2^2*f3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintLengths" Arg='P'/>

<Description>
prints just a list of all relator lengths of the given presentation
<A>P</A>.
<Example><![CDATA[
gap> TzPrintLengths( P );
[ 2, 4, 4, 5, 5, 8 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintStatus" Arg='P[, norepeat]'/>

<Description>
is an internal function which is used by the Tietze transformation
routines to print the number of generators, the number of relators,
and the total length of all relators in the given Tietze presentation
<A>P</A>.
If <A>norepeat</A> is specified as <K>true</K>, the printing is
suppressed if none of the three values has changed since the last call.
<Example><![CDATA[
gap> TzPrintStatus( P );
#I  there are 3 generators and 6 relators of total length 28
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintPresentation" Arg='P'/>

<Description>
prints the generators and the relators of a Tietze presentation.
In fact, it is an abbreviation for the successive call of the three
commands <Ref Func="TzPrintGenerators"/>,
<Ref Func="TzPrintRelators"/>, and <Ref Func="TzPrintStatus"/>,
each with the presentation <A>P</A> as only argument.
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrint" Arg='P[, list]'/>

<Description>
prints the current generators of the given presentation <A>P</A>,
and prints the relators of <A>P</A> as Tietze words (without converting
them back to abstract words as the functions
<Ref Func="TzPrintRelators"/> and <Ref Func="TzPrintPresentation"/> do).
The optional second argument can be used to specify the numbers of the
relators to be printed.
Default: all relators are printed.
<Example><![CDATA[
gap> TzPrint( P );
#I  generators: [ f1, f2, f3 ]
#I  relators:
#I  1.  2  [ 3, 3 ]
#I  2.  4  [ 2, 2, 2, 2 ]
#I  3.  4  [ -2, 3, -2, 3 ]
#I  4.  5  [ 1, 1, 1, 1, 1 ]
#I  5.  5  [ 1, 1, 2, 1, -2 ]
#I  6.  8  [ -1, 3, 1, 3, -1, 2, 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintPairs" Arg='P [,n]'/>

<Description>
prints the <A>n</A> most often occurring relator subwords of the form
<M>a b</M>,
where <M>a</M> and <M>b</M> are different generators or inverses of
generators, together with the number of their occurrences. The default
value of <A>n</A> is 10.
A value <A>n</A> = 0 is interpreted as <Ref Var="infinity"/>.
<P/>
The function <Ref Func="TzPrintPairs"/> is useful in the context of
Tietze transformations which introduce new generators by substituting
words in the current generators
(see <Ref Sect="Tietze Transformations that introduce new Generators"/>).
It gives some evidence for an appropriate choice of
a word of length 2 to be substituted.
<Example><![CDATA[
gap> TzPrintPairs( P, 3 );
#I  1.  3  occurrences of  f2 * f3
#I  2.  2  occurrences of  f2^-1 * f3
#I  3.  2  occurrences of  f1 * f3
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changing Presentations">
<Heading>Changing Presentations</Heading>

The functions described in this section may be used to change a presentation.
Note, however, that in general they do not perform Tietze transformations
because they change or may change the isomorphism type of the group defined
by the presentation.

<ManSection>
<Func Name="AddGenerator" Arg='P'/>

<Description>
extends the presentation <A>P</A> by a new generator.
<P/>
Let <M>i</M> be the smallest positive integer which has not yet been used
as a generator number in the given presentation.
<Ref Func="AddGenerator"/> defines a new abstract generator <M>x_i</M>
with the name <C>"_x</C><M>i</M><C>"</C> and adds it to the
list of generators of <A>P</A>.
<P/>
You may access the generator <M>x_i</M> by typing
<A>P</A><C>!.</C><M>i</M>. However, this
is only practicable if you are running an interactive job because you
have to know the value of <M>i</M>. Hence the proper way to access the new
generator is to write
<C>GeneratorsOfPresentation(P)[Length(GeneratorsOfPresentation(P))]</C>.
<Example><![CDATA[
gap> G := PerfectGroup( 120 );;
gap> H := Subgroup( G, [ G.1^G.2, G.3 ] );;
gap> P := PresentationSubgroup( G, H );
<presentation with 4 gens and 7 rels of total length 21>
gap> AddGenerator( P );
#I  now the presentation has 5 generators, the new generator is _x7
gap> gens := GeneratorsOfPresentation( P );
[ _x1, _x2, _x4, _x5, _x7 ]
gap> gen := gens[Length( gens )];
_x7
gap> gen = P!.7;
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzNewGenerator" Arg='P'/>

<Description>
is an internal function which defines a new abstract generator and
adds it to the presentation <A>P</A>.
It is called by <Ref Func="AddGenerator"/> and
by several Tietze transformation commands. As it does not know which
global lists have to be kept consistent, you should not call it.
Instead, you should call the function <Ref Func="AddGenerator"/>,
if needed.
</Description>
</ManSection>

<ManSection>
<Func Name="AddRelator" Arg='P, word'/>

<Description>
adds the relator <A>word</A> to the presentation <A>P</A>, probably
changing the group defined by <A>P</A>.
<A>word</A> must be an abstract word in the generators of <A>P</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="RemoveRelator" Arg='P, n'/>

<Description>
removes the <A>n</A>-th relator from the presentation <A>P</A>,
probably changing the group defined by <A>P</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tietze Transformations">
<Heading>Tietze Transformations</Heading>

The commands in this section can be used to modify a presentation by Tietze
transformations.
<P/>
In general, the aim of such modifications will be to <E>simplify</E> the given
presentation, i.e., to reduce the number of generators and the number of
relators without increasing too much the sum of all relator lengths which
we will call the <E>total length</E> of the presentation. Depending on the
concrete presentation under investigation one may end up with a nice,
short presentation or with a very huge one.
<P/>
Unfortunately there is no algorithm which could be applied to find the
shortest presentation which can be obtained by Tietze transformations
from a given one. Therefore, what &GAP; offers are some lower-level
Tietze transformation commands and, in addition, some higher-level
commands which apply the lower-level ones in a kind of default strategy
which of course cannot be the optimal choice for all presentations.
<P/>
The design of these commands follows closely the concept of the ANU
Tietze transformation program <Cite Key="Hav69"/> and its
later revisions (see <Cite Key="HKRR84"/>, <Cite Key="Rob88"/>).

<ManSection>
<Func Name="TzGo" Arg='P[, silent]'/>

<Description>
automatically performs suitable Tietze transformations of the given
presentation <A>P</A>. It is perhaps the most convenient one among the
interactive Tietze transformation commands. It offers a kind of default
strategy which, in general, saves you from explicitly calling the
lower-level commands it involves.
<P/>
If <A>silent</A> is specified as <K>true</K>,
the printing of the status line by <Ref Func="TzGo"/> is suppressed
if the Tietze option <C>printLevel</C>
(see <Ref Sect="Tietze Options"/>) has a value less than <M>2</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="SimplifyPresentation" Arg='P'/>

<Description>
<Ref Func="SimplifyPresentation"/> is a synonym for <Ref Func="TzGo"/>.
<Example><![CDATA[
gap> F2 := FreeGroup( "a", "b" );;
gap> G := F2 / [ F2.1^9, F2.2^2, (F2.1*F2.2)^4, (F2.1^2*F2.2)^3 ];;
gap> a := G.1;; b := G.2;;
gap> H := Subgroup( G, [ (a*b)^2, (a^-1*b)^2 ] );;
gap> Index( G, H );
408
gap> P := PresentationSubgroup( G, H );
<presentation with 8 gens and 36 rels of total length 111>
gap> PrimaryGeneratorWords( P );
[ b, a*b*a ]
gap> TzOptions( P ).protected := 2;
2
gap> TzOptions( P ).printLevel := 2;
2
gap> SimplifyPresentation( P );
#I  eliminating _x7 = _x5^-1
#I  eliminating _x5 = _x4
#I  eliminating _x18 = _x3
#I  eliminating _x8 = _x3
#I  there are 4 generators and 8 relators of total length 21
#I  there are 4 generators and 7 relators of total length 18
#I  eliminating _x4 = _x3^-1*_x2^-1
#I  eliminating _x3 = _x2*_x1^-1
#I  there are 2 generators and 4 relators of total length 14
#I  there are 2 generators and 4 relators of total length 13
#I  there are 2 generators and 3 relators of total length 9
gap> TzPrintRelators( P );
#I  1. _x1^2
#I  2. _x2^3
#I  3. (_x2*_x1)^2
]]></Example>
<P/>
Roughly speaking, <Ref Func="TzGo"/> consists of a loop over a
procedure which involves two phases: In the <E>search phase</E> it calls
<Ref Func="TzSearch"/> and <Ref Func="TzSearchEqual"/> described below
which try to reduce the relator lengths by substituting common subwords
of relators, in the <E>elimination phase</E> it calls the command
<Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
described below (or, more precisely, a subroutine of
<Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
in order to save some administrative overhead) which tries to eliminate
generators that can be expressed as words in the remaining generators.
<P/>
If <Ref Func="TzGo"/> succeeds in reducing the number of generators,
the number of relators, or the total length of all relators, it
displays the new status before returning (provided that you did not set
the print level to zero). However, it does not provide any output if all
these three values have remained unchanged, even if the command
<Ref Func="TzSearchEqual"/> involved has changed the presentation
such that another call of <Ref Func="TzGo"/> might provide further
progress.
Hence, in such a case it makes sense to repeat the call of the command
for several times (or to call the command <Ref Func="TzGoGo"/> instead).
</Description>
</ManSection>

<ManSection>
<Func Name="TzGoGo" Arg='P'/>

<Description>
calls the command <Ref Func="TzGo"/> again and again until it does not
reduce the presentation any more.
<P/>
The result of the Tietze transformations can be affected substantially by
the options parameters (see <Ref Sect="Tietze Options"/>).
To demonstrate the effect of the <C>eliminationsLimit</C> parameter,
we will give an example in which we handle a subgroup of index 240 in a
group of order 40320 given by a presentation due to B.&nbsp;H. Neumann.
First we construct a presentation of the subgroup, and then we apply to
it the command <Ref Func="TzGoGo"/> for different
values of the parameter <C>eliminationsLimit</C>
(including the default value 100). In fact, we also alter the
<C>printLevel</C> parameter, but this is only done in order to suppress
most of the output.  In all cases the resulting presentations cannot be
improved any more by applying the command <Ref Func="TzGoGo"/> again,
i.e., they are the best results which we can get without substituting new
generators.
<P/>
<Example><![CDATA[
gap> F3 := FreeGroup( "a", "b", "c" );;
gap> G := F3 / [ F3.1^3, F3.2^3, F3.3^3, (F3.1*F3.2)^5,
> (F3.1^-1*F3.2)^5, (F3.1*F3.3)^4, (F3.1*F3.3^-1)^4,
> F3.1*F3.2^-1*F3.1*F3.2*F3.3^-1*F3.1*F3.3*F3.1*F3.3^-1,
> (F3.2*F3.3)^3, (F3.2^-1*F3.3)^4 ];;
gap> a := G.1;; b := G.2;; c := G.3;;
gap> H := Subgroup( G, [ a, c ] );;
gap> for i in [ 61, 62, 63, 90, 97 ] do
> Pi := PresentationSubgroup( G, H );
> TzOptions( Pi ).eliminationsLimit := i;
> Print("#I eliminationsLimit set to ",i,"\n");
> TzOptions( Pi ).printLevel := 0;
> TzGoGo( Pi );
> TzPrintStatus( Pi );
> od;
#I eliminationsLimit set to 61
#I  there are 2 generators and 104 relators of total length 7012
#I eliminationsLimit set to 62
#I  there are 2 generators and 7 relators of total length 56
#I eliminationsLimit set to 63
#I  there are 3 generators and 97 relators of total length 5998
#I eliminationsLimit set to 90
#I  there are 3 generators and 11 relators of total length 68
#I eliminationsLimit set to 97
#I  there are 4 generators and 109 relators of total length 3813
]]></Example>
<P/>
Similarly, we demonstrate the influence of the <C>saveLimit</C> parameter
by just continuing the preceding example for some different values of the
<C>saveLimit</C> parameter (including its default value 10), but without
changing the <C>eliminationsLimit</C> parameter which keeps its default
value 100.
<P/>
<Example><![CDATA[
gap> for i in [ 7 .. 11 ] do
> Pi := PresentationSubgroup( G, H );
> TzOptions( Pi ).saveLimit := i;
> Print( "#I saveLimit set to ", i, "\n" );
> TzOptions( Pi ).printLevel := 0;
> TzGoGo( Pi );
> TzPrintStatus( Pi );
> od;
#I saveLimit set to 7
#I  there are 3 generators and 99 relators of total length 2713
#I saveLimit set to 8
#I  there are 2 generators and 103 relators of total length 11982
#I saveLimit set to 9
#I  there are 2 generators and 6 relators of total length 41
#I saveLimit set to 10
#I  there are 3 generators and 118 relators of total length 13713
#I saveLimit set to 11
#I  there are 3 generators and 11 relators of total length 58
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elementary Tietze Transformations">
<Heading>Elementary Tietze Transformations</Heading>

<ManSection>
<Heading>TzEliminate</Heading>
<Func Name="TzEliminate" Arg='P[, gen]'
 Label="for a presentation (and a generator)"/>
<Func Name="TzEliminate" Arg='P[, n]'
 Label="for a presentation (and an integer)"/>

<Description>
tries to eliminate a generator from a presentation <A>P</A> via
Tietze transformations.
<P/>
Any relator which contains some generator just once can be used to
substitute that generator by a word in the remaining generators.
If such generators and relators exist, then
<Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
chooses a generator for which the product of its number of occurrences
and the length of the substituting word is minimal,
and then it eliminates this generator from the presentation,
provided that the resulting total length of the relators does not exceed
the associated Tietze option parameter <C>spaceLimit</C>
(see <Ref Sect="Tietze Options"/>). The default value of that parameter
is <Ref Var="infinity"/>, but you may alter it appropriately.
<P/>
If a generator <A>gen</A> has been specified,
<Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
eliminates it if possible, i. e. if there is a relator in which
<A>gen</A> occurs just once.
If no second argument has been specified,
<Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
eliminates some appropriate generator if possible and if the resulting
total length of the relators will not exceed the Tietze options parameter
<C>lengthLimit</C>.
<P/>
If an integer <A>n</A> has been specified,
<Ref Func="TzEliminate" Label="for a presentation (and an integer)"/>
tries to eliminate up to <A>n</A> generators.
Note that the calls <C>TzEliminate(<A>P</A>)</C> and
<C>TzEliminate(<A>P</A>,1)</C> are equivalent.
</Description>
</ManSection>

<ManSection>
<Func Name="TzSearch" Arg='P'/>

<Description>
searches for relator subwords which, in some relator, have a complement
of shorter length and which occur in other relators, too, and uses them
to reduce these other relators.
<P/>
The idea is to find pairs of relators <M>r_1</M> and <M>r_2</M> of length
<M>l_1</M> and <M>l_2</M>, respectively,
such that <M>l_1 \leq l_2</M> and <M>r_1</M> and <M>r_2</M>
coincide (possibly after inverting or conjugating one of them) in some
maximal subword <M>w</M>, say, of length greater than <M>l_1/2</M>,
and then to substitute each copy of <M>w</M> in <M>r_2</M> by the inverse
complement of <M>w</M> in <M>r_1</M>.
<P/>
Two of the Tietze option parameters which are listed in section
<Ref Sect="Tietze Options"/> may strongly influence the performance and
the results of the command <Ref Func="TzSearch"/>.
These are the parameters <C>saveLimit</C> and <C>searchSimultaneous</C>.
The first of them has the following effect:
<P/>
When <Ref Func="TzSearch"/> has finished its main loop over all relators,
then, in general, there are relators which have changed and hence should
be handled again in another run through the whole procedure. However,
experience shows that it really does not pay to continue this way until
no more relators change.
Therefore, <Ref Func="TzSearch"/> starts a new loop only if
the loop just finished has reduced the total length of the relators by at
least <C>saveLimit</C> per cent.
<P/>
The default value of <C>saveLimit</C> is 10 per cent.
<P/>
To understand the effect of the option <C>searchSimultaneous</C>, we
have to look in more detail at how <Ref Func="TzSearch"/> proceeds:
<P/>
First, it sorts the list of relators by increasing lengths. Then it
performs a loop over this list. In each step of this loop, the current
relator is treated as <E>short relator</E> <M>r_1</M>, and a subroutine
is called which loops over the succeeding relators,
treating them as <E>long relators</E> <M>r_2</M> and performing the
respective comparisons and substitutions.
<P/>
As this subroutine performs a very expensive process, it has been
implemented as a C routine in the &GAP; kernel. For the given relator
<M>r_1</M> of length <M>l_1</M>, say, it first determines the
<E>minimal match length</E> <M>l</M> which is <M>l_1/2+1</M>,
if <M>l_1</M> is even, or <M>(l_1+1)/2</M>, otherwise.
Then it builds up a hash list for all subwords of length <M>l</M>
occurring in the conjugates of <M>r_1</M> or <M>r_1^{{-1}}</M>,
and finally it loops
over all long relators <M>r_2</M> and compares the hash values of their
subwords of length <M>l</M> against this list.
A comparison of subwords which is much more expensive is only done if a
hash match has been found.
<P/>
To improve the efficiency of this process we allow the subroutine to
handle several short relators simultaneously provided that they have the
same minimal match length.  If, for example, it handles <M>n</M> short
relators simultaneously, then you save <M>n - 1</M> loops over the long
relators <M>r_2</M>, but you pay for it by additional fruitless subword
comparisons. In general, you will not get the best performance by always
choosing the maximal possible number of short relators to be handled
simultaneously. In fact, the optimal choice of the number will depend on
the concrete presentation under investigation. You can use the parameter
<C>searchSimultaneous</C> to prescribe an upper bound for the number of
short relators to be handled simultaneously.
<P/>
The default value of <C>searchSimultaneous</C> is 20.
</Description>
</ManSection>

<ManSection>
<Func Name="TzSearchEqual" Arg='P'/>

<Description>
searches for Tietze relator subwords which, in some relator, have a
complement of equal length and which occur in other relators, too, and
uses them to modify these other relators.
<P/>
The idea is to find pairs of relators <M>r_1</M> and <M>r_2</M> of length
<M>l_1</M> and <M>l_2</M>, respectively, such that <M>l_1</M> is even,
<M>l_1 \leq l_2</M>, and <M>r_1</M> and <M>r_2</M> coincide (possibly 
after inverting or conjugating one of them) in some maximal subword
<M>w</M>, say, of length at least <M>l_1/2</M>.
Let <M>l</M> be the length of <M>w</M>. Then, if <M>l > l_1/2</M>,
the pair is handled as in <Ref Func="TzSearch"/>.
Otherwise, if <M>l = l_1/2</M>, then <Ref Func="TzSearchEqual"/>
substitutes each copy of <M>w</M> in <M>r_2</M> by the inverse complement
of <M>w</M> in <M>r_1</M>.
<P/>
The Tietze option parameter <C>searchSimultaneous</C> is used by
<Ref Func="TzSearchEqual"/> in the same way as described for
<Ref Func="TzSearch"/>. However, <Ref Func="TzSearchEqual"/> does
not use the parameter <C>saveLimit</C>:
The loop over the relators is executed exactly once.
</Description>
</ManSection>

<ManSection>
<Func Name="TzFindCyclicJoins" Arg='P'/>

<Description>
searches for  power and commutator relators in order
to find  pairs of generators  which  generate a  common  cyclic subgroup.
It uses these pairs to introduce new relators,  but it does not introduce
any new generators as is done by <Ref Func="TzSubstituteCyclicJoins"/>.
<P/>
More precisely:
<Ref Func="TzFindCyclicJoins"/> searches for pairs of generators <M>a</M>
and <M>b</M> such that (possibly after inverting or conjugating some
relators) the set of relators contains the commutator <M>[a,b]</M>,
a power <M>a^n</M>, and a product of the form <M>a^s b^t</M>
with <M>s</M> prime to <M>n</M>.
For each such pair, <Ref Func="TzFindCyclicJoins"/> uses the
Euclidean algorithm to express <M>a</M> as a power of <M>b</M>,
and then it eliminates <M>a</M>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tietze Transformations that introduce new Generators">
<Heading>Tietze Transformations that introduce new Generators</Heading>

Some of the Tietze transformation commands listed so far may eliminate
generators and hence change the given presentation to a presentation on a
subset of the given set of generators, but they all do <E>not</E> introduce
new generators. However, sometimes there will be the need to substitute
certain words as new generators in order to improve a presentation.
Therefore &GAP; offers the two commands
<Ref Func="TzSubstitute" Label="for a presentation and a word"/> and
<Ref Func="TzSubstituteCyclicJoins"/> which introduce new generators.

<ManSection>
<Heading>TzSubstitute</Heading>
<Func Name="TzSubstitute" Arg='P, word'
 Label="for a presentation and a word"/>
<Func Name="TzSubstitute" Arg='P[, n[, eliminate]]'
 Label="for a presentation (and an integer and 0/1/2)"/>

<Description>
In the first form
<Ref Func="TzSubstitute" Label="for a presentation and a word"/> expects
<A>P</A> to be a presentation and <A>word</A> to be either an abstract
word or a Tietze word in the generators of <A>P</A>.
It substitutes the given word as a new generator of <A>P</A>.
This is done as follows:
First, <Ref Func="TzSubstitute" Label="for a presentation and a word"/>
creates a new abstract generator, <M>g</M> say, and adds it to the
presentation, then it adds a new relator
<M>g^{{-1}} \cdot <A>word</A></M>.
<P/>
In its second form,
<Ref Func="TzSubstitute" Label="for a presentation (and an integer and 0/1/2)"/>
substitutes a squarefree word of length 2 as a new generator and then
eliminates a generator from the extended generator list.
We will describe this process in more detail below.
<P/>
The parameters <A>n</A> and <A>eliminate</A> are optional.
If you specify arguments for them, then <A>n</A> is expected to be a
positive integer, and <A>eliminate</A> is expected to be 0, 1, or 2.
The default values are <A>n</A> <M>= 1</M> and
<A>eliminate</A> <M>= 0</M>.
<P/>
<Ref Func="TzSubstitute" Label="for a presentation (and an integer and 0/1/2)"/>
first determines the <A>n</A> most frequently occurring
relator subwords of the form <M>g_1 g_2</M>,
where <M>g_1</M> and <M>g_2</M> are different generators or their
inverses, and sorts them by decreasing numbers of occurrences.
<P/>
Let <M>a b</M> be the last word in that list, and let <M>i</M> be the
smallest positive integer which has not yet been used as a generator
number in the presentation <A>P</A> so far.
<Ref Func="TzSubstitute" Label="for a presentation (and an integer and 0/1/2)"/>
defines a new abstract generator <M>x_i</M> named <C>"_x<A>i</A>"</C> and
adds it to <A>P</A> (see <Ref Func="AddGenerator"/>).
Then it adds the word <M>x_i^{{-1}} a b</M> as a new relator to <A>P</A>
and replaces all occurrences of <M>a b</M> in the relators by <M>x_i</M>.
Finally, it eliminates some suitable generator from <A>P</A>.
<P/>
The choice of the generator to be eliminated depends on the actual
value of the parameter <A>eliminate</A>:
<P/>
If <A>eliminate</A> is zero,
<Ref Func="TzSubstitute" Label="for a presentation (and an integer and 0/1/2)"/>
just calls the function
<Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>.
So it may happen that it is the just introduced generator <M>x_i</M>
which now is deleted again so that you don't get any
remarkable progress in simplifying your presentation.
On the first glance this does not look reasonable,
but it is a consequence of the request that a call of
<Ref Func="TzSubstitute" Label="for a presentation (and an integer and 0/1/2)"/>
with <A>eliminate</A> = 0 must not increase the total length of the
relators.
<P/>
Otherwise, if <A>eliminate</A> is 1 or 2,
<Ref Func="TzSubstitute" Label="for a presentation (and an integer and 0/1/2)"/>
eliminates the respective factor of the substituted word <M>a b</M>,
i. e., it eliminates <M>a</M> if <A>eliminate</A> = 1 or <M>b</M> if
<A>eliminate</A> = 2.
In this case, it may happen that the total length of the relators
increases, but sometimes such an intermediate extension is the only way
to finally reduce a given presentation.
<P/>
There is still another property of the command
<Ref Func="TzSubstitute" Label="for a presentation and a word"/> which
should be mentioned.
If, for instance, <C>word</C> is an abstract word, a call
<P/>
<Log><![CDATA[
TzSubstitute( P, word );
]]></Log>
<P/>
is more or less equivalent to
<P/>
<Log><![CDATA[
AddGenerator( P );
g := GeneratorsOfPresentation(P)[Length(GeneratorsOfPresentation(P))];
AddRelator( P, g^-1 * word );
]]></Log>
<P/>
However, there is a difference: If you are tracing generator images and
preimages of <A>P</A> through the Tietze transformations applied to
<A>P</A> (see
<Ref Sect="Tracing generator images through Tietze transformations"/>),
then <Ref Func="TzSubstitute" Label="for a presentation and a word"/>,
as a Tietze transformation of <A>P</A>, will update and save the
respective lists, whereas a call of the function
<Ref Func="AddGenerator"/>
(which does not perform a Tietze transformation) will delete these lists
and hence terminate the tracing.
<P/>
<Example><![CDATA[
gap> G := PerfectGroup( IsSubgroupFpGroup, 960, 1 );
A5 2^4
gap> P := PresentationFpGroup( G );
<presentation with 6 gens and 21 rels of total length 84>
gap> GeneratorsOfPresentation( P );
[ a, b, s, t, u, v ]
gap> TzGoGo( P );
#I  there are 3 generators and 10 relators of total length 81
#I  there are 3 generators and 10 relators of total length 80
gap> TzPrintGenerators( P );
#I  1.  a   31 occurrences   involution
#I  2.  b   26 occurrences
#I  3.  t   23 occurrences   involution
gap> a := GeneratorsOfPresentation( P )[1];;
gap> b := GeneratorsOfPresentation( P )[2];;
gap> TzSubstitute( P, a*b );
#I  now the presentation has 4 generators, the new generator is _x7
#I  substituting new generator _x7 defined by a*b
#I  there are 4 generators and 11 relators of total length 83
gap> TzGo( P );
#I  there are 3 generators and 10 relators of total length 74
gap> TzPrintGenerators( P );
#I  1.  a   23 occurrences   involution
#I  2.  t   23 occurrences   involution
#I  3.  _x7   28 occurrences
]]></Example>
<P/>
As an example of an application of the command
<Ref Func="TzSubstitute" Label="for a presentation and a word"/>
in its second
form we handle a subgroup of index 266 in the Janko group <M>J_1</M>.
<P/>
<Example><![CDATA[
gap> F2 := FreeGroup( "a", "b" );;
gap> J1 := F2 / [ F2.1^2, F2.2^3, (F2.1*F2.2)^7,
> Comm(F2.1,F2.2)^10, Comm(F2.1,F2.2^-1*(F2.1*F2.2)^2)^6 ];;
gap> a := J1.1;; b := J1.2;;
gap> H := Subgroup ( J1, [ a, b^(a*b*(a*b^-1)^2) ] );;
gap> P := PresentationSubgroup( J1, H );
<presentation with 23 gens and 82 rels of total length 530>
gap> TzGoGo( P );
#I  there are 3 generators and 47 relators of total length 1368
#I  there are 2 generators and 46 relators of total length 3773
#I  there are 2 generators and 46 relators of total length 2570
gap> TzGoGo( P );
#I  there are 2 generators and 46 relators of total length 2568
gap> TzGoGo( P );
]]></Example>
<P/>
Here we do not get any more progress without substituting a new
generator.
<P/>
<Example><![CDATA[
gap> TzSubstitute( P );
#I  substituting new generator _x28 defined by _x6*_x23^-1
#I  eliminating _x28 = _x6*_x23^-1
]]></Example>
<P/>
&GAP; cannot substitute a new generator without extending the total
length,
so we have to explicitly ask for it by using the second form of the
command <Ref Func="TzSubstitute" Label="for a presentation and a word"/>.
Our problem is to choose appropriate values for the arguments
<A>n</A> and <A>eliminate</A>.
For this purpose it may be helpful to print out a list of the most
frequently occurring squarefree relator subwords of length 2.
<P/>
<Example><![CDATA[
gap> TzPrintPairs( P );
#I  1.  504  occurrences of  _x6 * _x23^-1
#I  2.  504  occurrences of  _x6^-1 * _x23
#I  3.  448  occurrences of  _x6 * _x23
#I  4.  448  occurrences of  _x6^-1 * _x23^-1
gap> TzSubstitute( P, 2, 1 );
#I  substituting new generator _x29 defined by _x6^-1*_x23
#I  eliminating _x6 = _x23*_x29^-1
#I  there are 2 generators and 46 relators of total length 2867
gap> TzGoGo( P );
#I  there are 2 generators and 45 relators of total length 2417
#I  there are 2 generators and 45 relators of total length 2122
gap> TzSubstitute( P, 1, 2 );
#I  substituting new generator _x30 defined by _x23*_x29^-1
#I  eliminating _x29 = _x30^-1*_x23
#I  there are 2 generators and 45 relators of total length 2192
gap> TzGoGo( P );
#I  there are 2 generators and 42 relators of total length 1637
#I  there are 2 generators and 40 relators of total length 1286
#I  there are 2 generators and 36 relators of total length 807
#I  there are 2 generators and 32 relators of total length 625
#I  there are 2 generators and 22 relators of total length 369
#I  there are 2 generators and 18 relators of total length 213
#I  there are 2 generators and 13 relators of total length 141
#I  there are 2 generators and 12 relators of total length 121
#I  there are 2 generators and 10 relators of total length 101
gap> TzPrintPairs( P );
#I  1.  19  occurrences of  _x23 * _x30^-1
#I  2.  19  occurrences of  _x23^-1 * _x30
#I  3.  14  occurrences of  _x23 * _x30
#I  4.  14  occurrences of  _x23^-1 * _x30^-1
]]></Example>
<P/>
If we save a copy of the current presentation, then later we will be able to
restart the computation from the current state.
<P/>
<Example><![CDATA[
gap> P1 := ShallowCopy( P );
<presentation with 2 gens and 10 rels of total length 101>
]]></Example>
<P/>
Just for demonstration we make an inconvenient choice:
<P/>
<Example><![CDATA[
gap> TzSubstitute( P, 3, 1 );
#I  substituting new generator _x31 defined by _x23*_x30
#I  eliminating _x23 = _x31*_x30^-1
#I  there are 2 generators and 10 relators of total length 122
gap> TzGoGo( P );
#I  there are 2 generators and 9 relators of total length 105
]]></Example>
<P/>
This presentation is worse than the one we have saved, so we restart from
that presentation again.
<P/>
<Example><![CDATA[
gap> P := ShallowCopy( P1 );
<presentation with 2 gens and 10 rels of total length 101>
gap> TzSubstitute( P, 2, 1);
#I  substituting new generator _x31 defined by _x23^-1*_x30
#I  eliminating _x23 = _x30*_x31^-1
#I  there are 2 generators and 10 relators of total length 107
gap> TzGoGo( P );
#I  there are 2 generators and 9 relators of total length 84
#I  there are 2 generators and 8 relators of total length 75
gap> TzSubstitute( P, 2, 1);
#I  substituting new generator _x32 defined by _x30^-1*_x31
#I  eliminating _x30 = _x31*_x32^-1
#I  there are 2 generators and 8 relators of total length 71
gap> TzGoGo( P );
#I  there are 2 generators and 7 relators of total length 56
#I  there are 2 generators and 5 relators of total length 36
gap> TzPrintRelators( P );
#I  1. _x32^5
#I  2. _x31^5
#I  3. (_x31^-1*_x32^-1)^3
#I  4. _x31*(_x32*_x31^-1)^2*_x32*_x31*_x32^-2
#I  5. _x31^-1*_x32^2*(_x31*_x32^-1*_x31)^2*_x32^2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TzSubstituteCyclicJoins" Arg='P'/>

<Description>
tries to find pairs of commuting generators <M>a</M> and <M>b</M>, say,
such that the exponent of <M>a</M> (i. e. the least currently known
positive integer <M>n</M> such that <M>a^n</M> is a relator in <A>P</A>)
is prime to the exponent of <M>b</M>.
For each such pair, their product <M>a b</M> is substituted as a new
generator, and <M>a</M> and <M>b</M> are eliminated.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tracing generator images through Tietze transformations">
<Heading>Tracing generator images through Tietze transformations</Heading>

Any sequence of Tietze transformations applied to a presentation,
starting from some presentation <M>P_1</M> and ending up with some
presentation <M>P_2</M>, defines an  isomorphism, <M>\varphi</M> say,
between the groups defined by <M>P_1</M> and <M>P_2</M>, respectively.
Sometimes it is desirable to know the images of the (old) generators of
<M>P_1</M> or the preimages of the (new) generators of <M>P_2</M>
under <M>\varphi</M>.
The &GAP; Tietze transformation functions are able to trace these images.
This is not automatically done because the involved words may grow to
tremendous length, but it will be done if you explicitly request
for it by calling the function <Ref Func="TzInitGeneratorImages"/>.

<ManSection>
<Func Name="TzInitGeneratorImages" Arg='P'/>

<Description>
expects <A>P</A> to be a presentation. It defines the current generators
to be the <Q>old generators</Q> of <A>P</A> and initializes the
(pre)image tracing.
See <Ref Func="TzImagesOldGens"/> and <Ref Func="TzPreImagesNewGens"/>
for details.
<P/>
You can reinitialize the tracing of the generator images at any later
state by just calling the function <Ref Func="TzInitGeneratorImages"/>
again.
<P/>
Note:
A subsequent call of the function <Ref Func="DecodeTree"/> will imply
that the images and preimages are deleted and reinitialized
after decoding the tree.
<P/>
Moreover, if you introduce a new generator by calling the function
<Ref Func="AddGenerator"/> described
in Section <Ref Sect="Changing Presentations"/>, this
new generator cannot be traced in the old generators.
Therefore <Ref Func="AddGenerator"/> will terminate the tracing of the
generator images and preimages and delete the respective lists
whenever it is called.
</Description>
</ManSection>

<ManSection>
<Func Name="OldGeneratorsOfPresentation" Arg='P'/>

<Description>
assumes that <A>P</A> is a presentation for which the generator images
and preimages are being traced under Tietze transformations. It
returns the list of old generators of <A>P</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="TzImagesOldGens" Arg='P'/>

<Description>
assumes that <A>P</A> is a presentation for which the generator images
and preimages are being traced under Tietze transformations. It
returns a list <M>l</M> of words in the (current)
<Ref Func="GeneratorsOfPresentation"/> value of <A>P</A>
such that the <M>i</M>-th word
<M>l[i]</M> represents the <M>i</M>-th old generator of <A>P</A>, i. e.,
the <M>i</M>-th entry of the <Ref Func="OldGeneratorsOfPresentation"/>
value of <A>P</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="TzPreImagesNewGens" Arg='P'/>

<Description>
assumes that <A>P</A> is a presentation for which the generator images
and preimages are being traced under Tietze transformations.
It returns a list <M>l</M> of words in the old generators of <A>P</A>
(the <Ref Func="OldGeneratorsOfPresentation"/> value of <A>P</A>)
such that the <M>i</M>-th entry of <M>l</M>
represents the <M>i</M>-th (current) generator of <A>P</A>
(the <Ref Func="GeneratorsOfPresentation"/> value of <A>P</A>).
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintGeneratorImages" Arg='P'/>

<Description>
assumes that <A>P</A> is a presentation for which the generator images
and preimages are being traced under Tietze transformations. It
displays the preimages of the current generators as Tietze words in
the old generators, and the images of the old generators as Tietze
words in the current generators.
<Example><![CDATA[
gap> G := PerfectGroup( IsSubgroupFpGroup, 960, 1 );
A5 2^4
gap> P := PresentationFpGroup( G );
<presentation with 6 gens and 21 rels of total length 84>
gap> TzInitGeneratorImages( P );
gap> TzGo( P );
#I  there are 3 generators and 11 relators of total length 96
#I  there are 3 generators and 10 relators of total length 81
gap> TzPrintGeneratorImages( P );
#I  preimages of current generators as Tietze words in the old ones:
#I  1. [ 1 ]
#I  2. [ 2 ]
#I  3. [ 4 ]
#I  images of old generators as Tietze words in the current ones:
#I  1. [ 1 ]
#I  2. [ 2 ]
#I  3. [ 1, -2, 1, 3, 1, 2, 1 ]
#I  4. [ 3 ]
#I  5. [ -2, 1, 3, 1, 2 ]
#I  6. [ 1, 3, 1 ]
gap> gens := GeneratorsOfPresentation( P );
[ a, b, t ]
gap> oldgens := OldGeneratorsOfPresentation( P );
[ a, b, s, t, u, v ]
gap> TzImagesOldGens( P );
[ a, b, a*b^-1*a*t*a*b*a, t, b^-1*a*t*a*b, a*t*a ]
gap> for i in [ 1 .. Length( oldgens ) ] do
> Print( oldgens[i], " = ", TzImagesOldGens( P )[i], "\n" );
> od;
a = a
b = b
s = a*b^-1*a*t*a*b*a
t = t
u = b^-1*a*t*a*b
v = a*t*a
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:DecodeTree">
<Heading>The Decoding Tree Procedure</Heading>

<ManSection>
<Func Name="DecodeTree" Arg='P'/>

<Description>
assumes that <A>P</A> is a subgroup presentation provided by the Reduced
Reidemeister-Schreier or by the Modified Todd-Coxeter method (see
<Ref Func="PresentationSubgroupRrs"
Label="for two groups (and a string)"/>,
<Ref Func="PresentationNormalClosureRrs"/>,
<Ref Func="PresentationSubgroupMtc"/>).
It eliminates the secondary generators of <A>P</A>
(see Section <Ref Sect="Subgroup Presentations"/>) by applying the
so called <Q>decoding tree</Q> procedure.
<P/>
<Ref Func="DecodeTree"/> is called automatically by the command
<Ref Func="PresentationSubgroupMtc"/> where it
reduces <A>P</A> to a presentation on the given (primary) subgroup
generators.
<Index>secondary subgroup generators</Index>
<P/>
In order to explain the effect of this command we need to insert a few
remarks on the subgroup presentation commands described in section
<Ref Sect="Subgroup Presentations"/>.
All these commands have the common property that in the process of
constructing a presentation for a given subgroup <A>H</A> of a finitely
presented group <A>G</A> they first build up a highly
redundant list of generators of <A>H</A> which consists of an (in general
small) list of <Q>primary</Q> generators, followed by an (in general
large) list of <Q>secondary</Q> generators, and then construct a
presentation <M>P_0</M>, say,
<E>on a sublist of these generators</E> by rewriting
the defining relators of <A>G</A>.
This sublist contains all primary, but, at least in general,
by far not all secondary generators.
<Index>primary subgroup generators</Index>
<P/>
The role of the primary generators depends on the concrete choice of the
subgroup presentation command. If the Modified Todd-Coxeter method is
used, they are just the given generators of <A>H</A>,
whereas in the case of the Reduced Reidemeister-Schreier algorithm they
are constructed by the program.
<P/>
Each of the secondary generators is defined by a word of length two in
the preceding generators and their inverses. By historical reasons, the
list of these definitions is called the <E>subgroup generators tree</E>
though in fact it is not a tree but rather a kind of bush.
<Index>subgroup generators tree</Index>
<P/>
Now we have to distinguish two cases. If <M>P_0</M> has been constructed
by the Reduced Reidemeister-Schreier routines, it is a presentation of
<A>H</A>. However, if the Modified Todd-Coxeter routines have been used
instead, then the relators in <M>P_0</M> are valid relators of <A>H</A>,
but they do not necessarily define <A>H</A>.
We handle these cases in turn, starting with the latter one.
<P/>
In fact, we could easily receive a presentation of <A>H</A> also in this
case if we extended <M>P_0</M> by adding to it all the
secondary generators which are not yet contained in it and all the
definitions from the generators tree as additional generators and
relators.
Then we could recursively eliminate all secondary generators by Tietze
transformations using the new relators.
However, this procedure turns out to be too inefficient to
be of interest.
<P/>
Instead, we use the so called <E>decoding tree</E> procedure
(see <Cite Key="AMW82"/>, <Cite Key="AR84"/>). It proceeds as follows.
<P/>
Starting from <M>P = P_0</M>, it runs through a number of steps in each
of which it eliminates the current <Q>last</Q> generator (with respect to
the list of all primary and secondary generators). If the last generator
<A>g</A>, say, is a primary generator, then the procedure terminates.
Otherwise it checks whether there is a relator in the current
presentation which can be used to substitute <A>g</A> by a Tietze
transformation. If so, this is done.
Otherwise, and only then, the tree definition of <A>g</A> is added to
<A>P</A> as a new relator, and the generators involved are added as new
generators if they have not yet been contained in <A>P</A>.
Subsequently, <A>g</A> is eliminated.
<P/>
Note that the extension of <A>P</A> by one or two new generators is
<E>not</E> a Tietze transformation.
In general, it will change the isomorphism type
of the group defined by <A>P</A>.
However, it is a remarkable property of this procedure, that at the end,
i.e., as soon as all secondary generators have been eliminated,
it provides a presentation <M>P = P_1</M>,
say, which defines a group isomorphic to <A>H</A>. In fact, it is this
presentation which is returned by the command <Ref Func="DecodeTree"/>
and hence by the command <Ref Func="PresentationSubgroupMtc"/>.
<P/>
If, in the other case, the presentation <M>P_0</M> has been constructed
by the Reduced Reidemeister-Schreier algorithm,
then <M>P_0</M> itself is a presentation of <A>H</A>,
and the corresponding subgroup presentation command
(<Ref Func="PresentationSubgroupRrs"
Label="for two groups (and a string)"/> or
<Ref Func="PresentationNormalClosureRrs"/>) just returns <M>P_0</M>.
<P/>
As mentioned in section <Ref Sect="Subgroup Presentations"/>,
we recommend to further simplify this presentation before you use it.
The standard way to do this is to start from <M>P_0</M> and to apply
suitable Tietze transformations,
e. g., by calling the commands <Ref Func="TzGo"/> or
<Ref Func="TzGoGo"/>.
This is probably the most efficient approach, but you will end up with a
presentation on some unpredictable set of generators.
As an alternative, &GAP; offers you the <Ref Func="DecodeTree"/> command
which you can use to eliminate all secondary
generators (provided that there are no space or time problems). For this
purpose, the subgroup presentation commands do not only return the
resulting presentation, but also the tree (together with some associated
lists) as a kind of side result in a component <A>P</A><C>!.tree</C> of
the resulting presentation <A>P</A>.
<P/>
Note, however, that the decoding tree routines will not work correctly
any more on a presentation from which generators have already been
eliminated by Tietze transformations.
Therefore, to prevent you from getting wrong results by calling
<Ref Func="DecodeTree"/> in such a situation,
&GAP; will automatically remove the subgroup generators tree
from a presentation as soon as one of the generators is substituted by a
Tietze transformation.
<P/>
Nevertheless, a certain misuse of the command is still possible, and we
want to explicitly warn you from this.
The reason is that the Tietze option parameters described in
Section <Ref Sect="Tietze Options"/> apply to
<Ref Func="DecodeTree"/> as well.
Hence, in case of inadequate values of these parameters, it may happen that
<Ref Func="DecodeTree"/> stops before all the secondary generators have
vanished. In this case &GAP;
will display an appropriate warning. Then you should change the
respective parameters and continue the process by calling
<Ref Func="DecodeTree"/> again. Otherwise, if you would apply Tietze
transformations, it might happen because of the convention described
above that the tree is removed and that you end up with a wrong
presentation.
<P/>
After a successful run of <Ref Func="DecodeTree"/> it is convenient to
further simplify the resulting presentation by suitable Tietze
transformations.
<P/>
As an example of an explicit call of <Ref Func="DecodeTree"/> we compute
two presentations of a subgroup of order <M>384</M> in a group of order
<M>6912</M>. In both cases we use the Reduced Reidemeister-Schreier
algorithm, but in the first run we just apply the Tietze transformations
offered by the <Ref Func="TzGoGo"/> command with its default parameters,
whereas in the second run we call the <Ref Func="DecodeTree"/> command
before.
<P/>
<Example><![CDATA[
gap> F2 := FreeGroup( "a", "b" );;
gap> G := F2 / [ F2.1*F2.2^2*F2.1^-1*F2.2^-1*F2.1^3*F2.2^-1,
>                F2.2*F2.1^2*F2.2^-1*F2.1^-1*F2.2^3*F2.1^-1 ];;
gap> a := G.1;;  b := G.2;;
gap> H := Subgroup( G, [ Comm(a^-1,b^-1), Comm(a^-1,b), Comm(a,b) ] );;
]]></Example>
<P/>
We use the Reduced Reidemeister Schreier method and default Tietze
transformations to get a presentation for <A>H</A>.
<P/>
<Example><![CDATA[
gap> P := PresentationSubgroupRrs( G, H );
<presentation with 18 gens and 35 rels of total length 169>
gap> TzGoGo( P );
#I  there are 3 generators and 20 relators of total length 488
#I  there are 3 generators and 20 relators of total length 466
]]></Example>
<P/>
We end up with 20 relators of total length 466. Now we repeat the
procedure, but we call the decoding tree algorithm before doing the Tietze
transformations.
<P/>
<Example><![CDATA[
gap> P := PresentationSubgroupRrs( G, H );
<presentation with 18 gens and 35 rels of total length 169>
gap> DecodeTree( P );
#I  there are 9 generators and 26 relators of total length 185
#I  there are 6 generators and 23 relators of total length 213
#I  there are 3 generators and 20 relators of total length 252
#I  there are 3 generators and 20 relators of total length 244
gap> TzGoGo( P );
#I  there are 3 generators and 19 relators of total length 168
#I  there are 3 generators and 17 relators of total length 138
#I  there are 3 generators and 15 relators of total length 114
#I  there are 3 generators and 13 relators of total length 96
#I  there are 3 generators and 12 relators of total length 84
]]></Example>
<P/>
This time we end up with a shorter presentation.
<P/>
As an example of an implicit call of the function
<Ref Func="DecodeTree"/> via the command
<Ref Func="PresentationSubgroupMtc"/> we handle a subgroup
of index 240 in a
group of order 40320 given by a presentation due to
B.&nbsp;H.&nbsp;Neumann.
Note that we increase the level of <Ref InfoClass="InfoFpGroup"/>
temporarily to get some additional output.
<P/>
<Example><![CDATA[
gap> F3 := FreeGroup( "a", "b", "c" );;
gap> a := F3.1;;  b := F3.2;;  c := F3.3;;
gap> G := F3 / [ a^3, b^3, c^3, (a*b)^5, (a^-1*b)^5, (a*c)^4,
>     (a*c^-1)^4, a*b^-1*a*b*c^-1*a*c*a*c^-1, (b*c)^3, (b^-1*c)^4 ];;
gap> a := G.1;;  b := G.2;;  c := G.3;;
gap> H := Subgroup( G, [ a, c ] );;
gap> SetInfoLevel( InfoFpGroup, 1 );
gap> P := PresentationSubgroupMtc( G, H );;
#I  index = 240  total = 4737  max = 4507
#I  MTC defined 2 primary and 4444 secondary subgroup generators
#I  there are 246 generators and 617 relators of total length 2893
#I  calling DecodeTree
#I  there are 114 generators and 385 relators of total length 1860
#I  there are 69 generators and 294 relators of total length 1855
#I  there are 43 generators and 235 relators of total length 2031
#I  there are 35 generators and 207 relators of total length 2348
#I  there are 25 generators and 181 relators of total length 3055
#I  there are 19 generators and 165 relators of total length 3290
#I  there are 20 generators and 160 relators of total length 5151
#I  there are 23 generators and 159 relators of total length 8177
#I  there are 25 generators and 159 relators of total length 12241
#I  there are 29 generators and 159 relators of total length 18242
#I  there are 34 generators and 159 relators of total length 27364
#I  there are 38 generators and 159 relators of total length 41480
#I  there are 41 generators and 159 relators of total length 62732
#I  there are 45 generators and 159 relators of total length 88872
#I  there are 46 generators and 159 relators of total length 111092
#I  there are 44 generators and 155 relators of total length 158181
#I  there are 32 generators and 155 relators of total length 180478
#I  there are 7 generators and 133 relators of total length 29897
#I  there are 4 generators and 119 relators of total length 28805
#I  there are 3 generators and 116 relators of total length 35209
#I  there are 2 generators and 111 relators of total length 25658
#I  there are 2 generators and 111 relators of total length 22634
gap> TzGoGo( P );
#I  there are 2 generators and 108 relators of total length 11760
#I  there are 2 generators and 95 relators of total length 6482
#I  there are 2 generators and 38 relators of total length 1464
#I  there are 2 generators and 8 relators of total length 116
#I  there are 2 generators and 7 relators of total length 76
#I  there are 2 generators and 6 relators of total length 66
#I  there are 2 generators and 6 relators of total length 52
gap> TzPrintGenerators( P );
#I  1.  _x1   26 occurrences
#I  2.  _x2   26 occurrences
gap> TzPrint( P );
#I  generators: [ _x1, _x2 ]
#I  relators:
#I  1.  3  [ 1, 1, 1 ]
#I  2.  3  [ 2, 2, 2 ]
#I  3.  8  [ 2, -1, 2, -1, 2, -1, 2, -1 ]
#I  4.  8  [ 2, 1, 2, 1, 2, 1, 2, 1 ]
#I  5.  14  [ -1, -2, 1, 2, 1, -2, -1, 2, 1, -2, -1, -2, 1, 2 ]
#I  6.  16  [ 1, 2, 1, -2, 1, 2, 1, -2, 1, 2, 1, -2, 1, 2, 1, -2 ]
gap> K :=  FpGroupPresentation( P );
<fp group on the generators [ _x1, _x2 ]>
gap> SetInfoLevel( InfoFpGroup, 0 );
gap> Size( K );
168
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tietze Options">
<Heading>Tietze Options</Heading>

Several of the Tietze transformation commands described above are
controlled by certain parameters, the <E>Tietze options</E>, which often have
a tremendous influence on their performance and results.  However, in
each application of the commands, an appropriate choice of these option
parameters will depend on the concrete presentation under investigation.
Therefore we have implemented the Tietze options in such a way that they
are associated to the presentation: Each presentation
keeps its own set of Tietze option parameters as an attribute.

<ManSection>
<Attr Name="TzOptions" Arg='P'/>

<Description>
is a record whose components direct the heuristics applied by the Tietze
transformation functions.
<P/>
You may alter the value of any of these Tietze options by just assigning
a new value to the respective record component.
<P/>
The following Tietze options are recognized by &GAP;:
<P/>
<List>
<Mark><C>protected</C>:</Mark>
<Item>
  The first <C>protected</C> generators in a presentation <A>P</A> are
  protected from being eliminated by the Tietze transformations
  functions.  There are only  two exceptions:  The option
  <C>protected</C>   is   ignored   by   the   functions
  <Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
  and <Ref Func="TzSubstitute" Label="for a presentation and a word"/>
  because they explicitly specify the generator to be eliminated.
  The default value of <C>protected</C> is 0.
</Item>
<Mark><C>eliminationsLimit</C>:</Mark>
<Item>
  Whenever the elimination phase of the <Ref Func="TzGo"/> command is
  entered for a presentation <A>P</A>,  then it  will eliminate at most
  <C>eliminationsLimit</C> generators (except for further ones which
  have turned out to  be trivial). Hence you may use  the
  <C>eliminationsLimit</C> parameter as a break criterion for the
  <Ref Func="TzGo"/> command. Note, however, that it is ignored by the
  <Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
  command. The default value of <C>eliminationsLimit</C> is 100.
</Item>
<Mark><C>expandLimit</C>:</Mark>
<Item>
  Whenever the routine for eliminating more than 1 generators is
  called for a presentation <A>P</A> by the
  <Ref Func="TzEliminate" Label="for a presentation (and a generator)"/>
  command or the elimination phase of the <Ref Func="TzGo"/> command,
  then it saves the given total length of the relators,
  and subsequently it checks the current total length against its value
  before each elimination.
  If the total length has increased to more than <C>expandLimit</C>
  per cent of its original value, then the routine returns instead
  of  eliminating another generator.
  Hence you may use the <C>expandLimit</C> parameter as a break criterion
  for the <Ref Func="TzGo"/> command.
  The default value of <C>expandLimit</C> is 150.
</Item>
<Mark><C>generatorsLimit</C>:</Mark>
<Item>
  Whenever the elimination phase of the <Ref Func="TzGo"/> command is
  entered for a presentation <A>P</A> with <M>n</M> generators,
  then it will eliminate at most <M>n - </M><C>generatorsLimit</C>
  generators (except for generators which turn out to be trivial).
  Hence you may use the <C>generatorsLimit</C> parameter as a break
  criterion for the <Ref Func="TzGo"/> command.
  The default value of <C>generatorsLimit</C> is 0.
</Item>
<Mark><C>lengthLimit</C>:</Mark>
<Item>
  The Tietze transformation commands will never eliminate  a
  generator of a presentation <A>P</A>, if they cannot exclude the
  possibility that the resulting total length of the relators
  exceeds the maximal &GAP; list length of <M>2^{31}-1</M> or the value
  of the option <C>lengthLimit</C>.
  The default value of <C>lengthLimit</C> is <M>2^{31}-1</M>.
</Item>
<Mark><C>loopLimit</C>:</Mark>
<Item>
  Whenever the <Ref Func="TzGo"/> command is called for a presentation
  <A>P</A>, then it will loop over at most <C>loopLimit</C> of its basic
  steps. Hence you may use the <C>loopLimit</C> parameter as a break
  criterion for  the <Ref Func="TzGo"/>  command. The  default value of
  <C>loopLimit</C> is <Ref Var="infinity"/>.
</Item>
<Mark><C>printLevel</C>:</Mark>
<Item>
  Whenever  Tietze transformation commands are called for  a
  presentation <A>P</A> with <C>printLevel</C> <M>= 0</M>, they will not
  provide any output except for error messages. If <C>printLevel</C>
  <M>= 1</M>, they will display some reasonable amount of output which
  allows you to watch the progress of the computation and to decide
  about your next commands. In the case <C>printLevel</C> <M>= 2</M>, you
  will get a much more generous amount of output. Finally, if
  <C>printLevel</C> <M>= 3</M>, various messages on internal details will
  be added. The default value of <C>printLevel</C> is 1.
</Item>
<Mark><C>saveLimit</C>:</Mark>
<Item>
  Whenever the <Ref Func="TzSearch"/> command has finished its main loop
  over all relators of a presentation <A>P</A>, then it checks whether
  during this loop the total length of the relators has been reduced by
  at least <C>saveLimit</C> per cent. If this is the case, then
  <Ref Func="TzSearch"/> repeats its procedure instead of returning.
  Hence you may use the <C>saveLimit</C> parameter as a break criterion
  for the <Ref Func="TzSearch"/> command and, in particular,
  for the search phase of the <Ref Func="TzGo"/> command.
  The default value of <C>saveLimit</C> is 10.
</Item>
<Mark><C>searchSimultaneous</C>:</Mark>
<Item>
  Whenever the <Ref Func="TzSearch"/> or the <Ref Func="TzSearchEqual"/>
  command is called for a presentation <A>P</A>, then it is allowed to
  handle up to <C>searchSimultaneous</C> short relators simultaneously
  (see the description of the <Ref Func="TzSearch"/> command for more
  details).
  The choice of this parameter may heavily influence the performance as
  well as the result of the <Ref Func="TzSearch"/> and the
  <Ref Func="TzSearchEqual"/> commands and hence also of the search phase
  of the <Ref Func="TzGo"/> command.
  The default value of <C>searchSimultaneous</C> is 20.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="TzPrintOptions" Arg='P'/>

<Description>
prints the current values of the Tietze options of the presentation
<A>P</A>.
<Example><![CDATA[
gap> TzPrintOptions( P );
#I  protected          = 0
#I  eliminationsLimit  = 100
#I  expandLimit        = 150
#I  generatorsLimit    = 0
#I  lengthLimit        = 2147483647
#I  loopLimit          = infinity
#I  printLevel         = 1
#I  saveLimit          = 10
#I  searchSimultaneous = 20
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grpprod.msk                 GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grpprod.msk,v 1.34 2006/03/13 11:36:40 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Group Products">
<Heading>Group Products</Heading>

This chapter describes the various group product constructions that are
possible in &GAP;.
<P/>
At the moment for some of the products methods are available only if both
factors are given in the same representation or only for certain types of
groups such as  permutation groups and pc groups when the product can be
naturally represented as a group of the same kind.
<P/>
&GAP; does not guarantee that a product of two groups will be in a
particular representation.
(Exceptions are <Ref Func="WreathProductImprimitiveAction"/>
and <Ref Func="WreathProductProductAction"/>
which are construction that makes sense only for permutation groups,
see&nbsp;<Ref Func="WreathProduct"/>).
<P/>
&GAP; however will try to choose an efficient representation, so products
of permutation groups or pc groups often will be represented as a group of
the same kind again.
<P/>
Therefore the only guaranteed way to relate a product to its factors is via
the embedding and projection homomorphisms,
see&nbsp;<Ref Sect="Embeddings and Projections for Group Products"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Direct Products">
<Heading>Direct Products</Heading>

The direct product of  groups is the cartesian product of the groups
(considered as element sets) with component-wise multiplication.
<P/>
<ManSection>
<Func Name="DirectProduct" Arg='G[, H, ...]'/>
<Oper Name="DirectProductOp" Arg='list, expl'/>

<Description>
These functions construct the direct product of the groups given as
arguments.
<Ref Func="DirectProduct"/> takes an arbitrary positive number of
arguments and calls the operation <Ref Func="DirectProductOp"/>,
which takes exactly two arguments,
namely a nonempty list <A>list</A> of groups and one of these groups,
<A>expl</A>.
(This somewhat strange syntax allows the method selection to choose
a reasonable method for special cases, e.g., if all groups are
permutation groups or pc groups.)
<P/>
&GAP; will try to choose an efficient representation for the direct
product. For example the direct product of permutation groups will be a
permutation group again and the direct product of pc groups will be a pc
group.
<P/>
If the groups are in different representations a generic direct product
will be formed which may not be particularly efficient for many
calculations.
Instead it may be worth to convert all factors to a common representation
first, before forming the product.
<P/>
<Index Key="Embedding" Subkey="example for direct products">
<C>Embedding</C></Index>
<Index Key="Projection" Subkey="example for direct products">
<C>Projection</C></Index>
For a direct product <M>P</M>, calling
<Ref Func="Embedding" Label="for a domain and a positive integer"/> with
<M>P</M> and <M>n</M> yields the homomorphism embedding the <M>n</M>-th
factor into <M>P</M>; calling
<Ref Func="Projection" Label="for a domain and a positive integer"/> with
<A>P</A> and <A>n</A> yields the projection of <M>P</M> onto the
<M>n</M>-th factor,
see&nbsp;<Ref Sect="Embeddings and Projections for Group Products"/>.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));;
gap> d:=DirectProduct(g,g,g);
Group([ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ])
gap> Size(d);
216
gap> e:=Embedding(d,2);
2nd embedding into Group([ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), 
  (7,8) ])
gap> Image(e,(1,2));
(4,5)
gap> Image(Projection(d,2),(1,2,3)(4,5)(8,9));
(1,2)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Semidirect Products">
<Heading>Semidirect Products</Heading>

The semidirect product of a group <M>N</M> with a group <M>G</M>
acting on <M>N</M> via a homomorphism <M>\alpha</M> from <M>G</M> into the
automorphism group of <M>N</M> is the cartesian product
<M>G \times N</M> with the multiplication
<M>(g, n) \cdot (h, m) = (gh, n^{{h^\alpha}}m)</M>.

<ManSection>
<Heading>SemidirectProduct</Heading>
<Oper Name="SemidirectProduct" Arg='G, alpha, N'
 Label="for acting group, action, and a group"/>
<Oper Name="SemidirectProduct" Arg='autgp, N'
 Label="for a group of automorphisms and a group"/>

<Description>
constructs the semidirect product of <A>N</A> with <A>G</A> acting via
<A>alpha</A>, which must be a homomorphism from <A>G</A> into a group of
automorphisms of <A>N</A>.
<P/>
If <A>N</A> is a group, <A>alpha</A> must be a homomorphism from <A>G</A>
into a group of automorphisms of <A>N</A>.
<P/>
If <A>N</A> is a full row space over a field <A>F</A>, <A>alpha</A> must
be a homomorphism from <A>G</A> into a matrix group of the right
dimension over a subfield of <A>F</A>, or into a permutation group
(in this case permutation matrices are taken).
<P/>
In the second variant, <A>autgp</A> must be a group of automorphism of
<A>N</A>, it is a shorthand for
<C>SemidirectProduct(<A>autgp</A>,IdentityMapping(<A>autgp</A>),<A>N</A>)</C>.
Note that (unless <A>autgrp</A> has been obtained by the operation
<Ref Func="AutomorphismGroup"/>)
you have to test <Ref Func="IsGroupOfAutomorphisms"/> for <A>autgrp</A>
to ensure that &GAP; knows that <A>autgrp</A> consists of
group automorphisms.
<Example><![CDATA[
gap> n:=AbelianGroup(IsPcGroup,[5,5]);
<pc group of size 25 with 2 generators>
gap> au:=DerivedSubgroup(AutomorphismGroup(n));;
gap> Size(au);
120
gap> p:=SemidirectProduct(au,n);
<permutation group with 5 generators>
gap> Size(p);
3000
gap> n:=Group((1,2),(3,4));;
gap> au:=AutomorphismGroup(n);;
gap> au:=First(Elements(au),i->Order(i)=3);;
gap> au:=Group(au);
<group with 1 generators>
gap> IsGroupOfAutomorphisms(au);
true
gap> SemidirectProduct(au,n);
<pc group with 3 generators>
gap> n:=AbelianGroup(IsPcGroup,[2,2]);
<pc group of size 4 with 2 generators>
gap> au:=AutomorphismGroup(n);
<group of size 6 with 2 generators>
gap> apc:=IsomorphismPcGroup(au);
CompositionMapping( Pcgs([ (2,3), (1,2,3) ]) -> 
[ f1, f2 ], <action isomorphism> )
gap> g:=Image(apc);
Group([ f1, f2 ])
gap> apci:=InverseGeneralMapping(apc);
[ f1*f2^2, f1*f2 ] -> [ Pcgs([ f1, f2 ]) -> [ f1*f2, f2 ], 
  Pcgs([ f1, f2 ]) -> [ f2, f1 ] ]
gap> IsGroupHomomorphism(apci);
true
gap> p:=SemidirectProduct(g,apci,n);
<pc group of size 24 with 4 generators>
gap> IsomorphismGroups(p,Group((1,2,3,4),(1,2)));
[ f1, f2, f3, f4 ] -> [ (2,3), (1,2,3), (1,4)(2,3), (1,3)(2,4) ]
gap> SemidirectProduct(SU(3,3),GF(9)^3);
<matrix group of size 4408992 with 3 generators>
gap> SemidirectProduct(Group((1,2,3),(2,3,4)),GF(5)^4);
<matrix group of size 7500 with 3 generators>
gap> g:=Group((3,4,5),(1,2,3));;
gap> mats:=[[[Z(2^2),0*Z(2)],[0*Z(2),Z(2^2)^2]],
>          [[Z(2)^0,Z(2)^0], [Z(2)^0,0*Z(2)]]];;
gap> hom:=GroupHomomorphismByImages(g,Group(mats),[g.1,g.2],mats);;
gap> SemidirectProduct(g,hom,GF(4)^2);
<matrix group of size 960 with 3 generators>
gap> SemidirectProduct(g,hom,GF(16)^2);
<matrix group of size 15360 with 4 generators>
]]></Example>
<P/>
<Index Key="Embedding" Subkey="example for semidirect products">
<C>Embedding</C></Index>
<Index Key="Projection" Subkey="example for semidirect products">
<C>Projection</C></Index>
For a semidirect product <M>P</M> of <A>G</A> with <A>N</A>, calling
<Ref Func="Embedding" Label="for a domain and a positive integer"/> with
<M>P</M> and <C>1</C> yields the embedding of <A>G</A>, calling
<Ref Func="Embedding" Label="for a domain and a positive integer"/> with
<M>P</M> and <C>2</C> yields the embedding of <A>N</A>; calling
<Ref Func="Projection" Label="for a domain and a positive integer"/> with
<A>P</A> yields the projection of <M>P</M> onto <A>G</A>,
see&nbsp;<Ref Sect="Embeddings and Projections for Group Products"/>.
<P/>
<Example><![CDATA[
gap> Size(Image(Embedding(p,1)));
6
gap> Embedding(p,2);
[ f1, f2 ] -> [ f3, f4 ]
gap> Projection(p);
[ f1, f2, f3, f4 ] -> [ f1, f2, <identity> of ..., <identity> of ... ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subdirect Products">
<Heading>Subdirect Products</Heading>

The subdirect product of the groups <M>G</M> and <M>H</M> with respect to
the epimorphisms <M>\varphi\colon G \rightarrow A</M> and
<M>\psi\colon H \rightarrow A</M> (for a common group <M>A</M>)
is the subgroup of the direct product <M>G \times H</M> consisting of
the elements <M>(g,h)</M> for which <M>g^{\varphi} = h^{\psi}</M>.
It is the pull-back of the following diagram.
<P/>
<Alt Not="Text,HTML"><Display>
<![CDATA[
\matrix{
&&G&\cr
&&\Big\downarrow&\varphi\cr
H&\mathop{\longrightarrow}\limits^{\psi}&A&\cr
}
]]>
</Display></Alt>
<Alt Only="Text,HTML"><Verb>
                   G
                   | phi
             psi   V
          H  --->  A
</Verb></Alt>

<ManSection>
<Oper Name="SubdirectProduct" Arg='G, H, Ghom, Hhom'/>

<Description>
constructs the subdirect product of <A>G</A> and <A>H</A> with respect to
the epimorphisms <A>Ghom</A> from <A>G</A> onto a group <M>A</M> and
<A>Hhom</A> from <A>H</A> onto the same group <M>A</M>.
<P/>
<Index Key="Projection" Subkey="example for subdirect products">
<C>Projection</C></Index>
For a subdirect product <M>P</M>, calling
<Ref Func="Projection" Label="for a domain and a positive integer"/> with
<M>P</M> and <M>n</M> yields the projection on the <M>n</M>-th factor.
(In general the factors do not embed into a subdirect product.)
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> hom:=GroupHomomorphismByImagesNC(g,g,[(1,2,3),(1,2)],[(),(1,2)]);
[ (1,2,3), (1,2) ] -> [ (), (1,2) ]
gap> s:=SubdirectProduct(g,g,hom,hom);
Group([ (1,2,3), (1,2)(4,5), (4,5,6) ])
gap> Size(s);
18
gap> p:=Projection(s,2);
2nd projection of Group([ (1,2,3), (1,2)(4,5), (4,5,6) ])
gap> Image(p,(1,3,2)(4,5,6));
(1,2,3)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubdirectProducts" Arg='G, H'/>

<Description>
this function computes all subdirect products of <A>G</A> and <A>H</A> up
to conjugacy in the direct product of Parent(<A>G</A>) and
Parent(<A>H</A>).
The subdirect products are returned as subgroups of this direct product.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Wreath Products">
<Heading>Wreath Products</Heading>

The wreath product of a group <M>G</M> with a permutation group <M>P</M>
acting on <M>n</M> points is the semidirect product of the normal subgroup
<M><A>G</A>^n</M> with the group <M>P</M> which acts on <M><A>G</A>^n</M>
by permuting the components.
<P/>
Note that &GAP; always considers the domain of a permutation group to be the
points moved by elements of the group as returned by
<Ref Func="MovedPoints" Label="for a list or collection of permutations"/>,
i.e. it is not possible to have a domain to include fixed points, I.e.
<M>P = \langle (1,2,3) \rangle</M> and 
<M>P = \langle (1,3,5) \rangle</M> result in isomorphic wreath products.
(If fixed points are desired the wreath product <M>G \wr T</M>
has to be formed with a transitive overgroup <M>T</M> of <M>P</M> and then
the pre-image of <M>P</M> under the projection <M>G \wr T \rightarrow T</M>
has to be taken.)
<P/>
<ManSection>
<Oper Name="WreathProduct" Arg='G, H[, hom]'/>
<Oper Name="StandardWreathProduct" Arg='G, H'/>

<Description>
<C>WreathProduct</C>
constructs the wreath product of the group <A>G</A> with the group
<A>H</A>, acting as a permutation group.
<P/>
If a third argument <A>hom</A> is given, it must be
a homomorphism from <A>H</A> into a permutation group,
and the action of this group on its moved points is considered.
<P/>
If only two arguments are given, <A>H</A> must be a permutation group.
<P/>
<C>StandardWreathProduct</C> returns the wreath product for the (right
regular) permutation action of <A>H</A> on its elements.
<P/>
<Index Key="Embedding" Subkey="example for wreath products">
<C>Embedding</C></Index>
<Index Key="Projection" Subkey="example for wreath products">
<C>Projection</C></Index>
For a wreath product <M>W</M> of <A>G</A> with a permutation group
<M>P</M> of degree <M>n</M> and <M>1 \leq i \leq n</M> calling
<Ref Func="Embedding" Label="for a domain and a positive integer"/> with
<M>W</M> and <M>i</M> yields the embedding of <A>G</A> in the <M>i</M>-th
component of the direct product of the base group <M><A>G</A>^n</M> of
<M>W</M>.
For <M>i = n+1</M>,
<Ref Func="Embedding" Label="for a domain and a positive integer"/>
yields the embedding of <M>P</M> into <M>W</M>.  Calling
<Ref Func="Projection" Label="for a domain and a positive integer"/> with
<M>W</M> yields the projection onto the acting group <M>P</M>,
see&nbsp;<Ref Sect="Embeddings and Projections for Group Products"/>.
<P/>
<Example><![CDATA[
gap> g:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> p:=Group((1,2,3));
Group([ (1,2,3) ])
gap> w:=WreathProduct(g,p);
Group([ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8), 
  (1,4,7)(2,5,8)(3,6,9) ])
gap> Size(w);
648
gap> Embedding(w,1);
1st embedding into Group( [ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), 
  (7,8), (1,4,7)(2,5,8)(3,6,9) ] )
gap> Image(Embedding(w,3));
Group([ (7,8,9), (7,8) ])
gap> Image(Embedding(w,4));
Group([ (1,4,7)(2,5,8)(3,6,9) ])
gap> Image(Projection(w),(1,4,8,2,6,7,3,5,9));
(1,2,3)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="WreathProductImprimitiveAction" Arg='G, H'/>

<Description>
For two permutation groups <A>G</A> and <A>H</A>,
this function constructs the wreath product of <A>G</A> and <A>H</A>
in the imprimitive action.
If <A>G</A> acts on <M>l</M> points and <A>H</A> on <M>m</M> points
this action will be on <M>l \cdot m</M> points,
it will be imprimitive with <M>m</M> blocks of size <M>l</M> each.
<P/>
The operations <Ref Func="Embedding" Label="for two domains"/>
and <Ref Func="Projection" Label="for two domains"/>
operate on this product as described for general wreath products.
<P/>
<Example><![CDATA[
gap> w:=WreathProductImprimitiveAction(g,p);;
gap> LargestMovedPoint(w);
9
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="WreathProductProductAction" Arg='G, H'/>

<Description>
For two permutation groups <A>G</A> and <A>H</A>,
this function constructs the wreath product in product action.
If <A>G</A> acts on <M>l</M> points and <A>H</A> on
<M>m</M> points this action will be on <M>l^m</M> points.
<P/>
The operations <Ref Func="Embedding" Label="for two domains"/>
and <Ref Func="Projection" Label="for two domains"/>
operate on this product as described for general wreath products.
<Example><![CDATA[
gap> w:=WreathProductProductAction(g,p);
<permutation group of size 648 with 7 generators>
gap> LargestMovedPoint(w);
27
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="KuKGenerators" Arg='G, beta, alpha'/>

<Description>
<Index>Krasner-Kaloujnine theorem</Index>
<Index>Wreath product embedding</Index>
If <A>beta</A> is a homomorphism from <A>G</A> into a transitive
permutation group, <M>U</M> the full preimage of the point stabilizer and
<A>alpha</A> a homomorphism defined on (a superset) of <M>U</M>,
this function returns images of the generators of <A>G</A> when mapping
to the wreath product <M>(U <A>alpha</A>) \wr (<A>G</A> <A>beta</A>)</M>.
(This is the Krasner-Kaloujnine embedding theorem.)
<Example><![CDATA[
gap> g:=Group((1,2,3,4),(1,2));;
gap> hom:=GroupHomomorphismByImages(g,Group((1,2)),
> GeneratorsOfGroup(g),[(1,2),(1,2)]);;
gap> u:=PreImage(hom,Stabilizer(Image(hom),1));
Group([ (2,3,4), (1,2,4) ])
gap> hom2:=GroupHomomorphismByImages(u,Group((1,2,3)),
> GeneratorsOfGroup(u),[ (1,2,3), (1,2,3) ]);;
gap> KuKGenerators(g,hom,hom2);
[ (1,4)(2,5)(3,6), (1,6)(2,4)(3,5) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Free Products">
<Heading>Free Products</Heading>

Let <M>G</M> and <M>H</M> be groups with presentations
<M>\langle X \mid R \rangle</M> and <M>\langle Y \mid S \rangle</M>,
respectively. Then the free product <M>G*H</M> is
the group with presentation <M>\langle X \cup Y \mid R \cup S \rangle</M>.
This construction can be generalized to an arbitrary number of groups. 

<ManSection>
<Heading>FreeProduct</Heading>
<Func Name="FreeProduct" Arg='G[, H, ...]' Label="for several groups"/>
<Func Name="FreeProduct" Arg='list' Label="for a list"/>

<Description>
constructs a finitely presented group which is the free product of 
the groups given as arguments.
If the group arguments are not finitely presented groups,
then <Ref Func="IsomorphismFpGroup"/> must be defined for them.
<P/>
The operation <Ref Func="Embedding" Label="for two domains"/>
operates on this product.
<Example><![CDATA[
gap> g := DihedralGroup(8);;
gap> h := CyclicGroup(5);;
gap> fp := FreeProduct(g,h,h);
<fp group on the generators [ f1, f2, f3, f4, f5 ]>
gap> fp := FreeProduct([g,h,h]);
<fp group on the generators [ f1, f2, f3, f4, f5 ]>
gap> Embedding(fp,2);
[ f1 ] -> [ f4 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Embeddings and Projections for Group Products">
<Heading>Embeddings and Projections for Group Products</Heading>

The relation between a group product and its factors is provided via
homomorphisms,
the embeddings in the product and the projections from the product.
Depending on the kind of product only some of these are defined.
<P/>
<ManSection>
<Func Name="Embedding" Arg='P, nr' Label="for group products"/>

<Description>
returns the <A>nr</A>-th embedding in the group product <A>P</A>.
The actual meaning of this embedding is described in the
manual section for the appropriate product.
</Description>
</ManSection>

<ManSection>
<Func Name="Projection" Arg='P, nr' Label="for group products"/>

<Description>
returns the (<A>nr</A>-th) projection of the group product <A>P</A>.
The actual meaning of the projection returned is described in the
manual section for the appropriate product.
</Description>
</ManSection>

</Section>
</Chapter>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grplib.msk                  GAP documentation          Heiko Theißen -->
<!-- %A                                                         Volkmar Felsch -->
<!-- %A                                                         Bettina Eick -->
<!-- %A                                                         Alexander Hulpke -->
<!-- %A                                                         Hans Ulrich Besche -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grplib.msk,v 1.81 2005/12/08 22:13:29 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Group Libraries">
<Heading>Group Libraries</Heading>

When you start &GAP;, it  already knows several groups. Currently &GAP;
initially knows the following groups:
<List>
<Item>
 some basic groups, such  as cyclic groups or symmetric
    groups (see&nbsp;<Ref Sect="Basic Groups"/>),
</Item>
<Item>
 Classical matrix groups (see&nbsp;<Ref Sect="Classical Groups"/>),
</Item>
<Item>
 the transitive permutation groups of degree at most 30
    (see&nbsp;<Ref Sect="Transitive Permutation Groups"/>),
</Item>
<Item>
 a library of groups of small order (see&nbsp;<Ref Sect="Small Groups"/>),
</Item>
<Item>
  the  finite perfect  groups of   size  at most <M>10^6</M>
    (excluding 11 sizes) (see&nbsp;<Ref Sect="Finite Perfect Groups"/>).
</Item>
<Item>
  the  primitive  permutation groups of degree
    <M>&lt; 2499</M> (see&nbsp;<Ref Sect="Primitive Permutation Groups"/>),
</Item>
<Item>
  the  irreducible solvable subgroups of  <M>GL(n,p)</M> for
    <M>n>1</M> and <M>p^n &lt; 256</M> (see <Ref Sect="Irreducible Solvable Matrix Groups"/>),
</Item>
<Item>
 the irreducible maximal finite integral matrix groups
    of dimension at most  31
    (see&nbsp;<Ref Sect="Irreducible Maximal Finite Integral Matrix Groups"/>),
</Item>
<Item>
 the  crystallographic  groups  of  dimension  at most  4
<!-- %  (see&nbsp;<Ref Sect="The Crystallographic Groups Library"/>). -->
</Item>
</List>
<P/>
There   is usually no   relation  between the   groups  in the  different
libraries and a group may occur in different libraries in different
incarnations.
<P/>
Note that a system administrator may choose to install all, or
only a  few,  or even  none of the  libraries.  So some  of the libraries
mentioned below may not be available on your installation.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Basic Groups">
<Heading>Basic Groups</Heading>

There are several infinite families of groups which are parametrized by
numbers.
&GAP; provides various functions to construct these groups.
The functions always permit (but do not require) one to indicate
a filter (see&nbsp;<Ref Sect="Filters"/>),
for example <Ref Prop="IsPermGroup"/>, <Ref Prop="IsMatrixGroup"/> or
<Ref Prop="IsPcGroup"/>, in which the group shall be constructed.
There always is a default filter corresponding to a <Q>natural</Q> way
to describe the group in question.
Note that not every group can be constructed in every filter,
there may be theoretical restrictions (<Ref Prop="IsPcGroup"/> only works
for solvable groups) or methods may be available only for a few filters.
<P/>
Certain filters may admit additional hints.
For example, groups constructed in <Ref Prop="IsMatrixGroup"/> may be
constructed over a specified field, which can be given as second argument
of the function that constructs the group;
The default field is <Ref Var="Rationals"/>.

<ManSection>
<Func Name="TrivialGroup" Arg='[filter]'/>

<Description>
constructs a trivial group in the category given by the filter
<A>filter</A>.
If <A>filter</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
<P/>
<Example><![CDATA[
gap> TrivialGroup();
<pc group of size 1 with 0 generators>
gap> TrivialGroup( IsPermGroup );
Group(())
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CyclicGroup" Arg='[filt, ]n'/>

<Description>
constructs the cyclic group of size <A>n</A> in the category given by the
filter <A>filt</A>.
If <A>filt</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
<P/>
<Example><![CDATA[
gap> CyclicGroup(12);
<pc group of size 12 with 3 generators>
gap> CyclicGroup(IsPermGroup,12);
Group([ (1,2,3,4,5,6,7,8,9,10,11,12) ])
gap> matgrp1:= CyclicGroup( IsMatrixGroup, 12 );
<matrix group of size 12 with 1 generators>
gap> FieldOfMatrixGroup( matgrp1 );
Rationals
gap> matgrp2:= CyclicGroup( IsMatrixGroup, GF(2), 12 );
<matrix group of size 12 with 1 generators>
gap> FieldOfMatrixGroup( matgrp2 );
GF(2)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AbelianGroup" Arg='[filt, ]ints'/>

<Description>
constructs an abelian group in the category given by the filter
<A>filt</A> which is of isomorphism type
<M>C_{{<A>ints</A>[1]}} \times C_{{<A>ints</A>[2]}} \times \ldots
\times C_{{<A>ints</A>[n]}}</M>,
where <A>ints</A> must be a list of positive integers.
If <A>filt</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
The generators of the group returned are the elements corresponding to
the integers in <A>ints</A>.
<P/>
<Example><![CDATA[
gap> AbelianGroup([1,2,3]);
<pc group of size 6 with 3 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ElementaryAbelianGroup" Arg='[filt, ]n'/>

<Description>
constructs the elementary abelian group of size <A>n</A> in the category
given by the filter <A>filt</A>.
If <A>filt</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
<P/>
<Example><![CDATA[
gap> ElementaryAbelianGroup(8192);
<pc group of size 8192 with 13 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeAbelianGroup" Arg='[filt, ]rank'/>

<Description>
constructs the free abelian group of rank <A>n</A> in the category
given by the filter <A>filt</A>.
If <A>filt</A> is not given it defaults to <Ref Func="IsFpGroup"/>.
<P/>
<Example><![CDATA[
gap> FreeAbelianGroup(4);
<fp group on the generators [ f1, f2, f3, f4 ]>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DihedralGroup" Arg='[filt, ]n'/>

<Description>
constructs the dihedral group of size <A>n</A> in the category given by the
filter <A>filt</A>.
If <A>filt</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
<P/>
<Example><![CDATA[
gap> DihedralGroup(10);
<pc group of size 10 with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="QuaternionGroup" Arg='[filt, ]n'/>
<Func Name="DicyclicGroup" Arg='[filt, ]n'/>

<Description>
constructs the generalized quaternion group (or dicyclic group) of size
<A>n</A> in the category given by the filter <A>filt</A>.  Here, <A>n</A>
is a multiple of 4.
If <A>filt</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
Methods are also available for permutation and matrix groups (of minimal
degree and minimal dimension in coprime characteristic).
<P/>
<Example><![CDATA[
gap> QuaternionGroup(32);
<pc group of size 32 with 5 generators>
gap> g:=QuaternionGroup(IsMatrixGroup,CF(16),32);
Group([ [ [ 0, 1 ], [ -1, 0 ] ], [ [ E(16), 0 ], [ 0, -E(16)^7 ] ] ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ExtraspecialGroup" Arg='[filt, ]order, exp'/>

<Description>
Let <A>order</A> be of the form <M>p^{{2n+1}}</M>, for a prime integer
<M>p</M> and a positive integer <M>n</M>.
<Ref Func="ExtraspecialGroup"/> returns the extraspecial group of order
<A>order</A> that is determined by <A>exp</A>,
in the category given by the filter <A>filt</A>.
<P/>
If <M>p</M> is odd then admissible values of <A>exp</A> are the exponent
of the group (either <M>p</M> or <M>p^2</M>) or one of <C>'+'</C>,
<C>"+"</C>, <C>'-'</C>, <C>"-"</C>.
For <M>p = 2</M>, only the above plus or minus signs are admissible.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPcGroup"/>.
<P/>
<Example><![CDATA[
gap> ExtraspecialGroup( 27, 3 );
<pc group of size 27 with 3 generators>
gap> ExtraspecialGroup( 27, '+' );
<pc group of size 27 with 3 generators>
gap> ExtraspecialGroup( 8, "-" );
<pc group of size 8 with 3 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>AlternatingGroup</Heading>
<Func Name="AlternatingGroup" Arg='[filt, ]deg' Label="for a degree"/>
<Func Name="AlternatingGroup" Arg='[filt, ]dom' Label="for a domain"/>

<Description>
constructs the alternating group of degree <A>deg</A> in the category given
by the filter <A>filt</A>.
If <A>filt</A> is not given it defaults to <Ref Prop="IsPermGroup"/>.
In the second version, the function constructs the alternating group on
the points given in the set <A>dom</A> which must be a set of positive
integers.
<Example><![CDATA[
gap> AlternatingGroup(5);
Alt( [ 1 .. 5 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>SymmetricGroup</Heading>
<Func Name="SymmetricGroup" Arg='[filt, ]deg' Label="for a degree"/>
<Func Name="SymmetricGroup" Arg='[filt, ]dom' Label="for a domain"/>

<Description>
constructs the symmetric group of degree <A>deg</A> in the category
given by the filter <A>filt</A>.
If <A>filt</A> is not given it defaults to <Ref Prop="IsPermGroup"/>.
In the second version, the function constructs the symmetric group on
the points given in the set <A>dom</A> which must be a set of positive
integers.
<P/>
<Example><![CDATA[
gap> SymmetricGroup(10);
Sym( [ 1 .. 10 ] )
]]></Example>
<P/>
Note that permutation groups provide special treatment of symmetric and
alternating groups,
see&nbsp;<Ref Sect="Symmetric and Alternating Groups"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="MathieuGroup" Arg='[filt, ]degree'/>

<Description>
constructs the Mathieu group of degree <A>degree</A> in the category
given by the filter <A>filt</A>, where <A>degree</A> must be in the set
<M>\{ 9, 10, 11, 12, 21, 22, 23, 24 \}</M>.
If <A>filt</A> is not given it defaults to <Ref Prop="IsPermGroup"/>.
<P/>
<Example><![CDATA[
gap> MathieuGroup( 11 );
Group([ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SuzukiGroup" Arg='[filt, ] q'/>
<Func Name="Sz" Arg='[filt, ] q'/>

<Description>
Constructs a group isomorphic to the Suzuki group Sz( <A>q</A> )
over the field with <A>q</A> elements, where <A>q</A> is a non-square
power of <M>2</M>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the Suzuki group itself.
<Example><![CDATA[
gap> SuzukiGroup( 32 );
Sz(32)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ReeGroup" Arg='[filt, ] q'/>
<Func Name="Ree" Arg='[filt, ] q'/>

<Description>
Constructs a group isomorphic to the Ree group <M>^2G_2(q)</M> where
<M>q = 3^{{1+2m}}</M> for <M>m</M> a non-negative integer.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>
and the generating matrices are based on&nbsp;<Cite Key="KLM01"/>.
(No particular choice of a generating set is guaranteed.)
<P/>
<Example><![CDATA[
gap> ReeGroup( 27 );
Ree(27)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Classical Groups">
<Heading>Classical Groups</Heading>

The following functions return classical groups.
For the linear, symplectic, and unitary groups (the latter in dimension
at least <M>3</M>),
the generators are taken from&nbsp;<Cite Key="Tay87"/>.
For the unitary groups in dimension <M>2</M>, the isomorphism of
SU<M>(2,q)</M> and SL<M>(2,q)</M> is used,
see for example&nbsp;<Cite Key="Hup67"/>.
The generators of the general and special orthogonal groups are taken
from&nbsp;<Cite Key="IshibashiEarnest94"/> and
<Cite Key="KleidmanLiebeck90"/>,
except that the generators of the groups in odd dimension in even
characteristic are constructed via the isomorphism to a symplectic group,
see for example&nbsp;<Cite Key="Car72a"/>.
The generators of the groups <M>\Omega^\epsilon(d, q)</M> are taken
from&nbsp;<Cite Key="RylandsTalor98"/>,
except that the generators of SO<M>(5, 2)</M> are taken for
<M>\Omega(5, 2)</M>.
The generators for the semilinear groups are constructed from the
generators of the corresponding linear groups plus one additional
generator that describes the action of the group of field automorphisms;
for prime integers <M>p</M> and positive integers <M>f</M>,
this yields the matrix groups <M>Gamma</M>L<M>(d, p^f)</M> and
<M>Sigma</M>L<M>(d, p^f)</M> as groups of <M>d f \times df</M> matrices
over the field with <M>p</M> elements.
<P/>
For symplectic and orthogonal matrix groups returned by the functions
described below, the invariant bilinear form is stored as the value of
the attribute <Ref Attr="InvariantBilinearForm"/>.
Analogously, the invariant sesquilinear form defining the unitary groups
is stored as the value of the attribute
<Ref Attr="InvariantSesquilinearForm"/>).
The defining quadratic form of orthogonal groups is stored as the value
of the attribute <Ref Attr="InvariantQuadraticForm"/>.
<P/>
Note that due to the different sources for the generators,
the invariant forms for the groups <M>\Omega(e,d,q)</M> are in general
different from the forms for SO<M>(e,d,q)</M> and GO<M>(e,d,q)</M>.
<!--
If the <Package>Forms</Package> is loaded then compatible groups can be
created by specifying the desired form, see the examples below.
-->

<ManSection>
<Heading>GeneralLinearGroup</Heading>
<Func Name="GeneralLinearGroup" Arg='[filt, ]d, R'
 Label="for dimension and a ring"/>
<Func Name="GL" Arg='[filt, ]d, R'
 Label="for dimension and a ring"/>
<Func Name="GeneralLinearGroup" Arg='[filt, ]d, q'
 Label="for dimension and field size"/>
<Func Name="GL" Arg='[filt, ]d, q'
 Label="for dimension and field size"/>

<Description>
The first two forms construct a group isomorphic to the general linear
group GL( <A>d</A>, <A>R</A> ) of all <M><A>d</A> \times <A>d</A></M>
matrices that are invertible over the ring <A>R</A>,
in the category given by the filter <A>filt</A>.
<P/>
The third and the fourth form construct the general linear group over the
finite field with <A>q</A> elements.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the general linear group as a matrix group in
its natural action (see also&nbsp;<Ref Func="IsNaturalGL"/>,
<Ref Func="IsNaturalGLnZ"/>).
<P/>
Currently supported rings <A>R</A> are finite fields,
the ring <Ref Var="Integers"/>,
and residue class rings <C>Integers mod <A>m</A></C>,
see <Ref Sect="Residue Class Rings"/>.
<P/>
<Example><![CDATA[
gap> GL(4,3);
GL(4,3)
gap> GL(2,Integers);
GL(2,Integers)
gap> GL(3,Integers mod 12);
GL(3,Z/12Z)
]]></Example>
<P/>
<Index Key="OnLines" Subkey="example"><C>OnLines</C></Index>
Using the <Ref Func="OnLines"/> operation it is possible to obtain the
corresponding projective groups in a permutation action:
<P/>
<Example><![CDATA[
gap> g:=GL(4,3);;Size(g);
24261120
gap> pgl:=Action(g,Orbit(g,Z(3)^0*[1,0,0,0],OnLines),OnLines);;
gap> Size(pgl);
12130560
]]></Example>
<P/>
If you are interested only in the projective group as a permutation group
and not in the correspondence between its moved points and the points in
the projective space, you can also use <Ref Func="PGL"/>.
</Description>
</ManSection>

<ManSection>
<Heading>SpecialLinearGroup</Heading>
<Func Name="SpecialLinearGroup" Arg='[filt, ]d, R'
 Label="for dimension and a ring"/>
<Func Name="SL" Arg='[filt, ]d, R'
 Label="for dimension and a ring"/>
<Func Name="SpecialLinearGroup" Arg='[filt, ]d, q'
 Label="for dimension and a field size"/>
<Func Name="SL" Arg='[filt, ]d, q'
 Label="for dimension and a field size"/>

<Description>
The first two forms construct a group isomorphic to the special linear
group SL( <A>d</A>, <A>R</A> ) of all those
<M><A>d</A> \times <A>d</A></M> matrices over the ring <A>R</A> whose
determinant is the identity of <A>R</A>,
in the category given by the filter <A>filt</A>.
<P/>
The third and the fourth form construct the special linear group over the
finite field with <A>q</A> elements.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the special linear group as a matrix group in
its natural action (see also&nbsp;<Ref Func="IsNaturalSL"/>,
<Ref Func="IsNaturalSLnZ"/>).
<P/>
Currently supported rings <A>R</A> are finite fields,
the ring <Ref Var="Integers"/>,
and residue class rings <C>Integers mod <A>m</A></C>,
see <Ref Sect="Residue Class Rings"/>.
<P/>
<Example><![CDATA[
gap> SpecialLinearGroup(2,2);
SL(2,2)
gap> SL(3,Integers);
SL(3,Integers)
gap> SL(4,Integers mod 4);
SL(4,Z/4Z)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GeneralUnitaryGroup" Arg='[filt, ]d, q'/>
<Func Name="GU" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the general unitary group
GU( <A>d</A>, <A>q</A> ) of those <M><A>d</A> \times <A>d</A></M>
matrices over the field with <M><A>q</A>^2</M> elements
that respect a fixed nondegenerate sesquilinear form,
in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the general unitary group itself.
<P/>
<!--
If the &GAP; package <Package>Forms</Package> is loaded then one can also
specify the desired invariant sesquilinear form respected by the group. -->
<Example><![CDATA[
gap> GeneralUnitaryGroup( 3, 5 );
GU(3,5)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SpecialUnitaryGroup" Arg='[filt, ]d, q'/>
<Func Name="SU" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the special unitary group
GU(<A>d</A>, <A>q</A>) of those <M><A>d</A> \times <A>d</A></M> matrices
over the field with <M><A>q</A>^2</M> elements
whose determinant is the identity of the field and that respect a fixed
nondegenerate sesquilinear form,
in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the special unitary group itself.
<P/>
<!--
If the &GAP; package <Package>Forms</Package> is loaded then one can also
specify the desired invariant sesquilinear form respected by the group. -->
<Example><![CDATA[
gap> SpecialUnitaryGroup( 3, 5 );
SU(3,5)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>SymplecticGroup</Heading>
<Func Name="SymplecticGroup" Arg='[filt, ]d, q'
 Label="for dimension and field size"/>
<Func Name="SymplecticGroup" Arg='[filt, ]d, ring'
 Label="for dimension and a ring"/>
<Func Name="Sp" Arg='[filt, ]d, q'
 Label="for dimension and field size"/>
<Func Name="Sp" Arg='[filt, ]d, ring'
 Label="for dimension and a ring"/>
<Func Name="SP" Arg='[filt, ]d, q'
 Label="for dimension and field size"/>
<Func Name="SP" Arg='[filt, ]d, ring'
 Label="for dimension and a ring"/>

<Description>
constructs a group isomorphic to the symplectic group
Sp( <A>d</A>, <A>q</A> ) of those <M><A>d</A> \times <A>d</A></M>
matrices over the field with <A>q</A> elements (respectively the ring
<A>ring</A>)
that respect a fixed nondegenerate symplectic form,
in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the symplectic group itself.
<P/>
At the moment finite fields or residue class rings 
<C>Integers mod <A>q</A></C>, with <A>q</A> an odd prime power are
supported.
<!--
If the &GAP; package <Package>Forms</Package> is loaded then one can also
specify the desired invariant symplectic form respected by the group. -->
<Example><![CDATA[
gap> SymplecticGroup( 4, 2 );
Sp(4,2)
gap> g:=SymplecticGroup(6,Integers mod 9);
Sp(6,Z/9Z)
gap> Size(g);
95928796265538862080
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GeneralOrthogonalGroup" Arg='[filt, ][e, ]d, q'/>
<Func Name="GO" Arg='[filt, ][e, ]d, q'/>

<Description>
constructs a group isomorphic to the
general orthogonal group GO( <A>e</A>, <A>d</A>, <A>q</A> ) of those
<M><A>d</A> \times <A>d</A></M> matrices over the field with <A>q</A>
elements that respect a non-singular quadratic form
(see&nbsp;<Ref Func="InvariantQuadraticForm"/>) specified by <A>e</A>,
in the category given by the filter <A>filt</A>.
<P/>
The value of <A>e</A> must be <M>0</M> for odd <A>d</A> (and can
optionally be  omitted in this case), respectively one of <M>1</M> or
<M>-1</M> for even <A>d</A>.
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the general orthogonal group itself.
<P/>
<!--
If the &GAP; package <Package>Forms</Package> is loaded then one can also
specify the desired invariant quadratic form respected by the group. -->
Note that in&nbsp;<Cite Key="KleidmanLiebeck90"/>,
GO is defined as the stabilizer
<M>\Delta(V, F, \kappa)</M> of the quadratic form, up to scalars,
whereas our GO is called <M>I(V, F, \kappa)</M> there.
</Description>
</ManSection>

<ManSection>
<Func Name="SpecialOrthogonalGroup" Arg='[filt, ][e, ]d, q'/>
<Func Name="SO" Arg='[filt, ][e, ]d, q'/>

<Description>
<Ref Func="SpecialOrthogonalGroup"/> returns a group isomorphic to the 
special orthogonal group SO( <A>e</A>, <A>d</A>, <A>q</A> ),
which is the subgroup of all those matrices in the general orthogonal
group (see&nbsp;<Ref Func="GeneralOrthogonalGroup"/>) that have
determinant one, in the category given by the filter <A>filt</A>.
(The index of SO( <A>e</A>, <A>d</A>, <A>q</A> ) in
GO( <A>e</A>, <A>d</A>, <A>q</A> ) is <M>2</M> if <A>q</A> is
odd, and <M>1</M> if <A>q</A> is even.)
Also interesting is the group Omega( <A>e</A>, <A>d</A>, <A>q</A> ),
see <Ref Oper="Omega" Label="construct an orthogonal group"/>,
which is always of index <M>2</M> in SO( <A>e</A>, <A>d</A>, <A>q</A> ).
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the special orthogonal group itself.
<P/>
<!--
If the &GAP; package <Package>Forms</Package> is loaded then one can also
specify the desired invariant quadratic form respected by the group. -->
<Example><![CDATA[
gap> GeneralOrthogonalGroup( 3, 7 );
GO(0,3,7)
gap> GeneralOrthogonalGroup( -1, 4, 3 );
GO(-1,4,3)
gap> SpecialOrthogonalGroup( 1, 4, 4 );
GO(+1,4,4)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Omega" Arg='[filt, ][e, ]d, q'
 Label="construct an orthogonal group"/>

<Description>
constructs a group isomorphic to the
group <M>\Omega</M>( <A>e</A>, <A>d</A>, <A>q</A> ) of those
<M><A>d</A> \times <A>d</A></M> matrices over the field with <A>q</A>
elements that respect a non-singular quadratic form
(see&nbsp;<Ref Func="InvariantQuadraticForm"/>) specified by <A>e</A>,
and that have square spinor norm in odd characteristic
or Dickson invariant <M>0</M> in even characteristic, respectively,
in the category given by the filter <A>filt</A>.
This group has always index two in SO( <A>e</A>, <A>d</A>, <A>q</A> ),
see <Ref Func="SpecialOrthogonalGroup"/>.
<P/>
The value of <A>e</A> must be <M>0</M> for odd <A>d</A> (and can
optionally be omitted in this case), respectively one of <M>1</M> or
<M>-1</M> for even <A>d</A>.
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group is the group
<M>\Omega</M>( <A>e</A>, <A>d</A>, <A>q</A> ) itself.
<P/>
<!--
If the &GAP; package <Package>Forms</Package> is loaded then one can also
specify the desired invariant quadratic form respected by the group. -->
<Example><![CDATA[
gap> g:= Omega( 3, 5 );  StructureDescription( g );
Omega(0,3,5)
"A5"
gap> g:= Omega( 1, 4, 4 );  StructureDescription( g );
Omega(+1,4,4)
"A5 x A5"
gap> g:= Omega( -1, 4, 3 );  StructureDescription( g );
Omega(-1,4,3)
"A6"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GeneralSemilinearGroup" Arg='[filt, ]d, q'/>
<Func Name="GammaL" Arg='[filt, ]d, q'/>

<Description>
<Ref Func="GeneralSemilinearGroup"/> returns a group isomorphic to the
general semilinear group <M>\Gamma</M>L( <A>d</A>, <A>q</A> ) of
semilinear mappings of the vector space
<C>GF( </C><A>q</A><C> )^</C><A>d</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group consists of matrices of dimension
<A>d</A> <M>f</M> over the field with <M>p</M> elements,
where <A>q</A> <M>= p^f</M>, for a prime integer <M>p</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="SpecialSemilinearGroup" Arg='[filt, ]d, q'/>
<Func Name="SigmaL" Arg='[filt, ]d, q'/>

<Description>
<Ref Func="SpecialSemilinearGroup"/> returns a group isomorphic to the
special semilinear group <M>\Sigma</M>L( <A>d</A>, <A>q</A> ) of those
semilinear mappings of the vector space
<C>GF( </C><A>q</A><C> )^</C><A>d</A> 
(see <Ref Func="GeneralSemilinearGroup"/>)
whose linear part has determinant one.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsMatrixGroup"/>,
and the returned group consists of matrices of dimension
<A>d</A> <M>f</M> over the field with <M>p</M> elements,
where <A>q</A> <M>= p^f</M>, for a prime integer <M>p</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveGeneralLinearGroup" Arg='[filt, ]d, q'/>
<Func Name="PGL" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the projective general linear group
PGL( <A>d</A>, <A>q</A> ) of those <M><A>d</A> \times <A>d</A></M>
matrices over the field with <A>q</A> elements, modulo the
centre, in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPermGroup"/>,
and the returned group is the action on lines of the underlying vector
space.
<P/>
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveSpecialLinearGroup" Arg='[filt, ]d, q'/>
<Func Name="PSL" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the projective special linear group
PSL( <A>d</A>, <A>q</A> ) of those <M><A>d</A> \times <A>d</A></M>
matrices over the field with <A>q</A> elements whose determinant is the
identity of the field, modulo the centre,
in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPermGroup"/>,
and the returned group is the action on lines of the underlying vector
space.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveGeneralUnitaryGroup" Arg='[filt, ]d, q'/>
<Func Name="PGU" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the projective general unitary group
PGU( <A>d</A>, <A>q</A> ) of those <M><A>d</A> \times <A>d</A></M>
matrices over the field with <M><A>q</A>^2</M> elements that respect
a fixed nondegenerate sesquilinear form,
modulo the centre, in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPermGroup"/>,
and the returned group is the action on lines of the underlying vector
space.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveSpecialUnitaryGroup" Arg='[filt, ]d, q'/>
<Func Name="PSU" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the projective special unitary group
PSU( <A>d</A>, <A>q</A> ) of those <M><A>d</A> \times <A>d</A></M>
matrices over the field with <M><A>q</A>^2</M> elements that respect
a fixed nondegenerate sesquilinear form and have determinant 1,
modulo the centre, in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPermGroup"/>,
and the returned group is the action on lines of the underlying vector
space.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveSymplecticGroup" Arg='[filt, ]d, q'/>
<Func Name="PSP" Arg='[filt, ]d, q'/>
<Func Name="PSp" Arg='[filt, ]d, q'/>

<Description>
constructs a group isomorphic to the projective symplectic group
PSp(<A>d</A>,<A>q</A>) of those <M><A>d</A> \times <A>d</A></M> matrices
over the field with <A>q</A> elements that respect a fixed nondegenerate
symplectic form, modulo the centre,
in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPermGroup"/>,
and the returned group is the action on lines of the underlying vector
space.
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectiveOmega" Arg='[filt, ][e, ]d, q'/>
<Func Name="POmega" Arg='[filt, ][e, ]d, q'/>

<Description>
constructs a group isomorphic to the projective group
P<M>\Omega</M>( <A>e</A>, <A>d</A>, <A>q</A> )
of <M>\Omega</M>( <A>e</A>, <A>d</A>, <A>q</A> ),
modulo the centre
(see <Ref Oper="Omega" Label="construct an orthogonal group"/>),
in the category given by the filter <A>filt</A>.
<P/>
If <A>filt</A> is not given it defaults to <Ref Func="IsPermGroup"/>,
and the returned group is the action on lines of the underlying vector
space.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Conjugacy Classes in Classical Groups">
<Heading>Conjugacy Classes in Classical Groups</Heading>

<Index Key="ConjugacyClasses" Subkey="for linear groups">
<C>ConjugacyClasses</C></Index>
For  general  and   special  linear  groups  
(see&nbsp;<Ref Func="GeneralLinearGroup" Label="for dimension and a ring"/>
and&nbsp;<Ref Func="SpecialLinearGroup" Label="for dimension and a ring"/>)
&GAP;  has an efficient method  to generate
representatives  of  the conjugacy  classes.  This  uses results  from
linear algebra on normal forms of matrices. If you know how to do this
for other types of classical groups, please, tell us.
<P/>
<Example><![CDATA[
gap> g := SL(4,9);
SL(4,9)
gap> NrConjugacyClasses(g);
861
gap> cl := ConjugacyClasses(g);;
gap> Length(cl);
861
]]></Example>
<P/>
<ManSection>
<Func Name="NrConjugacyClassesGL" Arg='n, q'/>
<Func Name="NrConjugacyClassesGU" Arg='n, q'/>
<Func Name="NrConjugacyClassesSL" Arg='n, q'/>
<Func Name="NrConjugacyClassesSU" Arg='n, q'/>
<Func Name="NrConjugacyClassesPGL" Arg='n, q'/>
<Func Name="NrConjugacyClassesPGU" Arg='n, q'/>
<Func Name="NrConjugacyClassesPSL" Arg='n, q'/>
<Func Name="NrConjugacyClassesPSU" Arg='n, q'/>
<Func Name="NrConjugacyClassesSLIsogeneous" Arg='n, q, f'/>
<Func Name="NrConjugacyClassesSUIsogeneous" Arg='n, q, f'/>

<Description>
The first of these functions compute for given positive integer <A>n</A>
and prime power <A>q</A> the number of conjugacy classes in the classical
groups GL( <A>n</A>, <A>q</A> ), GU( <A>n</A>, <A>q</A> ),
SL( <A>n</A>, <A>q</A> ), SU( <A>n</A>, <A>q</A> ),
PGL( <A>n</A>, <A>q</A> ), PGU( <A>n</A>, <A>q</A> ),
PSL( <A>n</A>, <A>q</A> ), PSL( <A>n</A>, <A>q</A> ), respectively.
(See also <Ref Attr="ConjugacyClasses" Label="attribute"/>  and
Section&nbsp;<Ref Sect="Classical Groups"/>.)
<P/>
For each divisor <A>f</A> of <A>n</A> there is a group of Lie type
with the same order as SL( <A>n</A>, <A>q</A> ), such that its derived
subgroup modulo its center is isomorphic to PSL( <A>n</A>, <A>q</A> ).
The various such groups with fixed <A>n</A> and <A>q</A> are called
<E>isogeneous</E>.
(Depending on congruence conditions on <A>q</A> and <A>n</A> several of
these groups may actually be isomorphic.)
The function <Ref Func="NrConjugacyClassesSLIsogeneous"/> computes the
number of conjugacy classes in this group.
The extreme cases <A>f</A> <M>= 1</M> and <A>f</A> <M>= n</M> lead
to the groups SL( <A>n</A>, <A>q</A> ) and PGL( <A>n</A>, <A>q</A> ),
respectively.
<P/>
The function <Ref Func="NrConjugacyClassesSUIsogeneous"/> is the
analogous one for the corresponding unitary groups.
<P/>
The formulae for the number of conjugacy classes are taken
from&nbsp;<Cite Key="Mac81"/>.
<P/>
<Example><![CDATA[
gap> NrConjugacyClassesGL(24,27);
22528399544939174406067288580609952
gap> NrConjugacyClassesPSU(19,17);
15052300411163848367708
gap> NrConjugacyClasses(SL(16,16));
1229782938228219920
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructors for Basic Groups">
<Heading>Constructors for Basic Groups</Heading>

All functions described in the previous sections call constructor operations
to do the work.
The names of the constructors are obtained from the names of the functions
by appending <C>"Cons"</C>,
so for example <Ref Func="CyclicGroup"/> calls the constructor
<P/>
<C>CyclicGroupCons( <A>cat</A>, <A>n</A> )</C>
<P/>
The first argument <A>cat</A> for each method of this constructor must be
the category for which the method is installed.
For example the method for constructing a cyclic permutation group
is installed as follows (see&nbsp;<Ref Func="InstallMethod"/>
for the meaning of the arguments.
<P/>
<Log><![CDATA[
InstallMethod( CyclicGroupCons,
    "regular perm group",
    true,
    [ IsPermGroup and IsRegularProp and IsFinite, IsInt and IsPosRat ], 0,
    function( filter, n )

    ...

    end );
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Selection Functions">
<Heading>Selection Functions</Heading>

<Index Key="AllPrimitiveGroups"><C>AllPrimitiveGroups</C></Index>
<Index Key="AllTransitiveGroups"><C>AllTransitiveGroups</C></Index>
<Index Key="AllLibraryGroups"><C>All<A>Library</A>Groups</C></Index>
<C>All<A>Library</A>Groups( <A>fun1</A>, <A>val1</A>, ... )</C>
<P/>
For a number  of  the  group  libraries  two  <E>selection  functions</E>  are
provided. Each <C>All<A>Library</A>Groups</C> selection  function  permits  one  to
select <E>all</E> groups from the library <A>Library</A> that have a given  set  of
properties.
<!-- %The name of the selection  functions always begins  with <C>All</C> and always -->
<!-- %ends with <C>Groups</C>. In between is a  name that hints at the nature of the -->
<!-- %group library.  -->
Currently, the library selection functions provided, of  this  type,  are
<Ref Func="AllSmallGroups"/>, <Ref Func="AllIrreducibleSolvableGroups"/>,
<C>AllTransitiveGroups</C>, and <C>AllPrimitiveGroups</C>.
Corresponding to  each  of  these  there  is  a
<C>One<A>Library</A>Group</C> function (see below) which  returns  at
most one group.
<P/>
These functions take an arbitrary number of pairs (but at least one pair)
of arguments. The first argument in such a pair is a function that can be
applied to the groups in the library, and the second argument is either a
single value that this function must return in order to have  this  group
included in the selection, or a list of such  values.  For  the  function
<Ref Func="AllSmallGroups"/> the first such function must be
<Ref Attr="Size"/>, and, unlike  the
other library selection functions,  it  supports  an  alternative  syntax
where <Ref Func="Size"/> is omitted (see&nbsp;<Ref Func="AllSmallGroups"/>).
Also, see <Ref Func="AllIrreducibleSolvableGroups"/>,
for details pertaining to this function.
<P/>
For an example, let us consider the selection function for the library of
transitive groups
(also see&nbsp;<Ref Sect="Transitive Permutation Groups"/>).
The command
<P/>
<Log><![CDATA[
gap> AllTransitiveGroups(NrMovedPoints,[10..15],
>                        Size,         [1..100],
>                        IsAbelian,    false    );
]]></Log>
<P/>
returns a list of all transitive groups with degree between 10 and 15 and
size less than 100 that are not abelian.
<P/>
Thus <C>AllTransitiveGroups</C> behaves as if it was implemented by a
function similar to the one defined below,
where <C>TransitiveGroupsList</C> is a list of all transitive groups.
(Note that in the definition below we assume for simplicity that
<C>AllTransitiveGroups</C> accepts exactly 4 arguments.
It is of course obvious how to change this definition so that the function
would accept a variable number of arguments.)
<P/>
<Log><![CDATA[
AllTransitiveGroups := function( fun1, val1, fun2, val2 )
local    groups, g, i;
  groups := [];
  for i  in [ 1 .. Length( TransitiveGroupsList ) ] do
    g := TransitiveGroupsList[i];
    if      fun1(g) = val1  or IsList(val1) and fun1(g) in val1
        and fun2(g) = val2  or IsList(val2) and fun2(g) in val2
     then
      Add( groups, g );
    fi;
  od;
  return groups;
end;
]]></Log>
<P/>
Note that the real  selection functions are considerably  more difficult,
to improve the efficiency. Most  important, each recognizes a certain set
of properties which are precomputed for the library without having to
compute them anew for each group. This will substantially speed up the
selection process.
In the description of each library we will
list the properties that are stored for this library.
<P/>
<Index Key="OnePrimitiveGroup"><C>OnePrimitiveGroup</C></Index>
<Index Key="OneTransitiveGroup"><C>OneTransitiveGroup</C></Index>
<Index Key="OneLibraryGroup"><C>One<A>Library</A>Group</C></Index>
<C>One<A>Library</A>Group( <A>fun1</A>, <A>val1</A>, ... )</C>
<P/>
For each <C>All<A>Library</A>Groups</C> function (see above) there is
a corresponding function <C>One<A>Library</A>Group</C> on exactly the same
arguments, i.e., there are <C>OneSmallGroup</C>,
<C>OneIrreducibleSolvableGroup</C>, <C>OneTransitiveGroup</C>, and
<C>OnePrimitiveGroup</C>.
Each function simply returns <E>one</E> group in
the library that has the prescribed properties,
instead of <E>all</E> such groups.
It returns <K>fail</K> if no such group exists in the library.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Transitive Permutation Groups">
<Heading>Transitive Permutation Groups</Heading>

The transitive groups library currently contains representatives for all
transitive permutation groups of degree at most  30.
Two permutations groups of the same degree are considered to be
equivalent, if there is a renumbering of points, which maps one group into
the other one.
In other words, if they lie in the same conjugacy class under operation
of the full symmetric group by conjugation.
<P/>
The selection functions (see&nbsp;<Ref Sect="Selection Functions"/>) for the transitive
groups library are <C>AllTransitiveGroups</C> and <C>OneTransitiveGroup</C>.
They obtain the following attributes from the database without having to
compute them anew:
<P/>
<Ref Func="NrMovedPoints" Label="for a list or collection of permutations"/>,
<Ref Func="Size"/>,
<Ref Func="Transitivity" Label="for a group and an action domain"/>,
and <Ref Func="IsPrimitive" Label="for a group, an action domain, etc."/>.
<P/>
This library was computed by  Gregory Butler, John McKay, Gordon Royle
and Alexander Hulpke.  The list of transitive  groups up  to degree 11
was published in <Cite Key="BM83"/>,  the list of degree  12 was published in
<Cite Key="Roy87"/>, degree 14 and  15 were published in  <Cite Key="Butler93"/> and
degrees 16-30 were published in <Cite Key="Hulpke96"/> and <Cite Key="HulpkeTG"/>.
(Groups of prime degree of course are
primitive and were known long before.)
<P/>
The arrangement and the names of the groups of degree up to 15 is the same
as given in <Cite Key="ConwayHulpkeMcKay98"/>. With the exception of the symmetric
and alternating group (which are represented as
<Ref Func="SymmetricGroup" Label="for a degree"/>
and <Ref Func="AlternatingGroup" Label="for a degree"/>)
the generators for these groups also conform to this
paper with the only difference that 0 (which is not permitted in &GAP; for
permutations to act on) is always replaced by the degree.
<P/>
<ManSection>
<Func Name="TransitiveGroup" Arg='deg,nr'/>

<Description>
returns the <A>nr</A>-th transitive  group of degree <A>deg</A>.  Both  <A>deg</A> and
<A>nr</A> must be  positive integers. The transitive groups of equal  degree
are  sorted with  respect to   their  size, so for  example
<C>TransitiveGroup(  <A>deg</A>, 1 )</C> is a  transitive group  of degree and
size <A>deg</A>, e.g, the cyclic  group  of size <A>deg</A>,   if <A>deg</A> is a
prime.
</Description>
</ManSection>

<ManSection>
<Func Name="NrTransitiveGroups" Arg='deg'/>

<Description>
returns the number of transitive groups of degree <A>deg</A> stored in
the library of transitive groups.
The function returns <K>fail</K> if <A>deg</A> is
beyond the range of the library.
<P/>
<Example><![CDATA[
gap> TransitiveGroup(10,22);
S(5)[x]2
gap> l:=AllTransitiveGroups(NrMovedPoints,12,Size,1440,IsSolvable,false);
[ S(6)[x]2, M_10.2(12)=A_6.E_4(12)=[S_6[1/720]{M_10}S_6]2 ]
gap> List(l,IsSolvable);
[ false, false ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TransitiveIdentification" Arg='G'/>

<Description>
Let <A>G</A> be a permutation group, acting transitively on a set of up
to 30 points.
Then <Ref Func="TransitiveIdentification"/> will return the position of
this group in the transitive groups library.
This means, if <A>G</A> acts on <M>m</M> points and
<Ref Func="TransitiveIdentification"/>  returns <M>n</M>,
then <A>G</A> is permutation isomorphic to the group
<C>TransitiveGroup(m,n)</C>.
<P/>
Note: The points moved do <E>not</E> need to be [1..<A>n</A>], the group
<M>\langle (2,3,4),(2,3) \rangle</M> is considered to be transitive on 3
points. If the group has several orbits on the points moved by it the
result of <Ref Func="TransitiveIdentification"/> is undefined.
<Example><![CDATA[
gap> TransitiveIdentification(Group((1,2),(1,2,3)));
2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Small Groups">
<Heading>Small Groups</Heading>

The Small Groups library gives access to all groups of certain <Q>small</Q>
orders. The groups are sorted by their orders and they are listed up to
isomorphism; that is, for each of the available orders a complete and
irredundant list of isomorphism type representatives of groups is given.
Currently, the library contains the following groups:
<P/>
<List>
<Item>
 those of order at most 2000 except 1024 &nbsp; (<M>423\;164\;062</M> groups);
</Item>
<Item>
 those of cubefree order at most 50 000 &nbsp; (<M>395 \; 703</M> groups);
</Item>
<Item>
 those of order <M>p^7</M> for the primes <M>p = 3,5,7,11</M>
 &nbsp; (<M>907 \; 489</M> groups);
</Item>
<Item>
 those of order <M>p^n</M> for <M>n \leq 6</M> and all primes <M>p</M> 
</Item>
<Item>
 those of order <M>q^n \cdot p</M> for <M>q^n</M> dividing <M>2^8</M>, 
                   <M>3^6</M>, <M>5^5</M> or <M>7^4</M> and all primes <M>p</M> with <M>p \neq q</M>;
</Item>
<Item>
 those of squarefree order;
</Item>
<Item>
 those whose order factorises into at most 3 primes.
</Item>
</List>
<P/>
The first three items in this list cover an explicit range of orders; the 
last four provide access to infinite families of groups having orders of 
certain types.
<P/>
The library also has an identification function: it returns the library 
number of a given group. This function determines library numbers using
invariants of groups. The function is available for all orders in the 
library except for the orders 512 and 1536 and except for the orders
<M>p^5</M>, <M>p^6</M> and <M>p^7</M> above 2000.
<P/>
The library is organised in 11 layers. Each layer contains the groups of
certain orders and their corresponding group identification routines. It
is possible to install the first <M>n</M> layers of the group library and the
first <M>m</M> layers of the group identification for each <M>1 \leq m \leq n
\leq 11</M>. This might be useful to save disk space. There is an extensive
<F>README</F> file for the Small Groups library available in the <C>small</C> directory
of the &GAP; distribution containing detailed information on the layers.
A brief description of the layers is given here:
<List>
<Mark>(1)</Mark>
<Item>
 the groups whose order factorises into at most 3 primes.
</Item>
<Mark>(2)</Mark>
<Item>
 the remaining groups of order at most 1000 except 512 and 768.
</Item>
<Mark>(3)</Mark>
<Item>
 the remaining groups of order <M>2^n \cdot p</M> with <M>n \leq 8</M> and
              <M>p</M> an odd prime.
</Item>
<Mark>(4)</Mark>
<Item>
 the remaining groups of order <M>5^5</M>, <M>7^4</M> and of order 
              <M>q^n \cdot p</M> for <M>q^n</M> dividing <M>3^6</M>, <M>5^5</M> or <M>7^4</M> and 
              <M>p \neq q</M> a prime.
</Item>
<Mark>(5)</Mark>
<Item>
 the remaining groups of order at most 2000 except 1024,
              1152, 1536 and 1920.
</Item>
<Mark>(6)</Mark>
<Item>
 the groups of orders 1152 and 1920.
</Item>
<Mark>(7)</Mark>
<Item>
 the groups of order 512.
</Item>
<Mark>(8)</Mark>
<Item>
 the groups of order 1536.
</Item>
<Mark>(9)</Mark>
<Item>
 the remaining groups of order <M>p^n</M> for <M>4 \leq n \leq 6</M>.
</Item>
<Mark>(10)</Mark>
<Item>
 the remaining groups of cubefree order at most 50 000 and
               of squarefree order.
</Item>
<Mark>(11)</Mark>
<Item>
 the remaining groups of order <M>p^7</M> for <M>p = 3,5,7,11</M>.
</Item>
</List>
<P/>
The data in this library has been carefully checked and cross-checked.
It is believed to be reliable. However, no absolute guarantees are given
and users should, as always, make their own checks in critical cases.
<P/>
The data occupies about 30 MB (storing over 400 million groups in about
200 megabits). The group identification occupies about 47 MB of which
18 MB is used for the groups in layer (6). More information on the Small 
Groups library can be found on
<URL>http://www.icm.tu-bs.de/ag_algebra/software/small/</URL>
<P/>
This library has been constructed by Hans Ulrich Besche, Bettina Eick and 
E.&nbsp;A.&nbsp;O'Brien. A survey on this topic and an account of the history of 
group constructions can be found in <Cite Key="BEO01"/>. Further detailed 
information on the construction of this library is available in <Cite Key="New77"/>, 
<Cite Key="OBr90"/>, <Cite Key="OBr91"/>, <Cite Key="BescheEick98"/>, <Cite Key="BescheEick1000"/>, 
<Cite Key="BescheEick768"/>, <Cite Key="BEO00"/>, <Cite Key="EOB99"/>, <Cite Key="EOB98"/>, <Cite Key="NOV04"/>, 
<Cite Key="Gir03"/>, <Cite Key="DEi05"/>, <Cite Key="OV05"/>.
 
<Index Key="TwoGroup library"><C>TwoGroup</C> library</Index>
<Index Key="ThreeGroup library"><C>ThreeGroup</C> library</Index>
The Small Groups library incorporates the &GAP;&nbsp;3 libraries <C>TwoGroup</C> and
<C>ThreeGroup</C>. The data from these libraries was directly included into the
Small Groups library, and the ordering there was preserved. The Small
Groups library replaces the Gap 3 library of solvable groups of order at
most 100. However, both the organisation and data descriptions of these
groups has changed in the Small Groups library.
<P/>
<ManSection>
<Func Name="SmallGroup" Arg='order, i'
 Label="for group order and index"/>
<Func Name="SmallGroup" Arg='pair' Label="for a pair [ order, index ]"/>

<Description>
returns the <A>i</A>-th group of order <A>order</A> in the catalogue.
If the group is solvable, it will be given as a PcGroup;
otherwise it will be given as a permutation group.
If the groups of order <A>order</A> are not installed,
the function reports an error and enters a break loop.
</Description>
</ManSection>

<ManSection>
<Func Name="AllSmallGroups" Arg='arg'/>

<Description>
returns all groups with certain properties as specified by <A>arg</A>.
If <A>arg</A> is a number <M>n</M>, then this function returns all groups
of order <M>n</M>.
However, the function can also take several arguments which then
must be organized in pairs <C>function</C> and <C>value</C>.
In this case the first function must be <Ref Func="Size"/>
and the first value an order or a range of orders.
If value is a list then it is considered a list of possible function
values to include. 
The function returns those groups of the specified orders having those
properties specified by the remaining functions and their values.
<P/>
Precomputed information is stored for the properties
<Ref Func="IsAbelian"/>, <Ref Func="IsNilpotentGroup"/>,
<Ref Func="IsSupersolvableGroup"/>, <Ref Func="IsSolvableGroup"/>, 
<Ref Func="RankPGroup"/>, <Ref Func="PClassPGroup"/>,
<Ref Func="LGLength"/>, <C>FrattinifactorSize</C> and 
<C>FrattinifactorId</C> for the groups of order at most
<M>2000</M> which have  more than three prime factors,
except those of order <M>512</M>, <M>768</M>, 
<M>1024</M>, <M>1152</M>, <M>1536</M>, <M>1920</M> and those of order
<M>p^n \cdot q > 1000</M> 
with <M>n > 2</M>. 
</Description>
</ManSection>

<ManSection>
<Func Name="OneSmallGroup" Arg='arg'/>

<Description>
returns one group with certain properties as specified by <A>arg</A>.
The permitted arguments are those supported by
<Ref Func="AllSmallGroups"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="NumberSmallGroups" Arg='order'/>

<Description>
returns the number of groups of order <A>order</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="IdSmallGroup" Arg='G'/>
<Attr Name="IdGroup" Arg='G'/>

<Description>
returns the library number of <A>G</A>; that is, the function returns a pair
<C>[<A>order</A>, <A>i</A>]</C> where <A>G</A> is isomorphic to <C>SmallGroup( <A>order</A>, <A>i</A> )</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="IdsOfAllSmallGroups" Arg='arg'/>

<Description>
similar to <C>AllSmallGroups</C> but returns ids instead of groups. This may
prevent workspace overflows, if a large number of groups are expected in 
the output.
</Description>
</ManSection>

<ManSection>
<Attr Name="IdGap3SolvableGroup" Arg='G'/>
<Attr Name="Gap3CatalogueIdGroup" Arg='G'/>

<Description>
returns the catalogue number of <A>G</A> in the &GAP;&nbsp;3 catalogue
of solvable groups;
that is, the function returns a pair <C>[<A>order</A>, <A>i</A>]</C> meaning that
<A>G</A> is isomorphic to the group
<C>SolvableGroup( <A>order</A>, <A>i</A> )</C> in &GAP;&nbsp;3.
</Description>
</ManSection>

<ManSection>
<Func Name="SmallGroupsInformation" Arg='order'/>

<Description>
prints information on the groups of the specified order.
</Description>
</ManSection>

<ManSection>
<Func Name="UnloadSmallGroupsData" Arg=''/>

<Description>
&GAP; loads all necessary data from the library automatically,
but it does not delete the data from the workspace again.
Usually, this will be not necessary, since the data is stored in a
compressed format. However, if 
a large number of groups from the library have been loaded, then the user 
might wish to remove the data from the workspace and this can be done by 
the above function call.
<Example><![CDATA[
gap> G := SmallGroup( 768, 1000000 );
<pc group of size 768 with 9 generators>
gap> G := SmallGroup( [768, 1000000] );
<pc group of size 768 with 9 generators>
gap> AllSmallGroups( 6 );
[ <pc group of size 6 with 2 generators>, 
  <pc group of size 6 with 2 generators> ]
gap> AllSmallGroups( Size, 120, IsSolvableGroup, false );
[ Group(
    [ (1,2,4,8)(3,6,9,5)(7,12,13,17)(10,14,11,15)(16,20,21,24)(18,22,
        19,23), (1,3,7)(2,5,10)(4,9,13)(6,11,8)(12,16,20)(14,18,
        22)(15,19,23)(17,21,24) ]), Group([ (1,2,3,4,5), (1,2) ]), 
  Group([ (1,2,3,5,4), (1,3)(2,4)(6,7) ]) ]
gap> G := OneSmallGroup( 120, IsNilpotentGroup, false );
<pc group of size 120 with 5 generators>
gap> IdSmallGroup(G);
[ 120, 1 ]
gap> G := OneSmallGroup( Size, [1..1000], IsSolvableGroup, false );
Group([ (1,2,3,4,5), (1,2,3) ])
gap> IdSmallGroup(G);
[ 60, 5 ]
gap> UnloadSmallGroupsData();
gap> IdSmallGroup( GL( 2,3 ) );
[ 48, 29 ]
gap> IdSmallGroup( Group( (1,2,3,4),(4,5) ) );
[ 120, 34 ]
gap> IdsOfAllSmallGroups( Size, 60, IsSupersolvableGroup, true );
[ [ 60, 1 ], [ 60, 2 ], [ 60, 3 ], [ 60, 4 ], [ 60, 6 ], [ 60, 7 ], 
  [ 60, 8 ], [ 60, 10 ], [ 60, 11 ], [ 60, 12 ], [ 60, 13 ] ]
gap> NumberSmallGroups( 512 );
10494213
gap> NumberSmallGroups( 2^8 * 23 );
1083472
]]></Example>
<P/>
<Log><![CDATA[
gap> NumberSmallGroups( 2^9 * 23 );
Error, the library of groups of size 11776 is not available called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
gap>
]]></Log>
<P/>
<Example><![CDATA[
gap> SmallGroupsInformation( 32 );

  There are 51 groups of order 32.
  They are sorted by their ranks. 
     1 is cyclic. 
     2 - 20 have rank 2.
     21 - 44 have rank 3.
     45 - 50 have rank 4.
     51 is elementary abelian. 

  For the selection functions the values of the following attributes 
  are precomputed and stored:
     IsAbelian, PClassPGroup, RankPGroup, FrattinifactorSize and 
     FrattinifactorId. 

  This size belongs to layer 2 of the SmallGroups library. 
  IdSmallGroup is available for this size. 
 
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finite Perfect Groups">
<Heading>Finite Perfect Groups</Heading>

<Index>perfect groups</Index>
The &GAP; library of finite  perfect groups provides, up to isomorphism,
a list of all perfect groups whose sizes are less than  <M>10^6</M>  excluding
the following sizes:
<P/>
<List>
<Item>
      For <M>n = 61440</M>, 122880, 172032, 245760, 344064, 491520, 688128, or
      983040,  the perfect groups  of size  <M>n</M>  have not completely been
      determined yet.  The library  neither provides  the number of these
      groups nor the groups themselves.
</Item>
<Item>
      For  <M>n = 86016</M>,  368640,  or  737280,  the library  does not  yet
      contain  the perfect groups  of size  <M>n</M>,  it  only provides their
      numbers which are 52, 46, and 54, respectively.
</Item>
</List>
<P/>
Except for these eleven sizes, the list of altogether 1097 perfect groups
in the  library is complete.  It relies  on results of  Derek&nbsp;F. Holt and
Wilhelm Plesken which  are published in their  book    <Q>Perfect Groups</Q>
<Cite Key="HP89"/>. Moreover,   they     have  supplied us    with    files with
presentations of 488 of the groups. In terms of  these, the remaining 607
nontrivial groups in the library can be described as 276 direct products,
107  central   products, and 224  subdirect  products.  They are computed
automatically by suitable &GAP; functions whenever they are needed.  Two
additional groups omitted from the book <Q>Perfect Groups</Q> have also been
included.
<P/>
We are grateful to Derek Holt and Wilhelm Plesken for making their groups
available to the &GAP; community  by contributing their files. It should
be noted that  their book contains a  lot of further information for many
of the library groups.  So we would like  to recommend  it to any  &GAP;
user who is interested in the groups.
<P/>
The library has been brought into &GAP; format by Volkmar Felsch.
<P/>
As  all groups are stored  by presentations, a permutation representation
is obtained by coset enumeration. Note that some of the library groups do
not have a   faithful   permutation  representation  of small     degree.
Computations in these groups may be rather time consuming.

<ManSection>
<Func Name="SizesPerfectGroups" Arg=''/>

<Description>
This is the ordered list of all numbers up to <M>10^6</M> that occur as
sizes of perfect groups.
One can iterate over the perfect groups library with:
<Example><![CDATA[
gap> for n in SizesPerfectGroups() do
>      for k in [1..NrPerfectLibraryGroups(n)] do
>        pg := PerfectGroup(n,k);
>      od;
>    od;
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>PerfectGroup</Heading>
<Func Name="PerfectGroup" Arg='[filt, ]size[, n]'
 Label="for group order (and index)"/>
<Func Name="PerfectGroup" Arg='[filt, ]sizenumberpair'
 Label="for a pair [ order, index ]"/>

<Description>
returns a group which is isomorphic to the library group specified
by the size number <C>[ <A>size</A>, <A>n</A> ]</C> or by the two
separate arguments <A>size</A> and <A>n</A>, assuming a default value of
<M><A>n</A> = 1</M>.
The optional argument <A>filt</A> defines the filter in which the group is
returned.
Possible filters so far are <Ref Func="IsPermGroup"/> and
<Ref Func="IsSubgroupFpGroup"/>.
In the latter case, the  generators and relators used coincide with those
given in&nbsp;<Cite Key="HP89"/>.
<Example><![CDATA[
gap> G := PerfectGroup(IsPermGroup,6048,1);
U3(3)
gap> G:=PerfectGroup(IsPermGroup,823080,2);
A5 2^1 19^2 C 19^1
gap> NrMovedPoints(G);
6859
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PerfectIdentification" Arg='G'/>

<Description>
This attribute is set for all groups obtained from the perfect groups
library and has the value <C>[<A>size</A>,<A>nr</A>]</C> if the group is obtained with
these parameters from the library.
</Description>
</ManSection>

<ManSection>
<Func Name="NumberPerfectGroups" Arg='size'/>

<Description>
returns the number of non-isomorphic perfect groups of size <A>size</A> for
each positive integer  <A>size</A> up to <M>10^6</M> except for the eight  sizes
listed at the beginning  of  this section for  which the number is not
yet known. For these values as well as for any argument out of range it
returns <K>fail</K>.
</Description>
</ManSection>

<ManSection>
<Func Name="NumberPerfectLibraryGroups" Arg='size'/>

<Description>
returns the number of perfect groups of size <A>size</A> which are available
in the  library of finite perfect groups. (The purpose  of the function
is  to provide a simple way  to formulate a loop over all library groups
of a given size.)
</Description>
</ManSection>

<ManSection>
<Func Name="SizeNumbersPerfectGroups" Arg='factor1, factor2, ...'/>

<Description>
<Ref Func="SizeNumbersPerfectGroups"/> returns a list of pairs,
each entry consisting of a group order and the number of those groups in
the library of perfect groups that contain the specified factors
<A>factor1</A>, <A>factor2</A>, ...
among their composition factors.
<P/>
Each argument must either be the name of a simple group or an integer
which stands for the product of the sizes of one or more cyclic factors.
(In fact, the function replaces all integers among the arguments
by their product.)
<P/>
The following text strings are accepted as simple group names.
<List>
<Item>
   <C>A<A>n</A></C> or <C>A(<A>n</A>)</C> for the alternating groups
   <M>A_{<A>n</A>}</M>,
   <M>5 \leq n \leq 9</M>, for example <C>A5</C> or <C>A(6)</C>.
</Item>
<Item>
   <C>L<A>n</A>(<A>q</A>)</C> or <C>L(<A>n</A>,<A>q</A>)</C> for
   PSL<M>(n,q)</M>, where
   <M>n \in \{ 2, 3 \}</M> and <M>q</M> a prime power, ranging
   <List>
   <Item>
      for <M>n = 2</M> from 4 to 125
   </Item>
   <Item>
      for <M>n = 3</M> from 2 to 5
   </Item>
   </List>
</Item>
<Item>
   <C>U<A>n</A>(<A>q</A>)</C> or <C>U(<A>n</A>,<A>q</A>)</C> for
   PSU<M>(n,q)</M>, where
   <M>n \in \{ 3, 4 \}</M> and <M>q</M> a prime power, ranging
   <List>
   <Item>
      for <M>n = 3</M> from 3 to 5
   </Item>
   <Item>
      for <M>n = 4</M> from 2 to 2
   </Item>
   </List>
</Item>
<Item>
   <C>Sp4(4)</C> or <C>S(4,4)</C> for the symplectic group Sp<M>(4,4)</M>,
</Item>
<Item>
   <C>Sz(8)</C> for the Suzuki group Sz<M>(8)</M>,
</Item>
<Item>
   <C>M<A>n</A></C> or <C>M(<A>n</A>)</C> for the Mathieu groups
   <M>M_{11}</M>, <M>M_{12}</M>, and <M>M_{22}</M>, and
</Item>
<Item>
   <C>J<A>n</A></C> or <C>J(<A>n</A>)</C> for the Janko groups
   <M>J_1</M> and <M>J_2</M>.
</Item>
</List>
<P/>
Note  that, for  most  of the  groups,   the  preceding list  offers  two
different  names in order  to  be consistent  with the  notation used  in
<Cite Key="HP89"/> as well as with the notation used in the
<Ref Func="DisplayCompositionSeries"/> command of &GAP;.
However, as the names are
compared  as text strings, you are  restricted to  the above choice. Even
expressions like <C>L2(2^5)</C> are not accepted.
<P/>
As the use of the term PSU<M>(n,q)</M> is not unique in the literature,
we mention that in this library it denotes the factor group of
SU<M>(n,q)</M> by its centre, where SU<M>(n,q)</M> is the group of all
<M>n \times n</M> unitary matrices with entries in <M>GF(q^2)</M>
and determinant 1.
<P/>
The purpose  of the function is  to provide a  simple way to  formulate a
loop over all library groups which contain certain composition factors.
</Description>
</ManSection>

<ManSection>
<Heading>DisplayInformationPerfectGroups</Heading>
<Func Name="DisplayInformationPerfectGroups" Arg='size[, n]'
 Label="for group order (and index)"/>
<Func Name="DisplayInformationPerfectGroups" Arg='sizenumberpair'
 Label="for a pair [ order, index ]"/>

<Description>
<Ref Func="DisplayInformationPerfectGroups" Label="for group order (and index)"/>
displays some invariants of the <A>n</A>-th group of order <A>size</A>
from the perfect groups library.
<P/>
If no value of <A>n</A> has been specified, the invariants will be
displayed for all groups of size <A>size</A> available in the library.
<P/>
Alternatively, also a list of length two may be entered as the only
argument, with entries <A>size</A> and <A>n</A>.
<P/>
The information provided for <M>G</M> includes the following items:
<List>
<Item>
      a headline containing the size number <C>[ <A>size</A>, <A>n</A> ]</C> of <M>G</M>
      in the form <C><A>size</A>.<A>n</A></C> (the suffix <C>.<A>n</A></C> will be suppressed
      if, up to isomorphism, <M>G</M> is the only perfect group of order
      <A>size</A>),
</Item>
<Item>
 a message if <M>G</M> is simple  or quasisimple, i.e.,
      if the factor group of <M>G</M> by its centre is simple,
</Item>
<Item>
 the <Q>description</Q> of  the structure of  <M>G</M> as it is
    given by Holt and Plesken in&nbsp;<Cite Key="HP89"/> (see below),
</Item>
<Item>
 the size of  the centre of <M>G</M>  (suppressed, if <M>G</M> is
    simple),
</Item>
<Item>
 the prime decomposition of the size of <M>G</M>,
</Item>
<Item>
 orbit sizes for  a faithful permutation representation
    of <M>G</M> which is provided by the library (see below),
</Item>
<Item>
 a reference to each occurrence of <M>G</M> in the tables of
    section 5.3    of  <Cite Key="HP89"/>. Each  of   these  references
    consists of a class number and an internal number <M>(i,j)</M> under which
    <M>G</M> is listed in that class. For some groups, there  is more than one
    reference because these groups belong to more than one of the classes
    in the book.
</Item>
</List>
<Example><![CDATA[
gap> DisplayInformationPerfectGroups( 30720, 3 );
#I Perfect group 30720:  A5 ( 2^4 E N 2^1 E 2^4 ) A
#I   size = 2^11*3*5  orbit size = 240
#I   Holt-Plesken class 1 (9,3)
gap> DisplayInformationPerfectGroups( 30720, 6 );
#I Perfect group 30720:  A5 ( 2^4 x 2^4 ) C N 2^1
#I   centre = 2  size = 2^11*3*5  orbit size = 384
#I   Holt-Plesken class 1 (9,6)
gap> DisplayInformationPerfectGroups( Factorial( 8 ) / 2 );
#I Perfect group 20160.1:  A5 x L3(2) 2^1
#I   centre = 2  size = 2^6*3^2*5*7  orbit sizes = 5 + 16
#I   Holt-Plesken class 31 (1,1) (occurs also in class 32)
#I Perfect group 20160.2:  A5 2^1 x L3(2)
#I   centre = 2  size = 2^6*3^2*5*7  orbit sizes = 7 + 24
#I   Holt-Plesken class 31 (1,2) (occurs also in class 32)
#I Perfect group 20160.3:  ( A5 x L3(2) ) 2^1
#I   centre = 2  size = 2^6*3^2*5*7  orbit size = 192
#I   Holt-Plesken class 31 (1,3)
#I Perfect group 20160.4:  simple group  A8
#I   size = 2^6*3^2*5*7  orbit size = 8
#I   Holt-Plesken class 26 (0,1)
#I Perfect group 20160.5:  simple group  L3(4)
#I   size = 2^6*3^2*5*7  orbit size = 21
#I   Holt-Plesken class 27 (0,1)
]]></Example>
</Description>
</ManSection>


<Subsection Label="More about the Perfect Groups Library">
<Heading>More about the Perfect Groups Library</Heading>

For any library  group  <M>G</M>, the library    files do not  only provide  a
presentation, but, in  addition, a list  of  one or more subgroups  <M>S_1,
\ldots,  S_r</M>  of   <M>G</M> such   that   there is  a   faithful  permutation
representation of <M>G</M> of degree <M>\sum_{{i = 1}}^r [G:S_i]</M>
on the set <M>\{ S_i g \mid 1 \leq i \leq r, g \in G \}</M>
of the cosets of the <M>S_i</M>.
This allows one to construct the groups as permutation groups.
The function <Ref Func="DisplayInformationPerfectGroups"
Label="for group order (and index)"/> displays only the available degree.
The message
<Log><![CDATA[
orbit size = 8
]]></Log>
<P/>
in the above example means that the available permutation representation
is transitive and of degree 8, whereas the message
<Log><![CDATA[
orbit sizes = 5 + 16
]]></Log>
means that a nontransitive  permutation representation is available which
acts on two orbits of size 5 and 16 respectively.
<P/>
The  notation used in  the <Q>description</Q>  of  a  group is explained  in
section&nbsp;5.1.2 of <Cite Key="HP89"/>.
We quote the respective page from there:
<P/>
Within a class <M>Q\,\#\,p</M>, an isomorphism type of groups will be  denoted
by an ordered pair of integers <M>(r,n)</M>, where <M>r \geq 0</M>  and  <M>n  >  0</M>.
More precisely, the isomorphism types in <M>Q \# p</M> of order <M>p^r |Q|</M> will
be denoted by <M>(r,1), (r,2), (r,3), \ldots\,</M>. Thus <M>Q</M> will  always  get
the size number <M>(0,1)</M>.
<P/>
In addition to the symbol <M>(r,n)</M>, the groups in <M>Q\,\#\,p</M> will also  be
given a more descriptive name. The purpose of this is to provide  a  very
rough idea of the structure of the group. The names are  derived  in  the
following manner. First of all, the isomorphism  classes  of  irreducible
<M>F_pQ</M>-modules <M>M</M> with <M>|Q|.|M| \leq 10^6</M>, where <M>F_p</M> is the field  of
order <M>p</M>, are assigned symbols.
These will either be simply <M>p^x</M>, where <M>x</M> is the dimension of
the module, or, if there is more than one isomorphism class of irreducible
modules having the same dimension, they will be denoted by<M>p^x</M>,
<M>p^{{x'}}</M>, etc.
The  one-dimensional  module
with trivial <M>Q</M>-action will therefore be denoted by <M>p^1</M>. These symbols
will be listed under the description of  <M>Q</M>.  The  group  name  consists
essentially of a list of the composition factors working from the top  of
the group downwards; hence it always starts with the name of <M>Q</M>  itself.
(This convention is the  most  convenient  in  our  context,  but  it  is
different from that adopted in the ATLAS <Cite Key="CCN85"/>, for example, where
composition factors are listed in the  reverse  order.  For  example,  we
denote a group isomorphic to <M>SL(2,5)</M> by <M>A_5 2^1</M> rather than <M>2.A_5</M>.)
<P/>
Some  other symbols are used  in the name, in order  to give some idea of
the   relationship  between these    composition  factors, and  splitting
properties. We shall now list these additional symbols.
<P/>
<List>
<Mark><M>\times</M></Mark>
<Item>
  between  two  factors   denotes   a  direct  product  of
      <M>F_pQ</M>-modules or groups.
</Item>
<Mark>C</Mark>
<Item>
 (for <Q>commutator</Q>) between two factors  means  that the second
      lies in the commutator subgroup of the first.  Similarly, a segment
      of the form  <M>(f_1 \! \times \! f_2) C f_3</M>  would mean  that
      the factors <M>f_1</M> and <M>f_2</M>  commute modulo <M>f_3</M> and <M>f_3</M> lies in
      <M>[f_1,f_2]</M>.
</Item>
<Mark>A</Mark>
<Item>
 (for <Q>abelian</Q>) between two factors  indicates that the second
      is  in the  <M>p</M>th  power  (but not the commutator subgroup)  of the
      first.   <Q>A</Q>   may  also   follow  the  factors,   if  bracketed.
</Item>
<Mark>E</Mark>
<Item>
 (for <Q>elementary abelian</Q>) between two factors  indicates that
      together   they  generate  an  elementary  abelian  group   (modulo
      subsequent factors), but that the resulting <M>F_p Q</M>-module extension
      does not split.
</Item>
<Mark>N</Mark>
<Item>
  (for <Q>nonsplit</Q>) before  a  factor  indicates  that  <M>Q</M>  (or
      possibly its covering group)  splits down as far at this factor but
      not over the factor itself.  So  <Q><M>Q f_1 N f_2</M></Q> means that
      the normal subgroup  <M>f_1 f_2</M>  of the group  has no complement but,
      modulo <M>f_2</M>, <M>f_1</M>, does have a complement.
</Item>
</List>
<P/>
Brackets have their obvious meaning. Summarizing, we have:
<P/>
<List>
<Mark><M>\times</M></Mark>
<Item>
 = direct product;
</Item>
<Mark>C</Mark>
<Item>
 = commutator subgroup;
</Item>
<Mark>A</Mark>
<Item>
 = abelian;
</Item>
<Mark>E</Mark>
<Item>
 = elementary abelian; and
</Item>
<Mark>N</Mark>
<Item>
 = nonsplit.
</Item>
</List>
<P/>
Here are some examples.
<P/>
<List>
<Mark>(i)</Mark>
<Item>
  <M>A_5 (2^4 E 2^1 E 2^4) A</M>  means  that  the
      pairs  <M>2^4 E 2^1</M>  and <M>2^1 E 2^4</M> are both elementary
      abelian of exponent 4.
</Item>
<Mark>(ii)</Mark>
<Item>
   <M>A_5 (2^4 E 2^1 A) C 2^1</M> means that
   <M>O_2(G)</M> is of symplectic type <M>2^{{1+5}}</M>,
   with Frattini factor group of type <M>2^4 E 2^1</M>.
   The <Q>A</Q> after the <M>2^1</M> indicates that <M>G</M> has a central
   cyclic subgroup <M>2^1 A 2^1</M> of order 4.
</Item>
<Mark>(iii)</Mark>
<Item>
   <M>L_3(2) ((2^1 E) \! \times \! ( N 2^3 E 2^{{3'}} A) C) 2^{{3'}}</M> 
      means that the <M>2^{{3'}}</M>
      factor at the bottom lies in the commutator subgroup
      of the pair <M>2^3 E 2^{{3'}}</M> in the middle, but the lower
      pair <M>2^{{3'}} A 2^{{3'}}</M>  is abelian of exponent 4.
      There  is  also  a submodule  <M>2^1 E 2^{{3'}}</M>,  and  the
      covering group  <M>L_3(2) 2^1</M>  of  <M>L_3(2)</M>  does not split over the
      <M>2^3</M>  factor.  (Since <M>G</M> is perfect,  it goes without saying that
      the extension <M>L_3(2) 2^1</M> cannot split itself.)
</Item>
</List>
<P/>
We  must  stress  that this  notation does   not  always succeed in being
precise  or even unambiguous, and the  reader is free to  ignore it if it
does not seem helpful.
<P/>
If such a group description has been given in the book for <M>G</M>
(and, in fact, this is the case for most of the library groups),
it is displayed by <Ref Func="DisplayInformationPerfectGroups"
Label="for group order (and index)"/>.
Otherwise the function provides a less explicit description of the
(in these cases unique) Holt-Plesken class to which <M>G</M> belongs,
together with a serial number if this is necessary to make it unique.

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Primitive Permutation Groups">
<Heading>Primitive Permutation Groups</Heading>

&GAP; contains a library of primitive permutation groups which includes,
up to permutation isomorphism (i.e., up to conjugacy in the corresponding
symmetric group),
all  primitive  permutation groups of  degree <M>&lt;&nbsp;2500</M>,
calculated in <Cite Key="RoneyDougal05"/>,
in particular,
<List>
<Item>
  the primitive permutation groups up to degree&nbsp;50,
  calculated by C.&nbsp;Sims,
</Item>
<Item>
  the primitive groups with insoluble socles of degree
  <M>&lt;&nbsp;1000</M> as calculated in <Cite Key="DixonMortimer88"/>,
</Item>
<Item>
  the solvable (hence affine) primitive permutation groups of degree
  <M>&lt;&nbsp;256</M> as calculated by M.&nbsp;Short <Cite Key="Sho92"/>,
</Item>
<Item>
  some insolvable affine primitive permutation groups of degree
  <M>&lt;&nbsp;256</M> as calculated in <Cite Key="Theissen97"/>.
</Item>
<Item>
  The solvable primitive groups of degree up to <M>999</M> as calculated
  in <Cite Key="EickHoefling02"/>.
</Item>
<Item>
  The primitive groups of affine type of degree up to <M>999</M> as
  calculated in <Cite Key="RoneyDougal02"/>.
</Item>
</List>
<P/>
Not all groups are named, those which do have names use ATLAS notation.
Not all names are necessary unique!
<P/>
The list given in <Cite Key="RoneyDougal05"/> is believed to be complete,
correcting various omissions in <Cite Key="DixonMortimer88"/>,
<Cite Key="Sho92"/> and <Cite Key="Theissen97"/>.
<P/>
In detail, we guarantee the following properties for this and further
versions (but <E>not</E> versions which came before &GAP;&nbsp;4.2)
of the library:
<P/>
<List>
<Item>
  All groups in the library are primitive permutation groups
  of the indicated degree.
</Item>
<Item>
  The positions of the groups in the library are stable.
  That is <C>PrimitiveGroup(<A>n</A>,<A>nr</A>)</C> will always give you
  a permutation isomorphic group.
  Note however that we do not guarantee to keep the chosen
  <M>S_n</M>-representative, the generating set or the name for eternity.
</Item>
<Item>
  Different groups in the library are not conjugate in <M>S_n</M>.
</Item>
<Item>
  If a group in the library has a primitive subgroup with the same socle,
  this group is in the library as well.
</Item>
</List>
<P/>
(Note that the arrangement of groups is not guaranteed to be in
increasing size, though it holds for many degrees.)

<P/>
The selection functions (see&nbsp;<Ref Sect="Selection Functions"/>) for
the primitive groups library are <C>AllPrimitiveGroups</C> and
<C>OnePrimitiveGroup</C>.
They obtain the following properties from the database without having to
compute them anew: 
<P/>
<Ref Attr="NrMovedPoints" Label="for a list or collection of permutations"/>,
<Ref Attr="Size"/>,
<Ref Attr="Transitivity" Label="for a group and an action domain"/>,
<Ref Attr="ONanScottType"/>,
<Ref Prop="IsSimpleGroup"/>,
<Ref Prop="IsSolvableGroup"/>,
and <Ref Attr="SocleTypePrimitiveGroup"/>.
<P/>
(Note, that for groups of degree up to 2499, O'Nan-Scott types 4a, 4b and
5 cannot occur.)

<ManSection>
<Func Name="PrimitiveGroup" Arg='deg,nr'/>

<Description>
returns the primitive permutation  group of degree <A>deg</A> with number <A>nr</A>
from the list. 
<P/>
The arrangement of the groups differs from the arrangement of primitive
groups in the list of C.&nbsp;Sims, which was used in &GAP;&nbsp;3. See
<Ref Func="SimsNo"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="NrPrimitiveGroups" Arg='deg'/>

<Description>
returns the number of primitive permutation groups of degree <A>deg</A> in the
library.
<Example><![CDATA[
gap> NrPrimitiveGroups(25);
28
gap> PrimitiveGroup(25,19);
5^2:((Q(8):3)'4)
gap> PrimitiveGroup(25,20);
ASL(2, 5)
gap> PrimitiveGroup(25,22);
AGL(2, 5)
gap> PrimitiveGroup(25,23);
(A(5) x A(5)):2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrimitiveGroupsIterator" Arg='attr1,val1,attr2,val2,...'/>

<Description>
returns an iterator through
<C>AllPrimitiveGroups(<A>attr1</A>,<A>val1</A>,<A>attr2</A>,<A>val2</A>,...)</C> without creating
all these groups at the same time.
</Description>
</ManSection>


<ManSection>
<Var Name="COHORTS_PRIMITIVE_GROUPS"/>

<Description>
In <Cite Key="DixonMortimer88"/> the primitive groups are sorted in
<Q>cohorts</Q> according to their socle. For each degree, the variable
<Ref Var="COHORTS_PRIMITIVE_GROUPS"/> contains a list of the cohorts
for the primitive groups of this degree. Each cohort is represented by a
list of length 2, the first entry specifies the socle type (see
<Ref Func="SocleTypePrimitiveGroup"/>), the second
entry listing the index numbers of the groups in this degree.
<P/>
For example in degree 49, we have four cohorts with socles <M>(&ZZ; / 7 &ZZ;)^2</M>,
<M>L_2(7)^2</M>, <M>A_7^2</M> and <M>A_{49}</M> respectively. the group
<C>PrimitiveGroup(49,36)</C>,
which is isomorphic to <M>(A_7 \times A_7):2^2</M>, lies
in the third cohort with socle <M>(A_7 \times A_7)</M>.
<P/>
<Example><![CDATA[
gap> COHORTS_PRIMITIVE_GROUPS[49];
[ [ rec( parameter := 7, series := "Z", width := 2 ), 
      [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
          18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 
          33 ] ], 
  [ rec( parameter := [ 2, 7 ], series := "L", width := 2 ), [ 34 ] ],
  [ rec( parameter := 7, series := "A", width := 2 ), 
      [ 35, 36, 37, 38 ] ], 
  [ rec( parameter := 49, series := "A", width := 1 ), [ 39, 40 ] ] ]
]]></Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Index numbers of primitive groups">
<Heading>Index numbers of primitive groups</Heading>

<ManSection>
<Attr Name="PrimitiveIdentification" Arg='G'/>

<Description>
For a primitive permutation group for which an <M>S_n</M>-conjugate exists in
the library of primitive permutation groups
(see&nbsp;<Ref Sect="Primitive Permutation Groups"/>),
this attribute returns the index position. That is <A>G</A> is
conjugate to
<C>PrimitiveGroup(NrMovedPoints(<A>G</A>),PrimitiveIdentification(<A>G</A>))</C>.
<P/>
Methods only exist if the primitive groups library is installed.
<P/>
Note: As this function uses the primitive groups library, the result is
only guaranteed to the same extent as this library. If it is incomplete,
<C>PrimitiveIdentification</C> might return an existing index number for a
group not in the library.
<Example><![CDATA[
gap> PrimitiveIdentification(Group((1,2),(1,2,3)));
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SimsNo" Arg='G'/>

<Description>
If <A>G</A> is a primitive group obtained by <Ref Func="PrimitiveGroup"/>
(respectively one of the selection functions) this attribute contains the
number of the isomorphic group in the original list of C.&nbsp;Sims.
(This is the arrangement as it was used in &GAP;&nbsp;3.)
<P/>
<Example><![CDATA[
gap> g:=PrimitiveGroup(25,2);
5^2:S(3)
gap> SimsNo(g);
3
]]></Example>
<P/>
As mentioned in the previous section, the index numbers of primitive
groups in &GAP; are guaranteed to remain stable. (Thus, missing groups
will be added to the library at the end of each degree.)
In particular, it is safe to refer to a primitive group of type
<A>deg</A>, <A>nr</A> in the &GAP; library.
</Description>
</ManSection>


<ManSection>
<Var Name="PRIMITIVE_INDICES_MAGMA"/>

<Description>
The system <Package>Magma</Package> also provides a list of primitive groups
(see <Cite Key="RoneyDougal02"/>). For historical
reasons, its indexing up to degree 999 
differs from the one used by &GAP;. The
variable <Ref Var="PRIMITIVE_INDICES_MAGMA"/>
can be used to obtain this correspondence. The magma index number of
the &GAP; group <C>PrimitiveGroup(<A>deg</A>,<A>nr</A>)</C> is stored in the entry
<C>PRIMITIVE_INDICES_MAGMA[<A>deg</A>][<A>nr</A>]</C>, for degree at most 999.
<P/>
Vice versa, the group of degree <A>deg</A> with <Package>Magma</Package>
index number <A>nr</A> has the &GAP; index 
<P/>
<C>Position(PRIMITIVE_INDICES_MAGMA[<A>deg</A>],<A>nr</A>)</C>, in particular
it can be obtained by the &GAP; command
<P/>
<C>PrimitiveGroup(<A>deg</A>,Position(PRIMITIVE_INDICES_MAGMA[<A>deg</A>],<A>nr</A>));</C>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Irreducible Solvable Matrix Groups">
<Heading>Irreducible Solvable Matrix Groups</Heading>

<ManSection>
<Func Name="IrreducibleSolvableGroupMS" Arg='n, p, i'/>

<Description>
This function returns a representative of the <A>i</A>-th conjugacy class
of irreducible solvable subgroup of GL(<A>n</A>, <A>p</A>),
where <A>n</A> is an integer <M>&gt; 1</M>, <A>p</A> is a prime,
and <M><A>p</A>^{<A>n</A>} &lt; 256</M>.
<P/>
The numbering of the representatives should be 
considered arbitrary. However, it is guaranteed that the <A>i</A>-th 
group on this list will lie in the same conjugacy class in all future
versions of &GAP;, unless two (or more) groups on the list are discovered
to be duplicates,
in which case <Ref Func="IrreducibleSolvableGroupMS"/> will return
<K>fail</K> for all but one of the duplicates. 
<P/>
For values of <A>n</A>, <A>p</A>, and <A>i</A> admissible to
<Ref Func="IrreducibleSolvableGroup"/>,
<Ref Func="IrreducibleSolvableGroupMS"/> returns a representative of
the same conjugacy class of subgroups of GL(<A>n</A>, <A>p</A>) as
<Ref Func="IrreducibleSolvableGroup"/>.
Note that it currently adds two more groups (missing from the
original list by Mark Short) for <A>n</A> <M>= 2</M>,
<A>p</A> <M>= 13</M>. 
</Description>
</ManSection>

<ManSection>
<Func Name="NumberIrreducibleSolvableGroups" Arg='n, p'/>

<Description>
This function returns the number of conjugacy classes of 
irreducible solvable subgroup of 
GL(<A>n</A>, <A>p</A>). 
</Description>
</ManSection>

<ManSection>
<Func Name="AllIrreducibleSolvableGroups"
 Arg='func1, val1, func2, val2, ...'/>

<Description>
This function returns a list  of conjugacy class representatives <M>G</M>
of matrix groups over a prime field such that
<M>f(G) = v</M> or <M>f(G) \in v</M>, for all pairs <M>(f,v)</M> in
(<A>func1</A>, <A>val1</A>), (<A>func2</A>, <A>val2</A>), <M>\ldots</M>.
The following possibilities for the functions <M>f</M> 
are particularly efficient, because the values can be read off the
information in the data base:
<C>DegreeOfMatrixGroup</C> (or
<Ref Func="Dimension"/> or <Ref Func="DimensionOfMatrixGroup"/>) for the
linear degree,
<Ref Func="Characteristic"/> for the field characteristic,
<Ref Func="Size"/>, <C>IsPrimitiveMatrixGroup</C>
(or <C>IsLinearlyPrimitive</C>), and
<C>MinimalBlockDimension</C>>.
</Description>
</ManSection>

<ManSection>
<Func Name="OneIrreducibleSolvableGroup"
 Arg='func1, val1, func2, val2, ...'/>

<Description>
This function returns one solvable subgroup <M>G</M> of a
matrix group over a prime field such that
<M>f(G) = v</M> or <M>f(G) \in v</M>, for all pairs <M>(f,v)</M> in
(<A>func1</A>, <A>val1</A>), (<A>func2</A>, <A>val2</A>), <M>\ldots</M>.
The following possibilities for the functions <M>f</M>
are particularly efficient, because the values can be read off the
information in the data base:
<C>DegreeOfMatrixGroup</C> (or
<Ref Func="Dimension"/> or <Ref Func="DimensionOfMatrixGroup"/>) for the
linear degree,
<Ref Func="Characteristic"/> for the field characteristic,
<Ref Func="Size"/>, <C>IsPrimitiveMatrixGroup</C>
(or <C>IsLinearlyPrimitive</C>), and
<C>MinimalBlockDimension</C>>.
</Description>
</ManSection>

<ManSection>
<Var Name="PrimitiveIndexIrreducibleSolvableGroup"/>

<Description>
This variable provides a way to get from irreducible solvable groups to
primitive groups and vice versa. For the group
<M>G</M> = <C>IrreducibleSolvableGroup( <A>n</A>, <A>p</A>, <A>k</A> )</C>
and <M>d = p^n</M>, the entry
<C>PrimitiveIndexIrreducibleSolvableGroup[d][i]</C> gives the index
number of the semidirect product <M>p^n:G</M> in the library of primitive
groups.
<P/>
Searching for an index in this list with <Ref Func="Position"/> gives the
translation in the other direction.
</Description>
</ManSection>

<ManSection>
<Func Name="IrreducibleSolvableGroup" Arg='n, p, i'/>

<Description>
This function is obsolete, because for <A>n</A> <M>= 2</M>,
<A>p</A> <M>= 13</M>,  two groups were missing from the
underlying database. It has been replaced by the function
<Ref Func="IrreducibleSolvableGroupMS"/>. Please note that the latter
function does not guarantee any ordering of the groups in the database.
However, for values of <A>n</A>, <A>p</A>, and <A>i</A> admissible to
<Ref Func="IrreducibleSolvableGroup"/>,
<Ref Func="IrreducibleSolvableGroupMS"/> returns a representative of the
same conjugacy class of subgroups of GL(<A>n</A>, <A>p</A>) as
<Ref Func="IrreducibleSolvableGroup"/> did before. 
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Irreducible Maximal Finite Integral Matrix Groups">
<Heading>Irreducible Maximal Finite Integral Matrix Groups</Heading>

A   library of irreducible   maximal finite   integral  matrix groups  is
provided with &GAP;. It  contains <M>&QQ;</M>-class representatives for  all of
these groups of dimension at  most 31, and <M>&ZZ;</M>-class representatives for
those of dimension at most 11 or of dimension 13, 17, 19, or 23.
<P/>
The  groups  provided  in this  library  have been  determined by Wilhelm
Plesken, partially as joint work with Michael Pohst, or by members of his
institute (Lehrstuhl B für Mathematik, RWTH  Aachen).   In
particular, the data for the groups of dimensions  2 to 9 have been taken
from the output  of computer  calculations which  they performed in  1979
(see   <Cite Key="PP77"/>, <Cite Key="PP80"/>). The  <M>&ZZ;</M>-class  representatives of the
groups  of  dimension  10 have  been  determined and    computed by Bernd
Souvignier (<Cite Key="Sou94"/>),  and those of  dimensions 11, 13,  and 17 have
been  recomputed for this library from  the circulant Gram matrices given
in  <Cite Key="Ple85"/>, using the  stand-alone  programs for the computation of
short vectors and Bravais groups which have  been developed in  Plesken's
institute. The <M>&ZZ;</M>-class representatives of  the groups of dimensions 19
and  23 had already been  determined in  <Cite Key="Ple85"/>.  Gabriele Nebe has
recomputed them  for us. Her  main contribution to this library, however,
is that she has determined and computed the <M>&QQ;</M>-class representatives of
the groups  of non-prime dimensions  between 12 and  24 and the groups of
dimensions  25  to  31   (see   <Cite Key="PN95"/>,  <Cite Key="NP95"/>,  <Cite Key="Neb95"/>,
<Cite Key="Neb96"/>).
<P/>
The library has been brought into &GAP; format by Volkmar Felsch. He has
applied several &GAP; routines  to check certain consistency of the data.
However, the  credit  and responsibility for  the lists   remain with the
authors. We are   grateful to Wilhelm Plesken,  Gabriele  Nebe, and Bernd
Souvignier for supplying their results to &GAP;.
<P/>
In the preceding  acknowledgement, we used  some notations that will also
be needed in the sequel. We first define these.
<P/>
Any  integral matrix   group  <M>G</M>  of  dimension   <M>n</M> is a  subgroup  of
<M>GL_n(&ZZ;)</M> as  well  as of  <M>GL_n(&QQ;)</M>  and hence lies in  some conjugacy
class of integral  matrix groups   under  <M>GL_n(&ZZ;)</M>  and also in    some
conjugacy class of rational matrix  groups under <M>GL_n(&QQ;)</M>. As usual, we
call  these  classes    the  <M>&ZZ;</M>-class   and the   <M>&QQ;</M>-class   of  <M>G</M>,
respectively.  Note that any conjugacy  class of subgroups of  <M>GL_n(&QQ;)</M>
contains at least one <M>&ZZ;</M>-class of subgroups of <M>GL_n(&ZZ;)</M> and hence can
be considered as the <M>&QQ;</M>-class of some integral matrix group.
<P/>
In  the context of  this library we are  only concerned with <M>&ZZ;</M>-classes
and <M>&QQ;</M>-classes of subgroups   of <M>GL_n(&ZZ;)</M> which are irreducible   and
maximal   finite in <M>GL_n(&ZZ;)</M> (we   will call them <E>i.m.f.</E>&nbsp;subgroups of
<M>GL_n(&ZZ;)</M>).  We can distinguish two types of these groups:
<P/>
First, there are  those  i.m.f.&nbsp;subgroups  of <M>GL_n(&ZZ;)</M> which   are also
maximal  finite subgroups of <M>GL_n(&QQ;)</M>.  Let  us denote the set of their
<M>&QQ;</M>-classes by <M>Q_1(n)</M>. It is clear from the above remark that <M>Q_1(n)</M>
just consists of the <M>&QQ;</M>-classes of i.m.f.&nbsp;subgroups of <M>GL_n(&QQ;)</M>.
<P/>
Secondly, there is the set <M>Q_2(n)</M> of the  <M>&QQ;</M>-classes of the remaining
i.m.f.&nbsp;subgroups of <M>GL_n(&ZZ;)</M>, i.e.,  of   those which are  not  maximal
finite subgroups of <M>GL_n(&QQ;)</M>. For any such group  <M>G</M>, say, there is at
least one class <M>C \in Q_1(n)</M> such that <M>G</M> is conjugate under <M>&QQ;</M> to a
proper subgroup of some   group <M>H \in C</M>.   In  fact, the class <M>C</M>   is
uniquely determined for any group   <M>G</M> occurring in the library  (though
there seems to be no  reason to assume that  this property should hold in
general).  Hence   we may   call   <M>C</M>  the <E>rational   i.m.f.&nbsp;class</E>  of
<M>G</M>. Finally, we  will  denote the   number of  classes  in  <M>Q_1(n)</M> and
<M>Q_2(n)</M> by <M>q_1(n)</M> and <M>q_2(n)</M>, respectively.
<P/>
As an example, let us consider the case <M>n = 4</M>. There are 6 <M>&ZZ;</M>-classes
of i.m.f.&nbsp;subgroups  of <M>GL_4(&ZZ;)</M>   with representative subgroups  <M>G_1,
\ldots,  G_6</M> of isomorphism types  <M>G_1 \cong W(F_4)</M>, <M>G_2 \cong D_{12}
\wr C_2</M>, <M>G_3 \cong  G_4 \cong C_2 \times  S_5</M>, <M>G_5 \cong W(B_4)</M>, and
<M>G_6  \cong (D_{12}  </M><C>Y</C><M>  D_{12})   \!:\! C_2</M>.  The    corresponding
<M>&QQ;</M>-classes, <M>R_1, \ldots, R_6</M>, say, are pairwise different except that
<M>R_3</M> coincides  with <M>R_4</M>.   The  groups <M>G_1</M>,  <M>G_2</M>, and  <M>G_3</M>  are
i.m.f.&nbsp;subgroups of <M>GL_4(&QQ;)</M>, but <M>G_5</M>  and <M>G_6</M> are not because they
are  conjugate under <M>GL_4(&QQ;)</M> to proper  subgroups  of <M>G_1</M> and <M>G_2</M>,
respectively.  So we  have <M>Q_1(4) = \{ R_1,  R_2, R_3 \}</M>,  <M>Q_2(4) = \{
R_5, R_6 \}</M>, <M>q_1(4) = 3</M>, and <M>q_2(4) = 2</M>.
<P/>
The <M>q_1(n)</M> <M>&QQ;</M>-classes   of i.m.f.&nbsp;subgroups of  <M>GL_n(&QQ;)</M>  have been
determined  for each dimension  <M>n \leq 31</M>.   The current &GAP; library
provides integral representative groups for all these classes.  Moreover,
all <M>&ZZ;</M>-classes of i.m.f.&nbsp;subgroups of <M>GL_n(&ZZ;)</M>  are known for <M>n \leq
11</M> and  for <M>n \in \{13,17,19,23\}</M>. For   these dimensions, the library
offers integral  representative  groups for all <M>&QQ;</M>-classes  in <M>Q_1(n)</M>
and <M>Q_2(n)</M> as  well as  for   all <M>&ZZ;</M>-classes  of i.m.f.&nbsp;subgroups  of
<M>GL_n(&ZZ;)</M>.
<P/>
Any group <M>G</M> of dimension <M>n</M> given in the library is represented
as the automorphism group
<M>G = Aut(F,L) = \{ g \in GL_n(&ZZ;) \mid Lg = L, g F g^{tr} = F \}</M>
of a positive definite symmetric <M>n \times n</M> matrix
<M>F \in &ZZ;^{{n \times n}}</M> on an <M>n</M>-dimensional lattice
<M>L \cong &ZZ;^{{1 \times n}}</M>
(for details see e.g. <Cite Key="PN95"/>).
&GAP; provides for <M>G</M> a list of matrix generators and the
<E>Gram matrix</E> <M>F</M>.
<P/>
The positive definite quadratic form defined by <M>F</M> defines a
<E>norm</E> <M>v F v^{tr}</M> for each vector <M>v \in L</M>,
and there is only a finite set of vectors of minimal norm.
These vectors are often simply called the <E>short vectors</E>.
Their set splits into  orbits under <M>G</M>, and <M>G</M> being irreducible
acts faithfully on each of these orbits by multiplication from the right.
&GAP; provides for each of these orbits the orbit size and a representative
vector.
<P/>
Like most of the  other &GAP; libraries,  the library of i.m.f.&nbsp;integral
matrix   groups   supplies an   extraction   function,  <C>ImfMatrixGroup</C>.
However, as the  library involves only 525  different groups, there is no
need for a   selection or an  example function.  Instead,   there are two
functions,
<Ref Func="ImfInvariants"/> and <Ref Func="DisplayImfInvariants"/>,
which provide some
<M>&ZZ;</M>-class invariants   that can be extracted  from   the library without
actually constructing   the   representative    groups   themselves.  The
difference between these two functions  is  that the latter one  displays
the resulting data in some easily  readable format, whereas the first one
returns them as record components so that you can properly access them.
<P/>
We shall give an individual description of each of the library functions,
but first we would like to insert a short remark  concerning their names:
Any  self-explaining name of  a  function  handling  <E>irreducible maximal
finite integral  matrix groups</E> would  have to include  this term in full
length and hence would grow extremely long.  Therefore we have decided to
use the abbreviation <C>Imf</C> instead in order to restrict the names to some
reasonable length.
<P/>
The  first  three  functions can   be  used to formulate  loops  over the
classes.
<P/>
<ManSection>
<Func Name="ImfNumberQQClasses" Arg='dim'/>
<Func Name="ImfNumberQClasses" Arg='dim'/>
<Func Name="ImfNumberZClasses" Arg='dim, q'/>

<Description>
<C>ImfNumberQQClasses</C> returns the number <M>q_1(</M><A>dim</A><M>)</M> of <M>&QQ;</M>-classes of
i.m.f.&nbsp;rational matrix groups of dimension  <A>dim</A>. Valid values of  <A>dim</A>
are all positive integers up to 31.
<P/>
Note: In order  to enable you to loop  just over the classes belonging to
<M>Q_1(</M><A>dim</A><M>)</M>, we have  arranged  the list of <M>&QQ;</M>-classes  of dimension
<A>dim</A>  for any dimension  <A>dim</A>  in the  library such that,  whenever the
classes of <M>Q_2(</M><A>dim</A><M>)</M>  are known, too, i.e.,  in the cases  <M>dim \leq
11</M> or  <M>dim \in \{13,17,19,23\}</M>, the  classes of <M>Q_1(</M><A>dim</A><M>)</M> precede
those of <M>Q_2(</M><A>dim</A><M>)</M> and hence are numbered from 1 to <M>q_1(</M><A>dim</A><M>)</M>.
<P/>
<C>ImfNumberQClasses</C>  returns  the  number of <M>&QQ;</M>-classes    of groups of
dimension <A>dim</A>  which are available in the  library. If <M>dim \leq 11</M> or
<M>dim      \in \{13,17,19,23\}</M>,  this  is     the  number <M>q_1(</M><A>dim</A><M>) +
q_2(</M><A>dim</A><M>)</M> of  <M>&QQ;</M>-classes  of  i.m.f.&nbsp;subgroups of   <M>GL_{dim}(&ZZ;)</M>.
Otherwise, it is   just  the number  <M>q_1(</M><A>dim</A><M>)</M> of   <M>&QQ;</M>-classes  of
i.m.f.&nbsp;subgroups of <M>GL_{dim}(&QQ;)</M>.    Valid  values of <A>dim</A>     are all
positive integers up to 31.
<P/>
<Ref Func="ImfNumberZClasses"/> returns the number of <M>&ZZ;</M>-classes
in the <A>q</A>-th <M>&QQ;</M>-class of i.m.f.&nbsp;integral matrix groups
of dimension <A>dim</A>.
Valid values of <A>dim</A> are all  positive integers up  to 11 and all
primes up to 23.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="DisplayImfInvariants" Arg='dim, q[, z]'/>

<Description>
<Ref Func="DisplayImfInvariants"/> displays the following
<M>&ZZ;</M>-class invariants of the groups in the
<A>z</A>-th <M>&ZZ;</M>-class in the <A>q</A>-th <M>&QQ;</M>-class of
i.m.f.&nbsp;integral matrix groups of dimension <A>dim</A>:
<P/>
<List>
<Item>
      its  <M>&ZZ;</M>-class number  in the form  <A>dim</A>.<A>q</A>.<A>z</A>,  if <A>dim</A> is at
      most 11 or a prime at most 23, or its <M>&QQ;</M>-class number in the form
      <A>dim</A>.<A>q</A>, else,
</Item>
<Item>
      a message if the group is solvable,
</Item>
<Item>
      the size of the group,
</Item>
<Item>
      the isomorphism type of the group,
</Item>
<Item>
      the   elementary  divisors   of  the   associated  quadratic  form,
</Item>
<Item>
      the sizes  of the  orbits  of short vectors  (these  sizes  are the
      degrees of the  faithful permutation representations  which you may
      construct using the functions 
      <Ref Func="IsomorphismPermGroup" Label="for Imf matrix groups"/> or
      <Ref Func="IsomorphismPermGroupImfGroup"/> below),
</Item>
<Item>
      the norm of the associated short vectors,
</Item>
<Item>
      only  in  case  that  the  group  is  not  an  i.m.f.&nbsp;group  in
      <M>GL_n(&QQ;)</M>:  an  appropriate  message,  including the  <M>&QQ;</M>-class
      number    of   the    corresponding   rational    i.m.f.&nbsp;class.
</Item>
</List>
<P/>
If you specify the value 0 for any of the parameters <A>dim</A>, <A>q</A>,
or <A>z</A>,
the command will loop over all available dimensions, <M>&QQ;</M>-classes of
given dimension, or <M>&ZZ;</M>-classes within the given <M>&QQ;</M>-class,
respectively. Otherwise, the values of the arguments must be in range.  A
value <A>z</A> <M>\neq 1</M> must not be specified if the <M>&ZZ;</M>-classes
are not known for the given dimension, i.e., if <A>dim</A> <M>> 11</M> and
<A>dim</A> <M>\not \in \{ 13, 17, 19, 23 \}</M>.
The default value of <A>z</A> is&nbsp;1.  This value of <A>z</A> will
be accepted even if the <M>&ZZ;</M>-classes are not known.
Then it specifies the only representative group which is available for the
<A>q</A>-th <M>&QQ;</M>-class.
The greatest legal value of <A>dim</A> is 31.
<P/>
<Example><![CDATA[
gap> DisplayImfInvariants( 3, 1, 0 );
#I Z-class 3.1.1:  Solvable, size = 2^4*3
#I   isomorphism type = C2 wr S3 = C2 x S4 = W(B3)
#I   elementary divisors = 1^3
#I   orbit size = 6, minimal norm = 1
#I Z-class 3.1.2:  Solvable, size = 2^4*3
#I   isomorphism type = C2 wr S3 = C2 x S4 = C2 x W(A3)
#I   elementary divisors = 1*4^2
#I   orbit size = 8, minimal norm = 3
#I Z-class 3.1.3:  Solvable, size = 2^4*3
#I   isomorphism type = C2 wr S3 = C2 x S4 = C2 x W(A3)
#I   elementary divisors = 1^2*4
#I   orbit size = 12, minimal norm = 2
gap> DisplayImfInvariants( 8, 15, 1 );
#I Z-class 8.15.1:  Solvable, size = 2^5*3^4
#I   isomorphism type = C2 x (S3 wr S3)
#I   elementary divisors = 1*3^3*9^3*27
#I   orbit size = 54, minimal norm = 8
#I   not maximal finite in GL(8,Q), rational imf class is 8.5
gap> DisplayImfInvariants( 20, 23 );
#I Q-class 20.23:  Size = 2^5*3^2*5*11
#I   isomorphism type = (PSL(2,11) x D12).C2
#I   elementary divisors = 1^18*11^2
#I   orbit size = 3*660 + 2*1980 + 2640 + 3960, minimal norm = 4
]]></Example>
<P/>
Note that the function <Ref Func="DisplayImfInvariants"/> uses a kind of
shorthand to display the elementary divisors.
E.&nbsp;g., the expression <C>1*3^3*9^3*27</C> in
the   preceding     example   stands   for   the   elementary    divisors
<M>1,3,3,3,9,9,9,27</M>.  (See also  the next  example  which  shows  that the
function <Ref Func="ImfInvariants"/> provides the elementary  divisors in form of an
ordinary &GAP; list.)
<P/>
In  the description of the isomorphism  types the following notations are
used:
<List>
<Mark><M>A</M> <C>x</C> <M>B</M> </Mark>
<Item>
      denotes a direct product of a group <M>A</M> by a group <M>B</M>,
</Item>
<Mark><M>A</M> <C>subd</C> <M>B</M> </Mark>
<Item>
      denotes a subdirect product of <M>A</M> by <M>B</M>,
</Item>
<Mark><M>A</M> <C>Y</C> <M>B</M> </Mark>
<Item>
      denotes a central product of <M>A</M> by <M>B</M>,
</Item>
<Mark><M>A</M> <C>wr</C> <M>B</M> </Mark>
<Item>
      denotes a wreath product of <M>A</M> by <M>B</M>,
</Item>
<Mark><M>A</M><C>:</C><M>B</M> </Mark>
<Item>
      denotes a split extension of <M>A</M> by <M>B</M>,
</Item>
<Mark><M>A</M><C>.</C><M>B</M> </Mark>
<Item>
      denotes just an extension of <M>A</M> by <M>B</M> (split or nonsplit).
</Item>
</List>
<P/>
The groups involved are
<List>
<Item>
 the cyclic groups <M>C_n</M>, dihedral groups <M>D_n</M>,  and generalized
      quaternion groups  <M>Q_n</M> of order <M>n</M>,  denoted by <C>C</C><A>n</A>,  <C>D</C><A>n</A>,
      and <C>Q</C><A>n</A>, respectively,
</Item>
<Item>
 the  alternating groups  <M>A_n</M>  and  symmetric groups  <M>S_n</M>  of
      degree <M>n</M>, denoted by <C>A</C><A>n</A> and <C>S</C><A>n</A>, respectively,
</Item>
<Item>
 the  linear  groups   <M>GL_n(q)</M>,   <M>PGL_n(q)</M>,   <M>SL_n(q)</M>,  and
      <M>PSL_n(q)</M>,     denoted    by     <C>GL</C>(<A>n</A>,<A>q</A>),    <C>PGL</C>(<A>n</A>,<A>q</A>),
      <C>SL</C>(<A>n</A>,<A>q</A>), and <C>PSL</C>(<A>n</A>,<A>q</A>), respectively,
</Item>
<Item>
  the  unitary  groups  <M>SU_n(q)</M>  and  <M>PSU_n(q)</M>,   denoted  by
      <C>SU</C>(<A>n</A>,<A>q</A>) and <C>PSU</C>(<A>n</A>,<A>q</A>), respectively,
</Item>
<Item>
 the  symplectic groups  <M>Sp(n,q)</M>  and  <M>PSp(n,q)</M>,  denoted  by
      <C>Sp</C>(<A>n</A>,<A>q</A>) and <C>PSp</C>(<A>n</A>,<A>q</A>), respectively,
</Item>
<Item>
 the  orthogonal groups   <M>O_8^+(2)</M>   and   <M>PO_8^+(2)</M>,
      denoted by <C>O+</C>(8,2) and <C>PO+</C>(8,2), respectively,
</Item>
<Item>
   the extraspecial groups <M>2_+^{{1+8}}</M>, <M>3_+^{{1+2}}</M>,
   <M>3_+^{{1+4}}</M>, and <M>5_+^{{1+2}}</M>, denoted by <C>2+^(1+8)</C>,
   <C>3+^(1+2)</C>, <C>3+^(1+4)</C>, and <C>5+^(1+2)</C>, respectively,
</Item>
<Item>
 the Chevalley group <M>G_2(3)</M>, denoted by <C>G2(3)</C>,
</Item>
<Item>
 the twisted Chevalley group <M>{^3}D_4(2)</M>, denoted by <C>3D4(2)</C>,
</Item>
<Item>
 the Suzuki group <M>Sz(8)</M>, denoted by <C>Sz(8)</C>,
</Item>
<Item>
 the Weyl groups   <M>W(A_n)</M>,  <M>W(B_n)</M>,  <M>W(D_n)</M>,  <M>W(E_n)</M>, and
      <M>W(F_4)</M>,  denoted by  <C>W(A<A>n</A>)</C>,  <C>W(B<A>n</A>)</C>, <C>W(D<A>n</A>)</C>, <C>W(E<A>n</A>)</C>,
      and <C>W(F4)</C>, respectively,
</Item>
<Item>
 the sporadic simple groups  <M>Co_1</M>, <M>Co_2</M>, <M>Co_3</M>, <M>HS</M>, <M>J_2</M>,
      <M>M_{12}</M>, <M>M_{22}</M>, <M>M_{23}</M>, <M>M_{24}</M>, and <M>Mc</M>, denoted by <C>Co1</C>,
      <C>Co2</C>, <C>Co3</C>,  <C>HS</C>, <C>J2</C>,  <C>M12</C>, <C>M22</C>, <C>M23</C>, <C>M24</C>,  and  <C>Mc</C>,
      respectively,
</Item>
<Item>
 a point stabilizer of index 11 in <M>M_{11}</M>, denoted by <C>M10</C>.
</Item>
</List>
<P/>
As   mentioned      above,  the   data    assembled   by    the  function
<Ref Func="DisplayImfInvariants"/> are <Q>cheap data</Q> in the sense that they can be
provided by the library without loading any of its  large matrix files or
performing any matrix calculations. The following  function allows you to
get proper access to these cheap data instead of just displaying them.
</Description>
</ManSection>


<ManSection>
<Func Name="ImfInvariants" Arg='dim, q[, z]'/>

<Description>
<Ref Func="ImfInvariants"/> returns  a record which provides some
<M>&ZZ;</M>-class invariants of the groups in the
<A>z</A>-th <M>&ZZ;</M>-class in the <A>q</A>-th <M>&QQ;</M>-class of
i.m.f.&nbsp;integral matrix groups of dimension <A>dim</A>.
A value <A>z</A> <M>\neq 1</M> must not be specified if the
<M>&ZZ;</M>-classes are not known for the given dimension, i.e.,
if <A>dim</A> <M>&gt; 11</M> and
<A>dim</A> <M>\not \in \{ 13, 17, 19, 23 \}</M>.
The default value of <A>z</A> is&nbsp;1.
This value of <A>z</A> will be accepted even if the <M>&ZZ;</M>-classes are
not known.
Then it specifies the only representative group which is available for the
<A>q</A>-th <M>&QQ;</M>-class.
The greatest legal value of <A>dim</A> is 31.
<P/>
The resulting record contains six or seven components:
<P/>
<List>
<Mark><C>size</C> </Mark>
<Item>
      the size of any representative group <A>G</A>,
</Item>
<Mark><C>isSolvable</C> </Mark>
<Item>
      is <K>true</K> if <A>G</A> is solvable,
</Item>
<Mark><C>isomorphismType</C> </Mark>
<Item>
      a text string describing the isomorphism type of  <A>G</A>  (in the same
      notation as used by the function <C>DisplayImfInvariants</C> above),
</Item>
<Mark><C>elementaryDivisors</C> </Mark>
<Item>
      the elementary divisors of the associated Gram matrix  <A>F</A>  (in the
      same format as the result of the function
      <Ref Func="ElementaryDivisorsMat"/>,
</Item>
<Mark><C>minimalNorm</C> </Mark>
<Item>
      the norm of the associated short vectors,
</Item>
<Mark><C>sizesOrbitsShortVectors</C> </Mark>
<Item>
      the sizes of the orbits of short vectors under <A>F</A>,
</Item>
<Mark><C>maximalQClass</C> </Mark>
<Item>
      the  <M>&QQ;</M>-class  number  of  an  i.m.f.&nbsp;group  in  <M>GL_n(&QQ;)</M>  that
      contains <A>G</A> as a subgroup  (only in case that not <A>G</A> itself is an
      i.m.f.&nbsp;subgroup of <M>GL_n(&QQ;)</M>).
</Item>
</List>
<P/>
Note that four of these data, namely the group size, the solvability, the
isomorphism  type, and the   corresponding rational i.m.f.&nbsp;class, are not
only <M>&ZZ;</M>-class invariants, but also <M>&QQ;</M>-class invariants.
<P/>
Note further that, though the isomorphism type is a <M>&QQ;</M>-class invariant,
you will sometimes  get different descriptions for different <M>&ZZ;</M>-classes
of the same <M>&QQ;</M>-class (as, e.g., for the  classes 3.1.1 and 3.1.2 in the
last example above). The purpose  of  this behaviour  is to provide  some
more information about the underlying lattices.
<P/>
<Example><![CDATA[
gap> ImfInvariants( 8, 15, 1 );
rec( elementaryDivisors := [ 1, 3, 3, 3, 9, 9, 9, 27 ], 
  isSolvable := true, isomorphismType := "C2 x (S3 wr S3)", 
  maximalQClass := 5, minimalNorm := 8, size := 2592, 
  sizesOrbitsShortVectors := [ 54 ] )
gap> ImfInvariants( 24, 1 ).size;
10409396852733332453861621760000
gap> ImfInvariants( 23, 5, 2 ).sizesOrbitsShortVectors;
[ 552, 53130 ]
gap> for i in [ 1 .. ImfNumberQClasses( 22 ) ] do
>    Print( ImfInvariants( 22, i ).isomorphismType, "\n" ); od;
C2 wr S22 = W(B22)
(C2 x PSU(6,2)).S3
(C2 x S3) wr S11 = (C2 x W(A2)) wr S11
(C2 x S12) wr C2 = (C2 x W(A11)) wr C2
C2 x S3 x S12 = C2 x W(A2) x W(A11)
(C2 x HS).C2
(C2 x Mc).C2
C2 x S23 = C2 x W(A22)
C2 x PSL(2,23)
C2 x PSL(2,23)
C2 x PGL(2,23)
C2 x PGL(2,23)
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="ImfMatrixGroup" Arg='dim, q[, z]'/>

<Description>
<Ref Func="ImfMatrixGroup"/> is the essential extraction function of this
library (note that its name has been changed from <C>ImfMatGroup</C>
in &GAP;&nbsp;3 to <Ref Func="ImfMatrixGroup"/> in &GAP;&nbsp;4).
It returns a representative group, <M>G</M> say,
of the <A>z</A>-th <M>&ZZ;</M>-class in the <A>q</A>-th <M>&QQ;</M>-class of
i.m.f.&nbsp;integral matrix groups of dimension <A>dim</A>.
A value <A>z</A><M> \neq 1</M> must not be specified if the
<M>&ZZ;</M>-classes are not known for the given dimension, i.e.,
if <A>dim</A> <M>&gt; 11</M> and
<A>dim</A> <M>\not \in \{ 13, 17, 19, 23 \}</M>.
The default value of <A>z</A> is&nbsp;1.
This value of <A>z</A> will be accepted even if the <M>&ZZ;</M>-classes are
not known.
Then it specifies the only representative group which is available for the
<A>q</A>-th <M>&QQ;</M>-class.
The greatest legal value of <A>dim</A> is 31.
<P/>
<Example><![CDATA[
gap> G := ImfMatrixGroup( 5, 1, 3 );
ImfMatrixGroup(5,1,3)
gap> for m in GeneratorsOfGroup( G ) do PrintArray( m ); od;
[ [  -1,   0,   0,   0,   0 ],
  [   0,   1,   0,   0,   0 ],
  [   0,   0,   0,   1,   0 ],
  [  -1,  -1,  -1,  -1,   2 ],
  [  -1,   0,   0,   0,   1 ] ]
[ [  0,  1,  0,  0,  0 ],
  [  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  1,  0 ],
  [  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1 ] ]
]]></Example>
<P/>
The attributes <Ref Func="Size"/> and <C>IsSolvable</C> will be
properly set in the resulting matrix group <M>G</M>.
In addition, it has two attributes <C>IsImfMatrixGroup</C> and
<C>ImfRecord</C> where the first one is just a logical flag set to
<K>true</K> and the latter one is a record.
Except for the group size and the solvability flag, this record contains the
same components as the resulting record of the function
<Ref Func="ImfInvariants"/> described above, namely the components
<C>isomorphismType</C>, <C>elementaryDivisors</C>, <C>minimalNorm</C>,
and <C>sizesOrbitsShortVectors</C> and,
if <M>G</M> is not a rational i.m.f.&nbsp;group, <C>maximalQClass</C>.
Moreover, it has the two components
<P/>
<List>
<Mark><C>form</C></Mark>
<Item>
   the associated Gram matrix <M>F</M>, and
</Item>
<Mark><C>repsOrbitsShortVectors</C></Mark>
<Item>
   representatives of the orbits of short vectors under <M>F</M>.
</Item>
</List>
<P/>
The  last one  of  these  components  will be  required  by the  function
<Ref Func="IsomorphismPermGroup" Label="for Imf matrix groups"/> below.
<P/>
<Example><![CDATA[
gap> Size( G );
3840
gap> imf := ImfRecord( G );;
gap> imf.isomorphismType;
"C2 wr S5 = C2 x W(D5)"
gap> PrintArray( imf.form );
[ [  4,  0,  0,  0,  2 ],
  [  0,  4,  0,  0,  2 ],
  [  0,  0,  4,  0,  2 ],
  [  0,  0,  0,  4,  2 ],
  [  2,  2,  2,  2,  5 ] ]
gap> imf.elementaryDivisors;
[ 1, 4, 4, 4, 4 ]
gap> imf.minimalNorm;
4
]]></Example>
<P/>
If you want to perform calculations in such a matrix group <M>G</M>
you should be aware of the fact that the permutation group routines of &GAP;
are much more efficient than the matrix group routines.
Hence we recommend that you do your computations, whenever possible,
in the isomorphic permutation group which is induced by the action of
<M>G</M> on one of the orbits of the associated short vectors.
You may call one of the following functions
<Ref Func="IsomorphismPermGroup" Label="for Imf matrix groups"/> or
<Ref Func="IsomorphismPermGroupImfGroup"/> to get an isomorphism to such a
permutation group (note that these &GAP;&nbsp;4 functions have replaced the
&GAP;&nbsp;3 functions <C>PermGroup</C> and <C>PermGroupImfGroup</C>).
</Description>
</ManSection>


<ManSection>
<Meth Name="IsomorphismPermGroup" Arg='G' Label="for Imf matrix groups"/>

<Description>
returns an isomorphism, <M>\varphi</M> say, from the given
i.m.f.&nbsp;integral matrix group <M>G</M> to a permutation group
<M>P := \varphi(G)</M> acting on a minimal orbit, <M>S</M> say,
of short vectors of <M>G</M> such that each matrix <M>m \in G</M> is mapped
to the permutation induced by its action on <M>S</M>.
<P/>
Note that in case of a large orbit the construction of <M>\varphi</M> may be
space and time consuming.
Fortunately, there are only six <M>&QQ;</M>-classes in the library for which
the smallest orbit of short vectors is of size greater than <M>20000</M>,
the worst case being the orbit of size <M>196560</M>
for the Leech lattice (<A>dim</A> <M>= 24</M>, <A>q</A> <M>= 3</M>).
<P/>
The inverse isomorphism <M>\varphi^{{-1}}</M> from <M>P</M> to <M>G</M> is
constructed by determining a <M>&QQ;</M>-base <M>B \subset S</M> of
<M>&QQ;^{{1 \times dim}}</M> in <M>S</M> and, in addition,
the associated base change matrix <M>M</M> which transforms <M>B</M> into the
standard base of <M>&ZZ;^{{1 \times dim}}</M>.
This allows a simple computation of the preimage <M>\varphi^{{-1}}(p)</M> of
any permutation <M>p \in P</M>, as follows.
If, for <M>1 \leq i \leq</M> <A>dim</A>,
<M>b_i</M> is the position number in <M>S</M> of the <M>i</M>-th base vector
in <M>B</M>,
it suffices to look up the vector whose position number in <M>S</M> is the
image of <M>b_i</M> under <M>p</M> and to multiply this vector by <M>M</M> to
get the <M>i</M>-th row of <M>\varphi^{{-1}}(p)</M>.
<P/>
You may use the functions
<Ref Func="Image" Label="set of images of the source of a general mapping"/>
and
<Ref Func="PreImage" Label="set of preimages of the range of a general mapping"/>
to switch from <M>G</M> to <M>P</M> and back from <M>P</M> to <M>G</M>.
<P/>
As an  example, let  us continue  the preceding example  and  compute the
solvable residuum of the group <M>G</M>.
<P/>
<Example><![CDATA[
gap> # Perform the computations in an isomorphic permutation group.
gap> phi := IsomorphismPermGroup( G );;
gap> P := Image( phi );
Group([ (1,7,6)(2,9)(4,5,10), (2,3,4,5)(6,9,8,7) ])
gap> D := DerivedSubgroup( P );;
gap> Size( D );
960
gap> IsPerfectGroup( D );
true
gap> # We have found the solvable residuum of P,
gap> # now move the results back to the matrix group G.
gap> R := PreImage( phi, D );;
gap> StructureDescription(R);
"(C2 x C2 x C2 x C2) : A5"
gap> IdGroup(D)=IdGroup(R);
true
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="IsomorphismPermGroupImfGroup" Arg='G, n'/>

<Description>
<Ref Func="IsomorphismPermGroupImfGroup"/> returns an isomorphism,
<M>\varphi</M> say, from the given i.m.f.&nbsp;integral matrix group <A>G</A>
to a permutation group <M>P</M> acting on the <A>n</A>-th orbit,
<M>S</M> say, of short vectors of <A>G</A> such that each matrix
<M>m \in</M> <A>G</A> is mapped to the permutation induced
by its action on <M>S</M>.
<P/>
The only difference to the above function
<Ref Func="IsomorphismPermGroup" Label="for Imf matrix groups"/> is that
you can specify the orbit to be used.
In fact, as the orbits of short vectors are sorted by increasing sizes,
the function <C>IsomorphismPermGroup( <A>G</A> )</C> has been implemented
such that it is equivalent to
<C>IsomorphismPermGroupImfGroup( <A>G</A>, 1 )</C>.
<P/>
<Example><![CDATA[
gap> ImfInvariants( 12, 9 ).sizesOrbitsShortVectors;
[ 120, 300 ]
gap> G := ImfMatrixGroup( 12, 9 );
ImfMatrixGroup(12,9)
gap> phi1 := IsomorphismPermGroupImfGroup( G, 1 );;
gap> P1 := Image( phi1 );
<permutation group of size 2400 with 2 generators>
gap> LargestMovedPoint( P1 );
120
gap> phi2 := IsomorphismPermGroupImfGroup( G, 2 );;
gap> P2 := Image( phi2 );
<permutation group of size 2400 with 2 generators>
gap> LargestMovedPoint( P2 );
300
]]></Example>
</Description>
</ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  semigrp.msk                GAP documentation                Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: semigrp.msk,v 1.23 2003/10/24 16:52:42 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->

<Chapter Label="Semigroups">
<Heading>Semigroups and Monoids</Heading>

This chapter describes functions for creating semigroups and monoids
and determining information about them.

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsSemigroup">
<Heading>Semigroups</Heading>

<ManSection>
<Prop Name="IsSemigroup" Arg='D'/>

<Description>
returns <K>true</K> if the object <A>D</A> is a semigroup.
<Index>semigroup</Index>
A <E>semigroup</E> is a magma (see&nbsp;<Ref Chap="Magmas"/>) with
associative multiplication.
</Description>
</ManSection>

<ManSection>
<Heading>Semigroup</Heading>
<Func Name="Semigroup" Arg='gen1, gen2 ...'
 Label="for various generators"/>
<Func Name="Semigroup" Arg='gens' Label="for a list"/>

<Description>
In the first form, <Ref Func="Semigroup" Label="for various generators"/>
returns the semigroup generated by the arguments <A>gen1</A>,
<A>gen2</A>, <M>\ldots</M>,
that is, the closure of these elements under multiplication.
In the second form, <Ref Func="Semigroup" Label="for a list"/> returns
the semigroup generated by the elements in the homogeneous list
<A>gens</A>;
a square matrix as only argument is treated as one generator,
not as a list of generators.
<P/>
It is <E>not</E> checked whether the underlying multiplication is
associative, use <Ref Func="Magma"/> and <Ref Func="IsAssociative"/>
if you want to check whether a magma is in fact a semigroup.
<P/>
<Example><![CDATA[
gap> a:= Transformation( [ 2, 3, 4, 1 ] );
Transformation( [ 2, 3, 4, 1 ] )
gap> b:= Transformation( [ 2, 2, 3, 4 ] );
Transformation( [ 2, 2 ] )
gap> s:= Semigroup(a, b);
<transformation semigroup of degree 4 with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Subsemigroup" Arg='S, gens'/>
<Func Name="SubsemigroupNC" Arg='S, gens'/>

<Description>
are just synonyms of <Ref Func="Submagma"/> and <Ref Func="SubmagmaNC"/>,
respectively.
<P/>
<Example><![CDATA[
gap> a:=GeneratorsOfSemigroup(s)[1];
Transformation( [ 2, 3, 4, 1 ] )
gap> t:=Subsemigroup(s,[a]);
<commutative transformation semigroup of degree 4 with 1 generator>
]]></Example>
</Description>
</ManSection>


<ManSection>
  <Oper Name="IsSubsemigroup"  Arg="S, T"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This operation returns <K>true</K> if the semigroup <A>T</A> is a
    subsemigroup of the semigroup <A>S</A> and <K>false</K> if it is not. 
    <Example>
gap> f:=Transformation( [ 5, 6, 7, 1, 4, 3, 2, 7 ] );
Transformation( [ 5, 6, 7, 1, 4, 3, 2, 7 ] )
gap> T:=Semigroup(f);;
gap> IsSubsemigroup(FullTransformationSemigroup(4), T);
false
gap> S:=Semigroup(f);; T:=Semigroup(f^2);;
gap> IsSubsemigroup(S, T);                             
true</Example>
</Description>
</ManSection>
 
<ManSection>
<Oper Name="SemigroupByGenerators" Arg='gens'/>

<Description>
is the underlying operation
of&nbsp;<Ref Func="Semigroup" Label="for various generators"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="AsSemigroup" Arg='C'/>

<Description>
If <A>C</A> is a collection whose elements form a semigroup
(see&nbsp;<Ref Func="IsSemigroup"/>) then <Ref Func="AsSemigroup"/>
returns this semigroup.
Otherwise <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Oper Name="AsSubsemigroup" Arg='D, C'/>

<Description>
Let <A>D</A> be a domain and <A>C</A> a collection.
If <A>C</A> is a subset of <A>D</A> that forms a semigroup then
<Ref Func="AsSubsemigroup"/>
returns this semigroup, with parent <A>D</A>.
Otherwise <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfSemigroup" Arg='S'/>

<Description>
Semigroup generators of a semigroup <A>D</A> are the same as magma
generators, see&nbsp;<Ref Func="GeneratorsOfMagma"/>.
<Example><![CDATA[
gap> GeneratorsOfSemigroup(s);
[ Transformation( [ 2, 3, 4, 1 ] ), Transformation( [ 2, 2 ] ) ]
gap> GeneratorsOfSemigroup(t);
[ Transformation( [ 2, 3, 4, 1 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGeneratorsOfSemigroup" Arg='C'/>

<Description>
This property reflects wheter the list or collection <A>C</A> generates
a semigroup.
<Ref Prop="IsAssociativeElementCollection"/> implies 
&nbsp;<Ref Prop="IsGeneratorsOfSemigroup"/>,
but is not used directly in semigroup code, because of conflicts
with matrices.

<Example><![CDATA[
gap> IsGeneratorsOfSemigroup([Transformation([2,3,1])]);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>FreeSemigroup</Heading>
<Func Name="FreeSemigroup" Arg='[wfilt, ]rank[, name]'
 Label="for given rank"/>
<Func Name="FreeSemigroup" Arg='[wfilt, ]name1, name2, ...'
 Label="for various names"/>
<Func Name="FreeSemigroup" Arg='[wfilt, ]names'
 Label="for a list of names"/>
<Func Name="FreeSemigroup" Arg='[wfilt, ]infinity, name, init'
 Label="for infinitely many generators"/>

<Description>
Called with a positive integer <A>rank</A>,
<Ref Func="FreeSemigroup" Label="for given rank"/> returns
a free semigroup on <A>rank</A> generators.
If the optional argument <A>name</A> is given then the generators are
printed as <A>name</A><C>1</C>, <A>name</A><C>2</C> etc.,
that is, each name is the concatenation of the string <A>name</A> and an
integer from <C>1</C> to <A>range</A>.
The default for <A>name</A> is the string <C>"s"</C>.
<P/>
Called in the second form,
<Ref Func="FreeSemigroup" Label="for various names"/> returns
a free semigroup on as many generators as arguments, printed as
<A>name1</A>, <A>name2</A> etc.
<P/>
Called in the third form,
<Ref Func="FreeSemigroup" Label="for a list of names"/> returns
a free semigroup on as many generators as the length of the list
<A>names</A>, the <M>i</M>-th generator being printed as
<A>names</A><M>[i]</M>.
<P/>
Called in the fourth form,
<Ref Func="FreeSemigroup" Label="for infinitely many generators"/>
returns a free semigroup on infinitely many generators, where the first
generators are printed by the names in the list <A>init</A>,
and the other generators by <A>name</A> and an appended number.
<P/>
If the extra argument <A>wfilt</A> is given, it must be either
<Ref Func="IsSyllableWordsFamily"/> or <Ref Func="IsLetterWordsFamily"/>
or <Ref Func="IsWLetterWordsFamily"/> or
<Ref Func="IsBLetterWordsFamily"/>.
This filter then specifies the representation used for the elements of
the free semigroup
(see&nbsp;<Ref Sect="Representations for Associative Words"/>).
If no such filter is given, a letter representation is used.
<P/>
<Example><![CDATA[
gap> f1 := FreeSemigroup( 3 );
<free semigroup on the generators [ s1, s2, s3 ]>
gap> f2 := FreeSemigroup( 3 , "generator" );
<free semigroup on the generators 
[ generator1, generator2, generator3 ]>
gap> f3 := FreeSemigroup( "gen1" , "gen2" );
<free semigroup on the generators [ gen1, gen2 ]>
gap> f4 := FreeSemigroup( ["gen1" , "gen2"] );
<free semigroup on the generators [ gen1, gen2 ]>
]]></Example>
<P/>
Also see Chapter&nbsp;<Ref Chap="Semigroups"/>.
<P/>
Each free object defines a unique alphabet (and a unique family of words).
Its generators are the letters of this alphabet,
thus words of length one.
<P/>
<Example><![CDATA[
gap> FreeGroup( 5 );
<free group on the generators [ f1, f2, f3, f4, f5 ]>
gap> FreeGroup( "a", "b" );
<free group on the generators [ a, b ]>
gap> FreeGroup( infinity );
<free group with infinity generators>
gap> FreeSemigroup( "x", "y" );
<free semigroup on the generators [ x, y ]>
gap> FreeMonoid( 7 );
<free monoid on the generators [ m1, m2, m3, m4, m5, m6, m7 ]>
]]></Example>
<P/>
Remember that names are just a help for printing and do not necessarily
distinguish letters.
It is possible to create arbitrarily weird situations by choosing strange
names for the letters.
<P/>
<Example><![CDATA[
gap> f:= FreeGroup( "x", "x" );  gens:= GeneratorsOfGroup( f );;
<free group on the generators [ x, x ]>
gap> gens[1] = gens[2];
false
gap> f:= FreeGroup( "f1*f2", "f2^-1", "Group( [ f1, f2 ] )" );
<free group on the generators [ f1*f2, f2^-1, Group( [ f1, f2 ] ) ]>
gap> gens:= GeneratorsOfGroup( f );;
gap> gens[1]*gens[2];
f1*f2*f2^-1
gap> gens[1]/gens[3];
f1*f2*Group( [ f1, f2 ] )^-1
gap> gens[3]/gens[1]/gens[2];
Group( [ f1, f2 ] )*f1*f2^-1*f2^-1^-1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SemigroupByMultiplicationTable" Arg='A'/>

<Description>
returns the semigroup whose multiplication is defined by the square
matrix <A>A</A> (see&nbsp;<Ref Func="MagmaByMultiplicationTable"/>)
if such a semigroup exists.
Otherwise <K>fail</K> is returned.
<Example><![CDATA[
gap> SemigroupByMultiplicationTable([[1,2,3],[2,3,1],[3,1,2]]);
<semigroup of size 3, with 3 generators>
gap> SemigroupByMultiplicationTable([[1,2,3],[2,3,1],[3,2,1]]);
fail
]]></Example>
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Section Label="sect:IsMonoid">
<Heading>Monoids</Heading>

<ManSection>
<Prop Name="IsMonoid" Arg='D'/>

<Description>
A <E>monoid</E> is a magma-with-one (see&nbsp;<Ref Chap="Magmas"/>)
with associative multiplication.
</Description>
</ManSection>

<ManSection>
<Heading>Monoid</Heading>
<Func Name="Monoid" Arg='gen1, gen2 ...'
 Label="for various generators"/>
<Func Name="Monoid" Arg='gens[, id]' Label="for a list"/>

<Description>
In the first form, <Ref Func="Monoid" Label="for various generators"/>
returns the monoid generated by the arguments <A>gen1</A>, <A>gen2</A>,
<M>\ldots</M>,
that is, the closure of these elements under multiplication and taking
the 0-th power.
In the second form, <Ref Func="Monoid" Label="for a list"/> returns
the monoid generated by the elements in the homogeneous list <A>gens</A>;
a square matrix as only argument is treated as one generator,
not as a list of generators.
In the second form, the identity element <A>id</A> may be given as the
second argument.
<P/>
It is <E>not</E> checked whether the underlying multiplication is
associative, use <Ref Func="MagmaWithOne"/> and
<Ref Func="IsAssociative"/>
if you want to check whether a magma-with-one is in fact a monoid.
</Description>
</ManSection>

<ManSection>
<Func Name="Submonoid" Arg='M, gens'/>
<Func Name="SubmonoidNC" Arg='M, gens'/>

<Description>
are just synonyms of <Ref Func="SubmagmaWithOne"/>
and <Ref Func="SubmagmaWithOneNC"/>, respectively.
</Description>
</ManSection>

<ManSection>
<Oper Name="MonoidByGenerators" Arg='gens[, one]'/>

<Description>
is the underlying operation of <Ref Func="Monoid" Label="for a list"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="AsMonoid" Arg='C'/>

<Description>
If <A>C</A> is a collection whose elements form a monoid
(see&nbsp;<Ref Func="IsMonoid"/>)
then <Ref Func="AsMonoid"/> returns this monoid.
Otherwise <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Oper Name="AsSubmonoid" Arg='D, C'/>

<Description>
Let <A>D</A> be a domain and <A>C</A> a collection.
If <A>C</A> is a subset of <A>D</A> that forms a monoid then
<Ref Func="AsSubmonoid"/>
returns this monoid, with parent <A>D</A>.
Otherwise <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfMonoid" Arg='M'/>

<Description>
Monoid generators of a monoid <A>M</A> are the same as
magma-with-one generators
(see&nbsp;<Ref Func="GeneratorsOfMagmaWithOne"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="TrivialSubmonoid" Arg='M'/>

<Description>
is just a synonym for <Ref Func="TrivialSubmagmaWithOne"/>.
</Description>
</ManSection>

<ManSection>
<Heading>FreeMonoid</Heading>
<Func Name="FreeMonoid" Arg='[wfilt, ]rank[, name]'
 Label="for given rank"/>
<Func Name="FreeMonoid" Arg='[wfilt, ]name1, name2, ...'
 Label="for various names"/>
<Func Name="FreeMonoid" Arg='[wfilt, ]names'
 Label="for a list of names"/>
<Func Name="FreeMonoid" Arg='[wfilt, ]infinity, name, init'
 Label="for infinitely many generators"/>

<Description>
Called with a positive integer <A>rank</A>,
<Ref Func="FreeMonoid" Label="for given rank"/> returns
a free monoid on <A>rank</A> generators.
If the optional argument <A>name</A> is given then the generators are
printed as <A>name</A><C>1</C>, <A>name</A><C>2</C> etc.,
that is, each name is the concatenation of the string <A>name</A> and an
integer from <C>1</C> to <A>range</A>.
The default for <A>name</A> is the string <C>"m"</C>.
<P/>
Called in the second form,
<Ref Func="FreeMonoid" Label="for various names"/> returns
a free monoid on as many generators as arguments, printed as
<A>name1</A>, <A>name2</A> etc.
<P/>
Called in the third form,
<Ref Func="FreeMonoid" Label="for a list of names"/> returns
a free monoid on as many generators as the length of the list
<A>names</A>, the <M>i</M>-th generator being printed as
<A>names</A><C>[</C><M>i</M><C>]</C>.
<P/>
Called in the fourth form,
<Ref Func="FreeMonoid" Label="for infinitely many generators"/>
returns a free monoid on infinitely many generators, where the first
generators are printed by the names in the list <A>init</A>,
and the other generators by <A>name</A> and an appended number.
<P/>
If the extra argument <A>wfilt</A> is given, it must be either
<Ref Func="IsSyllableWordsFamily"/> or <Ref Func="IsLetterWordsFamily"/>
or <Ref Func="IsWLetterWordsFamily"/> or
<Ref Func="IsBLetterWordsFamily"/>.
This filter then specifies the representation used for the elements of
the free monoid
(see&nbsp;<Ref Sect="Representations for Associative Words"/>).
If no such filter is given, a letter representation is used.
<P/>
Also see Chapter&nbsp;<Ref Chap="Semigroups"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="MonoidByMultiplicationTable" Arg='A'/>

<Description>
returns the monoid whose multiplication is defined by the square
matrix <A>A</A> (see&nbsp;<Ref Func="MagmaByMultiplicationTable"/>)
if such a monoid exists.
Otherwise <K>fail</K> is returned.
<Example><![CDATA[
gap> MonoidByMultiplicationTable([[1,2,3],[2,3,1],[3,1,2]]);
<monoid of size 3, with 3 generators>
gap> MonoidByMultiplicationTable([[1,2,3],[2,3,1],[1,3,2]]);
fail
]]></Example>
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->


<Section Label="sect:IsInverseSemigroup">
  <Heading>Inverse semigroups and monoids</Heading>
  <ManSection>
    <Func Name="InverseSemigroup"  Arg="obj1, obj2, ... "/>
    <Returns>An inverse semigroup.</Returns>
    <Description>
      If <A>obj1</A>, <A>obj2</A>, ... are (any combination) of
      associative elements with unique semigroup inverses, 
      semigroups of such elements, or collections of such elements, then
      <C>InverseSemigroup</C>
      returns the inverse semigroup generated by the union of
      <A>obj1</A>, <A>obj2</A>, .... This equals the semigroup generated by the
      union of <A>obj1</A>, <A>obj2</A>, ... and their inverses.<P/>

      For example if <C>S</C> and <C>T</C> are inverse semigroups, then 
      <C>InverseSemigroup(S, f, Idempotents(T));</C> is the inverse semigroup
      generated by 
      <C>Union(GeneratorsOfInverseSemigroup(S), [f], Idempotents(T)));</C>.<P/>
      
      As present, the only associative elements with unique semigroup inverses,
      which do not always generate a group, are partial permutations; see
      Chapter <Ref Chap="Partial permutations"/>.

      <Example>
gap> S := InverseSemigroup(
> PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] ) );;
gap> f := PartialPerm( [ 1, 2, 3, 4, 5, 8, 10 ], 
> [ 7, 1, 4, 3, 2, 6, 5 ] );;
gap> S := InverseSemigroup(S, f, Idempotents(SymmetricInverseSemigroup(5)));
&lt;inverse partial perm semigroup of rank 10 with 34 generators>
gap> Size(S);
1233</Example>
  </Description>
  </ManSection>
  
  <ManSection>
    <Func Name="InverseMonoid"  Arg="obj1, obj2, ... "/>
    <Returns>An inverse monoid.</Returns>
    <Description>
      If <A>obj1</A>, <A>obj2</A>, ... are (any combination) of
      associative elements with unique semigroup inverses, 
      semigroups of such elements, or collections of such elements, then
      <C>InverseMonoid</C>
      returns the inverse monoid generated by the union of
      <A>obj1</A>, <A>obj2</A>, .... This equals the monoid generated by the
      union of <A>obj1</A>, <A>obj2</A>, ... and their inverses.<P/>

      As present, the only associative elements with unique semigroup inverses
      are partial permutations; see Chapter 
      <Ref Chap="Partial permutations"/>.<P/>

      For example if <C>S</C> and <C>T</C> are inverse monoids, then 
      <C>InverseMonoid(S, f, Idempotents(T));</C> is the inverse monoid
      generated by 
      <C>Union(GeneratorsOfInverseMonoid(S), [f], Idempotents(T)));</C>.
      <Example>
gap> S := InverseMonoid(
> PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] ) );;
gap> f := PartialPerm( [ 1, 2, 3, 4, 5, 8, 10 ], 
> [ 7, 1, 4, 3, 2, 6, 5 ] );;
gap> S := InverseMonoid(S, f, Idempotents(SymmetricInverseSemigroup(5)));
&lt;inverse partial perm monoid of rank 10 with 35 generators>
gap> Size(S);
1243</Example>
  </Description>
  </ManSection>

<ManSection>
  <Attr Name="GeneratorsOfInverseSemigroup" Arg="S"/>
  <Returns>The generators of an inverse semigroup.</Returns>
  <Description>
    If <A>S</A> is an inverse semigroup, then
    <C>GeneratorsOfInverseSemigroup</C> returns the generators used to define
    <A>S</A>, i.e. an inverse semigroup
    generating set for <A>S</A>. <P/>
   
    The value of <C>GeneratorsOfSemigroup(<A>S</A>)</C>, for an inverse
    semigroup <A>S</A>, is the union of 
    inverse semigroup generator and their inverses.
    So, <A>S</A> is the semigroup, as opposed to inverse semigroup,
    generated by the elements of <C>GeneratorsOfInverseSemigroup(<A>S</A>)</C>
    and their inverses.  <P/>

    If <A>S</A> is an inverse monoid, then <C>GeneratorsOfInverseSemigroup</C>
    returns the generators used to define <A>S</A>, as
    described above, and the identity of <A>S</A>.

    <Example><![CDATA[
gap> S:=InverseMonoid(
>  PartialPerm( [ 1, 2 ], [ 1, 4 ] ),
>  PartialPerm( [ 1, 2, 4 ], [ 3, 4, 1 ] ) );;
gap> GeneratorsOfSemigroup(S);
[ <identity partial perm on [ 1, 2, 3, 4 ]>, [2,4](1), [2,4,1,3], 
  [4,2](1), [3,1,4,2] ]
gap> GeneratorsOfInverseSemigroup(S);
[ [2,4](1), [2,4,1,3], <identity partial perm on [ 1, 2, 3, 4 ]> ]
gap> GeneratorsOfMonoid(S);
[ [2,4](1), [2,4,1,3], [4,2](1), [3,1,4,2] ]]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="GeneratorsOfInverseMonoid" Arg="S"/>
  <Returns>The generators of an inverse monoid.</Returns>
  <Description>
    If <A>S</A> is an inverse monoid, then
    <C>GeneratorsOfInverseMonoid</C> returns the generators used to
    define <A>S</A>, i.e. an inverse monoid
    generating set for <A>S</A>. <P/>

    There are four different possible generating sets which define an inverse
    monoid. More precisely, an inverse monoid can be generated as an inverse
    monoid, inverse semigroup, monoid, or semigroup. The different generating
    sets in each case can be obtained using 
    <Ref Attr="GeneratorsOfInverseMonoid"/>, 
    <Ref Attr="GeneratorsOfInverseSemigroup"/>, 
    <Ref Attr="GeneratorsOfMonoid"/>, and
    <Ref Attr="GeneratorsOfSemigroup"/>, respectively.

    <Example>
gap> S:=InverseMonoid(
>  PartialPerm( [ 1, 2 ], [ 1, 4 ] ),
>  PartialPerm( [ 1, 2, 4 ], [ 3, 4, 1 ] ) );;
gap> GeneratorsOfInverseMonoid(S);
[ [2,4](1), [2,4,1,3] ]</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="IsInverseSubsemigroup" Arg="S, T"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    If the semigroup <A>T</A> is an inverse subsemigroup of the semigroup
    <A>S</A>, then this operation returns <K>true</K>.

    <Example>
gap> T:=InverseSemigroup(RandomPartialPerm(4));;
gap> IsInverseSubsemigroup(SymmetricInverseSemigroup(4), T); 
true
gap> T:=Semigroup(Transformation( [ 1, 2, 4, 5, 6, 3, 7, 8 ] ),
> Transformation( [ 3, 3, 4, 5, 6, 2, 7, 8 ] ),
> Transformation([ 1, 2, 5, 3, 6, 8, 4, 4 ] ));;
gap> IsInverseSubsemigroup(FullTransformationSemigroup(8), T);
true</Example>
  </Description>
</ManSection>

</Section>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties of Semigroups">
<Heading>Properties of Semigroups</Heading>

The following functions determine information
about semigroups.

<ManSection>
<Prop Name="IsRegularSemigroup" Arg='S'/>

<Description>
returns <K>true</K> if <A>S</A> is regular, i.e.,
if every &D;-class of <A>S</A> is regular.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsRegularSemigroupElement" Arg='S, x'/>

<Description>
returns <K>true</K> if <A>x</A> has a general inverse in <A>S</A>, i.e.,
there is an element <M>y \in <A>S</A></M>
such that <M><A>x</A> y <A>x</A> = <A>x</A></M> and
<M>y <A>x</A> y = y</M>.
</Description>
</ManSection>


<ManSection>
  <Oper Name="InversesOfSemigroupElement" Arg="S, x"/>
  <Returns>The inverses of an element of a semigroup.</Returns>
  <Description>
    <C>InversesOfSemigroupElement</C> returns a list of the inverses of the 
    element <A>x</A> in the semigroup <A>S</A>.<P/>
     
    An element <A>y</A> in <A>S</A> is an <E>inverse</E> of <A>x</A> if      
    <C><A>x</A>*y*<A>x</A>=<A>x</A></C> and <C>y*<A>x</A>*y=y</C>.
    The element <A>x</A> has an inverse if and only if <A>x</A> is a regular  
    element of <A>S</A>.
    <Example>
gap> S:=Semigroup([ Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] ), 
>  Transformation( [ 5, 7, 8, 8, 7, 5, 9, 1, 9 ] ), 
>  Transformation( [ 7, 6, 2, 8, 4, 7, 5, 8, 3 ] ) ]);;
gap> x:=Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] );;
gap> InversesOfSemigroupElement(S, x);
[  ]
gap> IsRegularSemigroupElement(S, x);
false
gap> x:=Transformation( [ 1, 9, 7, 5, 5, 1, 9, 5, 1 ] );;
gap> Set(InversesOfSemigroupElement(S, x));
[ Transformation( [ 1, 2, 3, 5, 5, 1, 3, 5, 2 ] ), 
  Transformation( [ 1, 5, 1, 1, 5, 1, 3, 1, 2 ] ), 
  Transformation( [ 1, 5, 1, 2, 5, 1, 3, 2, 2 ] ) ]
gap> IsRegularSemigroupElement(S, x);
true
gap> S:=ReesZeroMatrixSemigroup(Group((1,2,3)), 
> [ [ (), () ], [ (), 0 ], [ (), (1,2,3) ] ]);;
gap> x:=ReesZeroMatrixSemigroupElement(S, 2, (1,2,3), 3);;
gap> InversesOfSemigroupElement(S, x);
[ (1,(1,2,3),3), (1,(1,3,2),1), (2,(),3), (2,(1,2,3),1) ]</Example>
  </Description>
</ManSection>

<ManSection>
<Prop Name="IsSimpleSemigroup" Arg='S'/>

<Description>
is <K>true</K> if and only if the semigroup <A>S</A> has no proper
ideals.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsZeroSimpleSemigroup" Arg='S'/>

<Description>
is <K>true</K> if and only if the semigroup has no proper ideals except
for 0, where <A>S</A> is a semigroup with zero. 
If the semigroup does not find its zero, then a break-loop is entered.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsZeroGroup" Arg='S'/>

<Description>
is <K>true</K> if and only if the semigroup <A>S</A> is a group with zero
adjoined.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsReesCongruenceSemigroup" Arg='S'/>

<Description>
returns <K>true</K> if <A>S</A> is a Rees Congruence semigroup, that is,
if all congruences of <A>S</A> are Rees Congruences.
</Description>
</ManSection>


<ManSection>
  <Prop Name="IsInverseSemigroup" Arg="S"/>
  <Prop Name="IsInverseMonoid" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A semigroup is an <E>inverse semigroup</E> if every element
    <C>x</C> has a unique semigroup inverse, that is, a unique
    element <C>y</C> such that <C>x*y*x=x</C> and <C>y*x*y=y</C>.<P/>

    A monoid that happens to be an inverse semigroup is called an <E>inverse
      monoid</E>. 
    <Example>
gap> S:=Semigroup( Transformation( [ 1, 2, 4, 5, 6, 3, 7, 8 ] ),
> Transformation( [ 3, 3, 4, 5, 6, 2, 7, 8 ] ),
> Transformation( [ 1, 2, 5, 3, 6, 8, 4, 4 ] ) );;
gap> IsInverseSemigroup(S);
true</Example>
  </Description>
</ManSection>

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Ideals of semigroups">
<Heading>Ideals of semigroups</Heading>

Ideals of semigroups are the same as ideals of the semigroup when 
considered as a magma.
For documentation on ideals for magmas, see <Ref Func="Magma"/>.

<ManSection>
<Oper Name="SemigroupIdealByGenerators" Arg='S, gens'/>

<Description>
<A>S</A> is a semigroup, <A>gens</A> is a list of elements of <A>S</A>.
Returns the two-sided ideal of <A>S</A> generated by <A>gens</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ReesCongruenceOfSemigroupIdeal" Arg='I'/>

<Description>
A two sided ideal <A>I</A> of a semigroup <A>S</A>  defines a congruence on 
<A>S</A> given by <M>\Delta \cup I \times I</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLeftSemigroupIdeal" Arg='I'/>
<Prop Name="IsRightSemigroupIdeal" Arg='I'/>
<Prop Name="IsSemigroupIdeal" Arg='I'/>

<Description>
Categories of semigroup ideals.
</Description>
</ManSection>

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Congruences for semigroups">
<Heading>Congruences for semigroups</Heading>

An equivalence or a congruence on a semigroup is the
equivalence or congruence on the semigroup considered as a magma.
So, to deal with equivalences and congruences on semigroups,
magma functions are used.
For documentation on equivalences and congruences for magmas,
see <Ref Func="Magma"/>.

<ManSection>
<Prop Name="IsSemigroupCongruence" Arg='c'/>

<Description>
a magma congruence <A>c</A> on a semigroup.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsReesCongruence" Arg='c'/>

<Description>
returns <K>true</K> if and only if the congruence <A>c</A> has at most
one nonsingleton congruence class.
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Quotients">
<Heading>Quotients</Heading>

Given a semigroup and a congruence on the semigroup, one
can construct a new semigroup: the quotient semigroup.
The following functions deal with quotient semigroups in &GAP;.

For a semigroup <M>S</M>,
elements of a quotient semigroup are equivalence classes of 
elements of the <Ref Func="QuotientSemigroupPreimage"/> value
under the congruence given by the value of
<Ref Func="QuotientSemigroupCongruence"/>.
<P/>
It is probably most useful for calculating the elements of 
the equivalence classes by using <Ref Func="Elements"/> or by looking at
the images of elements of <Ref Func="QuotientSemigroupPreimage"/> under
the map returned by <Ref Func="QuotientSemigroupHomomorphism"/>,
which maps the <Ref Func="QuotientSemigroupPreimage"/> value to <A>S</A>.
<P/>
For intensive computations in a quotient semigroup, it is probably
worthwhile finding another representation as the equality test 
could involve enumeration of the elements of the congruence classes
being compared.

<ManSection>
<Filt Name="IsQuotientSemigroup" Arg='S' Type='Category'/>

<Description>
is the category of semigroups constructed from another semigroup 
and a congruence on it.
</Description>
</ManSection>

<ManSection>
<Func Name="HomomorphismQuotientSemigroup" Arg='cong'/>

<Description>
for a congruence <A>cong</A> and a semigroup <A>S</A>. 
Returns the homomorphism from <A>S</A> to the quotient of <A>S</A> 
by <A>cong</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="QuotientSemigroupPreimage" Arg='S'/>
<Attr Name="QuotientSemigroupCongruence" Arg='S'/>
<Attr Name="QuotientSemigroupHomomorphism" Arg='S'/>

<Description>
for a quotient semigroup <A>S</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Green's Relations">
<Heading>Green's Relations</Heading>

Green's equivalence relations play a very important role in semigroup
theory. In this section we describe how they can be used in &GAP;.
<P/>
The five Green's relations are <M>R</M>, <M>L</M>, <M>J</M>, <M>H</M>,
<M>D</M>:
two elements <M>x</M>, <M>y</M> from a semigroup <M>S</M> are
<M>R</M>-related if and only if <M>xS^1 = yS^1</M>,
<M>L</M>-related if and only if <M>S^1 x = S^1 y</M>
and <M>J</M>-related if and only if <M>S^1 xS^1 = S^1 yS^1</M>;
finally, <M>H = R \wedge L</M>, and <M>D = R \circ L</M>.
<P/>
Recall that relations <M>R</M>, <M>L</M> and <M>J</M> induce a partial
order among the elements of the semigroup <M>S</M>:
for two elements <M>x</M>, <M>y</M> from <M>S</M>,
we say that <M>x</M> is less than or equal to <M>y</M> in the order on
<M>R</M> if <M>xS^1 \subseteq yS^1</M>;
similarly, <M>x</M> is less than or equal to <M>y</M> under <M>L</M> if
<M>S^1x \subseteq S^1y</M>;
finally <M>x</M> is less than or equal to <M>y</M> under <M>J</M> if
<M>S^1 xS^1 \subseteq S^1 tS^1</M>.
We extend this preorder to a partial order on equivalence classes in
the natural way.

<ManSection>
<Attr Name="GreensRRelation" Arg='semigroup'/>
<Attr Name="GreensLRelation" Arg='semigroup'/>
<Attr Name="GreensJRelation" Arg='semigroup'/>
<Attr Name="GreensDRelation" Arg='semigroup'/>
<Attr Name="GreensHRelation" Arg='semigroup'/>

<Description>
The Green's relations (which are equivalence relations)
are attributes of the semigroup <A>semigroup</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGreensRelation" Arg='bin-relation'/>
<Prop Name="IsGreensRRelation" Arg='equiv-relation'/>
<Prop Name="IsGreensLRelation" Arg='equiv-relation'/>
<Prop Name="IsGreensJRelation" Arg='equiv-relation'/>
<Prop Name="IsGreensHRelation" Arg='equiv-relation'/>
<Prop Name="IsGreensDRelation" Arg='equiv-relation'/>

<Description>
Categories for the Green's relations.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGreensClass" Arg='equiv-class'/>
<Prop Name="IsGreensRClass" Arg='equiv-class'/>
<Prop Name="IsGreensLClass" Arg='equiv-class'/>
<Prop Name="IsGreensJClass" Arg='equiv-class'/>
<Prop Name="IsGreensHClass" Arg='equiv-class'/>
<Prop Name="IsGreensDClass" Arg='equiv-class'/>

<Description>
return <K>true</K> if the equivalence class <A>equiv-class</A> is
a Green's class of any type, or of <M>R</M>, <M>L</M>, <M>J</M>,
<M>H</M>, <M>D</M> type, respectively, or <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsGreensLessThanOrEqual" Arg='C1, C2'/>

<Description>
returns <K>true</K> if the Green's class <A>C1</A> is less than or equal
to <A>C2</A>  under the respective ordering (as defined above),
and <K>false</K> otherwise.
<P/>
Only defined for <M>R</M>, <M>L</M> and <M>J</M> classes.
</Description>
</ManSection>

<ManSection>
<Attr Name="RClassOfHClass" Arg='H'/>
<Attr Name="LClassOfHClass" Arg='H'/>

<Description>
are attributes reflecting the natural ordering over the various Green's
classes. <Ref Func="RClassOfHClass"/> and <Ref Func="LClassOfHClass"/>
return the <M>R</M> and <M>L</M> classes, respectively,
in which an <M>H</M> class is contained.
</Description>
</ManSection>

<ManSection>
<Attr Name="EggBoxOfDClass" Arg='Dclass'/>

<Description>
returns for a Green's <M>D</M> class <A>Dclass</A> a matrix whose rows
represent <M>R</M> classes and columns represent <M>L</M> classes.
The entries are the <M>H</M> classes.
</Description>
</ManSection>

<ManSection>
<Func Name="DisplayEggBoxOfDClass" Arg='Dclass'/>

<Description>
displays a <Q>picture</Q> of the <M>D</M> class <A>Dclass</A>,
as an array of 1s and 0s.
A 1 represents a group <M>H</M> class.
</Description>
</ManSection>

<ManSection>
<Oper Name="GreensRClassOfElement" Arg='S, a'/>
<Oper Name="GreensLClassOfElement" Arg='S, a'/>
<Oper Name="GreensDClassOfElement" Arg='S, a'/>
<Oper Name="GreensJClassOfElement" Arg='S, a'/>
<Oper Name="GreensHClassOfElement" Arg='S, a'/>

<Description>
Creates the <M>X</M> class of the element <A>a</A>
in the semigroup <A>S</A> where <M>X</M> is one of
<M>L</M>, <M>R</M>, <M>D</M>, <M>J</M>, or <M>H</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GreensRClasses" Arg='semigroup'/>
<Attr Name="GreensLClasses" Arg='semigroup'/>
<Attr Name="GreensJClasses" Arg='semigroup'/>
<Attr Name="GreensDClasses" Arg='semigroup'/>
<Attr Name="GreensHClasses" Arg='semigroup'/>

<Description>
return the <M>R</M>, <M>L</M>, <M>J</M>, <M>H</M>, or <M>D</M>
Green's classes, respectively for semigroup <A>semigroup</A>.
<Ref Func="EquivalenceClasses" Label="attribute"/> for a Green's relation
lead to one of these functions.
</Description>
</ManSection>

<ManSection>
<Attr Name="GroupHClassOfGreensDClass" Arg='Dclass'/>

<Description>
for a <M>D</M> class <A>Dclass</A> of a semigroup,
returns a group <M>H</M> class of the <M>D</M> class,
or <K>fail</K> if there is no group <M>H</M> class.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGroupHClass" Arg='Hclass'/>

<Description>
returns <K>true</K> if the Green's <M>H</M> class <A>Hclass</A> is a
group, which in turn is true if and only if <A>Hclass</A><M>^2</M>
intersects <A>Hclass</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsRegularDClass" Arg='Dclass'/>

<Description>
returns <K>true</K> if the Greens <M>D</M> class <A>Dclass</A> is
regular.
A <M>D</M> class is regular if and only if each of its elements is
regular, which in turn is true if and only if any one element of
<A>Dclass</A> is regular.
Idempotents are regular since <M>eee = e</M> so it follows that a Green's
<M>D</M> class containing an idempotent is regular.
Conversely, it is true that a regular <M>D</M> class must contain
at least one idempotent.
(See&nbsp;<Cite Key="Howie76" Where="Prop. 3.2"/>.)
</Description>
</ManSection>


</Section>

<Section Label="Rees Matrix Semigroups">
  <Heading>Rees Matrix Semigroups</Heading>
    
  In this section, we describe the functions in &GAP; for Rees matrix
  and 0-matrix semigroups and their subsemigroups.  The importance of these
  semigroups lies in the fact that Rees matrix semigroups over groups are
  exactly the completely simple semigroups, and Rees 0-matrix semigroups over
  groups are the completely 0-simple semigroups.  <P/>

  Let <M>I</M> and <M>J</M> be sets, let <M>S</M> be a semigroup, and let
  <M>P=(p_{ji})_{j\in J, i\in I}</M> be a <M>|J|\times |I|</M> matrix with
  entries in <M>S</M>. Then the <E>Rees matrix semigroup</E> with underlying
  semigroup <M>S</M> and matrix <M>P</M> is just the direct product 
  <M>I\times S \times J</M> with multiplication defined by 
  <Display>(i, s, j)(k, t, l)=(i,s\cdot p_{j,k}\cdot t, l).</Display>

  Rees 0-matrix semigroups are defined as follows. If <M>I</M>, <M>J</M>,
  <M>S</M>, and <M>P</M> are as above and <M>0</M> denotes a new element, then
  the <E>Rees 0-matrix semigroup</E> with underlying semigroup <M>S</M> and
  matrix <M>P</M> is <M>(I\times S\times J)\cup \{0\}</M> with multiplication
  defined by 
  <Display>(i, s, j)(k, t, l)=(i, s\cdot p_{j,k}\cdot t, l)</Display> 
  when <M>p_{j,k}</M> is not <M>0</M> and <M>0</M> if <M>p_{j,k}</M> is 0.<P/>

  If <M>R</M> is a Rees matrix or 0-matrix semigroup, then the <E>rows</E> of
  <M>R</M> is the index set <M>I</M>, the <E>columns</E> of <M>R</M> is the
  index set <M>J</M>, the semigroup <M>S</M> is the <E>underlying semigroup</E>
  of <M>R</M>, and the <E>matrix</E> <M>P</M> is the matrix of <M>S</M>. <P/>

  Thoroughout this section, wherever the distinction is unimportant, we will
  refer to Rees matrix or 0-matrix semigroups collectively as Rees matrix
  semigroups.<P/>

  Multiplication of elements of a Rees matrix semigroup obviously depends on
  the matrix used to create the semigroup. Hence elements of a Rees matrix
  semigroup can only be created with reference to the semigroup to which they
  belong. More specifically, every collection or semigroup of Rees matrix
  semigroup elements is created from a specific Rees matrix semigroup, which
  contains the whole family of its elements.  So, it is not possible to
  multiply or compare elements belonging to distinct Rees matrix semigroups, 
  since they belong to different families. This situation is similar to, say,
  free groups, and different to, say, permutations, which belong to a single
  family, and where arbitrary permutations can be compared and multiplied
  without reference to any group containing them. <P/>

  A subsemigroup of a Rees matrix semigroup is not necessarily a Rees matrix
  semigroup.  Every semigroup consisting of elements of a Rees matrix semigroup
  satisfies the property <Ref Attr="IsReesMatrixSubsemigroup"/> and every
  semigroup of Rees 0-matrix semigroup elements satisfies 
  <Ref Attr="IsReesZeroMatrixSubsemigroup"/>. <P/>
    
  Rees matrix and 0-matrix semigroups can be created using the operations 
  <Ref Oper="ReesMatrixSemigroup"/> and <Ref Oper="ReesZeroMatrixSemigroup"/>,
  respectively, from an underlying semigroup and a matrix. Rees matrix
  semigroups created in this way contain the whole family of their elements.
  Every element of a Rees matrix semigroup belongs to a unique semigroup
  created in this way; every subsemigroup of a Rees matrix semigroup
  is a subsemigroup of a unique semigroup created in this way.<P/>

  Subsemigroups of Rees matrix semigroups can also be created by specifying
  generators. A subsemigroup of a Rees matrix semigroup <M>I\times U\times J</M>
  satisfies <Ref Prop="IsReesMatrixSemigroup"/> if and only if it is equal to 
  <M>I'\times U'\times J'</M> where <M>I'\subseteq I</M>, <M>J'\subseteq J</M>,
      and <M>U'</M> is a subsemigroup of <M>U</M>.
  The analogous statements holds for Rees 0-matrix semigroups. <P/>

  It is not necessarily the case that a simple subsemigroups of Rees matrix
  semigroups satisfies <Ref Prop="IsReesMatrixSemigroup"/>. A Rees matrix semigroup is
  simple if and only if its underlying semigroup is simple. 
  A finite semigroup is simple if and only if it is isomorphic to a Rees matrix
  semigroup over a group; this isomorphism can be obtained explicitly using 
  <Ref Attr="IsomorphismReesMatrixSemigroup"/>.<P/>

  Similarly, 0-simple subsemigroups of Rees 0-matrix semigroups do not have to
  satisfy <Ref Prop="IsReesZeroMatrixSemigroup"/>.  A Rees 0-matrix semigroup
  with more than 2 elements is 0-simple if and only if every row and every
  column of its matrix contains a non-zero entry, and its underlying semigroup
  is simple. A finite semigroup is 0-simple if and only if it is isomorphic to a
  Rees 0-matrix semigroup over a group; again this isomorphism can be found by
  using <Ref Attr="IsomorphismReesZeroMatrixSemigroup"/>.<P/>

  Elements of a Rees matrix or 0-matrix semigroup belong to the categories 
  <Ref Filt="IsReesMatrixSemigroupElement"/> and 
  <Ref Filt="IsReesZeroMatrixSemigroupElement"/>, respectively. 
  Such elements can be created directly using the functions 
  <Ref Func="ReesMatrixSemigroupElement"/> and 
  <Ref Func="ReesZeroMatrixSemigroupElement"/>. <P/>

  A semigroup in &GAP; can either satisfies <Ref Prop="IsReesMatrixSemigroup"/>
  or <Ref Prop="IsReesZeroMatrixSemigroup"/> but not both.

  <ManSection>
    <Oper Name="ReesMatrixSemigroup" Arg="S, mat"/>
    <Oper Name="ReesZeroMatrixSemigroup" Arg="S, mat"/>
    <Returns>A Rees matrix or 0-matrix semigroup.</Returns>
    <Description>
      When <A>S</A> is a semigroup and <A>mat</A> is an <C>m</C> by <C>n</C>
      matrix with entries in <A>S</A>, the function <C>ReesMatrixSemigroup</C>
      returns the <C>n</C> by <C>m</C> Rees matrix semigroup over <A>S</A> with
      multiplication defined by <A>mat</A>. <P/>

      The arguments of <C>ReesZeroMatrixSemigroup</C> should be a semigroup
      <A>S</A> and an <C>m</C> by <C>n</C> matrix <A>mat</A> with entries in
      <A>S</A> or equal to the integer <C>0</C>. <C>ReesZeroMatrixSemigroup</C>
      returns the <C>n</C> by <C>m</C> Rees 0-matrix semigroup over <A>S</A>
      with multiplication defined by <A>mat</A>. In &GAP; a Rees 0-matrix
      semigroup always contains a multiplicative zero element, regardless of
      whether there are any entries in <A>mat</A> which are equal to <C>0</C>.
      
      <Example><![CDATA[
gap> G:=Random(AllGroups(Size, 32));;
gap> mat:=List([1..5], x-> List([1..3], y-> Random(G)));;
gap> S:=ReesMatrixSemigroup(G, mat);
<Rees matrix semigroup 3x5 over <pc group of size 32 with 
 5 generators>>
gap> mat:=[[(), 0, (), ()], [0, 0, 0, 0]];;
gap> S:=ReesZeroMatrixSemigroup(DihedralGroup(IsPermGroup, 8), mat);
<Rees 0-matrix semigroup 4x2 over Group([ (1,2,3,4), (2,4) ])>
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="ReesMatrixSubsemigroup" Arg="R, I, U, J"/>
    <Oper Name="ReesZeroMatrixSubsemigroup" Arg="R, I, U, J"/>
    <Returns>A Rees matrix or 0-matrix subsemigroup.</Returns>
    <Description>
      The arguments of <C>ReesMatrixSubsemigroup</C> should be a Rees matrix
      semigroup <A>R</A>, subsets <A>I</A> and <A>J</A> of the rows and columns
      of <A>R</A>, respectively, and a subsemigroup <A>S</A> of the underlying
      semigroup of <A>R</A>. <C>ReesMatrixSubsemigroup</C>
      returns the subsemigroup of <A>R</A> generated by the direct product of
      <A>I</A>, <A>U</A>, and <A>J</A>. <P/>      

      The usage and returned value of <C>ReesZeroMatrixSubsemigroup</C> is
      analogous when <A>R</A> is a Rees 0-matrix semigroup. 
      <Example><![CDATA[
gap> G:=CyclicGroup(IsPermGroup, 1007);;
gap> mat:=[[(), 0, 0], [0, (), 0], [0, 0, ()], 
> [(), (), ()], [0, 0, ()]];;
gap> R:=ReesZeroMatrixSemigroup(G, mat);
<Rees 0-matrix semigroup 3x5 over 
  <permutation group of size 1007 with 1 generators>>
gap> ReesZeroMatrixSubsemigroup(R, [1,3], G, [1..5]);
<Rees 0-matrix semigroup 2x5 over 
  <permutation group of size 1007 with 1 generators>>
]]></Example>
    </Description>
  </ManSection>
  
  <ManSection>
    <Attr Name="IsomorphismReesMatrixSemigroup" Arg="S"/>
    <Attr Name="IsomorphismReesZeroMatrixSemigroup" Arg="S"/>
    <Returns>An isomorphism.</Returns>
    <Description>
      Every finite simple semigroup is isomorphic to a Rees matrix semigroup
      over a group, and every finite 0-simple semigroup is isomorphic to a Rees
      0-matrix semigroup over a group.
      <P/>

      If the argument <A>S</A> is a simple semigroup, then
      <C>IsomorphismReesMatrixSemigroup</C> returns an isomorphism to a Rees
      matrix semigroup over a group. If <A>S</A> is not simple, then
      <C>IsomorphismReesMatrixSemigroup</C> returns an error.
      <P/>
      
      If the argument <A>S</A> is a 0-simple semigroup, then
      <C>IsomorphismReesZeroMatrixSemigroup</C> returns an isomorphism to a
      Rees 0-matrix semigroup over a group. If <A>S</A> is not 0-simple, then
      <C>IsomorphismReesMatrixSemigroup</C> returns an error.
      <P/>
      
      See <Ref Prop="IsSimpleSemigroup"/> and 
      <Ref Prop="IsZeroSimpleSemigroup"/>.
      <Example><![CDATA[
gap> S := Semigroup(Transformation([2, 1, 1, 2, 1]), 
>                   Transformation([3, 4, 3, 4, 4]), 
>                   Transformation([3, 4, 3, 4, 3]),  
>                   Transformation([4, 3, 3, 4, 4]));;
gap> IsSimpleSemigroup(S);
true
gap> Range(IsomorphismReesMatrixSemigroup(S));
<Rees matrix semigroup 4x2 over Group([ (1,2) ])>
gap> mat := [[(), 0, 0], 
>            [0, (), 0], 
>            [0, 0, ()]];;
gap> R := ReesZeroMatrixSemigroup(Group((1,2,4,5,6)), mat);
<Rees 0-matrix semigroup 3x3 over Group([ (1,2,4,5,6) ])>
gap> U := ReesZeroMatrixSubsemigroup(R, [1, 2], Group(()), [2, 3]);
<subsemigroup of 3x3 Rees 0-matrix semigroup with 4 generators>
gap> IsZeroSimpleSemigroup(U);
false
gap> U := ReesZeroMatrixSubsemigroup(R, [2, 3], Group(()), [2, 3]);
<subsemigroup of 3x3 Rees 0-matrix semigroup with 3 generators>
gap> IsZeroSimpleSemigroup(U);
true
gap> Rows(U); Columns(U);
[ 2, 3 ]
[ 2, 3 ]
gap> V := Range(IsomorphismReesZeroMatrixSemigroup(U));
<Rees 0-matrix semigroup 2x2 over Group(())>
gap> Rows(V); Columns(V); 
[ 1, 2 ]
[ 1, 2 ]]]></Example>
    </Description>
  </ManSection>

  <ManSection>
  <Filt Name="IsReesMatrixSemigroupElement" Arg="elt" Type="Category"/>
  <Filt Name="IsReesZeroMatrixSemigroupElement" Arg="elt" Type="Category"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Every element of a Rees matrix semigroup belongs to the category
    <C>IsReesMatrixSemigroupElement</C>, and every element of a Rees 0-matrix
    semigroup belongs to the category <C>IsReesZeroMatrixSemigroupElement</C>.
    <Example><![CDATA[
gap> G:=Group((1,2,3));;
gap> mat:=[ [ (), (1,3,2) ], [ (1,3,2), () ] ];;
gap> R:=ReesMatrixSemigroup(G, mat);
<Rees matrix semigroup 2x2 over Group([ (1,2,3) ])>
gap> GeneratorsOfSemigroup(R);
[ (1,(1,2,3),1), (2,(),2) ]
gap> IsReesMatrixSemigroupElement(last[1]);
true
gap> IsReesZeroMatrixSemigroupElement(last2[1]);
false]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="ReesMatrixSemigroupElement" Arg="R, i, x, j"/>
    <Func Name="ReesZeroMatrixSemigroupElement" Arg="R, i, x, j"/>
    <Returns>An element of a Rees matrix or <C>0</C>-matrix semigroup.</Returns>
    <Description>
      The arguments of <A>ReesMatrixSemigroupElement</A> should be a
      Rees matrix subsemigroup <A>R</A>, elements <A>i</A> and <A>j</A> of the 
      the rows and columns of <A>R</A>, respectively, and an element <A>x</A> 
      of the underlying semigroup of <A>R</A>.
      <C>ReesMatrixSemigroupElement</C> returns the element of <A>R</A> with row
      index <A>i</A>, underlying element <A>x</A> in the underlying semigroup of
      <A>R</A>, and column index <A>j</A>, if such an element exist, if such an
      element exists.<P/>

      The usage of <C>ReesZeroMatrixSemigroupElement</C> is analogous to that
      of <C>ReesMatrixSemigroupElement</C>, when <A>R</A> is a Rees 0-matrix
      semigroup. <P/>

      The  row <A>i</A>, underlying element <A>x</A>, and column <A>j</A> of an
      element <C>y</C> of a Rees matrix (or 0-matrix) semigroup can be
      recovered from <C>y</C> using <C>y[1]</C>, <C>y[2]</C>, and <C>y[3]</C>,
      respectively.<P/>

      <Example><![CDATA[
gap> G:=Group((1,2,3));;
gap> mat:=[ [ 0, () ], [ (1,3,2), (1,3,2) ] ];;
gap> R:=ReesZeroMatrixSemigroup(G, mat);
<Rees 0-matrix semigroup 2x2 over Group([ (1,2,3) ])>
gap> ReesZeroMatrixSemigroupElement(R, 1, (1,2,3), 2);
(1,(1,2,3),2)
gap> MultiplicativeZero(R);
0]]></Example>
  </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsReesMatrixSubsemigroup" Arg="R"/>
    <Prop Name="IsReesZeroMatrixSubsemigroup" Arg="R"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
    Every semigroup consisting of elements of a Rees matrix
    semigroup satisfies the property <Ref Attr="IsReesMatrixSubsemigroup"/> and
    every semigroup of Rees 0-matrix semigroup elements satisfies 
    <Ref Attr="IsReesZeroMatrixSubsemigroup"/>.   <P/>
    Note that a subsemigroup of a Rees matrix semigroup is not necessarily a
    Rees matrix semigroup.  
   
    <Example><![CDATA[
gap> G:=DihedralGroup(32);;
gap> mat:=List([1..2], x-> List([1..10], x-> Random(G)));;
gap> R:=ReesMatrixSemigroup(G, mat);
<Rees matrix semigroup 10x2 over <pc group of size 32 with 
 5 generators>>
gap> S:=Semigroup(GeneratorsOfSemigroup(R));      
<subsemigroup of 10x2 Rees matrix semigroup with 14 generators>
gap> IsReesMatrixSubsemigroup(S); 
true
gap> S:=Semigroup(GeneratorsOfSemigroup(R)[1]);
<subsemigroup of 10x2 Rees matrix semigroup with 1 generator>
gap> IsReesMatrixSubsemigroup(S);
true]]></Example> 
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsReesMatrixSemigroup" Arg="R"/>
    <Prop Name="IsReesZeroMatrixSemigroup" Arg="R"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      A subsemigroup of a Rees matrix semigroup <M>I\times U\times J</M>
      satisfies <Ref Prop="IsReesMatrixSemigroup"/> if and only if it is equal to
      <M>I'\times U'\times J'</M> where <M>I'\subseteq I</M>, <M>J'\subseteq J</M>,
      and <M>U'</M> is a subsemigroup of <M>U</M>. 
      It can be costly to check that a subsemigroup defined by generators satisfies
      <C>IsReesMatrixSemigroup</C>.
      The  analogous statements holds for Rees 0-matrix semigroups. <P/>

      It is not necessarily the case that a simple subsemigroups of Rees matrix
      semigroups satisfies <Ref Prop="IsReesMatrixSemigroup"/>. A Rees matrix
      semigroup is simple if and only if its underlying semigroup is simple. 
      A finite semigroup is simple if and only if it is isomorphic to a Rees matrix
      semigroup over a group; this isomorphism can be obtained explicitly using 
      <Ref Attr="IsomorphismReesMatrixSemigroup"/>.<P/>

      Similarly, 0-simple subsemigroups of Rees 0-matrix semigroups do not have to
      satisfy <Ref Prop="IsReesZeroMatrixSemigroup"/>.  A Rees 0-matrix
      semigroup with more than 2 elements is 0-simple if and only if every row
      and every column of its matrix contains a non-zero entry, and its
      underlying semigroup is simple. A finite semigroup is 0-simple if and only
      if it is isomorphic to a Rees 0-matrix semigroup over a group; again this
      isomorphism can be found by using <Ref Attr="IsomorphismReesMatrixSemigroup"/>.

<Example><![CDATA[
gap> G:=PSL(2,5);;
gap> mat:=[ [ 0, (), 0, (2,6,3,5,4) ], 
> [ (), 0, (), 0 ], [ 0, 0, 0, () ] ];;
gap> R:=ReesZeroMatrixSemigroup(G, mat);
<Rees 0-matrix semigroup 4x3 over Group([ (3,5)(4,6), (1,2,5)
(3,4,6) ])>
gap> IsReesZeroMatrixSemigroup(R);
true
gap> U:=ReesZeroMatrixSubsemigroup(R, [1..3], Group(()), [1..2]);
<subsemigroup of 4x3 Rees 0-matrix semigroup with 4 generators>
gap> IsReesZeroMatrixSemigroup(U);
true
gap> V:=Semigroup(GeneratorsOfSemigroup(U));
<subsemigroup of 4x3 Rees 0-matrix semigroup with 4 generators>
gap> IsReesZeroMatrixSemigroup(V);
true
gap> S:=Semigroup(Transformation([1,1]), Transformation([1,2]));
<commutative transformation monoid of degree 2 with 1 generator>
gap> IsSimpleSemigroup(S);
false
gap> mat:=[[0, One(S), 0, One(S)], [One(S), 0, One(S), 0], 
> [0, 0, 0, One(S)]];;
gap> R:=ReesZeroMatrixSemigroup(S, mat);;
gap> U:=ReesZeroMatrixSubsemigroup(R, [1..3], 
> Semigroup(Transformation([1,1])), [1..2]);
<subsemigroup of 4x3 Rees 0-matrix semigroup with 6 generators>
gap> V:=Semigroup(GeneratorsOfSemigroup(U));
<subsemigroup of 4x3 Rees 0-matrix semigroup with 6 generators>
gap> IsReesZeroMatrixSemigroup(V);
true
gap> T:=Semigroup(
> ReesZeroMatrixSemigroupElement(R, 3, Transformation( [ 1, 1 ] ), 3), 
> ReesZeroMatrixSemigroupElement(R, 2, Transformation( [ 1, 1 ] ), 2));
<subsemigroup of 4x3 Rees 0-matrix semigroup with 2 generators>
gap> IsReesZeroMatrixSemigroup(T);
false]]></Example>
  </Description>  
</ManSection>

  <ManSection>
    <Attr Name="Matrix" Arg="R"/>
    <Returns>A matrix.</Returns>
    <Description>
      If <A>R</A> is a Rees matrix or 0-matrix semigroup, then 
      <C>Matrix</C> returns the matrix used to define multiplication in
      <A>R</A>. <P/>

      More specifically, if <A>R</A> is a Rees matrix or 0-matrix semigroup,
      which is a proper subsemigroup of another such semigroup, then 
      <C>Matrix</C> returns the matrix used to define the Rees matrix (or
      0-matrix) semigroup consisting of the whole family to which the elements
      of <A>R</A> belong. Thus, for example, a <C>1</C> by <C>1</C> Rees matrix
      semigroup can have a <C>65</C> by <C>15</C> matrix. <P/>

      Arbitrary subsemigroups of Rees matrix or 0-matrix semigroups do not have
      a matrix. Such a subsemigroup <A>R</A> has a matrix if and
      only if it satisfies <Ref Attr="IsReesMatrixSemigroup"/> or <Ref
        Attr="IsReesZeroMatrixSemigroup"/>.
      <Example><![CDATA[
gap> G:=AlternatingGroup(5);;
gap> mat:=[[(), (), ()], [(), (), ()]];;
gap> R:=ReesMatrixSemigroup(G, mat);
<Rees matrix semigroup 3x2 over Alt( [ 1 .. 5 ] )>
gap> Matrix(R); 
[ [ (), (), () ], [ (), (), () ] ]
gap> R:=ReesMatrixSubsemigroup(R, [1,2], Group(()), [2]);
<subsemigroup of 3x2 Rees matrix semigroup with 2 generators>
gap> Matrix(R);
[ [ (), (), () ], [ (), (), () ] ]
]]></Example>
    </Description>
  </ManSection>

  <ManSection><Heading>Rows and columns</Heading>
    <Attr Name="Rows" Arg="R"/>
    <Attr Name="Columns" Arg="R"/>
    <Returns>The rows or columns of <A>R</A>.</Returns>
    <Description>
      <C>Rows</C> returns the rows of the Rees matrix or 0-matrix semigroup
      <A>R</A>. Note that the rows of the semigroup correspond to the columns of
      the matrix used to define multiplication in <A>R</A>.<P/>

      <C>Columns</C> returns the columns of the Rees matrix or 0-matrix
      semigroup <A>R</A>. Note that the columns of the semigroup correspond to
      the rows of the matrix used to define multiplication in <A>R</A>.<P/>

      Arbitrary subsemigroups of Rees matrix or 0-matrix semigroups do not have
      rows or columns. Such a subsemigroup <A>R</A> has rows and columns  if and
      only if it satisfies <Ref Attr="IsReesMatrixSemigroup"/> or <Ref
        Attr="IsReesZeroMatrixSemigroup"/>.
    <Example><![CDATA[
gap> G:=Group((1,2,3));;                      
gap> mat:=List([1..100], x-> List([1..200], x->Random(G)));;
gap> R:=ReesZeroMatrixSemigroup(G, mat); 
<Rees 0-matrix semigroup 200x100 over Group([ (1,2,3) ])>
gap> Rows(R);
[ 1 .. 200 ]
gap> Columns(R);
[ 1 .. 100 ]
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="UnderlyingSemigroup" Arg="R" 
      Label="for a Rees matrix semigroup"/>
    <Attr Name="UnderlyingSemigroup" Arg="R" 
      Label="for a Rees 0-matrix semigroup"/>
    <Returns>A semigroup.</Returns>
    <Description>
      <C>UnderlyingSemigroup</C> returns the underlying semigroup of the Rees
      matrix or 0-matrix semigroup <A>R</A>. <P/>
      
      Arbitrary subsemigroups of Rees matrix or 0-matrix semigroups do not have
      an underlying semigroup. Such a subsemigroup <A>R</A> has an underlying
      semigroup if and only if it satisfies <Ref Attr="IsReesMatrixSemigroup"/>
      or <Ref Attr="IsReesZeroMatrixSemigroup"/>.
    <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 1, 1, 2, 1 ] ), 
> Transformation( [ 3, 4, 3, 4, 4 ] ), Transformation([ 3, 4, 3, 4, 3 ] ),
> Transformation([ 4, 3, 3, 4, 4 ] ) );;
gap> R:=Range(IsomorphismReesMatrixSemigroup(S));    
<Rees matrix semigroup 4x2 over Group([ (1,2) ])>
gap> UnderlyingSemigroup(R);
Group([ (1,2) ])
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="AssociatedReesMatrixSemigroupOfDClass" Arg="D"/>
    <Returns>A Rees matrix or 0-matrix semigroup.</Returns>
    <Description>
      If <A>D</A> is a regular &D;-class of a finite semigroup <C>S</C>, then
      there is a standard way of associating a Rees matrix semigroup to
      <A>D</A>.  If <A>D</A> is a subsemigroup of <C>S</C>, then <A>D</A> is
      simple and hence is isomorphic to a Rees matrix semigroup. In this case,
      the associated Rees matrix semigroup of <A>D</A> is just the Rees matrix
      semigroup isomorphic to <A>D</A>. <P/>
      
      If <A>D</A> is not a subsemigroup of <C>S</C>, then we define a semigroup
      with elements <A>D</A> and a new element <C>0</C> with multiplication of
      <M>x,y\in D</M> defined by:
      <Alt Not="Text">
        <Display>
          xy=\left\{\begin{array}{ll}
          x*y\ (\textrm{in }S)&amp;\textrm{if }x*y\in D\\
          0&amp;\textrm{if }xy\not\in D.
          \end{array}\right.
        </Display>
      </Alt>
      <Alt Only="Text">
        <C>xy</C> equals the product of <C>x</C> and <C>y</C> if it belongs to
        <A>D</A> and <C>0</C> if it does not. <P/>
      </Alt>
      The semigroup thus defined is 0-simple and hence is isomorphic to a Rees
      0-matrix semigroup. This semigroup can also be described as the Rees
      quotient of the ideal generated by <A>D</A> by it maximal subideal. The
      associated Rees matrix semigroup of <A>D</A> is just the Rees 0-matrix
      semigroup isomorphic to the semigroup defined above.
    <Log><![CDATA[
gap> S:=FullTransformationSemigroup(5);;
gap> D:=GreensDClasses(S)[3];
{Transformation( [ 1, 1, 1, 2, 3 ] )}
gap> AssociatedReesMatrixSemigroupOfDClass(D);
<Rees 0-matrix semigroup 25x10 over Group([ (1,2)(3,5)(4,6), (1,3)
(2,4)(5,6) ])>
]]></Log>
    </Description>
  </ManSection>
</Section>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  fpsemi.msk                GAP documentation                Isabel Araújo -->
<!-- %% -->
<!-- %A  @(#)<M>Id: fpsemi.msk,v 1.27 2002/08/09 17:49:33 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Finitely Presented Semigroups and Monoids">
<Heading>Finitely Presented Semigroups and Monoids</Heading>

A <E>finitely presented semigroup</E> (resp. <E>finitely presented monoid</E>)
is a quotient of a free semigroup (resp. free monoid) on a finite 
number of generators over a finitely generated congruence on
the free semigroup (resp. free monoid).
<P/>
Finitely presented semigroups are obtained by factoring a free semigroup 
by a set of relations (a generating set for the congruence), i.e., a set of
pairs of words in the free semigroup.
<P/>
<Example><![CDATA[
gap> f:=FreeSemigroup("a","b");;
gap> x:=GeneratorsOfSemigroup(f);;
gap> s:=f/[ [x[1]*x[2],x[2]*x[1]] ];
<fp semigroup on the generators [ a, b ]>
gap> GeneratorsOfSemigroup(s);
[ a, b ]
gap> RelationsOfFpSemigroup(s);
[ [ a*b, b*a ] ]
]]></Example>
<P/>
Finitely presented monoids are obtained by factoring a free monoid by
a set of relations, i.e. a set of pairs of words in the free monoid. 
<P/>
<Example><![CDATA[
gap> f:=FreeMonoid("a","b");;
gap> x:=GeneratorsOfMonoid(f);
[ a, b ]
gap> e:=Identity(f);
<identity ...>
gap> m:=f/[ [x[1]*x[2],e] ];
<fp monoid on the generators [ a, b ]>
gap> RelationsOfFpMonoid(m);
[ [ a*b, <identity ...> ] ]
]]></Example>
<P/>
Notice that for &GAP; a finitely presented monoid is not a finitely 
presented semigroup.
<P/>
<Example><![CDATA[
gap> IsFpSemigroup(m);
false
]]></Example>
<P/>
However, one can build a finitely presented semigroup isomorphic
to that finitely presented monoid (see <Ref Func="IsomorphismFpSemigroup"/>).
<P/>
Also note that is not possible to refer to the generators by their names.
These names are not variables, but just display figures.
So, if one wants to access the generators by their names, one first has to 
introduce the respective variables and to assign the generators to them.
 
<Example><![CDATA[
gap> Unbind(a);
gap> f:=FreeSemigroup("a","b");;
gap> x:=GeneratorsOfSemigroup(f);;
gap> s:=f/[ [x[1]*x[2],x[2]*x[1]] ];;
gap> a;
Error, Variable: 'a' must have a value
gap> a:=GeneratorsOfSemigroup(s)[1];
a
gap> b:=GeneratorsOfSemigroup(s)[2];
b
gap> a in f;
false
gap> a in s;
true
]]></Example>
<P/>
The generators of the free semigroup (resp. free monoid) are different 
from the generators of the finitely presented semigroup (resp. finitely
presented monoid) (even though they are displayed by the same names). 
This means that words in the generators of the free semigroup (resp.
free monoid) are not elements of the finitely presented semigroup (resp. 
finitely presented monoid). Conversely elements of the finitely presented 
semigroup (resp. finitely presented monoid) are not words of the free
semigroup (resp. free monoid).
<P/>
Calculations comparing elements of an finitely presented semigroup
may run into problems: there are finitely presented semigroups for 
which no algorithm exists (it is known that no such algorithm can exist) 
that will tell for two arbitrary words in the generators whether the 
corresponding elements in the finitely presented semigroup are equal.  
Therefore the methods used by &GAP; to compute in finitely presented 
semigroups may run into warning errors, run out of memory or run forever. 
If the finitely presented semigroup is (by theory) known to be 
finite the algorithms are guaranteed to terminate (if there is sufficient 
memory available), but the time needed for the calculation cannot be 
bounded a priori. The same can be said for monoids.
(See <Ref Sect="Rewriting Systems and the Knuth-Bendix Procedure"/>.)
<P/>
<Example><![CDATA[
gap> a*b=a^5;
false
gap> a^5*b^2*a=a^6*b^2;
true
]]></Example>
<P/>
Note that elements of a finitely presented semigroup (or monoid) are not 
printed in a unique way:
<P/>
<Example><![CDATA[
gap> a^5*b^2*a;
a^5*b^2*a
gap> a^6*b^2;
a^6*b^2
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsSubsemigroupFpSemigroup">
<Heading>IsSubsemigroupFpSemigroup (Filter)</Heading>

<ManSection>
<Attr Name="IsSubsemigroupFpSemigroup" Arg='t'/>

<Description>
true if <A>t</A> is a finitely presented semigroup or a 
subsemigroup of a finitely presented semigroup
(generally speaking, such a subsemigroup can be constructed
with <C>Semigroup(<A>gens</A>)</C>, where <A>gens</A> is a list of elements
of a finitely presented semigroup).
</Description>
</ManSection>

<ManSection>
<Attr Name="IsSubmonoidFpMonoid" Arg='t'/>

<Description>
true if <A>t</A> is a finitely presented monoid or a 
submonoid of a finitely presented monoid 
(generally speaking, such a semigroup can be constructed
with <C>Monoid(<A>gens</A>)</C>, where <A>gens</A> is a list of elements
of a finitely presented monoid).
<P/>
A submonoid of a monoid has the same identity as the monoid.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFpSemigroup" Arg='s'/>

<Description>
is a synonym for <C>IsSubsemigroupFpSemigroup(<A>s</A>)</C> and 
<C>IsWholeFamily(<A>s</A>)</C> (this is because a subsemigroup
of a finitely presented semigroup is not necessarily finitely presented).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFpMonoid" Arg='m'/>

<Description>
is a synonym for <C>IsSubmonoidFpMonoid(<A>m</A>)</C> and 
<C>IsWholeFamily(<A>m</A>)</C> (this is because a submonoid 
of a finitely presented monoid is not necessarily finitely presented).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsElementOfFpSemigroup" Arg='elm' Type='Category'/>

<Description>
returns true if <A>elm</A> is an element of a finitely presented semigroup. 
</Description>
</ManSection>

<ManSection>
<Filt Name="IsElementOfFpMonoid" Arg='elm' Type='Category'/>

<Description>
returns true if <A>elm</A> is an element of a finitely presented monoid. 
</Description>
</ManSection>

<ManSection>
<Oper Name="FpGrpMonSmgOfFpGrpMonSmgElement" Arg='elm'/>

<Description>
returns the finitely presented group, monoid or semigroup to which 
<A>elm</A> belongs
<Example><![CDATA[
gap> f := FreeSemigroup("a","b");;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> s := f / [ [ a^2 , a*b ] ];;
gap> IsFpSemigroup( s );
true
gap> t := Semigroup( [ GeneratorsOfSemigroup( s )[ 1 ] ]);
<commutative semigroup with 1 generator>
gap> IsSubsemigroupFpSemigroup( t );
true
gap> IsElementOfFpSemigroup( GeneratorsOfSemigroup( t )[ 1 ] );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Finitely Presented Semigroups">
<Heading>Creating Finitely Presented Semigroups</Heading>

<ManSection>
<Meth Name="\/" Arg="F, rels"
 Label="for a free semigroup and a list of pairs of elements"/>

<Description>
<Index Subkey="of free semigroup">quotient</Index> 
creates a finitely presented semigroup given by the presentation
<M>\langle gens \mid <A>rels</A> \rangle</M>
where <M>gens</M> are the generators of the free
semigroup <A>F</A>, and the relations <A>rels</A> are entered as pairs of
words in the generators of the free semigroup. 
<P/>
The same result is obtained with the infix operator <C>/</C>,
i.e., as <A>F</A> <C>/</C> <A>rels</A>.
<P/>
<Example><![CDATA[
gap> f:=FreeSemigroup(3);;
gap> s:=GeneratorsOfSemigroup(f);;
gap> f/[ [s[1]*s[2]*s[1],s[1]] , [s[2]^4,s[1]] ];
<fp semigroup on the generators [ s1, s2, s3 ]>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FactorFreeSemigroupByRelations" Arg='f, rels'/>

<Description>
for a free semigroup <A>f</A> and <A>rels</A> is a list of
pairs of elements of <A>f</A>. Returns the finitely presented semigroup 
which is the quotient of <A>f</A> by the least congruence on <A>f</A> generated by
the pairs in <A>rels</A>.
<Example><![CDATA[
gap> FactorFreeSemigroupByRelations(f,
>                            [[s[1]*s[2]*s[1],s[1]],[s[2]^4,s[1]]]);
<fp semigroup on the generators [ s1, s2, s3 ]>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismFpSemigroup" Arg='s'/>

<Description>
for a semigroup <A>s</A> returns an isomorphism from <A>s</A> to a 
finitely presented semigroup 
<Example><![CDATA[
gap> f := FreeGroup(2);;
gap> g := f/[f.1^4,f.2^5];
<fp group on the generators [ f1, f2 ]>
gap> phi := IsomorphismFpSemigroup(g);
MappingByFunction( <fp group on the generators 
[ f1, f2 ]>, <fp semigroup on the generators 
[ <identity ...>, f1^-1, f1, f2^-1, f2 
 ]>, function( x ) ... end, function( x ) ... end )
gap> s := Range(phi);
<fp semigroup on the generators [ <identity ...>, f1^-1, f1, f2^-1, 
  f2 ]>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Elements of Finitely Presented Semigroups">
<Heading>Comparison of Elements of Finitely Presented Semigroups</Heading>

<ManSection>
<Meth Name="\=" Arg="a, b" Label="for two elements in a f.p. semigroup"/>

<Description>
<Index Subkey="fp semigroup elements">comparison</Index>
Two elements <A>a</A>, <A>b</A> of a finitely presented semigroup are equal
if they are equal in the semigroup.
Nevertheless they may be represented as different words in the
generators. Because of the fundamental problems mentioned in the
introduction to this chapter such a test may take a very long time and cannot be
guaranteed to finish
(see <Ref Sect="Rewriting Systems and the Knuth-Bendix Procedure"/>).
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Preimages in the Free Semigroup">
<Heading>Preimages in the Free Semigroup</Heading>

Elements of a finitely presented semigroup are not words, but are represented
using a word from the free semigroup as representative. 
<P/>
<ManSection>
<Oper Name="UnderlyingElement" Arg='elm' Label="fp semigroup elements"/>

<Description>
for an element <A>elm</A> of a finitely presented semigroup, it 
returns the word from the free semigroup that is used as a
representative for <A>elm</A>.
<P/>
<Example><![CDATA[
gap> f := FreeSemigroup( "a" , "b" );;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> s := f / [ [ a^3 , a ] , [ b^3 , b ] , [ a*b , b*a ] ];
<fp semigroup on the generators [ a, b ]>
gap> w := GeneratorsOfSemigroup(s)[1] * GeneratorsOfSemigroup(s)[2];
a*b
gap> IsWord (w );
false
gap> ue := UnderlyingElement( w );
a*b
gap> IsWord( ue );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ElementOfFpSemigroup" Arg='fam, w'/>

<Description>
for a family <A>fam</A> of elements of a finitely presented semigroup and 
a word <A>w</A> in the free generators underlying this finitely presented
semigroup, this operation creates the element of the finitely 
presented semigroup with the representative <A>w</A> in the free semigroup.
<Example><![CDATA[
gap> fam := FamilyObj( GeneratorsOfSemigroup(s)[1] );;
gap> ge := ElementOfFpSemigroup( fam, a*b );
a*b
gap> ge in f;
false
gap> ge in s;
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="FreeSemigroupOfFpSemigroup" Arg='s'/>

<Description>
returns the underlying free semigroup for the finitely presented 
semigroup <A>s</A>, ie, the free semigroup over which <A>s</A> is defined 
as a quotient
(this is the free semigroup generated by the free generators provided 
by <C>FreeGeneratorsOfFpSemigroup(<A>s</A>)</C>).
</Description>
</ManSection>

<ManSection>
<Attr Name="FreeGeneratorsOfFpSemigroup" Arg='s'/>

<Description>
returns the underlying free generators corresponding to the 
generators of the finitely presented semigroup <A>s</A>.  
</Description>
</ManSection>

<ManSection>
<Attr Name="RelationsOfFpSemigroup" Arg='s'/>

<Description>
returns the relations of the finitely presented semigroup <A>s</A> as
pairs of words in the free generators provided by
<C>FreeGeneratorsOfFpSemigroup(<A>s</A>)</C>.
<Example><![CDATA[
gap> f := FreeSemigroup( "a" , "b" );;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> s := f / [ [ a^3 , a ] , [ b^3 , b ] , [ a*b , b*a ] ];
<fp semigroup on the generators [ a, b ]>
gap> Size( s );
8
gap> fs := FreeSemigroupOfFpSemigroup( s );;
gap> f = fs;
true
gap> FreeGeneratorsOfFpSemigroup( s );
[ a, b ]
gap> RelationsOfFpSemigroup( s );
[ [ a^3, a ], [ b^3, b ], [ a*b, b*a ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finitely presented monoids">
<Heading>Finitely presented monoids</Heading>

The functionality available for finitely presented monoids is essentially
the same as that available for finitely presented semigroups,
and thus the previous sections apply (with the obvious changes)
to finitely presented monoids.

<ManSection>
<Meth Name="\/" Arg="F, rels"
 Label="for a free monoid and a list of pairs of elements"/>

<Description>
<Index Subkey="of free monoid">quotient</Index>
creates a finitely presented monoid given by the monoid presentation 
<M>\langle <A>gens</A> \mid <A>rels</A> \rangle</M>
where <A>gens</A> are the generators of 
the free monoid <A>F</A>, and the relations <A>rels</A> are entered as pairs of 
words in both the identity and the generators of the free monoid.
<P/>
The same result is obtained with the infix operator <C>/</C>,
i.e., as <C><A>F</A>/<A>rels</A></C>.
<P/>
<Example><![CDATA[
gap> f := FreeMonoid( 3 );
<free monoid on the generators [ m1, m2, m3 ]>
gap> x := GeneratorsOfMonoid( f );
[ m1, m2, m3 ]
gap> e:= Identity ( f );
<identity ...>
gap> m := f/[ [x[1]^3,e] , [x[1]*x[2],x[2] ]];
<fp monoid on the generators [ m1, m2, m3 ]>
]]></Example>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Rewriting Systems and the Knuth-Bendix Procedure">
<Heading>Rewriting Systems and the Knuth-Bendix Procedure</Heading>

If a finitely presented semigroup has a confluent rewriting system then 
it has a solvable word problem, that is, there is an algorithm to decide 
when two words in the free underlying semigroup represent the same element 
of the finitely presented semigroup. 
Indeed, once we have a confluent rewriting system, it is possible to 
successfully test that two words represent the same element in the 
semigroup, by reducing both words using the rewriting system rules. 
This is, at the moment, the method that &GAP; uses to check equality
in finitely presented semigroups and monoids.
<P/>
<ManSection>
<Attr Name="ReducedConfluentRewritingSystem" Arg='S[, ordering]'/>

<Description>
returns a reduced confluent rewriting system of
the finitely presented semigroup or monoid <A>S</A> with respect to the 
reduction ordering <A>ordering</A> (see <Ref Chap="Orderings"/>). 
<P/>
The default for <A>ordering</A> is the length plus lexicographic ordering
on words, also called the shortlex ordering; for the definition see for
example <Cite Key="Sims94"/>.
<P/>
Notice that this might not terminate. In particular, if the semigroup or 
monoid <A>S</A> does not have a solvable word problem then it this will
certainly never end.
Also, in this case, the object returned is an immutable 
rewriting system, because once we have a confluent
rewriting system for a finitely presented semigroup or monoid we do 
not want to allow it to change (as it was most probably very time 
consuming to get it in the first place). Furthermore, this is also
an attribute storing object (see <Ref Sect="Representation"/>).
<Example><![CDATA[
gap> f := FreeSemigroup( "a" , "b" );;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> g := f /  [ [ a^2 , a*b ] , [ a^4 , b] ];;
gap> rws := ReducedConfluentRewritingSystem(g);
Rewriting System for Semigroup( [ a, b ] ) with rules 
[ [ a*b, a^2 ], [ a^4, b ], [ b*a, a^2 ], [ b^2, a^2 ] ]
]]></Example>
<P/>
The creation of a reduced confluent rewriting system for a semigroup
or for a monoid, in &GAP;, uses the Knuth-Bendix procedure for strings,
which manipulates a rewriting system of the semigroup or monoid and attempts
to make it confluent (See <Ref Chap="Rewriting Systems"/>.
See also Sims <Cite Key="Sims94"/>).
(Since the word problem for semigroups/monoids is not solvable in general,
Knuth-Bendix procedure cannot always terminate).
<P/>
In order to apply this procedure we will build a rewriting system
for the semigroup or monoid, which we will call a  <E>Knuth-Bendix Rewriting
System</E> (we need to define this because we need the rewriting system
to store some information needed for the implementation of the
Knuth-Bendix procedure).
<P/>
Actually, Knuth-Bendix Rewriting Systems do not only serve this purpose.
Indeed these  are objects which are mutable and which can be manipulated
(see <Ref Chap="Rewriting Systems"/>).
<P/>
Note that the implemented version of the Knuth-Bendix procedure, in &GAP;
returns, if it terminates, a confluent rewriting system which is reduced.
Also, a reduction ordering has to be specified when building a rewriting
system. If none is specified, the shortlex ordering is assumed
(note that the procedure may terminate with a certain ordering and
not with another one).
<P/>
On Unix systems it is possible to replace the built-in Knuth-Bendix by
other routines, for example the package <Package>kbmag</Package> offers
such a possibility.
</Description>
</ManSection>

<ManSection>
<Var Name="KB_REW"/>
<Var Name="GAPKB_REW"/>

<Description>
<C>KB_REW</C> is a global record variable whose components contain functions
used for Knuth-Bendix. By default <C>KB_REW</C> is assigned to
<C>GAPKB_REW</C>, which contains the KB functions provided by
the GAP library.
</Description>
</ManSection>



<ManSection>
<Heading>KnuthBendixRewritingSystem</Heading>
<Func Name="KnuthBendixRewritingSystem" Arg='s, wordord'
 Label="for a semigroup and a reduction ordering"/>
<Func Name="KnuthBendixRewritingSystem" Arg='m, wordord'
 Label="for a monoid and a reduction ordering"/>

<Description>
in the first form, for a semigroup <A>s</A> and a reduction ordering
for the underlying free semigroup, it returns the Knuth-Bendix 
rewriting system of the finitely presented semigroup <A>s</A> using the 
reduction ordering <A>wordord</A>.
In the second form, for a monoid <A>m</A> and a reduction ordering
for the underlying free monoid, it returns the Knuth-Bendix 
rewriting system of the finitely presented monoid <A>m</A> using the 
reduction ordering <A>wordord</A>.
</Description>
</ManSection>


<ManSection>
<Attr Name="SemigroupOfRewritingSystem" Arg='rws'/>

<Description>
returns the semigroup over which <A>rws</A> is
a rewriting system
</Description>
</ManSection>

<ManSection>
<Attr Name="MonoidOfRewritingSystem" Arg='rws'/>

<Description>
returns the monoid over which <A>rws</A> is a rewriting system
</Description>
</ManSection>

<ManSection>
<Attr Name="FreeSemigroupOfRewritingSystem" Arg='rws'/>

<Description>
returns the free semigroup over which <A>rws</A> is
a rewriting system
</Description>
</ManSection>

<ManSection>
<Attr Name="FreeMonoidOfRewritingSystem" Arg='rws'/>

<Description>
returns the free monoid over which <A>rws</A> is
a rewriting system
<Example><![CDATA[
gap> f1 := FreeSemigroupOfRewritingSystem(rws);
<free semigroup on the generators [ a, b ]>
gap> f1=f;
true
gap> g1 := SemigroupOfRewritingSystem(rws);
<fp semigroup on the generators [ a, b ]>
gap> g1=g;
true
]]></Example>
<P/>
As mentioned before, having a confluent rewriting system, one can decide
whether two words represent the same element of a finitely
presented semigroup (or finitely presented monoid).
<P/>
<Example><![CDATA[
gap> a := GeneratorsOfSemigroup( g )[ 1 ];
a
gap> b := GeneratorsOfSemigroup( g )[ 2 ];
b
gap> a*b*a=a^3;
true
gap> ReducedForm(rws,UnderlyingElement(a*b*a));
a^3
gap> ReducedForm(rws,UnderlyingElement(a^3));
a^3
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Todd-Coxeter Procedure">
<Heading>Todd-Coxeter Procedure</Heading>

This procedure gives a standard way of finding a transformation
representation of a finitely presented semigroup. Usually
one does not explicitly call this procedure but uses
<Ref Func="IsomorphismTransformationSemigroup"/>.
<!--or <Ref Func="HomomorphismTransformationSemigroup"/>-->

<ManSection>
<Attr Name="CosetTableOfFpSemigroup" Arg='r'/>

<Description>
<A>r</A> is a right congruence of an fp-semigroup <A>S</A>.
This attribute is the coset table of FP semigroup 
<A>S</A> on a right congruence <A>r</A>.
Given a right congruence <A>r</A> we represent <A>S</A> as a set of 
transformations of the congruence classes of <A>r</A>.
<P/>
The images   of the cosets under the   generators are compiled in  a list
<A>table</A> such that  <A>table[i][s]</A> contains  the image  of  coset <A>s</A> under
generator <A>i</A>.   
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<Chapter Label="Transformations">
<Heading>Transformations</Heading>

This chapter describes the functions in &GAP; for transformations. 
<P/>

A <E>transformation</E> in &GAP; is simply a function from the positive
integers to the positive integers. 
Transformations are to semigroup theory what permutations are to group theory,
in the sense that every semigroup can be realised as a semigroup of
transformations. In &GAP; transformation semigroups are always finite, and so 
only finite semigroups can be realised in this way. 
<P/>

A transformation in &GAP; acts on the positive integers (up to some
architecture dependent limit) on the right. The image of a point
<C>i</C> under a transformation <C>f</C> is expressed as <C>i^f</C> in &GAP;.
This action is also implemented by the function <Ref Func="OnPoints"/>. 
If <C>i^f</C> is different from <C>i</C>, then <C>i</C> is <E>moved</E> by
<E>f</E> and otherwise it is <E>fixed</E> by <C>f</C>.
Transformations in &GAP; are created using the operations described in Section
<Ref Sect="sect:CreatingTransformations"/>. 
<P/>

The <E>degree</E> of a transformation <C>f</C> is usually defined as the
largest positive integer where <C>f</C> is defined.  In previous versions of
&GAP;, transformations were only defined on positive integers less than their
degree, it was only possible to multiply transformations of equal degree, and a
transformation did not act on any point exceeding its degree.  Starting with
version 4.7 of &GAP;, transformations behave more like permutations, in that
they fix unspecified points and it is possible to multiply arbitrary
transformations; see Chapter <Ref Chap="Permutations"/>.  
The definition of the degree of a transformation <C>f</C> in the current
version of &GAP; is the largest value <C>n</C> such that <C>n^f&lt;>n</C> or
<C>i^f=n</C> for some <C>i&lt;>n</C>. Equivalently, the degree of a
transformation is the least value <C>n</C> such that <C>[n+1,n+2,...]</C> is fixed
pointwise by <C>f</C>.<P/>

The transformations of a given degree belong to the full transformation
semigroup of that degree; see <Ref Func="FullTransformationSemigroup"/>.
Transformation semigroups are hence subsemigroups of the full transformation
semigroup. <P/>

It is possible to use transformations in &GAP; without reference to the
degree, much as it is possible to use permutations in this way.
However, for backwards compatibility, and because it is sometimes useful, it is
possible to access the degree of a transformation using 
<Ref Attr="DegreeOfTransformation"/>. Certain attributes of transformations are
also calculated with respect to the degree, such as the rank, image set,
or kernel (these values can also be calculated with
respect to any positive integer). So, it is possible to ignore the 
degree of a transformation if you prefer to think of transformations as acting
on the positive integers in a similar way to permutations. For example, this
approach is used in the <Package>FR</Package> package. It is also possible to
think of transformations as only acting on the positive integers not exceeding
their degree. For example, this was the approach formerly used in
&GAP; and it is also useful in the <Package>Semigroups</Package> package. 
<P/>

Transformations are displayed, by default, using the list <C>[1^f..n^f]</C>
where <C>n</C> is the degree of <C>f</C>.
This behaviour differs from versions of &GAP; earlier than 4.7. 
See Section <Ref Sect="sect:DisplayingTransformations"/> for more information.
<P/>

The <E>rank</E> of a transformation on the positive integers up to <C>n</C> 
is the number of distinct points in <C>[1^f..n^f]</C>.  The <E>kernel</E> of
a transformation <C>f</C> on <C>[1..n]</C> is the
equivalence relation on <C>[1..n]</C> consisting of those <C>(i, j)</C> such
that  <C>i^f = j^f</C>.  The kernel of a transformation is represented in two
ways: as a partition of <C>[1..n]</C> or as the image list of a transformation
<C>g</C> such that the kernel of <C>g</C> on <C>[1..n]</C> equals the kernel of
<C>f</C> and <C>j^g=i</C> for all <C>j</C> in <C>i</C>th class. The latter is referred to as the flat kernel of <C>f</C>. For any
given transformation and value <C>n</C>, there is a unique transformation with
this property. <P/>

A <E>functional digraph</E> is a directed graph where every vertex has
out-degree <M>1</M>.  A transformation <A>f</A> can be thought of as a
functional digraph with vertices the positive integers and 
edges from <C>i</C> to <C>i^f</C> for every <C>i</C>. A <E>component</E>
of a transformation is defined as a component and a <E>cycle</E> is just a
cycle (or strongly connected component) of the corresponding functional
digraph.  More specifically, <C>i</C> and <C>j</C> are in the same component if
and only if there are <M>i=v_0, v_1, \ldots, v_n=j</M> such that either 
<M>v_{k+1}=v_{k}^f</M> or <M>v_{k}=v_{k+1}^f</M> for all <M>k</M>. 
A <E>cycle</E> of a transformation is defined as a cycle (or strongly connected
component) of the corresponding functional digraph.  More specifically,
<C>i</C> belongs to a cycle of <A>f</A> if there are <M>i=v_0, v_1, \ldots,
  v_n=i</M> such that either <M>v_{k+1}=v_{k}^f</M> or <M>v_{k}=v_{k+1}^f</M> for all <M>k</M>. <P/>
<P/>

Internally, &GAP; stores a transformation <C>f</C> as a list consisting of the
images <C>i^f</C> of the points in <C>i</C> less than some value, which is at
least the degree of <C>f</C> and which is determined at the time of creation.
When the degree of a transformation <C>f</C> is at most 65536, the images of
points under <C>f</C> are stored as 16-bit integers, the kernel and image set
are subobjects of <C>f</C> which are plain lists of &GAP; integers.  When the
degree of <C>f</C> is greater than 65536, the images of points under
<C>f</C> are stored as 32-bit integers; the kernel and image set are stored in
the same way as before. A transformation belongs to <C>IsTrans2Rep</C> if it is
stored using 16-bit integers and to <C>IsTrans4Rep</C> if it is stored using
32-bit integers.  <P/>

<Section>
    <Heading>The family and categories of transformations</Heading>
  <ManSection>
    <Filt Name="IsTransformation" Arg="obj" Type="Category"/>
    <Description>
    Every transformation in &GAP; belongs to the category
    <C>IsTransformation</C>. Basic operations for transformations are 
    <Ref Attr="ImageListOfTransformation"/>, 
    <Ref Attr="ImageSetOfTransformation"/>,
    <Ref Attr="KernelOfTransformation"/>, 
    <Ref Attr="FlatKernelOfTransformation"/>, 
    <Ref Attr="RankOfTransformation" Label="for a transformation and a list"/>,
    <Ref Attr="DegreeOfTransformation"/>, multiplication of two transformations
    via <K>*</K>, and exponentiation with the first argument
    a positive integer <C>i</C> and second argument a transformation
    <C>f</C> where the result is the image <C>i^f</C> of the point <C>i</C>
    under <C>f</C>.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsTransformationCollection" Arg="obj" Type="Category"/>
    <Description>
     Every collection of transformations belongs to the category
     <C>IsTransformationCollection</C>. For example, transformation semigroups
     belong to <C>IsTransformationCollection</C>.
    </Description>
  </ManSection>

  <ManSection>
    <Fam Name="TransformationFamily"/>
    <Description>
      The family of all transformations is <C>TransformationFamily</C>.
    </Description>
  </ManSection>
</Section>

<!-- *************************************************************** -->

<Section Label="sect:CreatingTransformations">
  <Heading>Creating transformations</Heading>

  There are several ways of creating transformations in &GAP;, which are 
  described in this section.  

  <!-- *************************************************************** -->

  <ManSection>
    <Oper Name="Transformation" Arg="list" Label="for an image list"/>
    <Oper Name="Transformation" Arg="list, func" 
      Label="for a list and function"/>
    <Func Name="TransformationList" Arg="list" Label="for an image list"/>
    <Returns>A transformation or <K>fail</K>.</Returns>
    <Description>
      <C>TransformationList</C> returns the transformation <C>f</C> such that
      <C>i^<A>f</A>=<A>list</A>[i]</C> if <C>i</C> is between <C>1</C> and the
      length of <A>list</A> and <C>i^<A>f</A>=i</C> if <C>i</C> is larger than
      the length of <A>list</A>. <C>TransformationList</C> will return
      <K>fail</K> if <A>list</A> is not dense, if <A>list</A> contains an
      element which is not a positive integer, or if <A>list</A> contains an
      integer not in <C>[1..Length(<A>list</A>)]</C>. <P/>
  
      This is the analogue in the context of transformations of 
      <Ref Func="PermList"/>. <C>Transformation</C> is a synonym of
      <C>TransformationList</C> when the argument is a list. <P/>

      When the arguments are a list of positive integers <A>list</A> and a
      function <A>func</A>, <C>Transformation</C> returns the transformation
      <C>f</C> such that <C><A>list</A>[i]^f=<A>func</A>(<A>list</A>[i])</C>
      if <C>i</C> is in the range <C>[1..Length(<A>list</A>)]</C> and 
      <C>f</C> fixes all other points.

      <Example><![CDATA[
gap> SetUserPreference("NotationForTransformations", "input");
gap> f:=Transformation( [ 11, 10, 2, 11, 4, 4, 7, 6, 9, 10, 1, 11 ] );
Transformation( [ 11, 10, 2, 11, 4, 4, 7, 6, 9, 10, 1, 11 ] )
gap> f:=TransformationList( [ 2, 3, 3, 1 ] );
Transformation( [ 2, 3, 3, 1 ] )
gap> SetUserPreference("NotationForTransformations", "fr");
gap> f:=Transformation([10, 11], x-> x^2);
<transformation: 1,2,3,4,5,6,7,8,9,100,121>
gap> SetUserPreference("NotationForTransformations", "input");
]]></Example>
    </Description>
  </ManSection>
  
  <!-- *************************************************************** -->

  <ManSection>
    <Oper Name="Transformation" Arg="src, dst" 
      Label="for a source and destination"/>
    <Func Name="TransformationListList" Arg="src, dst" 
      Label="for a source and destination"/>
    <Returns>A transformation or <K>fail</K>.</Returns>
    <Description>
      If <A>src</A> and <A>dst</A> are lists of positive integers of the same
      length, such that <A>src</A> contains no  element  twice, then 
      <C>TransformationListList(<A>src</A>, <A>dst</A>)</C> 
      returns  a transformation  <C>f</C>  such  that  
      <C>src[i]^<A>f</A>= dst[i]</C>. The
      transformation <A>f</A> fixes all points larger than the maximum of the
      entries in <A>src</A> and <A>dst</A>. <P/>

      This is the analogue in the context of transformations of 
      <Ref Func="MappingPermListList"/>. <C>Transformation</C> is a
      synonym of <C>TransformationListList</C> when its arguments are two
      lists of positive integers.
    <Example><![CDATA[
gap> Transformation( [ 10, 11 ],[ 11, 12 ] );
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12 ] )
gap> TransformationListList( [ 1, 2, 3 ], [ 4, 5, 6 ] );
Transformation( [ 4, 5, 6, 4, 5, 6 ] )
]]></Example>
    </Description>
  </ManSection>

  <!-- *************************************************************** -->

  <ManSection>
    <Oper Name="TransformationByImageAndKernel" Arg="im, ker" 
      Label="for an image and kernel"/>
    <Returns>A transformation or <K>fail</K>.</Returns>
    <Description>
      <C>Transformation</C> returns the transformation <C>f</C> 
      <C>i^f=<A>im</A>[<A>ker</A>[i]]</C> for <C>i</C> in the range
      <C>[1..Length(<A>ker</A>)]</C>. This transformation has flat kernel equal
      to <A>ker</A> and image set equal to <C>Set(<A>im</A>)</C>.<P/>

      The argument <A>im</A> should be a duplicate free
      list  of positive integers and <A>ker</A> should be the flat kernel of a
      transformation with rank equal to the length of <A>im</A>. If the 
      arguments do not fulfil these conditions, then <K>fail</K> is returned.

      <Example><![CDATA[
gap> TransformationByImageAndKernel([ 8, 1, 3, 4 ],
> [ 1, 2, 3, 1, 2, 1, 2, 4 ]);
Transformation( [ 8, 1, 3, 8, 1, 8, 1, 4 ] )
gap> TransformationByImageAndKernel([ 1, 3, 8, 4 ],
> [ 1, 2, 3, 1, 2, 1, 2, 4 ]);
Transformation( [ 1, 3, 8, 1, 3, 1, 3, 4 ] )
]]></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Func Name="Idempotent" Arg="im, ker"/>
    <Returns>A transformation or <K>fail</K>.</Returns>
    <Description>
      <C>Idempotent</C> returns the idempotent transformation with image set
      <A>im</A> and flat kernel <A>ker</A> if such a transformation exists and
      <K>fail</K> if it does not. <P/>
      
      More specifically, a transformation is returned when the argument
      <A>im</A> is a set of positive integers and <A>ker</A> is the flat kernel
      of a transformation with rank equal to the length of <A>im</A> and where
      <A>im</A> has one element in every class of the kernel corresponding to
      <A>ker</A>. <P/>

      Note that this is function does not always return the same transformation
      as <C>TransformationByImageAndKernel</C> with the same arguments.
      
      <Example><![CDATA[
gap> Idempotent([ 2, 4, 6, 7, 8, 10, 11 ],
> [ 1, 2, 1, 3, 3, 4, 5, 1, 6, 6, 7, 5 ] );
Transformation( [ 8, 2, 8, 4, 4, 6, 7, 8, 10, 10, 11, 7 ] )
gap> TransformationByImageAndKernel([ 2, 4, 6, 7, 8, 10, 11 ],
> [ 1, 2, 1, 3, 3, 4, 5, 1, 6, 6, 7, 5 ] );
Transformation( [ 2, 4, 2, 6, 6, 7, 8, 2, 10, 10, 11, 8 ] )
]]></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->
  
  <ManSection>
    <Func Name="TransformationOp" Arg="obj, list[, func]"/>
    <Func Name="TransformationOpNC" Arg="obj, list[, func]"/>
    <Returns>A transformation or <K>fail</K>.</Returns>
    <Description>
      <C>TransformationOp</C> returns the transformation that corresponds to
      the action of the object <A>obj</A> on the domain or list <A>list</A>
      via the function <A>func</A>. If the optional third argument <A>func</A>
      is not specified, then the action <Ref Func="OnPoints"/> is used by
      default.  Note that the returned transformation
      refers to the positions in <A>list</A> even if <A>list</A> itself
      consists of integers.  <P/>
      
      This function is the analogue in the context of
      transformations of <Ref Func="Permutation" BookName="ref"/>.  <P/>
      
      If <A>obj</A> does not map elements of <A>list</A> into <A>list</A>, then
      <K>fail</K> is returned.<P/>

      <C>TransformationOpNC</C> does not check that <A>obj</A> maps elements of
      <A>list</A> to elements of <A>list</A> or that a transformation is
      defined by the action of <A>obj</A> on <A>list</A> via <A>func</A>. 
      This function should be used only with caution, and in situations where
      it is guaranteed that the arguments have the required properties.

      <Example><![CDATA[
gap> f:=Transformation( [ 10, 2, 3, 10, 5, 10, 7, 2, 5, 6 ] );;
gap> TransformationOp(f, [ 2, 3 ] );
IdentityTransformation
gap> TransformationOp(f, [ 1, 2, 3 ] );
fail
gap> S:=SemigroupByMultiplicationTable( [ [ 1, 1, 1 ], [ 1, 1, 1 ], 
> [ 1, 1, 2 ] ] );;
gap> TransformationOp(Elements(S)[1], S, OnRight);
Transformation( [ 1, 1, 1 ] )
gap> TransformationOp(Elements(S)[3], S, OnRight);
Transformation( [ 1, 1, 2 ] )
]]></Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="TransformationNumber" Arg="m, n"/>
    <Oper Name="NumberTransformation" Arg="f[, n]"/>
    <Returns>A transformation or a number.</Returns>
    <Description>
      These functions implement a bijection from the transformations with
      degree at most <A>n</A> to the numbers <C>[1..<A>n</A>^<A>n</A>]</C>.<P/>

      More precisely, if <A>m</A> and <A>n</A> are positive integers such that
      <A>m</A> is at most <C><A>n</A>^<A>n</A></C>, then
      <C>TransformationNumber</C> returns the <A>m</A>th transformation with
      degree at most <A>n</A>.<P/>

      If <A>f</A> is a transformation and <A>n</A> is a positive integer, which
      is greater than or equal to the degree of <A>f</A>, then
      <C>NumberTransformation</C> returns the number in
      <C>[1..<A>n</A>^<A>n</A>]</C> that corresponds to <A>f</A>. If the
      optional second argument <A>n</A> is not specified, then the degree of
      <A>f</A> is used by default. 
      <Example><![CDATA[
gap> f:=Transformation( [ 3, 3, 5, 3, 3 ] );;
gap> NumberTransformation(f, 5);
1613
gap> NumberTransformation(f, 10);
2242256790
gap> TransformationNumber(2242256790, 10);
Transformation( [ 3, 3, 5, 3, 3 ] )
gap> TransformationNumber(1613, 5); 
Transformation( [ 3, 3, 5, 3, 3 ] )
]]></Example> 
    </Description>
  </ManSection>


<!-- *************************************************************** -->

  <ManSection><Heading>RandomTransformation</Heading>
    <Oper Name="RandomTransformation" Arg="n"/>
    <Returns>A random transformation.</Returns>
    <Description>
      If <A>n</A> is a positive integer, then <C>RandomTransformation</C>
      returns a random transformation with degree at most <A>n</A>.
      <Log>
gap> RandomTransformation(6);             
Transformation( [ 2, 1, 2, 1, 1, 2 ] )</Log> 
    </Description>
  </ManSection>

<!-- *************************************************************** -->

 <ManSection>
   <Var Name="IdentityTransformation"/>
   <Returns>The identity transformation.</Returns>
   <Description>
     Returns the identity transformation, which has degree <C>0</C>. 
     <Example><![CDATA[
gap> f:=IdentityTransformation;
IdentityTransformation
]]></Example>
   </Description>
  </ManSection>
  
<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="ConstantTransformation" Arg="m, n"/>
    <Returns>A transformation.</Returns>
    <Description>
      This function returns a constant transformation <C>f</C> such that
      <C>i^f=<A>n</A></C> for all <C>i</C> less than or equal to <A>m</A>, when
      <A>n</A> and <A>m</A> are positive integers. 
    <Example><![CDATA[
gap> ConstantTransformation(5, 1);
Transformation( [ 1, 1, 1, 1, 1 ] )
gap> ConstantTransformation(6, 4);
Transformation( [ 4, 4, 4, 4, 4, 4 ] )
]]></Example>
    </Description>
  </ManSection>
</Section>

<!-- *************************************************************** -->

<Section Label="sect:ChangingRepTransformations">
  <Heading>Changing the representation of a transformation</Heading>
  It is possible that a transformation in &GAP; can be represented as another
  type of object, or that another type of &GAP; object can be represented as
  a transformation.  <P/>

  The operations <Ref Oper="AsPermutation"/> and 
  <Ref Oper="AsPartialPerm" Label="for a transformation"/> can be used to
  convert transformations into permutations or partial permutations, where
  appropriate.  In this section we describe functions for converting other
  types of objects into transformations.

  <ManSection>
  <Oper Name="AsTransformation" Arg="f[, n]"/>
  <Returns>A transformation.</Returns>
  <Description>
  <C>AsTransformation</C> 
  returns the permutation, transformation, partial permutation or binary
  relation <A>f</A> as a transformation. 
  <List>
    <Mark>for permutations</Mark>
    <Item>
      If <A>f</A> is a permutation and <A>n</A> is a non-negative integer, then 
      <C>AsTransformation(<A>f</A>, <A>n</A>)</C> returns the transformation
      <C>g</C> such that <C>i^g=i^f</C> for all <C>i</C> in the range
      <C>[1..<A>n</A>]</C>.<P/>
      
      If no non-negative integer <A>n</A> is specified, then
      the largest moved point of <A>f</A> is used as the value for <A>n</A>; see
      <Ref Func="LargestMovedPoint" Label="for a permutation"/>.
    </Item>
    <Mark>for transformations</Mark>      
    <Item>
      If <A>f</A> is a transformation and <A>n</A> is a non-negative integer
      less than the degree of <A>f</A> such that <A>f</A> is a
      transformation of <C>[1..<A>n</A>]</C>, then <C>AsTransformation</C>
      returns the restriction of <A>f</A> to <C>[1..<A>n</A>]</C>.<P/>

      If <A>f</A> is a transformation and <A>n</A> is not specified or equals a
      is greater than or equal to the degree of <A>f</A>, then <A>f</A> is
      returned.<P/>
    </Item> 
    <Mark>for partial permutations</Mark>
    <Item>
      A partial permutation <A>f</A> can be converted into a transformation
      <C>g</C> as follows. The degree <C>m</C> of <C>g</C> is equal to the
      maximum of <A>n</A>, the largest moved point of <A>f</A> plus <C>1</C>,
      and the largest image of a moved point plus <C>1</C>.  The
      transformation <C>g</C> agrees with <A>f</A> on the domain of <A>f</A>
      and maps the points in <C>[1..m]</C>, which are not in the domain of
      <A>f</A> to <C>n</C>, i.e.  <C>i^g=i^<A>f</A></C> for all <C>i</C> in the
      domain of <A>f</A>, <C>i^g=n</C> for all <C>i</C> in <C>[1..n]</C>, and
      <C>i^g=i</C> for all <C>i</C> greater than <A>n</A>.
      <C>AsTransformation(<A>f</A>)</C> returns the transformation <C>g</C>
      defined in the previous sentences. <P/>

      If the optional argument <A>n</A> is not present, then the default value
      of the maximum of the largest moved point and the largest image of a
      moved point of <A>f</A> plus <C>1</C> is used.
    </Item>
    <Mark>for binary relations</Mark>
    <Item>
      In the case that <A>f</A> is a binary relation, which defines 
      a transformation, then <C>AsTransformation</C> returns that
      transformation. 
    </Item>
  </List>
  <Example><![CDATA[
gap> f:=Transformation( [ 3, 5, 3, 4, 1, 2 ] );;
gap> AsTransformation(f, 5);
Transformation( [ 3, 5, 3, 4, 1 ] )
gap> AsTransformation(f, 10);
Transformation( [ 3, 5, 3, 4, 1, 2 ] )
gap> AsTransformation((1, 3)(2, 4));
Transformation( [ 3, 4, 1, 2 ] )
gap> AsTransformation((1, 3)(2, 4), 10);
Transformation( [ 3, 4, 1, 2 ] )
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 6 ], [ 6, 7, 1, 4, 3, 2 ] );
[5,3,1,6,2,7](4)
gap> AsTransformation(f, 11);
Transformation( [ 6, 7, 1, 4, 3, 2, 11, 11, 11, 11, 11 ] )
gap> AsPartialPerm(last, DomainOfPartialPerm(f));
[5,3,1,6,2,7](4)
gap> AsTransformation(f, 14);
Transformation( [ 6, 7, 1, 4, 3, 2, 14, 14, 14, 14, 14, 14, 14, 14 ] )
gap> AsPartialPerm(last, DomainOfPartialPerm(f));
[5,3,1,6,2,7](4)
gap> AsTransformation(f);
Transformation( [ 6, 7, 1, 4, 3, 2, 8, 8 ] )
gap> AsTransformation(Transformation( [ 1, 1, 2 ] ), 0);
IdentityTransformation
]]></Example>
  </Description>
  </ManSection>

  <ManSection>
  <Oper Name="RestrictedTransformation" Arg="f, list"/>
  <Oper Name="RestrictedTransformationNC" Arg="f, list"/>
  <Returns>A transformation.</Returns>
  <Description>
    <C>RestrictedTransformation</C> returns the new transformation <C>g</C>
    such that <C>i^g=i^<A>f</A></C> for all <C>i</C> in <A>list</A> and 
    such that <C>i^g=i</C> for all <C>i</C> not in <A>list</A>. <P/>
  
    <C>RestrictedTransformation</C> checks that <A>list</A> is a duplicate
    free dense list consisting of positive integers, whereas
    <C>RestrictedTransformationNC</C> performs no checks.

    <Example><![CDATA[
gap> f:=Transformation( [ 2, 10, 5, 9, 10, 9, 6, 3, 8, 4, 6, 5 ] );;
gap> RestrictedTransformation(f, [ 1, 2, 3, 10, 11, 12 ] );
Transformation( [ 2, 10, 5, 4, 5, 6, 7, 8, 9, 4, 6, 5 ] )
]]></Example>
  </Description>
</ManSection>

  <ManSection>
  <Attr Name="PermutationOfImage" Arg="f"/>
  <Returns>A permutation or <K>fail</K>.</Returns>
  <Description>
    If the transformation <A>f</A> is a permutation of the points in its image,
    then <C>PermutationOfImage</C> returns this permutation. If <A>f</A> does
    not permute its image, then <K>fail</K> is returned. <P/> 

    If <A>f</A> happens to be a permutation, then <C>PermutationOfImage</C>
    with argument <A>f</A> returns the same value as <C>AsPermutation</C> with
    argument <A>f</A>.

  <Example><![CDATA[
gap> f:=Transformation( [ 5, 8, 3, 5, 8, 6, 2, 2, 7, 8 ] );;
gap> PermutationOfImage(f);
fail
gap> f:=Transformation( [ 8, 2, 10, 2, 4, 4, 7, 6, 9, 10 ] );; 
gap> PermutationOfImage(f);
fail
gap> f:=Transformation( [ 1, 3, 6, 6, 2, 10, 2, 3, 10, 5 ] );;
gap> PermutationOfImage(f);
(2,3,6,10,5)
gap> f:=Transformation( [ 5, 2, 8, 4, 1, 8, 10, 3, 5, 7 ] );;
gap> PermutationOfImage(f);
(1,5)(3,8)(7,10)
]]></Example>
  </Description>
  </ManSection>
</Section>

<!-- *************************************************************** -->
<!-- *************************************************************** -->

<Section Label="sect:OperatorsTransformations">
  <Heading>Operators for transformations</Heading>
    <List>
    <Mark><C><A>i</A> ^ <A>f</A></C></Mark>
    <Item>
      <Index Key="\^" Subkey="for a positive integer and a transformation"><C>\^</C></Index>
      returns the image of the positive integer <A>i</A> under the
      transformation <A>f</A>.
    </Item>
    <Mark><C><A>f</A> ^ <A>g</A></C></Mark>
    <Item>
      <Index Key="\^" Subkey="for a transformation and a permutation"><C>\^</C></Index>
      returns <C><A>g</A>^-1*<A>f</A>*<A>g</A></C> when
      <A>f</A> is a transformation and <A>g</A> is a permutation
      <Ref Oper="\^" BookName="ref"/>.  
      This operation requires essentially the same number of steps 
      as multiplying a transformation by a permutation, which is approximately
      one third of the number required to first invert <A>g</A>, take the
      produce with <A>f</A>, and then the product with <A>g</A>. 

     </Item>
     <Mark><C><A>f</A> * <A>g</A></C></Mark>
     <Item>
       <Index Key="\*" Subkey="for transformations"><C>\*</C></Index>
       returns the composition of <A>f</A> and <A>g</A> when <A>f</A> and
       <A>g</A> are transformations or permutations. The product of a
       permutation and a transformation is returned as a transformation. 
     </Item>
     <Mark><C><A>f</A> / <A>g</A></C></Mark>
    <Item>
      <Index Key="\/" Subkey="for a transformation and a permutation"><C>\/</C></Index>
      returns <C><A>f</A>*<A>g</A>^-1</C> when <A>f</A> is a transformation and
      <A>g</A> is a permutation. 
      This operation requires essentially the same number of steps 
      as multiplying a transformation by a permutation, which is approximately
      half the number required to first invert <A>g</A> and then take the
      produce with <A>f</A>. 
    </Item>
     <Mark><C>LQUO(<A>g</A>, <A>f</A>)</C></Mark>
    <Item>
      <Index Key="LQUO" Subkey="for a permutation and transformation"><C>LQUO</C></Index>
      returns <C><A>g</A>^-1*<A>f</A></C> when <A>f</A> is a transformation and
      <A>g</A> is a permutation. This operation uses essentially the same
      number of steps as multiplying a transformation by a permutation, which
      is approximately half the number required to first invert <A>g</A> and
      then take the produce with <A>f</A>. 
    </Item>
    <Mark><C><A>f</A> &lt; <A>g</A></C></Mark>
    <Item>
      <Index Key="\&lt;" Subkey="for transformations"><C>\&lt;</C></Index>
      <Index Subkey="for transformations">smaller</Index>
      returns <K>true</K> if the image list of <A>f</A>
      is lexicographically less than the image list of <A>g</A>
      and <K>false</K> if it is not.
    </Item>
    <Mark><C><A>f</A> = <A>g</A></C></Mark>
    <Item>
      <Index Key="\=" Subkey="for transformations"><C>\=</C></Index>
      <Index Subkey="for transformations">equality</Index>
      returns <K>true</K> if the transformation <A>f</A> equals the
      transformation <A>g</A> and returns <K>false</K> if it does not.
    </Item>
   </List>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="PermLeftQuoTransformation" Arg="f, g"/>
    <Oper Name="PermLeftQuoTransformationNC" Arg="f, g"/>
    <Returns>A permutation.</Returns>
    <Description>
      Returns the permutation on the image set of <A>f</A> induced by 
      <C><A>f</A>^-1*<A>g</A></C> when the transformations <A>f</A> and 
      <A>g</A> have equal kernel and image set. <P/>
      
      <C>PermLeftQuoTransformation</C> verifies that <A>f</A> and <A>g</A> have
      equal kernels and image sets, and returns an error if they do not. 
      <C>PermLeftQuoTransformationNC</C> does no checks.
      <Example><![CDATA[
gap> f:=Transformation( [ 5, 6, 7, 1, 4, 3, 2, 7 ] );;
gap> g:=Transformation( [ 5, 7, 1, 6, 4, 3, 2, 1 ] );;
gap> PermLeftQuoTransformation(f, g);
(1,6,7)
gap> PermLeftQuoTransformation(g, f);
(1,7,6)
]]></Example>
    </Description>
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <ManSection>
    <Oper Name="IsInjectiveListTrans" Arg="obj, list"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      The argument <A>obj</A> should be a transformation or the list of images
      of a transformation and <A>list</A> should be a list of positive
      integers.  <C>IsInjectiveListTrans</C> checks if <A>obj</A> is
      injective on <A>list</A>. <P/>
      
      More precisely,
      if <A>obj</A> is a transformation, then we define
      <C>f:=<A>obj</A></C> and if <A>obj</A> is the image list of a
      transformation we define <C>f:=Transformation(<A>obj</A>)</C>.
      <C>IsInjectiveListTrans</C> returns <K>true</K> if <C>f</C> is injective
      on <A>list</A> and <K>false</K> if it is not. If <A>list</A> is not
      duplicate free, then <K>false</K> is returned. <P/>
      <Example><![CDATA[
gap> f:=Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] );;
gap> IsInjectiveListTrans( [ 1, 5 ], f );
true
gap> IsInjectiveListTrans( [ 5, 1 ], f );
true
gap> IsInjectiveListTrans( [ 5, 1, 5, 1, 1, ], f );
false
gap> IsInjectiveListTrans( [ 5, 1, 2, 3 ], [ 1, 2, 3, 4, 5 ] );
true
]]></Example>
    </Description>
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="ComponentTransformationInt" Arg="f, n" /> 
  <Returns>A list of positive integers.</Returns>
  <Description>
    If <A>f</A> is a transformation and <A>n</A> is a positive
    integer, then <C>ComponentTransformationInt</C> returns those elements
    <C>i</C> such that <C><A>n</A>^<A>f</A>^j=i</C> for some positive
    integer <C>j</C>, i.e. the elements of the component of <A>f</A> containing
    <A>n</A> that can be obtained by applying powers of <A>f</A> to <A>n</A>.
<Example><![CDATA[
gap> f:=Transformation( [ 6, 2, 8, 4, 7, 5, 8, 3, 5, 8 ] );;
gap> ComponentTransformationInt(f, 1);
[ 1, 6, 5, 7, 8, 3 ]
gap> ComponentTransformationInt(f, 12);
[ 12 ]
gap> ComponentTransformationInt(f, 5); 
[ 5, 7, 8, 3 ]
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <ManSection>
    <Oper Name="PreImagesOfTransformation" Arg="f, n"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      Returns the preimages of the positive integer <A>n</A> under the
      transformation <A>f</A>, i.e. the positive integers <C>i</C> such that
      <C>i^<A>f</A>=n</C>.

      <Example><![CDATA[
gap> f:=Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] );;
gap> PreImagesOfTransformation(f, 1);
[ 8, 9 ]
gap> PreImagesOfTransformation(f, 3);
[  ]
gap> PreImagesOfTransformation(f, 100);
[ 100 ]
]]></Example>
</Description>
</ManSection>

</Section>

<!-- *************************************************************** -->

<Section Label="sect:AttributesTransformations">
  <Heading>Attributes for transformations</Heading>
  In this section we describe the functions available in &GAP; for finding
  various properties and attributes of transformations. 

  <ManSection>
    <Attr Name="DegreeOfTransformation" Arg="f"/>
    <Attr Name="DegreeOfTransformationCollection" Arg="coll"/>
    <Returns>A positive integer.</Returns>
    <Description>
      The <E>degree</E> of a transformation <A>f</A> is the largest value such
      that <C>n^<A>f</A>&lt;>n</C> or <C>i^<A>f</A>=n</C> for some <C>i&lt;>n</C>.
      Equivalently, the degree of a transformation is the least value <C>n</C>
      such that <C>[n+1,n+2,...]</C> is fixed pointwise by <A>f</A>.

      The degree a collection of transformations <A>coll</A> is
      the maximum degree of any transformation in <A>coll</A>. 
      <Example><![CDATA[
gap> DegreeOfTransformation(IdentityTransformation);
0
gap> DegreeOfTransformationCollection([ Transformation( [ 1, 3, 4, 1 ] ), 
> Transformation( [ 3, 1, 1, 3, 4 ]), Transformation( [ 2, 4, 1, 2 ] ) ]);
5
]]></Example>
    </Description>
  </ManSection>
  
<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="ImageListOfTransformation" Arg="f[, n]"/>
    <Oper Name="ListTransformation" Arg="f[, n]"/>
    <Returns>The list of images of a transformation.</Returns>
    <Description>
      Returns the list of images of <C>[1..<A>n</A>]</C> under the
      transformation <A>f</A>, which is <C>[1^<A>f</A>..<A>n</A>^<A>f</A>]</C>.
      If the optional second argument <A>n</A> is not present, then the
      degree of <A>f</A> is used by default.<P/>

      This is the analogue for transformations of <Ref Func="ListPerm"/> for
      permutations.
      <Example><![CDATA[
gap> f:=Transformation( [ 2 ,3, 4, 2, 4 ] );;
gap> ImageListOfTransformation(f);
[ 2, 3, 4, 2, 4 ]
gap> ImageListOfTransformation(f, 10);
[ 2, 3, 4, 2, 4, 6, 7, 8, 9, 10 ]
]]></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Attr Name="ImageSetOfTransformation" Arg="f[, n]"/>
    <Returns>The set of images of the transformation.</Returns>
    <Description>
      Returns the set of points in the list of images of <C>[1..<A>n</A>]</C>
      under <A>f</A>, i.e. the sorted list of images with duplicates removed.
      If the optional second argument <A>n</A> is not given, then the
      degree of <A>f</A> is used. <P/>

      <Example><![CDATA[
gap> f:=Transformation( [ 5, 6, 7, 1, 4, 3, 2, 7 ] );;
gap> ImageSetOfTransformation(f);
[ 1, 2, 3, 4, 5, 6, 7 ]
gap> ImageSetOfTransformation(f, 10);
[ 1, 2, 3, 4, 5, 6, 7, 9, 10 ]
]]></Example>
</Description>
</ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Attr Name="RankOfTransformation" Arg="f[, n]" 
      Label="for a transformation and a positive integer"/>
    <Attr Name="RankOfTransformation" Arg="f[, list]"
      Label="for a transformation and a list"/>
    <Returns>The rank of a transformation.</Returns>
    <Description>
      When the arguments are a transformation <A>f</A> and a positive integer 
      <A>n</A>, <C>RankOfTransformation</C> returns the size of the set of
      images of the transformation <A>f</A> in the range <C>[1..<A>n</A>]</C>.
      If the optional second argument <A>n</A> is not specified, then the
      degree of <A>f</A> is used. <P/>

     When the arguments are a transformation <A>f</A> and a list
      <A>list</A> of positive integers, this function returns the size of the
      set of images of the transformation <A>f</A> on <A>list</A>.

      <Example><![CDATA[
gap> f:=Transformation( [ 8, 5, 8, 2, 2, 8, 4, 7, 3, 1 ] );;
gap> ImageSetOfTransformation(f);
[ 1, 2, 3, 4, 5, 7, 8 ]
gap> RankOfTransformation(f);
7
gap> RankOfTransformation(f, 100);                   
97
gap> RankOfTransformation(f, [ 2, 5, 8 ] );
3
]]></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="MovedPoints" Arg="f" Label="for a transformation"/>
    <Oper Name="MovedPoints" Arg="coll" Label="for a transformation coll"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      When the argument is a transformation, <C>MovedPoints</C> returns the set
      of positive integers <C>i</C> such that <C>i^<A>f</A>&lt;>i</C>. 
      
      <C>MovedPoints</C> returns the set of points moved by some element of
      the collection of transformations <A>coll</A>.
      <Example><![CDATA[
gap> f:=Transformation( [ 6, 10, 1, 4, 6, 5, 1, 2, 3, 3 ] );;
gap> MovedPoints(f); 
[ 1, 2, 3, 5, 6, 7, 8, 9, 10 ]
gap> f:=IdentityTransformation;  
IdentityTransformation
gap> MovedPoints(f);
[  ]
]]></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="NrMovedPoints" Arg="f" Label="for a transformation"/>
    <Oper Name="NrMovedPoints" Arg="coll" Label="for a transformation coll"/>
    <Returns>A positive integer.</Returns>
    <Description>
      When the argument is a transformation,<C>NrMovedPoints</C> returns the
      number of positive integers <C>i</C> such that <C>i^<A>f</A>&lt;>i</C>. 
      
      <C>MovedPoints</C> returns the number of points which are moved by at
      least one element of the collection of transformations <A>coll</A>.
      <Example><![CDATA[
gap> f:=Transformation( [ 7, 1, 4, 3, 2, 7, 7, 6, 6, 5 ] );;
gap> NrMovedPoints(f);
9
gap> NrMovedPoints(IdentityTransformation);
0
]]></Example>
    </Description>
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Oper Name="SmallestMovedPoint" Arg="f" Label="for a transformation"/>
  <Oper Name="SmallestMovedPoint" Arg="coll" Label="for a transformation coll"/>
  <Returns>A positive integer or <K>infinity</K>.</Returns>
  <Description>
    <C>SmallestMovedPoint</C> returns the smallest  positive integer <C>i</C>
    such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C> exists.  If <A>f</A>
    is the identity transformation, then <K>infinity</K> is returned.<P/>

    If the argument is a collection of transformations <A>coll</A>, then the
    smallest point which is moved by at least one element of <A>coll</A> is
    returned, if such a point exists.  If <A>coll</A> only contains identity
    transformations, then <C>SmallestMovedPoint</C> returns <K>infinity</K>.
    <Example><![CDATA[
gap> S := FullTransformationSemigroup(5);    
<full transformation monoid of degree 5>
gap> SmallestMovedPoint(S);              
1
gap> S := Semigroup(IdentityTransformation);
<trivial transformation group of degree 0 with 1 generator>
gap> SmallestMovedPoint(S);
infinity
gap> f := Transformation( [ 1, 2, 3, 6, 6, 6 ] );;
gap> SmallestMovedPoint(f);
4
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Oper Name="LargestMovedPoint" Arg="f" Label="for a transformation"/>
  <Oper Name="LargestMovedPoint" Arg="coll" Label="for a transformation coll"/>
  <Returns>A positive integer.</Returns>
  <Description>
    <C>LargestMovedPoint</C> returns the largest positive integers <C>i</C>
    such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C> exists.  If <A>f</A>
    is the identity transformation, then <C>0</C> is returned.<P/>

    If the argument is a collection of transformations <A>coll</A>, then the
    largest point which is moved by at least one element of <A>coll</A> is
    returned, if such a point exists.  If <A>coll</A> only contains identity
    transformations, then <C>LargestMovedPoint</C> returns <C>0</C>.

    <Example><![CDATA[
gap> S := FullTransformationSemigroup(5);    
<full transformation monoid of degree 5>
gap> LargestMovedPoint(S);
5
gap> S := Semigroup(IdentityTransformation);
<trivial transformation group of degree 0 with 1 generator>
gap> LargestMovedPoint(S);
0
gap> f := Transformation( [ 1, 2, 3, 6, 6, 6 ] );;
gap> LargestMovedPoint(f); 
5
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Oper Name="SmallestImageOfMovedPoint" Arg="f" Label="for a transformation"/>
  <Oper Name="SmallestImageOfMovedPoint" Arg="coll" 
    Label="for a transformation coll"/>
  <Returns>A positive integer or <K>infinity</K>.</Returns>
  <Description>
    <C>SmallestImageOfMovedPoint</C> returns the smallest positive integer
    <C>i^<A>f</A></C> such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C>
    exists.  If <A>f</A> is the identity transformation, then <K>infinity</K> is
    returned.<P/>

    If the argument is a collection of transformations <A>coll</A>, then the
    smallest integer which is the image a point moved by at least one element
    of <A>coll</A> is
    returned, if such a point exists.  If <A>coll</A> only contains identity
    transformations, then <C>SmallestImageOfMovedPoint</C> returns
    <K>infinity</K>.

    <Example><![CDATA[
gap> S := FullTransformationSemigroup(5);    
<full transformation monoid of degree 5>
gap> SmallestImageOfMovedPoint(S);              
1
gap> S := Semigroup(IdentityTransformation);
<trivial transformation group of degree 0 with 1 generator>
gap> SmallestImageOfMovedPoint(S);
infinity
gap> f := Transformation( [ 1, 2, 3, 6, 6, 6 ] );;
gap> SmallestImageOfMovedPoint(f);
6
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Oper Name="LargestImageOfMovedPoint" Arg="f" Label="for a transformation"/>
  <Oper Name="LargestImageOfMovedPoint" Arg="coll" 
    Label="for a transformation coll"/>
  <Returns>A positive integer.</Returns>
  <Description>
    <C>LargestImageOfMovedPoint</C> returns the largest positive integer
    <C>i^<A>f</A></C> such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C>
    exists.  If <A>f</A> is the identity transformation, then <C>0</C> is
    returned.<P/>

    If the argument is a collection of transformations <A>coll</A>, then the
    largest integer which is the image a point moved by at least one element
    of <A>coll</A> is returned, if such a point exists.  If <A>coll</A> only
    contains identity transformations, then <C>LargestImageOfMovedPoint</C>
    returns <C>0</C>.
    <Example><![CDATA[
gap> S := FullTransformationSemigroup(5);    
<full transformation monoid of degree 5>
gap> LargestImageOfMovedPoint(S);
5
gap> S := Semigroup(IdentityTransformation);;
gap> LargestImageOfMovedPoint(S);
0
gap> f := Transformation( [ 1, 2, 3, 6, 6, 6 ] );;
gap> LargestImageOfMovedPoint(f); 
6
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <ManSection>
    <Func Name="FlatKernelOfTransformation" Arg="f[, n]"/>
    <Returns>The flat kernel of a transformation.</Returns>
    <Description>
      If the kernel classes of the transformation <A>f</A> on
      <C>[1..<A>n</A>]</C> are <M>K_1, \dots, K_r</M>, then
      <C>FlatKernelOfTransformation</C> returns a list <C>L</C> such that
      <C>L[i]=j</C> for all <C>i</C> in <M>K_j</M>. 
      For a given transformation and positive integer <A>n</A>,
      there is a unique such list.<P/>

      If the optional second argument <A>n</A> is not present, then the degree
      of <A>f</A> is used by defualt. 
      <Example><![CDATA[
gap> f:=Transformation( [ 10, 3, 7, 10, 1, 5, 9, 2, 6, 10 ] );;
gap> FlatKernelOfTransformation(f);
[ 1, 2, 3, 1, 4, 5, 6, 7, 8, 1 ]
]]></Example>
    </Description>
  </ManSection>
  
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <ManSection>
    <Attr Name="KernelOfTransformation" Arg="f[, n, bool]"/>
    <Returns>The kernel of a transformation.</Returns>
    <Description>
      When the arguments are a transformation <A>f</A>, a positive integer
      <A>n</A>, and <K>true</K>, 
      <C>KernelOfTransformation</C> returns the kernel of the
      transformation <A>f</A> on <C>[1..<A>n</A>]</C> as a set of sets of
      positive integers. If the argument <A>bool</A> is <K>false</K>, then only
      the non-singleton classes are returned. <P/>

      The second and third arguments are optional, the default values are the
      degree of <A>f</A> and <K>true</K>.
      <Example><![CDATA[
gap> f:=Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 11, 1, 12, 5 ] );;
gap> KernelOfTransformation(f);
[ [ 1, 4 ], [ 2, 5 ], [ 3 ], [ 6, 7 ], [ 8, 10 ], [ 9 ], [ 11 ], 
  [ 12 ] ]
gap> KernelOfTransformation(f, 5);
[ [ 1, 4 ], [ 2, 5 ], [ 3 ] ]
gap> KernelOfTransformation(f, 5, false);
[ [ 1, 4 ], [ 2, 5 ] ]
gap> KernelOfTransformation(f, 15);
[ [ 1, 4 ], [ 2, 5 ], [ 3 ], [ 6, 7 ], [ 8, 10 ], [ 9 ], [ 11 ], 
  [ 12 ], [ 13 ], [ 14 ], [ 15 ] ]
gap> KernelOfTransformation(f, false);    
[ [ 1, 4 ], [ 2, 5 ], [ 6, 7 ], [ 8, 10 ] ]
]]></Example>
  </Description>
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Oper Name="InverseOfTransformation" Arg="f"/>
  <Returns>A transformation.</Returns>
  <Description>
    <C>InverseOfTransformation</C> returns a semigroup inverse of the
    transformation <A>f</A> in the full transformation semigroup. An 
    <E>inverse</E> of <A>f</A> is any transformation <C>g</C>
    such that <C><A>f</A>*g*<A>f</A>=<A>f</A></C> and
    <C>g*<A>f</A>*g=g</C>. 
    Every transformation has at least one inverse in a full
    transformation semigroup.
    <Example><![CDATA[
gap> f:=Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] );;
gap> g:=InverseOfTransformation(f);
Transformation( [ 8, 1, 1, 1, 10, 2, 3, 1, 6, 1 ] )
gap> f*g*f;
Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] )
gap> g*f*g;
Transformation( [ 8, 1, 1, 1, 10, 2, 3, 1, 6, 1 ] )
]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="Inverse" Arg="f" Label="for a transformation"/>
  <Returns>A transformation.</Returns>
  <Description>
    If the transformation <A>f</A> is a bijection, then <C>Inverse</C> or 
    <C><A>f</A>^-1</C> returns the inverse of <A>f</A>. 
    If <A>f</A> is not a bijection, then <K>fail</K> is returned. 
    <Example><![CDATA[
gap> Transformation( [ 3, 8, 12, 1, 11, 9, 9, 4, 10, 5, 10, 6 ] )^-1;
fail
gap> Transformation( [ 2, 3, 1 ] )^-1;
Transformation( [ 3, 1, 2 ] )
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <ManSection> 
    <Attr Name="IndexPeriodOfTransformation" Arg="f"/> 
    <Returns>A pair of positive integers.</Returns> 
    <Description> 
      Returns the least positive integers <C>m</C> and <C>r</C> such that
      <C><A>f</A>^(m+r)=<A>f</A>^m</C>, which are  known as the <E>index</E>
      and <E>period</E> of the transformation <A>f</A>.  
      <Example><![CDATA[ 
gap> f:=Transformation( [ 3, 4, 4, 6, 1, 3, 3, 7, 1 ] );; 
gap> IndexPeriodOfTransformation(f); 
[ 2, 3 ]
gap> f^2=f^5; 
true
gap> IndexPeriodOfTransformation(IdentityTransformation);
[ 1, 1 ]
gap> IndexPeriodOfTransformation(Transformation([1,2,1]));
[ 1, 1 ]
gap> IndexPeriodOfTransformation(Transformation([1,2,3]));
[ 1, 1 ]
gap> IndexPeriodOfTransformation(Transformation([1,3,2]));
[ 1, 2 ]
]]></Example>  
    </Description> 
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="SmallestIdempotentPower" Arg="f" Label="for a transformation"/> 
  <Returns>A positive integer.</Returns> 
  <Description> 
      This function returns the least positive integer <C>n</C> such that the 
      transformation <C><A>f</A>^n</C> is an idempotent.  The smallest
      idempotent power of <A>f</A> is the least multiple of the period of
      <A>f</A> that is greater than or equal to the index of <A>f</A>; 
      see <Ref Attr="IndexPeriodOfTransformation"/>.

      <Example><![CDATA[
gap> f:=Transformation( [ 6, 7, 4, 1, 7, 4, 6, 1, 3, 4 ] );;
gap> SmallestIdempotentPower(f);
3
gap> f:=Transformation( [ 6, 6, 6, 2, 7, 1, 5, 3, 10, 6 ] );;
gap> SmallestIdempotentPower(f);
2
]]></Example>
    </Description>
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Attr Name="ComponentsOfTransformation" Arg="f" /> 
  <Returns>A list of lists of positive integers.</Returns>
  <Description> 
    <C>ComponentsOfTransformation</C> returns a list of the components of the
    transformation <A>f</A>.  Each component is a subset of
    <C>[1..DegreeOfTransformation(f)]</C>, and the union of the components is
    <C>[1..DegreeOfTransformation(f)]</C>.

    <Example><![CDATA[
gap> f:=Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] );
Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] )
gap> ComponentsOfTransformation(f);  
[ [ 1, 4, 6, 9 ], [ 2, 3, 5, 7, 10, 11, 12 ], [ 8 ] ]
gap> f:=AsTransformation((1,8,2,4,11,5,10)(3,7)(9,12));
Transformation( [ 8, 4, 7, 11, 10, 6, 3, 2, 12, 1, 5, 9 ] )
gap> ComponentsOfTransformation(f);  
[ [ 1, 2, 4, 5, 8, 10, 11 ], [ 3, 7 ], [ 6 ], [ 9, 12 ] ]
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Attr Name="NrComponentsOfTransformation" Arg="f" /> 
  <Returns>A positive integer.</Returns>
  <Description> 
    <C>NrComponentsOfTransformation</C>
    returns the number of components of the transformation <A>f</A> on the
    range <C>[1..DegreeOfTransformation(<A>f</A>)]</C>. 
    
    <Example><![CDATA[
gap> f:=Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] );
Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] )
gap> NrComponentsOfTransformation(f);
3
gap> f:=AsTransformation((1,8,2,4,11,5,10)(3,7)(9,12));
Transformation( [ 8, 4, 7, 11, 10, 6, 3, 2, 12, 1, 5, 9 ] )
gap> NrComponentsOfTransformation(f);
4
]]></Example>
  </Description>
</ManSection>
    
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Attr Name="ComponentRepsOfTransformation" Arg="f" /> 
  <Returns>A list of lists of positive integers.</Returns>
  <Description> 
    <C>ComponentRepsOfTransformation</C> returns the representatives, in the
    following sense, of the components of the transformation <A>f</A>.  For
    every <C>i</C> in <C>[1..DegreeOfTransformation(f)]</C> there exists a
    representative <C>j</C> and a positive integer <C>k</C> such that
    <C>i^(<A>f</A>^k)=j</C>. The representatives returned by
    <C>ComponentRepsOfTransformation</C> are partitioned according to the
    component they belong to.  <C>ComponentRepsOfTransformation</C> returns the
    least number of representatives. 
    <Example><![CDATA[
gap> f:=Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] );
Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] )
gap> ComponentRepsOfTransformation(f);
[ [ 3, 10 ], [ 9 ], [ 8 ] ]
gap> f:=AsTransformation((1,8,2,4,11,5,10)(3,7)(9,12));
Transformation( [ 8, 4, 7, 11, 10, 6, 3, 2, 12, 1, 5, 9 ] )
gap> ComponentRepsOfTransformation(f);
[ [ 1 ], [ 3 ], [ 6 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="CyclesOfTransformation" Arg="f[, list]" /> 
  <Returns>A list of lists of positive integers.</Returns>
  <Description> 
    When the arguments of this function are a transformation<A>f</A> and a list 
    <A>list</A>, it returns a list of the cycles of
    the components of <A>f</A> containing any element of <A>list</A>.<P/>

    If the optional second argument is not present, then the range
    <C>[1..DegreeOfTransformation(<A>f</A>)]</C> is used as the default value
    for <A>list</A>.  
    <Example><![CDATA[
gap> f:=Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] );
Transformation( [ 6, 12, 11, 1, 7, 6, 2, 8, 4, 7, 5, 12 ] )
gap> CyclesOfTransformation(f);   
[ [ 6 ], [ 12 ], [ 8 ] ]
gap> CyclesOfTransformation(f, [ 1, 2, 4 ] ); 
[ [ 6 ], [ 12 ] ]
gap> CyclesOfTransformation(f, [ 1 .. 17 ]);
[ [ 6 ], [ 12 ], [ 8 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ] ]
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="CycleTransformationInt" Arg="f, n" /> 
  <Returns>A list of positive integers.</Returns>
  <Description>
    If <A>f</A> is a transformation and <A>n</A> is a positive
    integer, then <C>CycleTransformationInt</C> returns the cycle of the
    component of <A>f</A> containing <A>n</A>.
    <Example><![CDATA[
gap> f:=Transformation( [ 6, 2, 8, 4, 7, 5, 8, 3, 5, 8 ] );;
gap> CycleTransformationInt(f, 1);
[ 8, 3 ]
gap> CycleTransformationInt(f, 12);
[ 12 ]
gap> CycleTransformationInt(f, 5); 
[ 8, 3 ]
]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="LeftOne" Arg="f" Label="for a transformation"/> 
  <Attr Name="RightOne" Arg="f" Label="for a transformation"/> 
  <Returns>A transformation.</Returns>
  <Description> 
    <C>LeftOne</C> returns an idempotent transformation <C>e</C> such that
    the kernel (with respect to the degree of <A>f</A>) of <C>e</C>
    equals the kernel of the transformation <A>f</A> and <C>e*<A>f</A>=f</C>.
    <P/>

    <C>RightOne</C> returns an idempotent transformation <C>e</C> such that the
    image set (with respect to the degree of <A>f</A>) of <C>e</C>
    equals the image set of <A>f</A> and <C><A>f</A>*e=f</C>. 
    
    <Example><![CDATA[
gap> f:=Transformation( [ 11, 10, 2, 11, 4, 4, 7, 6, 9, 10, 1, 11 ] );;
gap> e:=RightOne(f);
Transformation( [ 1, 2, 2, 4, 4, 6, 7, 7, 9, 10, 11, 11 ] )
gap> IsIdempotent(e);
true
gap> f*e=f;
true
gap> e:=LeftOne(f);
Transformation( [ 1, 2, 3, 1, 5, 5, 7, 8, 9, 2, 11, 1 ] )
gap> e*f=f;  
true
gap> IsIdempotent(e);
true
]]></Example>
  </Description>
</ManSection>

  <ManSection>
    <Func Name="TrimTransformation" Arg="f[, n]"/>
    <Returns>Nothing.</Returns>
    <Description>
      It can happen that the internal representation of a transformation 
      uses more memory than necessary. For example, this can happen when
      composing transformations where it is possible that the resulting
      transformation <A>f</A> has belongs to <C>IsTrans4Rep</C> and has its
      images stored as 32-bit integers, while none of its moved points exceeds
      65536. The purpose of <C>TrimTransformation</C> is to change the internal
      representation of such an <A>f</A> to remove the trailing fixed points.
      <P/>

      If the optional second argument <A>n</A> is provided, then the internal
      representation of <A>f</A> is reduced to the images of the first <A>n</A> 
      positive integers. Please note that it must be the case that
      <C>i^<A>f</A>&lt;=n</C> for all <C>i</C> in the range
      <C>[1..<A>n</A>]</C> otherwise the resulting object will not define a
      transformation. <P/>

      If the optional second argument is not included, then the 
      degree of <A>f</A> is used by default.<P/>

      The transformation <A>f</A> is changed in-place, and
      nothing is returned by this function.

      <Log><![CDATA[ 
gap> f:=Transformation( [ 1 .. 2^16 ], x-> x+1 );
<transformation on 65537 pts with rank 65536>
gap> g:=Transformation( [ 1 .. 2^16+1 ], function(x)
> if x=1 or x=65537 then return x; else return x-1; fi; end);
<transformation on 65536 pts with rank 65535>
gap> h:=g*f;
Transformation( [ 2, 2 ] )
gap> DegreeOfTransformation(h); IsTrans4Rep(h); MemoryUsage(h);
65537
true
262188
gap> TrimTransformation(h); h;
Transformation( [ 2, 2 ] )
gap> DegreeOfTransformation(h); IsTrans4Rep(h); MemoryUsage(h);
2
false
44
]]></Log>
    </Description>
  </ManSection>
</Section>

<!-- *************************************************************** -->

<Section Label="sect:DisplayingTransformations">
  <Heading>Displaying transformations</Heading>
    It is possible to change the way that &GAP; displays transformations
    using the user preferences <C>TransformationDisplayLimit</C> and 
    <C>NotationForTransformations</C>; see Section <Ref Func="UserPreference"/>
    for more information about user preferences. <P/>

    If <C>f</C> is a transformation where degree <C>n</C> exceeds
    the value of the user preference <C>TransformationDisplayLimit</C>, then 
    <C>f</C> is displayed as:
    <Log>&lt;transformation on n pts with rank r></Log>
    where <C>r</C> is the rank of <C>f</C> relative to <C>n</C>.  The idea is to
    abbreviate the display of transformations defined on many points. The
    default value for the <C>TransformationDisplayLimit</C> is <C>100</C>. <P/>

    If the degree of <C>f</C> does not exceed the value of 
    <C>TransformationDisplayLimit</C>, then how <C>f</C> is displayed depends
    on the value of the user preference <C>NotationForTransformations</C>.<P/>

    There are two possible values for <C>NotationForTransformations</C>:
    <List>
      <Mark>input</Mark>
      <Item>With this option a transformation <A>f</A> is displayed in as:
        <C>Transformation(ImageListOfTransformation(<A>f</A>, n)</C>
        where <C>n</C> is the degree of <A>f</A>. The only exception is
        the identity transformation, which is displayed as:
        <C>IdentityTransformation</C>.  
      </Item>
      <Mark>fr</Mark>
      <Item>With this option a transformation <A>f</A> is displayed in as:
        <C>&lt;transformation: ImageListOfTransformation(<A>f</A>, n)></C>
        where <C>n</C> is the largest moved point of <A>f</A>. The only
        exception is the identity transformation, which is displayed as:
        <C>&lt;identity transformation></C>.
      </Item>
    </List>
    <Log><![CDATA[
gap> SetUserPreference("TransformationDisplayLimit", 12);
gap> f:=Transformation([ 3, 8, 12, 1, 11, 9, 9, 4, 10, 5, 10, 6 ]);
<transformation on 12 pts with rank 10>
gap> SetUserPreference("TransformationDisplayLimit", 100);
gap> f;
Transformation( [ 3, 8, 12, 1, 11, 9, 9, 4, 10, 5, 10, 6 ] )
gap> SetUserPreference("NotationForTransformations", "fr");
gap> f;
<transformation: 3,8,12,1,11,9,9,4,10,5,10,6>
]]></Log>
</Section>

<!-- *************************************************************** -->

<Section Label="Making transformation semigroups">
<Heading>Semigroups of transformations</Heading>

As mentioned at the start of the chapter, every semigroup is isomorphic to a
semigroup of transformations, and in this section we describe the functions in
&GAP; specific to transformation semigroups. For more information about semigroups in general see Chapter <Ref Chap="Semigroups"/>. <P/>

The <Package>Semigroups</Package> package contains
many additional functions and methods for computing with semigroups of
transformations. In particular, <Package>Semigroups</Package> 
contains more efficient methods than those available in the &GAP; library (and
in many cases more efficient than any other software) for creating semigroups of transformations, calculating their Green"s classes, size, elements,
group of units, minimal ideal, small generating sets, testing membership,
finding the inverses of a regular element, factorizing elements over the
generators, and more. 

Since a transformation semigroup is also a transformation collection, there are
special methods for 
<Ref Attr="MovedPoints" Label="for a transformation coll"/>,
<Ref Attr="NrMovedPoints" Label="for a transformation coll"/>,
<Ref Attr="LargestMovedPoint" Label="for a transformation coll"/>,
<Ref Attr="SmallestMovedPoint" Label="for a transformation coll"/>,
<Ref Attr="LargestImageOfMovedPoint" Label="for a transformation coll"/>, and
<Ref Attr="SmallestImageOfMovedPoint" Label="for a transformation coll"/>,
when applied to a transformation semigroup.

<!-- *************************************************************** -->

<ManSection>
<Prop Name="IsTransformationSemigroup" Arg="obj"/>
<Prop Name="IsTransformationMonoid" Arg="obj"/>
<Returns><K>true</K> or <K>false</K>.</Returns>
<Description>
A <E>transformation semigroup</E> is simply a semigroup consisting of
transformations. An object <A>obj</A> is a transformation semigroup in &GAP; if
it satisfies <Ref Prop="IsSemigroup"/> and 
<Ref Filt="IsTransformationCollection"/>.<P/>

A  <E>transformation monoid</E> is a monoid consisting of transformations. 
An object <A>obj</A> is a transformation monoid in &GAP; if it satisfies 
<Ref Prop="IsMonoid"/> and <Ref Filt="IsTransformationCollection"/>.<P/>

Note that it is possible for a transformation semigroup to have a multiplicative neutral element (i.e. an identity element) but not to satisfy <C>IsTransformationMonoid</C>. For example, 
    <Example><![CDATA[
gap> f := Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] );;
gap> S := Semigroup(f, One(f));
<commutative transformation monoid of degree 10 with 1 generator>
gap> IsMonoid(S);
true
gap> IsTransformationMonoid(S);
true
gap> S := Semigroup( 
> Transformation( [ 3, 8, 1, 4, 5, 6, 7, 1, 10, 10 ] ), 
> Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 10 ] ) );
<transformation semigroup of degree 10 with 2 generators>
gap> One(S);
fail
gap> MultiplicativeNeutralElement(S);
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 10 ] )
gap> IsMonoid(S);
false
]]></Example>
In this example <C>S</C> cannot be converted into a monoid using 
<Ref Attr="AsMonoid"/> since the <Ref Attr="One"/> of any element in <C>S</C>
differs from the multiplicative neutral element. <P/>

For more details see <Ref Filt="IsMagmaWithOne"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="DegreeOfTransformationSemigroup" Arg="S"/>
<Returns>A non-negative integer.</Returns>
<Description>
  The <E>degree</E> of a transformation semigroup <A>S</A> is just the
  maximum of the degrees of the elements of <A>S</A>.

  <Example><![CDATA[
gap> S := Semigroup(
> Transformation( [ 3, 8, 1, 4, 5, 6, 7, 1, 10, 10, 11 ] ),
> Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 1, 11 ] ) );
<transformation semigroup of degree 10 with 2 generators>
gap> DegreeOfTransformationSemigroup(S);
10
]]></Example>
</Description>
</ManSection>

<!-- *************************************************************** -->

<ManSection>
<Func Name="FullTransformationSemigroup" Arg="n"/>
<Func Name="FullTransformationMonoid" Arg="n"/>
<Returns>The full transformation semigroup of degree <A>n</A>.</Returns>
<Description>
  If <A>n</A> is a positive integer, then <C>FullTransformationSemigroup</C>
  returns the monoid consisting of all transformations with degree at most
  <A>n</A>, called the <E>full transformation semigroup</E>. <P/>
 
  The full transformation semigroup is regular, has <C><A>n</A>^<A>n</A></C>
  elements, and is generated by any set containing transformations that
  generate the symmetric group on <A>n</A> points and any transformation of
  rank <C><A>n</A>-1</C>.<P/>

  <C>FulTransformationMonoid</C> is a synonym for
  <C>FullTransformationSemigroup</C>. 

  <Example><![CDATA[
gap> FullTransformationSemigroup(1234); 
<full transformation monoid of degree 1234>
]]></Example>
</Description>
</ManSection>

<!-- *************************************************************** -->

<ManSection>
<Prop Name="IsFullTransformationSemigroup" Arg="S"/>
<Prop Name="IsFullTransformationMonoid" Arg="S"/>
<Returns><K>true</K> or <K>false</K>.</Returns>
<Description>
  If the transformation semigroup <A>S</A> of degree <C>n</C> contains every
  transformation of degree at most <C>n</C>, then
  <C>IsFullTransformationSemigroup</C> return <K>true</K> and otherwise it
  returns <K>false</K>.  <P/>

  <C>IsFullTransformationMonoid</C> is a synonym of
  <C>IsFullTransformationSemigroup</C>. It is common in the literature 
  for the full transformation monoid to be referred to as the full
  transformation semigroup.  

  <Example><![CDATA[
gap> S := Semigroup(AsTransformation((1,3,4,2), 5), 
>                   AsTransformation((1,3,5), 5),
>                   Transformation( [ 1, 1, 2, 3, 4 ] ));
<transformation semigroup of degree 5 with 3 generators>
gap> IsFullTransformationSemigroup(S);
true
gap> S;
<full transformation monoid of degree 5>
gap> IsFullTransformationMonoid(S);
true
gap> S := FullTransformationSemigroup(5);; 
gap> IsFullTransformationSemigroup(S);
true
]]></Example>
</Description>
</ManSection>

<!-- *************************************************************** -->

<ManSection>
<Attr Name="IsomorphismTransformationSemigroup" Arg="S"/>
<Attr Name="IsomorphismTransformationMonoid" Arg="S"/>
<Returns>An isomorphism to a transformation semigroup or monoid.</Returns>
<Description>
  Returns an isomorphism from the finite semigroup <A>S</A> to a
  transformation semigroup. For most types of objects in &GAP; the degree of
  this transformation semigroup will be equal to the size of <A>S</A> plus
  <C>1</C>. <P/>
  
  Let <C><A>S</A>^1</C> denote the monoid obtained from <A>S</A> by adjoining
  an identity element. Then  <A>S</A> acts faithfully on <C><A>S</A>^1</C> by
  right multiplication, i.e.  every element of <A>S</A> describes a
  transformation on <C>1,..,|S|+1</C>. The isomorphism from <A>S</A> to the
  transformation semigroup described in this way is called the <E>right regular
  representation</E> of <A>S</A>.  In most cases,
  <C>IsomorphismTransformationSemigroup</C> will return the right regular
  representation of <A>S</A>. <P/>

  As exceptions, if <A>S</A> is a permutation group or a partial perm
  semigroup, then the elements of <A>S</A> act naturally and faithfully by
  transformations on the values from <C>1</C> to the largest moved point of
  <A>S</A>. <P/>

  If <A>S</A> is a finitely presented semigroup, then the Todd-Coxeter approach
  will be attempted.<P/>
  
  <C>IsomorphismTransformationMonoid</C> differs from
  <C>IsomorphismTransformationSemigroup</C> 
  only in that its range is a transformation monoid, and not only a semigroup,
  when the semigroup <A>S</A> is a monoid. 

  <Log><![CDATA[
gap> gens := [ [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3) ^ 0 ] ], 
>  [ [ Z(3), Z(3)^0 ], [ Z(3), 0*Z(3) ] ], 
>  [ [ Z(3)^0, 0*Z(3) ], [ 0*Z(3), 0*Z(3) ] ] ];;
gap> S := Semigroup(gens);;
gap> Size(S);
81
gap> IsomorphismTransformationSemigroup(S);;
gap> S := SymmetricInverseSemigroup(4);
<symmetric inverse semigroup on 4 pts>
gap> IsomorphismTransformationMonoid(S);
MappingByFunction( <symmetric inverse semigroup on 4 pts>, 
<transformation monoid on 5 pts with 4 generators>
 , function( x ) ... end, <Operation "AsPartialPerm"> )
gap> G := Group((1,2,3));
Group([ (1,2,3) ])
gap> IsomorphismTransformationMonoid(G);
MappingByFunction( Group([ (1,2,3) ]), <commutative transformation 
 monoid on 3 pts with 1 generator>
 , function( x ) ... end, function( x ) ... end )]]></Log>
</Description>
</ManSection>
  
<ManSection>
<Oper Name="AntiIsomorphismTransformationSemigroup" Arg="S"/>
<Returns>An anti-isomorphism.</Returns>
<Description>
  If <A>S</A> is a semigroup, then
  <C>AntiIsomorphismTransformationSemigroup</C> returns an anti-isomorphism
  from <A>S</A> to a transformation semigroup. At present, the degree of the
  resulting transformation semigroup equals the size of <A>S</A> plus
  <M>1</M>, and, consequently, this function is of limited use. <P/>

    <Example><![CDATA[
gap> S := Semigroup( Transformation( [ 5, 5, 1, 1, 3 ] ), 
> Transformation( [ 2, 4, 1, 5, 5 ] ) );
<transformation semigroup of degree 5 with 2 generators>
gap> Size(S);
172
gap> AntiIsomorphismTransformationSemigroup(S);
MappingByFunction( <transformation semigroup of size 172, degree 5 
 with 2 generators>, <transformation semigroup of degree 173 with 2 
 generators>, function( x ) ... end, function( x ) ... end )
]]></Example>
    </Description>
  </ManSection>
</Section>
</Chapter>

<Chapter Label="Partial permutations">
<Heading>Partial permutations</Heading>

This chapter describes the functions in &GAP; for partial permutations. 
<P/>

A <E>partial permutation</E> in &GAP; is simply an injective function from any
finite set of positive integers to any other finite set of positive integers.
The largest point on which a partial permutation can be defined, and the
largest value that the image of such a point can have, are defined by certain
architecture dependent limits. <P/>

Every inverse semigroup is isomorphic to an inverse semigroup of partial
permutations and, as such, partial permutations are to inverse semigroup theory
what permutations are to group theory and transformations are to semigroup
theory.  In this way, partial permutations are the
elements of inverse partial permutation semigroups.  <P/>

A partial permutations in &GAP; acts on a finite set of positive integers on
the right. The image of a point <C>i</C> under a partial permutation <C>f</C>
is expressed as <C>i^f</C> in &GAP;.  This action is also implemented by the
function <Ref Func="OnPoints"/>.  The preimage of a point <C>i</C> under the
partial permutation <C>f</C> can be computed using  <C>i/f</C> without
constructing the inverse of <C>f</C>.  Partial permutations in &GAP; are
created using the operations described in Section <Ref
  Sect="sect:CreatingPartialPerms"/>. 
Partial permutations are, by default, displayed
in component notation, which is described in Section 
<Ref Sect="sect:DisplayingPartialPerms"/>. <P/>

The fundamental attributes of a partial permutation are:
<List>
  <Mark>Domain</Mark>
  <Item>The <E>domain</E> of a partial permutation is just the set of positive
    integers where it is defined; see <Ref Attr="DomainOfPartialPerm"/>. We
    will denote the domain of a partial permutation <C>f</C> by dom(<C>f</C>).
  </Item>
  <Mark>Degree</Mark>
  <Item> The <E>degree</E> of a partial permutation <C>f</C> is just the largest
    positive integer where <C>f</C> is defined. In other words, the degree of
    <C>f</C> is the largest element in the domain of <C>f</C>; 
    see <Ref Attr="DegreeOfPartialPerm"/>. 
  </Item>
  <Mark>Image list</Mark>
  <Item>
    The <E>image list</E> of a partial permutation <C>f</C> is the list 
    <C>[i_1^f, i_2^f, .. , i_n^f]</C>
    where the domain of <C>f</C> is 
    <C>[i_1, i_2, .., i_n]</C>
    see <Ref Attr="ImageListOfPartialPerm"/>. For example, the partial perm 
    sending <C>1</C> to <C>5</C> and <C>2</C> to <C>4</C> has image list 
    <C>[ 5, 4 ]</C>.
  </Item>
  <Mark>Image set</Mark>
  <Item>
    The <E>image set</E> of a partial permutation <C>f</C> is just the set of
    points in the image list (i.e. the image list after it has been sorted into
    increasing order);
    see <Ref Attr="ImageSetOfPartialPerm"/>. We will denote the image set of a
    partial permutation <C>f</C> by im(<C>f</C>). 
  </Item>
  <Mark>Codegree</Mark>
  <Item> The <E>codegree</E> of a partial permutation <C>f</C> is just the
    largest positive integer of the form <C>i^f</C> for any <C>i</C>
    in the domain of <C>f</C>. In other words, the codegree of <C>f</C> is
    the largest element in the image of <C>f</C>; see 
    <Ref Attr="CodegreeOfPartialPerm"/>. 
  </Item>
 <Mark>Rank</Mark>
  <Item>The <E>rank</E> of a partial permutation <C>f</C> is the size of its
    domain, or equivalently the size of its image set or image list; see 
    <Ref Attr="RankOfPartialPerm"/>.
  </Item>
</List>

  A <E>functional digraph</E> is a directed graph where every vertex has
  out-degree <C>1</C>.  A partial permutation <A>f</A> can be thought of as a
  functional digraph with vertices <C>[1..DegreeOfPartialPerm(f)]</C> and 
  edges from <C>i</C> to <C>i^f</C> for every <C>i</C>. A <E>component</E>
  of a partial permutation is defined as a component of the corresponding
  functional digraph. 
  More specifically, <C>i</C> and <C>j</C> are in the same component if and
  only if there are <M>i=v_0, v_1, \ldots, v_n=j</M> such that either 
  <M>v_{k+1}=v_{k}^f</M> or <M>v_{k}=v_{k+1}^f</M> for all <C>k</C>. <P/>
  
  If <C>S</C> is a semigroup and <C>s</C> is an element of <C>S</C>, then an
  element <C>t</C> in <C>S</C> is a <E>semigroup inverse</E> for <C>s</C> if 
  <C>s*t*s=s</C> and <C>t*s*t=t</C>; see, for example,
  <Ref Oper="InverseOfTransformation"/>. A semigroup in which every element has
  a unique semigroup inverse is called an <E>inverse semigroup</E>.<P/> 

  Every partial permutation belongs to a symmetric inverse monoid; see 
  <Ref Func="SymmetricInverseSemigroup"/>. Inverse semigroups of partial
  permutations are hence inverse subsemigroups of the symmetric inverse
  monoids. <P/>

  The inverse <C>f^-1</C> of a partial permutation <C>f</C> is simply the
  partial permutation that maps <C>i^f</C> to <C>i</C> for all <C>i</C> in the
  image of <C>f</C>. It follows that the domain of <C>f^-1</C> equals the
  image of <C>f</C> and that the image of <C>f^-1</C> equals the domain of
  <C>f</C>.  The inverse <C>f^-1</C> is the
  unique partial permutation with the property that <C>f*f^-1*f=f</C>
  and <C>f^-1*f*f^-1=f^-1</C>. In other words, <C>f^-1</C> is the unique
  semigroup inverse of <C>f</C> in the symmetric inverse monoid. <P/>

  If <C>f</C> and <C>g</C> are partial permutations, then the domain and image
  of the product are:
  <Alt Only='Text'>
  <Display>
    dom(fg)=(im(f)\cap dom(g))f^-1 and
    im(fg)=(im(f)\cap dom(g))g
  </Display>
  </Alt>
  <Alt Not='Text'>
  <Display>
    \textrm{dom}(fg)=(\textrm{im}(f)\cap \textrm{dom}(g))f^{-1}\textrm{ and }
    \textrm{im}(fg)=(\textrm{im}(f)\cap \textrm{dom}(g))g
  </Display>
  </Alt>

  A partial permutation is an idempotent if and only if it is the identity 
  function on its domain.
  The products <C>f*f^-1</C> and <C>f^-1*f</C> are just the identity
  functions on the domain and image of <C>f</C>, respectively. It follows that
  <C>f*f^-1</C> is a left identity for <C>f</C> and <C>f^-1*f</C> is a right
  identity. These products will be referred to here 
  as the <E>left one</E> and <E>right one</E> of the partial permutation
  <C>f</C>; see <Ref Oper="LeftOne" Label="for a partial perm"/>.  The
  <E>one</E> of a partial permutation is just the identity on the
  union of its domain and its image, and the <E>zero</E> of a partial
  permutation is just the empty partial permutation; see 
  <Ref Oper="One" Label="for a partial perm"/> and
  <Ref Oper="Zero" Label="for a partial perm"/>.
  <P/>

  If <C>S</C> is an arbitrary inverse semigroup, the <E>natural partial
  order</E> on <C>S</C> is defined as follows: for elements <C>x</C> and
  <C>y</C> of <C>S</C> we say <C>x</C><M>\leq</M><C>y</C> if there exists an
  idempotent element <C>e</C> in <C>S</C> such that <C>x=ey</C>. 
  In the context of the symmetric inverse monoid, a partial permutation
  <C>f</C> is less than or equal to a partial permutation <C>g</C> in the
  natural partial order if and only
  if <C>f</C> is a restriction of <C>g</C>. The natural partial order is a meet
  semilattice, in other words, every pair of elements has a greatest lower
  bound; see <Ref Oper="MeetOfPartialPerms"/>.<P/> 

  Note that unlike permutations, partial permutations do not fix unspecified
  points but are simply undefined on such points; see Chapter 
  <Ref Chap="Permutations"/>. Similar to permutations, and unlike
  transformations, it is possible to multiply any two partial permutations in
  &GAP;.<P/>

  Internally, &GAP; stores a partial permutation <C>f</C> as a list consisting
  of the codegree of <C>f</C> and the images <C>i^f</C> of the points
  <C>i</C> that are less than or equal to the degree of <C>f</C>; the value
  <C>0</C> is stored where <C>i^f</C> is undefined.  The domain and image set
  of <C>f</C> are also stored after either of these values is computed. When
  the codegree of a partial permutation <C>f</C> is less than 65536, the
  codegree and images <C>i^f</C> are stored as 16-bit integers, the domain and
  image set are subobjects of <C>f</C>  which are immutable plain lists of
  &GAP; integers.  When the codegree of <C>f</C> is greater than or equal to
  65536, the codegree and images are stored as 32-bit integers; the domain and
  image set are stored in the same way as before. A partial permutation belongs
  to <C>IsPPerm2Rep</C> if it is stored using 16-bit integers  and to
  <C>IsPPerm4Rep</C> otherwise. 
<P/>

In the names of the &GAP; functions that deal with partial permutations, the word <Q>Permutation</Q> is usually abbreviated to <Q>Perm</Q>, to save typing. 
For example, the category test function for partial permutations is 
<Ref Filt="IsPartialPerm"/>. 

  <Section>
    <Heading>The family and categories of partial permutations</Heading>
  <ManSection>
    <Filt Name="IsPartialPerm" Arg='obj' Type='Category'/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
    Every partial permutation in &GAP; belongs to the category
    <C>IsPartialPerm</C>. Basic operations for partial permutations are 
    <Ref Attr="DomainOfPartialPerm"/>, <Ref Attr="ImageListOfPartialPerm"/>, 
    <Ref Attr="ImageSetOfPartialPerm"/>, <Ref Attr="RankOfPartialPerm"/>,
    <Ref Attr="DegreeOfPartialPerm"/>, multiplication of two partial 
    permutations is via <K>*</K>, and exponentiation with the first argument
    a positive integer <C>i</C> and second argument a partial permutation
    <C>f</C> where the result is the image <C>i^f</C> of the point <C>i</C>
    under <C>f</C>. The inverse of a partial permutation <C>f</C> can be
    obtains using <C>f^-1</C>.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsPartialPermCollection" Arg='obj' Type='Category'/>
    <Description>
     Every collection of partial permutations belongs to the category
     <C>IsPartialPermCollection</C>. 
      For example, a semigroup of partial permutations belongs
      in <C>IsPartialPermCollection</C>.
    </Description>
  </ManSection>

  <ManSection>
    <Fam Name="PartialPermFamily"/>
    <Description>
      The family of all partial permutations is <C>PartialPermFamily</C>
    </Description>
  </ManSection>
</Section>

<!-- *************************************************************** -->
<!-- *************************************************************** -->

<Section Label="sect:CreatingPartialPerms">
  <Heading>Creating partial permutations</Heading>

  There are several ways of creating partial permutations in &GAP;, which are 
  described in this section.  

<!-- *************************************************************** -->
  
  <ManSection>
    <Func Name="PartialPerm" Arg="dom, img" Label="for a domain and image"/>
    <Func Name="PartialPerm" Arg="list" Label="for a dense image"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      Partial permutations can be created in two ways: by giving the domain
      and the image, or the dense image list.<P/>

      <List>
        <Mark>Domain and image</Mark>
        <Item>
          The partial permutation defined by a domain <A>dom</A> and image
          <A>img</A>, where <A>dom</A> is a set of positive integers and
          <A>img</A> is a duplicate free list of positive integers, maps
          <A>dom</A><C>[i]</C> to <A>img</A><C>[i]</C>. For example,
          the partial permutation mapping <C>1</C> and <C>5</C> to <C>20</C> and
          <C>2</C> can be created using: 
          <Log>PartialPerm([1,5],[20,2]); </Log>
          In this setting, <C>PartialPerm</C> is the analogue in the context of
          partial permutations of <Ref Func="MappingPermListList"/>. 
        </Item>
        <Mark>Dense image list</Mark>
        <Item>
          The partial permutation defined by a dense image list <A>list</A>,
          maps the positive integer <C>i</C> to <A>list</A><C>[i]</C> if
          <A>list</A><C>[i]&lt;>0</C> and is undefined at <C>i</C> if
          <A>list</A><C>[i]=0</C>.  For example, the partial permutation
          mapping <C>1</C> and <C>5</C> to <C>20</C> and <C>2</C> can be
          created using: <Log>PartialPerm([20,0,0,0,2]);</Log>
          In this setting, <C>PartialPerm</C> is the analogue in the context of
          partial permutations of <Ref Func="PermList"/>.
        </Item>
      </List>

      Regardless of which of these two methods are used to create a partial
      permutation in &GAP; the internal representation is the same. <P/>

      If the largest point in the domain is larger than the
      rank of the partial permutation, then using the dense image list to
      define the partial permutation will require less typing; otherwise
      using the domain and the image will require less typing. For example,
      the partial permutation mapping <C>10000</C> to <C>1</C> can be defined
      using:
      <Log>PartialPerm([10000], [1]);</Log>
      but using the dense image list would require a list with <C>9999</C>
      entries equal to <C>0</C> and the final entry equal to <C>1</C>. 
      On the other hand, the identity on <C>[1,2,3,4,6]</C> can be defined
      using:
      <Log>PartialPerm([1,2,3,4,0,6]);</Log>
      <P/>

      Please note that a partial permutation in &GAP; is never a permutation
      nor is a permutation ever a partial permutation. For example, the
      permutation <C>(1,4,2)</C> fixes <C>3</C> but the partial permutation
      <C>PartialPerm([4,1,0,2]);</C> is not defined on <C>3</C>. 
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Func Name="PartialPermOp" Arg='obj, list[, func]'/>
    <Func Name="PartialPermOpNC" Arg='obj, list[, func]'/>
    <Returns>A partial permutation or <K>fail</K>.</Returns>
    <Description>
      <C>PartialPermOp</C> returns the partial permutation that corresponds to
      the action of the object <A>obj</A> on the domain or list <A>list</A>
      via the function <A>func</A>. If the optional third argument <A>func</A>
      is not specified, then the action <Ref Func="OnPoints"/> is used by
      default.  Note that the returned partial permutation
      refers to the positions in <A>list</A> even if <A>list</A> itself
      consists of integers.  <P/>
      
      This function is the analogue in the context of
      partial permutations of <Ref Func="Permutation" BookName="ref"/> or 
      <Ref Func="TransformationOp"/>.<P/>
      
      If <A>obj</A> does not map the elements of <A>list</A> injectively,
      then <K>fail</K> is returned.<P/>

      <C>PartialPermOpNC</C> does not check that <A>obj</A> maps elements of
      <A>list</A> injectively or that a partial permutation is
      defined by the action of <A>obj</A> on <A>list</A> via <A>func</A>. This
      function should be used only with caution, in situations where it is
      guaranteed that the arguments have the required properties.

      <Example>
gap> f:=Transformation( [ 9, 10, 4, 2, 10, 5, 9, 10, 9, 6 ] );;
gap> PartialPermOp(f, [ 6 .. 8 ], OnPoints);
[1,4][2,5][3,6]</Example>
    </Description>
  </ManSection>
  
<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="RestrictedPartialPerm" Arg="f, set"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      <C>RestrictedPartialPerm</C> returns a new partial permutation that acts
      on the points in the set of positive integers <A>set</A> in  the  same
      way as the partial permutation <A>f</A>, and that is undefined on those
      points that are not in <A>set</A>.

      <Example>
gap> f:=PartialPerm( [ 1, 3, 4, 7, 8, 9 ], [ 9, 4, 1, 6, 2, 8 ] );;
gap> RestrictedPartialPerm(f, [ 2, 3, 6, 10 ] );
[3,4]</Example>
    </Description>
  </ManSection>
  
<!-- *************************************************************** -->

  <ManSection>
    <Func Name="JoinOfPartialPerms" Arg="arg"/>
    <Func Name="JoinOfIdempotentPartialPermsNC" Arg="arg"/>
    <Returns>A partial permutation or <K>fail</K>.</Returns>
    <Description>
      The join of partial permutations <A>f</A> and <A>g</A> is just the join,
      or supremum,  of <A>f</A> and <A>g</A> under the natural partial
      ordering of partial permutations. <P/>

      <C>JoinOfPartialPerms</C> returns the union of the partial permutations
      in its argument if this defines a partial permutation, and <K>fail</K>
      if it is not.  The argument <A>arg</A> can be a partial permutation
      collection or a number of partial permutations. 
      <P/>

      The function <C>JoinOfIdempotentPartialPermsNC</C> returns the join of
      its argument which is assumed to be a collection of idempotent partial
      permutations or a number of idempotent partial permutations. It is not
      checked that the arguments are idempotents. The performance of this
      function is higher than <C>JoinOfPartialPerms</C> when it is known 
      <E>a priori</E> that the argument consists of idempotents.<P/> 

      The union of <A>f</A> and <A>g</A> is a partial
      permutation if and only if <A>f</A> and <A>g</A> agree on the
      intersection dom(<A>f</A>)<M>\cap</M> dom(<A>g</A>) of their domains and
      the images of dom(<A>f</A>)<M>\setminus</M> dom(<A>g</A>) 
      and dom(<A>g</A>)<M>\setminus</M> dom(<A>f</A>) under 
      <A>f</A> and <A>g</A>, respectively, are disjoint. 

      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );
[3,7][8,1,2,6,9][10,5]
gap> g:=PartialPerm( [ 11, 12, 14, 16, 18, 19 ], 
> [ 17, 20, 11, 19, 14, 12 ] );
[16,19,12,20][18,14,11,17]
gap> JoinOfPartialPerms(f, g);
[3,7][8,1,2,6,9][10,5][16,19,12,20][18,14,11,17]
gap> f:=PartialPerm( [ 1, 4, 5, 6, 7 ], [ 5, 7, 3, 1, 4 ] );
[6,1,5,3](4,7)
gap> g:=PartialPerm( [ 100 ], [ 1 ] );
[100,1]
gap> JoinOfPartialPerms(f, g);
fail
gap> f:=PartialPerm( [ 1, 3, 4 ], [ 3, 2, 4 ] );
[1,3,2](4)
gap> g:=PartialPerm( [ 1, 2, 4 ], [ 2, 3, 4 ] );
[1,2,3](4)
gap> JoinOfPartialPerms(f, g);
fail
gap> f:=PartialPerm( [ 1 ], [ 2 ] ); 
[1,2]
gap> JoinOfPartialPerms(f, f^-1);
(1,2)</Example>
    </Description>
  </ManSection>
  
<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="MeetOfPartialPerms" Arg="arg"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      The meet of partial permutations <A>f</A> and <A>g</A> is just the meet,
      or infimum,  of <A>f</A> and <A>g</A> under the natural partial
      ordering of partial permutations. In other words, the meet is the
      greatest partial permuation which is a restriction of both <A>f</A> and
      <A>g</A>. <P/>
      
      Note that unlike the join of partial permutations, the meet always
      exists. <P/>

      <C>MeetOfPartialPerms</C> returns the meet of the partial permutations
      in its argument. The argument <A>arg</A> can be a partial permutation
      collection or a number of partial permutations. 

      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 6, 100000 ], [ 2, 6, 7, 1, 5 ] );
[3,7][100000,5](1,2,6)
gap> g:=PartialPerm( [ 1, 2, 3, 4, 6 ], [ 2, 4, 6, 1, 5 ] );
[3,6,5](1,2,4)
gap> MeetOfPartialPerms(f, g);
[1,2]
gap> g:=PartialPerm( [ 1, 2, 3, 5, 6, 7, 9, 10 ], 
> [ 4, 10, 5, 6, 7, 1, 3, 2 ] );
[9,3,5,6,7,1,4](2,10)
gap> MeetOfPartialPerms(f, g);
&lt;empty partial perm></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Func Name="EmptyPartialPerm" Arg=""/>
    <Returns>The empty partial permutation.</Returns>
    <Description>
      The empty partial permutation is returned by this function when it is
      called with no arguments. This is just short hand for
      <C>PartialPerm([]);</C>. 

      <Example>
gap> EmptyPartialPerm();
&lt;empty partial perm></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection><Heading>RandomPartialPerm</Heading>
    <Oper Name="RandomPartialPerm" Arg="n" Label="for a positive integer"/>
    <Oper Name="RandomPartialPerm" Arg="set" Label="for a set of positive
      integers"/>
    <Oper Name="RandomPartialPerm" Arg="dom, img" Label="for domain and image"/>
    <Returns>A random partial permutation.</Returns>
    <Description>
      In its first form, 
      <C>RandomPartialPerm</C> returns a randomly chosen partial permutation
      where points in the domain and image are bounded above by the
      positive integer <A>n</A>. 
<Log>gap> RandomPartialPerm(10);  
[2,9][4,1,6,5][7,3](8)</Log>

      In its second form, <C>RandomPartialPerm</C> returns a randomly chosen
      partial permutation with points in the domain and image contained in the
      set of positive integers <A>set</A>. 
<Log>gap> RandomPartialPerm([1,2,3,1000]);
[2,3,1000](1)</Log>

      In its third form, <C>RandomPartialPerm</C> creates a randomly chosen
      partial permutation with domain contained in the set of positive integers
      <A>dom</A> and image contained in the set of positive integers
      <A>img</A>. The arguments <A>dom</A> and <A>img</A> do not have to have
      equal length.<P/>

      Note that it is not guarenteed in either of these cases that partial
      permutations are chosen with a uniform distribution. 
 </Description>
  </ManSection>
</Section>

<!-- *************************************************************** -->

<Section Label="sect:AttributesPartialPerms">
  <Heading>Attributes for partial permutations</Heading>
  In this section we describe the functions available in &GAP; for
  finding various attributes of partial permutations.  <P/>

  <ManSection>
    <Attr Name="DegreeOfPartialPerm" Arg="f"/>
    <Attr Name="DegreeOfPartialPermCollection" Arg="coll"/>
    <Returns>A non-negative integer.</Returns>
    <Description>
      The <E>degree</E> of a partial permutation <A>f</A> is the largest
      positive integer where it is defined, i.e. the maximum element in the
      domain of <A>f</A>. <P/>

      The degree a collection of partial permutations <A>coll</A> is the 
      largest degree of any partial permutation in <A>coll</A>. 
      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );
[3,7][8,1,2,6,9][10,5]
gap> DegreeOfPartialPerm(f);
10</Example>
    </Description>
  </ManSection>
  
<!-- *************************************************************** -->

  <ManSection>
    <Attr Name="CodegreeOfPartialPerm" Arg="f"/>
    <Attr Name="CodegreeOfPartialPermCollection" Arg="coll"/>
    <Returns>A non-negative integer.</Returns>
    <Description>
      The <E>codegree</E> of a partial permutation <A>f</A> is the largest
      positive integer in its image. <P/>

      The codegree a collection of partial permutations <A>coll</A> is the 
      largest codegree of any partial permutation in <A>coll</A>. 
      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 8, 10 ], [ 7, 1, 4, 3, 2, 6, 5 ] );
[8,6][10,5,2,1,7](3,4)
gap> CodegreeOfPartialPerm(f);
7</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Attr Name="RankOfPartialPerm" Arg="f"/>
    <Attr Name="RankOfPartialPermCollection" Arg="coll"/>
    <Returns>A non-negative integer.</Returns>
    <Description>
    The <E>rank</E> of a partial permutation <A>f</A> is the size of its
    domain, or equivalently the size of its image set or image list.<P/>

    The rank of a partial permutation collection <A>coll</A> is the size of the
    union of the domains of the elements of <A>coll</A>, or
    equivalently, the total number of points on which the elements of <A>coll</A>
    act. Note that this is value may not the same as the size of the union of
    the images of the elements in <A>coll</A>.

      <Example>
gap> f:=PartialPerm( [ 1, 2, 4, 6, 8, 9 ], [ 7, 10, 1, 9, 4, 2 ] );
[6,9,2,10][8,4,1,7]
gap> RankOfPartialPerm(f);
6</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

<ManSection>
    <Oper Name="DomainOfPartialPerm" Arg="f"/>
    <Oper Name="DomainOfPartialPermCollection" Arg="f"/>
    <Returns>A set of positive integers (maybe empty).</Returns>
    <Description>
      The <E>domain</E> of a partial permutation <A>f</A> is the set of
      positive integers where <A>f</A> is defined. <P/>

      The domain of a partial permutation collection <A>coll</A> is the union of
      the domains of its elements. 

      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );
[3,7][8,1,2,6,9][10,5]
gap> DomainOfPartialPerm(f);
[ 1, 2, 3, 6, 8, 10 ]</Example>
    </Description>
  </ManSection>
 
<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="ImageOfPartialPermCollection" Arg="coll"/>
    <Returns>A set of positive integers (maybe empty).</Returns>
    <Description>
      The <E>image</E> of a partial permutation collection <A>coll</A> is the
      union of the images of its elements. 

      <Example><![CDATA[
gap> S := SymmetricInverseSemigroup(5);                                
<symmetric inverse monoid of degree 5>
gap> ImageOfPartialPermCollection(GeneratorsOfInverseSemigroup(S));
[ 1, 2, 3, 4, 5 ]]]></Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="ImageListOfPartialPerm" Arg="f"/>
    <Returns>The list of images of a partial permutation.</Returns>
    <Description>
      The <E>image list</E> of a partial permutation <A>f</A> is the list of
      images of the elements of the domain <A>f</A> where
      <C>ImageListOfPartialPerm(<A>f</A>)[i]=DomainOfPartialPerm(<A>f</A>)[i]^<A>f</A></C>
      for any <C>i</C> in the range from <C>1</C> to the rank of <A>f</A>.
<Example>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 8, 10 ], [ 7, 1, 4, 3, 2, 6, 5 ] );
[8,6][10,5,2,1,7](3,4)
gap> ImageListOfPartialPerm(f);
[ 7, 1, 4, 3, 2, 6, 5 ]</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Attr Name="ImageSetOfPartialPerm" Arg='f'/>
    <Returns>The image set of a partial permutation.</Returns>
    <Description>
      The <E>image set</E> of a partial permutation <C>f</C> is just the set of
      points in the image list (i.e. the image list after it has been sorted
      into increasing order).
      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 5, 7, 10 ], [ 10, 2, 3, 5, 7, 6 ] );
[1,10,6](2)(3)(5)(7)
gap> ImageSetOfPartialPerm(f);
[ 2, 3, 5, 6, 7, 10 ]</Example>
    </Description>
</ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="FixedPointsOfPartialPerm" Arg="f" Label="for a partial perm"/>
    <Oper Name="FixedPointsOfPartialPerm" Arg="coll" Label="for a partial perm coll"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      <C>FixedPointsOfPartialPerm</C> returns the set of points <C>i</C> in the
      domain of the partial permutation <A>f</A> such that <C>i^<A>f</A>=i</C>.
      <P/>
      
      When the argument is a collection of partial permutations <A>coll</A>,
      <C>FixedPointsOfPartialPerm</C> returns the set of points fixed by every
      element of the collection of partial permutations <A>coll</A>. 
      <Example>
gap> f := PartialPerm( [ 1, 2, 3, 6, 7 ], [ 1, 3, 4, 7, 5 ] );
[2,3,4][6,7,5](1)
gap> FixedPointsOfPartialPerm(f);
[ 1 ]
gap> f := PartialPerm([1 .. 10]);;
gap> FixedPointsOfPartialPerm(f);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</Example>
    </Description>
  </ManSection>
  
  <ManSection>
    <Oper Name="MovedPoints" Arg="f" Label="for a partial perm"/>
    <Oper Name="MovedPoints" Arg="coll" Label="for a partial perm coll"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      <C>MovedPoints</C> returns the set of points <C>i</C> in the domain of
      the partial permutation <A>f</A> such that <C>i^<A>f</A>&lt;>i</C>. <P/>
      
      When the argument is a collection of partial permutations
      <A>coll</A>, <C>MovedPoints</C> returns the set of points moved by some
      element of the collection of partial permutations <A>coll</A>. 
      
      <Example>
gap> f := PartialPerm( [ 1, 2, 3, 4 ], [ 5, 7, 1, 6 ] );
[2,7][3,1,5][4,6]
gap> MovedPoints(f);
[ 1, 2, 3, 4 ]
gap> FixedPointsOfPartialPerm(f);
[  ]
gap> FixedPointsOfPartialPerm(PartialPerm([1 .. 4]));
[ 1, 2, 3, 4 ]</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="NrFixedPoints" Arg="f" Label="for a partial perm"/>
    <Oper Name="NrFixedPoints" Arg="coll" Label="for a partial perm coll"/>
    <Returns>A positive integer.</Returns>
    <Description>
      <C>NrFixedPoints</C> returns the number of points <C>i</C> in the domain
      of the partial permutation <A>f</A> such that <C>i^<A>f</A>=i</C>. <P/>
      
      When the argument is a collection of partial permutations
      <A>coll</A>, <C>NrFixedPoints</C> returns the number of points fixed by
      every element of the collection of partial permutations <A>coll</A>. 
      <Example>
gap> f := PartialPerm( [ 1, 2, 3, 4, 5 ], [ 3, 2, 4, 6, 1 ] );
[5,1,3,4,6](2)
gap> NrFixedPoints(f);
1
gap> NrFixedPoints(PartialPerm([1 .. 10]));
10</Example>
    </Description>
  </ManSection>
  
  <ManSection>
    <Oper Name="NrMovedPoints" Arg="f" Label="for a partial perm"/>
    <Oper Name="NrMovedPoints" Arg="coll" Label="for a partial perm coll"/>
    <Returns>A positive integer.</Returns>
    <Description>
      <C>NrMovedPoints</C> returns the number of points <C>i</C> in the domain
      of the partial permutation <A>f</A> such that <C>i^<A>f</A>&lt;>i</C>.
      <P/>
      
      When the argument is a collection of partial permutations
      <A>coll</A>, <C>NrMovedPoints</C> returns the number of points moved by
      some element of the collection of partial permutations <A>coll</A>. 
      
      <Example>
gap> f := PartialPerm( [ 1, 2, 3, 4, 5, 7, 8 ], [ 4, 5, 6, 7, 1, 3, 2 ] );
[8,2,5,1,4,7,3,6]
gap> NrMovedPoints(f);
7
gap> NrMovedPoints(PartialPerm([1 .. 4]));
0</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

<ManSection>
  <Oper Name="SmallestMovedPoint" Arg="f" Label="for a partial perm"/>
  <Oper Name="SmallestMovedPoint" Arg="coll" Label="for a partial perm coll"/>
  <Returns>A positive integer or <K>infinity</K>.</Returns>
  <Description>
    <C>SmallestMovedPoint</C> returns the smallest  positive integer <C>i</C>
    such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C> exists.  If <A>f</A>
    is an identity partial permutation, then <K>infinity</K> is returned.<P/>

    If the argument is a collection of partial permutations
    <A>coll</A>, then the smallest point which is moved by at least one element
    of <A>coll</A> is returned, if such a point exists.  If <A>coll</A> only
    contains identity partial permutations, then <C>SmallestMovedPoint</C>
    returns <K>infinity</K>.

    <Example>
gap> f := PartialPerm( [ 1, 3 ], [ 4, 3 ] );
[1,4](3)
gap> SmallestMovedPoint(f);
1
gap> SmallestMovedPoint(PartialPerm([1 .. 10]));
infinity</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LargestMovedPoint" Arg="f" Label="for a partial perm"/>
  <Oper Name="LargestMovedPoint" Arg="coll" Label="for a partial perm coll"/>
  <Returns>A positive integer or <K>infinity</K>.</Returns>
  <Description>
     <C>LargestMovedPoint</C> returns the largest positive integers <C>i</C>
    such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C> exists.  If <A>f</A>
    is the identity partial permutation, then <C>0</C> is returned.<P/>

    If the argument is a collection of partial permutations <A>coll</A>, then
    the largest point which is moved by at least one element of <A>coll</A> is
    returned, if such a point exists.  If <A>coll</A> only contains identity
    partial permutations, then <C>LargestMovedPoint</C> returns <C>0</C>. 
    <Example>
gap> f := PartialPerm( [ 1, 3, 4, 5 ], [ 5, 1, 6, 4 ] );
[3,1,5,4,6]
gap> LargestMovedPoint(f);
5
gap> LargestMovedPoint(PartialPerm([1 .. 10]));
0</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="SmallestImageOfMovedPoint" Arg="f" Label="for a partial permutation"/>
  <Oper Name="SmallestImageOfMovedPoint" Arg="coll" 
    Label="for a partial permutation coll"/>
  <Returns>A positive integer or <K>infinity</K>.</Returns>
  <Description>
    <C>SmallestImageOfMovedPoint</C> returns the smallest positive integer
    <C>i^<A>f</A></C> such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C>
    exists.  If <A>f</A> is the identity partial permutation, then
    <K>infinity</K> is returned.<P/>

    If the argument is a collection of partial permutations <A>coll</A>, then
    the smallest integer which is the image a point moved by at least one
    element of <A>coll</A> is returned, if such a point exists.  If <A>coll</A>
    only contains identity partial permutations, then
    <C>SmallestImageOfMovedPoint</C> returns <K>infinity</K>.

  <Example><![CDATA[
gap> S := SymmetricInverseSemigroup(5);
<symmetric inverse monoid of degree 5>
gap> SmallestImageOfMovedPoint(S);
1
gap> S := Semigroup(PartialPerm([10 .. 100], [10 .. 100]));;
gap> SmallestImageOfMovedPoint(S);
infinity
gap> f := PartialPerm( [ 1, 2, 3, 6 ] );
[4,6](1)(2)(3)
gap> SmallestImageOfMovedPoint(f);
6]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Oper Name="LargestImageOfMovedPoint" Arg="f" 
    Label="for a partial permutation"/>
  <Oper Name="LargestImageOfMovedPoint" Arg="coll" 
    Label="for a partial permutation coll"/>
  <Returns>A positive integer.</Returns>
  <Description>
    <C>LargestImageOfMovedPoint</C> returns the largest positive integer
    <C>i^<A>f</A></C> such that <C>i^<A>f</A>&lt;>i</C> if such an <C>i</C>
    exists.  If <A>f</A> is an identity partial permutation, then <C>0</C> is
    returned.<P/>

    If the argument is a collection of partial permutations <A>coll</A>, then
    the largest integer which is the image of a point moved by at least one
    element of <A>coll</A> is returned, if such a point exists.  If <A>coll</A>
    only contains identity partial permutations, then
    <C>LargestImageOfMovedPoint</C> returns <C>0</C>.
  <Example><![CDATA[
gap> S := SymmetricInverseSemigroup(5);
<symmetric inverse monoid of degree 5>
gap> LargestImageOfMovedPoint(S);
5
gap> S := Semigroup(PartialPerm([10 .. 100], [10 .. 100]));;
gap> LargestImageOfMovedPoint(S);
0
gap> f := PartialPerm( [ 1, 2, 3, 6 ] );;
gap> LargestImageOfMovedPoint(f);
6]]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <ManSection> 
    <Attr Name="IndexPeriodOfPartialPerm" Arg="f"/> 
    <Returns>A pair of positive integers.</Returns> 
    <Description> 
      Returns the least positive integers <C>m, r</C> such that 
      <C><A>f</A>^(m+r)=<A>f</A>^m</C>, which are  
      known as the <E>index</E> and <E>period</E> of the partial permutation 
      <A>f</A>. 
      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 5, 6, 7, 8, 11, 12, 16, 19 ], 
> [ 9, 18, 20, 11, 5, 16, 8, 19, 14, 13, 1 ] );
[2,18][3,20][6,5,11,19,1,9][7,16,13][12,14](8)
gap> IndexPeriodOfPartialPerm(f);
[ 6, 1 ]
gap> f^6=f^7;
true</Example>  
    </Description> 
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="SmallestIdempotentPower" Arg="f" Label="for a partial perm"/> 
  <Returns>A positive integer.</Returns> 
  <Description> 
      This function returns the least positive integer <C>n</C> such that the 
      partial permutation <C><A>f</A>^n</C> is an idempotent.  The smallest
      idempotent power of <A>f</A> is the least multiple of the period of
      <A>f</A> that is greater than or equal to the index of <A>f</A>; 
      see <Ref Attr="IndexPeriodOfPartialPerm"/>.

      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 7, 8, 10, 11, 13, 18, 19, 20 ], 
> [ 5, 1, 7, 3, 10, 2, 12, 14, 11, 16, 6, 9, 15 ] );
[4,3,7,2,1,5,10,14][8,12][13,16][18,6][19,9][20,15](11)
gap> SmallestIdempotentPower(f);
8
gap> f^8;
&lt;identity partial perm on [ 11 ]></Example>
    </Description>
  </ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="ComponentsOfPartialPerm" Arg="f" /> 
  <Returns>A list of lists of positive integer.</Returns>
  <Description> 
    <C>ComponentsOfPartialPerm</C> returns a list of the components of the
    partial permutation <A>f</A>.  Each component is a subset of the domain of
    <A>f</A>, and the union of the components equals the domain.

    <Example> 
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 19 ], 
> [ 20, 4, 6, 19, 9, 14, 3, 12, 17, 5, 15, 13 ] );
[1,20][2,4,19,13,15][7,14][8,3,6][10,12,5,9][11,17]
gap> ComponentsOfPartialPerm(f);
[ [ 1, 20 ], [ 2, 4, 19, 13, 15 ], [ 7, 14 ], [ 8, 3, 6 ], 
  [ 10, 12, 5, 9 ], [ 11, 17 ] ]</Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="NrComponentsOfPartialPerm" Arg="f" /> 
  <Returns>A positive integer.</Returns>
  <Description> 
    <C>NrComponentsOfPartialPerm</C>
    returns the number of components of the partial permutation
    <A>f</A> on its domain. 

    <Example> 
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 19 ], 
> [ 20, 4, 6, 19, 9, 14, 3, 12, 17, 5, 15, 13 ] );
[1,20][2,4,19,13,15][7,14][8,3,6][10,12,5,9][11,17]
gap> NrComponentsOfPartialPerm(f);
6</Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="ComponentRepsOfPartialPerm" Arg="f" /> 
  <Returns>A list of positive integers.</Returns>
  <Description> 
      <C>ComponentRepsOfPartialPerm</C> returns the representatives, in the
      following sense, of the components of the partial permutation <A>f</A>.
      Every component of <A>f</A> contains a unique element in the domain but
      not the image of <A>f</A>; this element is called the
      <E>representative</E> of the component. If <C>i</C> is a representative
      of a component of <A>f</A>, then for every <C>j</C><M>\not=</M><C>i</C>
      in the component of <C>i</C>, there exists a positive integer <C>k</C>
      such that <C>i ^ (<A>f</A> ^ k) = j</C>. Unlike transformations, there is
      exactly one representative for every component of <A>f</A>.
      <C>ComponentRepsOfPartialPerm</C> returns the least number of
      representatives. 

    <Example> 
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 19 ], 
> [ 20, 4, 6, 19, 9, 14, 3, 12, 17, 5, 15, 13 ] );
[1,20][2,4,19,13,15][7,14][8,3,6][10,12,5,9][11,17]
gap> ComponentRepsOfPartialPerm(f);
[ 1, 2, 7, 8, 10, 11 ]</Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>  
  <Attr Name="LeftOne" Arg="f" Label="for a partial perm"/> 
  <Attr Name="RightOne" Arg="f" Label="for a partial perm"/> 
  <Returns>A partial permutation.</Returns>
  <Description> 
    <C>LeftOne</C> returns the identity partial permutation
    <C>e</C> such that the domain and image of <C>e</C> equal the domain of
    the partial permutation <A>f</A> and such that <C>e*<A>f</A>=f</C>. <P/>

    <C>RightOne</C> returns the identity partial permutation
    <C>e</C> such that the domain and image of <C>e</C> equal the image of
    <A>f</A> and such that <C><A>f</A>*e=f</C>. 
    
    <Example>
gap> f:=PartialPerm( [ 1, 2, 4, 5, 6, 7 ], [ 10, 1, 6, 5, 8, 7 ] ); 
[2,1,10][4,6,8](5)(7)
gap> RightOne(f);
&lt;identity partial perm on [ 1, 5, 6, 7, 8, 10 ]>
gap> LeftOne(f);
&lt;identity partial perm on [ 1, 2, 4, 5, 6, 7 ]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Meth Name="One" Arg="f" Label="for a partial perm"/>
  <Returns>A partial permutation.</Returns>
  <Description>
    As described in <Ref Attr="OneImmutable" BookName="ref"/>,
    <C>One</C> returns the multiplicative neutral element of the partial
    permutation <A>f</A>, which is the identity partial permutation on the
    union of the domain and image of <A>f</A>. Equivalently, the one of
    <A>f</A> is the join of the right one and left one of <A>f</A>.
    <Example>
gap> f:=PartialPerm([ 1, 2, 3, 4, 5, 7, 10 ], [ 3, 7, 9, 6, 1, 10, 2 ]);;
gap> One(f);
&lt;identity partial perm on [ 1, 2, 3, 4, 5, 6, 7, 9, 10 ]></Example>
  </Description>
</ManSection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<ManSection>
  <Meth Name="Zero" Arg="f" Label="for a partial perm"/>
  <Returns>The empty partial permutation.</Returns>
  <Description>
    As described in <Ref Attr="ZeroImmutable" BookName="ref"/>,
    <C>Zero</C> returns the multiplicative zero element of the partial
    permutation <A>f</A>, which is the empty partial permutation. 
    <Example>
gap> f:=PartialPerm([ 1, 2, 3, 4, 5, 7, 10 ], [ 3, 7, 9, 6, 1, 10, 2 ]);;
gap> Zero(f);
&lt;empty partial perm></Example>
  </Description>
</ManSection>

 <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

</Section>

<!-- *************************************************************** -->

<Section Label="sect:ChangingRepPartialPerms">
  <Heading>Changing the representation of a partial permutation</Heading>
  It is possible that a partial permutation in &GAP; can be represented by other
  types of objects, or that other types of &GAP; objects can be represented by
  partial permutations. Partial permutations which are
  mathematically permutations can be converted into permutations in &GAP; using
  the function <Ref Oper="AsPermutation"/>.  Similarly, a partial permutation
  can be converted into a transformation using <Ref Oper="AsTransformation"/>.
  <P/>
  
  In this section we describe functions for converting other types of objects
  in &GAP; into partial permutations. 
  
  <ManSection>
  <Func Name="AsPartialPerm" Arg="f, set" Label="for a permutation and a set of
    positive integers"/>
  <Func Name="AsPartialPerm" Arg="f" Label="for a permutation"/>
  <Func Name="AsPartialPerm" Arg="f, n" Label="for a permutation and a positive integer"/>
  <Returns>A partial permutation.</Returns>
  <Description>
    A permutation <A>f</A> defines a partial permutation when it is restricted
    to any finite set of positive integers.  <C>AsPartialPerm</C> can be used to
    obtain this partial permutation.<P/>
    
    There are several possible arguments for <C>AsPartialPerm</C>:

    <List>
      <Mark>for a permutation and set of positive integers</Mark>
      <Item><C>AsPartialPerm</C> returns the 
      partial permutation that equals <A>f</A> on the set of positive
      integers <A>set</A> and that is undefined on every other positive integer.
      <P/>
      
      Note that as explained in 
      <Ref Func="PartialPerm" Label="for a domain and image"/> 
      <E>a permutation is never a partial permutation</E> in &GAP;, please
      keep this in mind when using <C>AsPartialPerm</C>.
      </Item>
      <Mark>for a permutation</Mark>
      <Item><C>AsPartialPerm</C> returns the partial permutation that agrees
      with <A>f</A> on <C>[1..LargestMovedPoint(<A>f</A>)]</C> and that is
      not defined on any other positive integer. 
      </Item>
      <Mark>for a permutation and a positive integer</Mark>
      <Item><C>AsPartialPerm</C> returns the partial permutation that agrees
        with <A>f</A> on <C>[1..<A>n</A>]</C>, when <A>n</A> is a positive
        integer,  and that is not defined on any other positive integer. 
      </Item>
    </List>

    The operation <Ref Oper="PartialPermOp"/> can also be used to convert
    permutations into partial permutations.

    <Example>
gap> f:=(2,8,19,9,14,10,20,17,4,13,12,3,5,7,18,16);;
gap> AsPartialPerm(f);
(1)(2,8,19,9,14,10,20,17,4,13,12,3,5,7,18,16)(6)(11)(15)
gap> AsPartialPerm(f, [ 1, 2, 3 ] );
[2,8][3,5](1)</Example>
    </Description>
  </ManSection>
  
<!-- *************************************************************** -->
  
  <ManSection>
    <Func Name="AsPartialPerm" Arg="f, set" Label="for a transformation and a
      set of positive integer"/> 
    <Func Name="AsPartialPerm" Arg="f, n" Label="for a transformation and a
      positive integer"/> 
    <Func Name="AsPartialPerm" Arg="f" Label="for a transformation"/> 
  <Returns>A partial permutation or <K>fail</K>.</Returns>
  <Description>
    A transformation <A>f</A> defines a partial permutation when it is
    restricted to a set of positive integers where it is injective.
    <C>AsPartialPerm</C> can be used to obtain this partial permutation. <P/>

    There are several possible arguments for <C>AsPartialPerm</C>:
    <List>
      <Mark>for a transformation and set of positive integers</Mark>
      <Item>
        <C>AsPartialPerm</C> returns the partial permutation obtained by
        restricting <A>f</A> to the set of positive integers <A>set</A> when:
        <List>
          <Item><A>set</A> contains no elements exceeding the degree of
            <A>f</A>;
          </Item>
          <Item><A>f</A> is injective on <A>set</A>.
          </Item>
        </List>
      </Item>
      <Mark>for a transformation and a positive integer</Mark>
      <Item><C>AsPartialPerm</C> returns the partial permutation that agrees
        with <A>f</A> on <C>[1..<A>n</A>]</C> when <A>A</A> is a positive
        integer and this set satisfies the
        conditions given above.
      </Item>
      <Mark>for a transformation</Mark>
      <Item> 
        Let <C>n</C> denote the degree of <A>f</A>. If 
        <C>n^<A>f</A>=n</C> and <A>f</A> is injective on those <C>i</C> such
        that <C>i^<A>f</A>&lt;>n</C>, then <C>AsPartialPerm</C> returns
        the partial permutation obtained by restricting <A>f</A> to those
        <C>i</C> such that <C>i^<A>f</A>&lt;>n</C>.
      </Item>
    </List>

    <C>AsPartialPerm</C> returns <K>fail</K> if the arguments do not describe a
    partial permutation.<P/>

    The operation <Ref Oper="PartialPermOp"/> can also be used to convert
    transformations into partial permutations.

  <Example>
gap> f:=Transformation( [ 8, 3, 5, 9, 6, 2, 9, 7, 9 ] );;
gap> AsPartialPerm(f);
[1,8,7](2,3,5,6)
gap> AsPartialPerm(f, 3);
[1,8][2,3,5]
gap> AsPartialPerm(f, [ 2 .. 4 ] );
[2,3,5][4,9]
gap> f:=Transformation( [ 2, 10, 2, 4, 4, 7, 6, 9, 10, 1 ] );;
gap> AsPartialPerm(f);
fail</Example>
  </Description>
</ManSection>
</Section>
<!-- *************************************************************** -->
<!-- *************************************************************** -->

<Section Label="sect:OperatorsPartialPerms">
  <Heading>Operators and operations for partial permutations</Heading>
  <List>    
    
    <Mark><C><A>f</A> ^ -1</C></Mark>
    <Item>
      returns the inverse of the partial permutation <A>f</A>.
    </Item>

    <Mark><C><A>i</A> ^ <A>f</A></C></Mark>
    <Item>
      returns the image of the positive integer <A>i</A> under the
      partial permutation <A>f</A> if it is defined and <C>0</C> if it is not.
    </Item>    
    <Mark><C><A>i</A> / <A>f</A></C></Mark>
    <Item>
      returns the preimage of the positive integer <A>i</A> under the
      partial permutation <A>f</A> if it is defined and <C>0</C> if it is not.
      Note that the inverse of <A>f</A> is not calculated to find the
      preimage of <A>i</A>.
    </Item>

    <Mark><C><A>f</A> ^ <A>g</A></C></Mark>
    <Item>
    returns <C><A>g</A>^-1*<A>f</A>*<A>g</A></C> when
     <A>f</A> is a partial permutation and <A>g</A> is a permutation or partial
     permutation; see <Ref Oper="\^"/>. This operation requires
     essentially the same number of steps as multiplying partial permutations,
     which is around one third as many as inverting and multiplying twice. 
   </Item>

     <Mark><C><A>f</A> * <A>g</A></C></Mark>
     <Item>
       returns the composition of <A>f</A> and <A>g</A> when <A>f</A> and
       <A>g</A> are partial permutations or permutations. The product of a
       permutation and a partial permutation is returned as a partial
       permutation. 
     </Item>
   
     <Mark><C><A>f</A> / <A>g</A></C></Mark>
    <Item>
      returns <C><A>f</A>*<A>g</A>^-1</C> when <A>f</A> is a partial
      permutation and
      <A>g</A> is a permutation or partial permutation. 
      This operation requires essentially the same number of steps 
      as multiplying partial permutations, which is
      approximately half that required to first invert <A>g</A> and then take
      the product with <A>f</A>. 
    </Item>
    
    <Mark><C>LQUO(<A>g</A>, <A>f</A>)</C></Mark>
    <Item>
      <Index Key="LQUO" Subkey="for a permutation or partial permutation
        and partial permutation"><C>LQUO</C></Index>
      returns <C><A>g</A>^-1*<A>f</A></C>
      when <A>f</A> is a partial permutation and
      <A>g</A> is a permutation or partial permutation. 
      This operation requires essentially the same number of steps 
      as multiplying partial permutations, which is
      approximately half that required to first invert <A>g</A> and then take
      the product with <A>f</A>. 
    </Item>
    
    <Mark><C><A>f</A> &lt; <A>g</A></C></Mark>
    <Item>
      returns <K>true</K> if the image of <A>f</A> on the range from 1 to the
      degree of <A>f</A> 
      is lexicographically less than the corresponding image for <A>g</A>
      and <K>false</K> if it is not. See <Ref Func="NaturalLeqPartialPerm"/>
      and <Ref Func="ShortLexLeqPartialPerm"/> for additional orders for
      partial permutations. 
    </Item>
    
    <Mark><C><A>f</A> = <A>g</A></C></Mark>
    <Item>
      returns <K>true</K> if the partial permutation <A>f</A> equals the
      partial permutation <A>g</A> and returns <K>false</K> if it does not.
    </Item>
   </List>

<!-- *************************************************************** -->

  <ManSection>
    <Oper Name="PermLeftQuoPartialPerm" Arg='f, g'/>
    <Oper Name="PermLeftQuoPartialPermNC" Arg='f, g'/>
    <Returns>A permutation.</Returns>
    <Description>
      Returns the permutation on the image set of <A>f</A> induced by 
      <C><A>f</A>^-1*<A>g</A></C> when the partial permutations <A>f</A> and 
      <A>g</A> have equal domain and image set. <P/>
      
      <C>PermLeftQuoPartialPerm</C> verifies that <A>f</A> and <A>g</A> have
      equal domains and image sets, and returns an error if they do not. 
      <C>PermLeftQuoPartialPermNC</C> does no checks.
      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 7 ], [ 7, 9, 10, 4, 2, 5 ] );
[1,7,5,2,9][3,10](4)
gap> g:=PartialPerm( [ 1, 2, 3, 4, 5, 7 ], [ 7, 4, 9, 2, 5, 10 ] );
[1,7,10][3,9](2,4)(5)
gap> PermLeftQuoPartialPerm(f, g);
(2,5,10,9,4)</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

<ManSection>
  <Oper Name="PreImagePartialPerm" Arg='f, i'/>
  <Returns>A positive integer or <K>fail</K>.</Returns>
  <Description>
    <C>PreImagePartialPerm</C> returns the preimage of the positive
    integer <A>i</A> under the partial permutation <A>f</A> if 
    <A>i</A> belongs to the image of <A>f</A>. If <A>i</A> does not belong to
    the image of <A>f</A>, then <K>fail</K> is returned. <P/>

    The same result can be obtained by using <C><A>i</A>/<A>f</A></C> as
    described in Section <Ref Sect="sect:OperatorsPartialPerms"/>.

    <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 5, 9, 10 ], [ 5, 10, 7, 8, 9, 1 ] );
[2,10,1,5,8][3,7](9)
gap> PreImagePartialPerm(f, 8);
5
gap> PreImagePartialPerm(f, 5);
1
gap> PreImagePartialPerm(f, 1);
10
gap> PreImagePartialPerm(f, 10);
2
gap> PreImagePartialPerm(f, 2); 
fail</Example>
  </Description>
</ManSection>

<!-- *************************************************************** -->

<ManSection>
  <Oper Name="ComponentPartialPermInt" Arg='f, i'/>
  <Returns>A set of positive integers.</Returns>
  <Description>
    <C>ComponentPartialPermInt</C> returns the elements of the component of
    <A>f</A> containing <A>i</A> that can be obtained by repeatedly applying
    <A>f</A> to <A>i</A>.  
    <Example>
gap> f:=PartialPerm( [ 1, 2, 4, 5, 6, 7, 8, 10, 14, 15, 16, 17, 18 ], 
> [ 11, 4, 14, 16, 15, 3, 20, 8, 17, 19, 1, 6, 12 ] );
[2,4,14,17,6,15,19][5,16,1,11][7,3][10,8,20][18,12]
gap> ComponentPartialPermInt(f, 4);
[ 4, 14, 17, 6, 15, 19 ]
gap> ComponentPartialPermInt(f, 3);
[  ]
gap> ComponentPartialPermInt(f, 10);
[ 10, 8, 20 ]
gap> ComponentPartialPermInt(f, 100);
[  ]</Example>
  </Description>
</ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Func Name="NaturalLeqPartialPerm" Arg="f, g"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      The <E>natural partial order</E> <M>\leq</M> on an inverse semigroup
      <C>S</C> is defined by <C>s</C><M>\leq</M><C>t</C> if there exists an
      idempotent
      <C>e</C> in <C>S</C> such that <C>s=et</C>. Hence if <A>f</A> and
      <A>g</A> are partial permutations, then <A>f</A><M>\leq</M><A>g</A> if
      and only if <A>f</A> is a restriction of <A>g</A>; 
      see <Ref Oper="RestrictedPartialPerm"/>. <P/>
     
      <C>NaturalLeqPartialPerm</C>
      returns <K>true</K> if <A>f</A> is a restriction of <A>g</A> and
      <K>false</K> if it is not. Note that since this is a partial order and
      not a total order, it is possible that <A>f</A> and <A>g</A> are
      incomparable with respect to the natural partial order. 

      <Example>
gap> f:=PartialPerm( 
> [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ], 
> [ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ] );;
gap> g:=RestrictedPartialPerm(f, [ 1, 2, 3, 9, 13, 20 ] );
[1,3,14][2,12]
gap> NaturalLeqPartialPerm(g,f);
true
gap> NaturalLeqPartialPerm(f,g);
false
gap> g:=PartialPerm( [ 1, 2, 3, 4, 5, 8, 10 ], 
> [ 7, 1, 4, 3, 2, 6, 5 ] );;
gap> NaturalLeqPartialPerm(f, g);
false
gap> NaturalLeqPartialPerm(g, f);
false</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

  <ManSection>
    <Func Name="ShortLexLeqPartialPerm" Arg="f, g"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>ShortLexLeqPartialPerm</C> returns <K>true</K> if
      the concatenation of the domain and image list of <A>f</A> is short-lex
      less than the corresponding concatenation for <A>g</A> and <K>false</K>
      otherwise.<P/>  
      
      Note that this is not the natural partial order
      on partial permutation or the same as comparing <A>f</A> and <A>g</A>
      using <C>\&lt;</C>.
      <Example>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 6, 7, 8, 10 ], 
> [ 3, 8, 1, 9, 4, 10, 5, 6 ] );
[2,8,5][7,10,6,4,9](1,3)
gap> g:=PartialPerm( [ 1, 2, 3, 4, 5, 8, 10 ], 
> [ 7, 1, 4, 3, 2, 6, 5 ] );
[8,6][10,5,2,1,7](3,4)
gap> f&lt;g;
true
gap> g&lt;f;
false
gap> ShortLexLeqPartialPerm(f, g);
false
gap> ShortLexLeqPartialPerm(g, f);
true
gap> NaturalLeqPartialPerm(f, g);
false
gap> NaturalLeqPartialPerm(g, f);
false</Example>
    </Description>
  </ManSection>
 
  <ManSection>
    <Func Name="TrimPartialPerm" Arg="f"/>
    <Returns>Nothing.</Returns>
    <Description>
      It can happen that the internal representation of a partial permutation
      uses more memory than necessary. For example, by composing a partial
      permutation with codegree less than 65536 with a partial permutation with
      codegree greater than 65535. It is possible that the resulting partial
      permutation <A>f</A> has its codegree and images stored as
      32-bit integers, while none of its image points exceeds 65536. The
      purpose of this function is to change the internal representation of
      such an <A>f</A> from using 32-bit to using 16-bit integers. <P/>

      Note that the partial permutation <A>f</A> is changed in-place, and
      nothing is returned by this function.

      <Example>
gap> f:=PartialPerm( [ 1, 2 ], [ 3, 4 ] )
> *PartialPerm( [ 3, 5 ], [ 3, 100000 ] );
[1,3]
gap> IsPPerm4Rep(f);
true
gap> TrimPartialPerm(f); f;
[1,3]
gap> IsPPerm4Rep(f);
false</Example>
    </Description>
  </ManSection>

<!-- *************************************************************** -->

</Section>

<!-- *************************************************************** -->

<Section Label="sect:DisplayingPartialPerms">
  <Heading>Displaying partial permutations</Heading>
    It is possible to change the way that &GAP; displays partial permutations
    using the user preferences <C>PartialPermDisplayLimit</C>
    and <C>NotationForPartialPerms</C>;  see Section 
    <Ref Func="UserPreference"/> for more information about user preferences.
    <P/>

    If <C>f</C> is a partial permutation of rank <C>r</C> exceeding the value
    of the user preference <C>PartialPermDisplayLimit</C>, then <C>f</C> is 
    displayed as:
    <Log>&lt;partial perm on r pts with degree m, codegree n&gt;</Log>
    where the degree and codegree are <C>m</C> and <C>n</C>, respectively.
    The idea is to abbreviate the display of partial permutations defined on
    many points. The default value for the <C>PartialPermDisplayLimit</C> is
    <C>100</C>. <P/>

    If the rank of <C>f</C> does not exceed the value of
    <C>PartialPermDisplayLimit</C>, then how <C>f</C> is displayed depends on
    the value of the user preference <C>NotationForPartialPerms</C> except in
    the case that <C>f</C> is the empty partial permutation or an identity  
    partial permutation.  <P/>
  
    There are three possible values for <C>NotationForPartialPerms</C> user
    preference, which are described below.
    <List>
      <Mark>component</Mark>
      <Item> Similar to permutations, and unlike transformations, partial
        permutations can be expressed as products of disjoint permutations and
        chains. 
        A <E>chain</E> is a list <C>c</C> of some length <C>n</C> such
        that:
        <List>
          <Item>
          <C>c[1]</C> is an element of the domain of <A>f</A> but not the
          image
         </Item>
         <Item><C>c[i]^<A>f</A>=c[i+1]</C> for all <C>i</C> in the range from
           <C>1</C> to <C>n-1</C>.
        </Item> 
        <Item><C>c[n]</C> is in the image of <A>f</A> but not the
          domain.</Item>
      </List>
      In the display, permutations are displayed as they usually are in &GAP;,
      except that fixed points are displayed enclosed in round brackets, and
      chains are displayed enclosed in square brackets.

      <Log>
gap> f := PartialPerm([ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ],
> [ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ]);
[1,3,14][16,8,2,12,15](4)(5,11)[6,18,10,9][7,17,20](19)</Log>
      This option is the most compact way to display a partial permutation and
      is the default value of the user preference
      <C>NotationForPartialPerms</C>.
      </Item>
      
      <Mark>domainimage</Mark>
      <Item> 
        With this option a partial permutation <C>f</C> is displayed 
        in the format: <C>DomainOfPartialPerm(<A>f</A>)-> 
          ImageListOfPartialPerm(<A>f</A>)</C>. 
<Log>gap> f:=PartialPerm( [ 1, 2, 4, 5, 6, 7 ], [ 10, 1, 6, 5, 8, 7 ]);
[ 1, 2, 4, 5, 6, 7 ] -> [ 10, 1, 6, 5, 8, 7 ]</Log>
      </Item>
      <Mark>input</Mark>
      <Item>
        With this option a partial permutation <A>f</A> is displayed as:
        <C>PartialPerm(DomainOfPartialPerm(<A>f</A>),
          ImageListOfPartialPerm(<A>f</A>))</C>
        which corresponds to the input (of the first type described in 
        <Ref Func="PartialPerm" Label="for a domain and image"/>).
<Log>gap> f:=PartialPerm( [ 1, 2, 3, 5, 6, 9, 10 ], 
> [ 4, 7, 3, 8, 2, 1, 6 ] );
PartialPerm( [ 1, 2, 3, 5, 6, 9, 10 ], [ 4, 7, 3, 8, 2, 1, 6 ] )</Log>
      </Item>
    </List>
    <Log>
gap> SetUserPreference("PartialPermDisplayLimit", 12);                
gap> UserPreference("PartialPermDisplayLimit");
12
gap> f:=PartialPerm([1,2,3,4,5,6], [6,7,1,4,3,2]);
[5,3,1,6,2,7](4)
gap> f:=PartialPerm( 
> [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ], 
> [ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ] );
&lt;partial perm on 15 pts with degree 19, codegree 20>
gap> SetUserPreference("PartialPermDisplayLimit", 100);
gap> f;
[1,3,14][6,18,10,9][7,17,20][16,8,2,12,15](4)(5,11)(19)
gap> UserPreference("NotationForPartialPerms");
"component"
gap> SetUserPreference("NotationForPartialPerms", "domainimage");
gap> f;
[ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ] -> 
[ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ]
gap> SetUserPreference("NotationForPartialPerms", "input");
gap> f;
PartialPerm( 
[ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ], 
[ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ] )</Log>
</Section>

<Section Label="Partial perm semigroups">
<Heading>Semigroups and inverse semigroups of partial permutations</Heading>

As mentioned at the start of the chapter, every inverse semigroup is isomorphic
to a semigroup of partial permutations, and in this section we describe the
functions in &GAP; specific to partial permutation semigroups. For more information
about semigroups and inverse semigroups see Chapter <Ref Chap="Semigroups"/>. <P/>

The <Package>Semigroups</Package> package contains
many additional functions and methods for computing with semigroups of
partial permutations. In particular, <Package>Semigroups</Package> 
contains more efficient methods than those available in the &GAP; library (and
in many cases more efficient than any other software) for creating semigroups of transformations, calculating their Green's classes, size, elements,
group of units, minimal ideal, small generating sets, testing membership,
finding the inverses of a regular element, factorizing elements over the
generators, and more. <P/>

Since a partial permutation semigroup is also a partial permutation collection, there are special methods for <Ref Attr="DomainOfPartialPermCollection"/>, 
<Ref Attr="ImageOfPartialPermCollection"/>, 
<Ref Attr="FixedPointsOfPartialPerm" Label="for a partial perm coll"/>, 
<Ref Attr="MovedPoints" Label="for a partial perm coll"/>, 
<Ref Attr="NrFixedPoints" Label="for a partial perm coll"/>, 
<Ref Attr="NrMovedPoints" Label="for a partial perm coll"/>,
<Ref Attr="LargestMovedPoint" Label="for a partial perm coll"/>, and 
<Ref Attr="SmallestMovedPoint" Label="for a partial perm coll"/> 
when applied to a partial permutation semigroup. 

<ManSection>
  <Prop Name="IsPartialPermSemigroup" Arg="obj"/>
  <Prop Name="IsPartialPermMonoid" Arg="obj"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description> 
    A <E>partial perm semigroup</E> is simply a semigroup consisting of partial
    permutations, which may or may not be an inverse semigroup. An object
    <A>obj</A> in &GAP; is a partial perm semigroup if and only if it satisfies
    <Ref Prop="IsSemigroup"/> and <Ref Filt="IsPartialPermCollection"/>.<P/>

    A <E>partial perm monoid</E> is a monoid consisting of partial
    permutations. An object in &GAP; is a partial perm monoid if it satisfies 
    <Ref Prop="IsMonoid"/> and <Ref Filt="IsPartialPermCollection"/>.<P/> 

Note that it is possible for a partial perm semigroup to have a
multiplicative neutral element (i.e. an identity element) but not to satisfy
<C>IsPartialPermMonoid</C>. For example,
<Example><![CDATA[
gap> f := PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );;
gap> S := Semigroup(f, One(f));
<commutative partial perm monoid of rank 9 with 1 generator>
gap> IsMonoid(S);
true
gap> IsPartialPermMonoid(S);
true]]></Example>

Note that unlike transformation semigroups, the <Ref Attr="One"/> of a partial permutation semigroup must coincide with the multiplicative neutral element, if either exists.<P/>

For more details see <Ref Filt="IsMagmaWithOne"/>.
  </Description>
</ManSection>

<ManSection>
  <Attr Name="DegreeOfPartialPermSemigroup" Arg="S"/>
  <Attr Name="CodegreeOfPartialPermSemigroup" Arg="S"/>
  <Attr Name="RankOfPartialPermSemigroup" Arg="S"/>
  <Returns>A non-negative integer.</Returns>
  <Description>
    The <E>degree</E> of a partial permutation semigroup <A>S</A> is the 
    largest degree of any partial permutation in <A>S</A>. <P/>

    The <E>codegree</E> of a partial permutation semigroup <A>S</A> is the
    largest positive integer in its image.<P/>

    The <E>rank</E> of a partial permutation semigroup <A>S</A> is the number
    of points on which it acts. 
    <Example><![CDATA[
gap> S := Semigroup( PartialPerm( [ 1, 5 ], [ 10000, 3 ] ) );
<commutative partial perm semigroup of rank 2 with 1 generator>
gap> DegreeOfPartialPermSemigroup(S);
5
gap> CodegreeOfPartialPermSemigroup(S);
10000
gap> RankOfPartialPermSemigroup(S);
2]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="SymmetricInverseSemigroup" Arg="n"/>
  <Oper Name="SymmetricInverseMonoid" Arg="n"/>
  <Returns>The symmetric inverse semigroup of degree <A>n</A>.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, then
    <C>SymmetricInverseSemigroup</C> returns the inverse semigroup consisting
    of all partial permutations with degree and codegree at most <A>n</A>. 
    Note that <A>n</A> must be non-negative, but in particular, can equal
    <C>0</C>.  <P/>
    
    The symmetric inverse semigroup 
    <Alt Not="Text">
      has <M>\sum_{r=0}^n{n\choose r}^2\cdot r!</M>
      elements and </Alt>
    is generated by any set that of partial permutations that
    generate the symmetric group on <A>n</A> points and any partial permutation
    of rank <C><A>n</A>-1</C>.<P/>

    <C>SymmetricInverseMonoid</C> is a synonym for
    <C>SymmetricInverseSemigroup</C>.

    <Example><![CDATA[
gap> S := SymmetricInverseSemigroup(5);
<symmetric inverse monoid of degree 5>
gap> Size(S);
1546
gap> GeneratorsOfInverseMonoid(S);
[ (1,2,3,4,5), (1,2)(3)(4)(5), [5,4,3,2,1] ]]]></Example>
  </Description>
</ManSection>

<ManSection>
<Prop Name="IsSymmetricInverseSemigroup" Arg='S'/>
<Prop Name="IsSymmetricInverseMonoid" Arg='S'/>
<Returns><K>true</K> or <K>false</K>.</Returns>
<Description>
  If the partial perm semigroup <A>S</A> of degree and codegree <A>n</A> 
  equals the symmetric inverse semigroup on <A>n</A> points, then
  <C>IsSymmetricInverseSemigroup</C> return <K>true</K> and otherwise it
  returns <K>false</K>.<P/>

  <C>IsSymmetricInverseMonoid</C> is a synonym of
  <C>IsSymmetricInverseSemigroup</C>. It is common in the literature
  for the symmetric inverse monoid to be referred to as the symmetric inverse
  semigroup.  

  <Example><![CDATA[
gap> S := Semigroup(AsPartialPerm((1, 3, 4, 2), 5), AsPartialPerm((1, 3, 5), 5),
> PartialPerm( [ 1, 2, 3, 4 ] ) );
<partial perm semigroup of rank 5 with 3 generators>
gap> IsSymmetricInverseSemigroup(S);
true
gap> S;
<symmetric inverse monoid of degree 5>]]></Example>
</Description>
</ManSection>

<ManSection>
  <Attr Name="NaturalPartialOrder" Arg="S"/>
  <Attr Name="ReverseNaturalPartialOrder" Arg="S"/>
  <Returns>The natural partial order on an inverse semigroup.</Returns>
  <Description>
    The <E>natural partial order</E> <M>\leq</M> on an inverse semigroup
    <A>S</A> is defined by <C>s</C><M>\leq</M><C>t</C> if there exists an
    idempotent
    <C>e</C> in <A>S</A> such that <C>s=et</C>. Hence if <C>f</C> and
    <C>g</C> are partial permutations, then <C>f</C><M>\leq</M><C>g</C> if
    and only if <C>f</C> is a restriction of <C>g</C>;
    see <Ref Oper="RestrictedPartialPerm"/>.<P/> 

    <C>NaturalPartialOrder</C> returns the natural partial order on the inverse
    semigroup of partial permutations <A>S</A> as a list of sets of positive
    integers where entry <C>i</C> in <C>NaturalPartialOrder(<A>S</A>)</C> is
    the set of positions in <C>Elements(<A>S</A>)</C> of elements which are
    less than <C>Elements(<A>S</A>)[i]</C>. See also 
    <Ref Func="NaturalLeqPartialPerm"/>.<P/>

    <C>ReverseNaturalPartialOrder</C> returns the reverse of the natural
    partial order on the inverse semigroup of partial permutations <A>S</A> as
    a list of sets of
    positive integers where entry <C>i</C> in
    <C>ReverseNaturalPartialOrder(<A>S</A>)</C> is the set of positions in
    <C>Elements(<A>S</A>)</C> of elements which are greater than
    <C>Elements(<A>S</A>)[i]</C>. See also 
    <Ref Func="NaturalLeqPartialPerm"/>.
  
    <Example><![CDATA[
gap> S := InverseSemigroup([ PartialPerm( [ 1, 3 ], [ 1, 3 ] ),
> PartialPerm( [ 1, 2 ], [ 3, 2 ] ) ] );
<inverse partial perm semigroup of rank 3 with 2 generators>
gap> Size(S);
11
gap> NaturalPartialOrder(S);
[ [  ], [ 1 ], [ 1 ], [ 1 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 1 ], [ 1 ], 
  [ 1, 4, 7 ], [ 1, 4, 8 ], [ 1, 2, 8 ] ]
gap> NaturalLeqPartialPerm(Elements(S)[4], Elements(S)[10]);
true
gap> NaturalLeqPartialPerm(Elements(S)[4], Elements(S)[1]); 
false]]></Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="IsomorphismPartialPermMonoid" Arg="S"/>
  <Oper Name="IsomorphismPartialPermSemigroup" Arg="S"/>
  <Returns>An isomorphism.</Returns>
  <Description>
    <C>IsomorphismPartialPermSemigroup(<A>S</A>)</C>
     returns an isomorphism from the inverse semigroup or group <A>S</A> to an
     inverse semigroup of partial permutations.<P/>

     <C>IsomorphismPartialPermMonoid(<A>S</A>)</C> returns an isomorphism from
     the inverse monoid or group <A>S</A> to an inverse monoid of partial
     permutations.<P/> 
     
     We only describe <C>IsomorphismPartialPermMonoid</C>,
     the corresponding statements for <C>IsomorphismPartialPermSemigroup</C>
     also hold.

     <List>
       <Mark>Partial permutation semigroups</Mark>
       <Item>
         If <A>S</A> is a partial permutation semigroup that does not satisfy
         <Ref Prop="IsMonoid" BookName="ref"/> but where
         <C>MultiplicativeNeutralElement(<A>S</A>)&lt;>fail</C>, then
         <C>IsomorphismPartialPermMonoid(<A>S</A>)</C> returns an isomorphism
         from <A>S</A> to an inverse monoid of partial permutations.
       </Item>
       
      <Mark>Permutation groups</Mark>
      <Item>
        If <A>S</A> is a permutation group, then
        <C>IsomorphismPartialPermMonoid</C> returns an isomorphism from
        <A>S</A> to an inverse monoid of partial permutations on the set
        <C>MovedPoints(<A>S</A>)</C> obtained using 
        <Ref Func="AsPartialPerm" Label="for a permutation"/>.
        The inverse of this isomorphism is obtained using 
        <Ref Func="AsPermutation"/>.
      </Item>

      <Mark>Transformation semigroups</Mark>
      <Item>
        If <A>S</A> is a transformation semigroup satisfying 
        <Ref Prop="IsInverseMonoid"/>, then
        <C>IsomorphismPartialPermMonoid</C> returns an isomorphism from
        <A>S</A> to an inverse monoid of partial permutations on a subset of
        <C>[1 .. DegreeOfTransformationSemigroup(<A>S</A>)]</C>.
      </Item>
    </List>
    <Example><![CDATA[
gap> S := InverseSemigroup( 
> PartialPerm( [ 1, 2, 3, 4, 5 ], [ 4, 2, 3, 1, 5 ] ),
> PartialPerm( [ 1, 2, 4, 5 ], [ 3, 1, 4, 2 ] ) );;
gap> IsMonoid(S); 
false
gap> iso := IsomorphismPartialPermMonoid(S);
MappingByFunction( <inverse partial perm semigroup of rank 5 with 2 
 generators>, <inverse partial perm monoid of rank 5 with 2 
 generators>, function( object ) ... end, function( object ) ... end )
gap> Size(S);
508
gap> Size(Range(iso));
508
gap> G := Group((1,2)(3,8)(4,6)(5,7), (1,3,4,7)(2,5,6,8), (1,4)(2,6)(3,7)(5,8));;
gap> IsomorphismPartialPermSemigroup(G);
MappingByFunction( Group([ (1,2)(3,8)(4,6)(5,7), (1,3,4,7)
(2,5,6,8), (1,4)(2,6)(3,7)
(5,8) ]), <inverse partial perm semigroup of rank 8 with 3 generators>
 , function( p ) ... end, function( f ) ... end )
gap> S := Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;
gap> iso := IsomorphismPartialPermMonoid(S);;
gap> MultiplicativeNeutralElement(S) ^ iso;
<identity partial perm on [ 1, 2, 3, 5, 6, 7 ]>
gap> One(Range(iso));
<identity partial perm on [ 1, 2, 3, 5, 6, 7 ]>
gap> MovedPoints(Range(iso));
[ 1, 2, 3, 5, 6 ]]]></Example>
  </Description>
</ManSection>
</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  addmagma.msk               GAP documentation                Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: addmagma.msk,v 1.5 2006/03/10 08:55:52 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Additive Magmas">
<Heading>Additive Magmas</Heading>

This chapter deals with domains that are closed under addition <C>+</C>,
which are called <E>near-additive magmas</E> in &GAP;.
Together with the domains closed under multiplication <C>*</C>
(see&nbsp;<Ref Chap="Magmas"/>),
they are the basic algebraic structures.
In many cases, the addition is commutative
(see&nbsp;<Ref Func="IsAdditivelyCommutative"/>),
the domain is called an <E>additive magma</E> then.
Every module (see&nbsp;<Ref Chap="Modules"/>),
vector space (see&nbsp;<Ref Chap="Vector Spaces"/>),
ring (see&nbsp;<Ref Chap="Rings"/>),
or field (see&nbsp;<Ref Chap="Fields and Division Rings"/>)
is an additive magma.
In the cases of all <E>(near-)additive magma-with-zero</E> or
<E>(near-)additive magma-with-inverses</E>,
additional additive structure is present
(see&nbsp;<Ref Sect="(Near-)Additive Magma Categories"/>).


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="(Near-)Additive Magma Categories">
<Heading>(Near-)Additive Magma Categories</Heading>

<ManSection>
<Filt Name="IsNearAdditiveMagma" Arg='obj' Type='Category'/>

<Description>
A <E>near-additive magma</E> in &GAP; is a domain <M>A</M>
with an associative but not necessarily commutative addition
<C>+</C><M>: A \times A \rightarrow A</M>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearAdditiveMagmaWithZero" Arg='obj' Type='Category'/>

<Description>
A <E>near-additive magma-with-zero</E> in &GAP; is a near-additive magma
<M>A</M> with an operation <C>0*</C> (or <Ref Func="Zero"/>)
that yields the zero element of <M>A</M>.
<P/>
So a near-additive magma-with-zero <A>A</A> does always contain a unique
additively neutral element <M>z</M>,
i.e., <M>z + a = a = a + z</M> holds for all <M>a \in A</M>
(see&nbsp;<Ref Func="AdditiveNeutralElement"/>).
This zero element <M>z</M> can be computed with the operation
<Ref Func="Zero"/>, by applying this function to <M>A</M> or to any
element <M>a</M> in <M>A</M>.
The zero element can be computed also as <C>0 * </C><M>a</M>,
for any <M>a</M> in <M>A</M>.
<P/>
<E>Note</E> that it may happen that
a near-additive magma containing a zero does <E>not</E> lie in the
category <Ref Func="IsNearAdditiveMagmaWithZero"/>
(see&nbsp;<Ref Sect="Domain Categories"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsNearAdditiveGroup" Arg='obj' Type='Category'/>
<Filt Name="IsNearAdditiveMagmaWithInverses" Arg='obj' Type='Category'/>

<Description>
A <E>near-additive group</E> in &GAP; is a near-additive magma-with-zero
<M>A</M> with an operation <C>-1*</C><M>: A \rightarrow A</M> that maps
each element <M>a</M> of <M>A</M> to its additive inverse
<C>-1*</C><M>a</M> (or <C>AdditiveInverse( </C><A>a</A><C> )</C>,
see&nbsp;<Ref Func="AdditiveInverse"/>).
<P/>
The addition <C>+</C> of <M>A</M> is assumed to be associative,
so a near-additive group is not more than a
<E>near-additive magma-with-inverses</E>.
<Ref Func="IsNearAdditiveMagmaWithInverses"/> is just a synonym for
<Ref Func="IsNearAdditiveGroup"/>,
and can be used alternatively in all function names involving the string
<C>"NearAdditiveGroup"</C>.
<P/>
Note that not every trivial near-additive magma is a near-additive
magma-with-zero,
but every trivial near-additive magma-with-zero is a near-additive group.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditiveMagma" Arg='obj' Type='Category'/>

<Description>
An <E>additive magma</E> in &GAP; is a domain <M>A</M> with an
associative and commutative addition
<C>+</C><M>: A \times A \rightarrow A</M>,
see&nbsp;<Ref Func="IsNearAdditiveMagma"/> and
<Ref Func="IsAdditivelyCommutative"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditiveMagmaWithZero" Arg='obj' Type='Category'/>

<Description>
An <E>additive magma-with-zero</E> in &GAP; is an additive magma <M>A</M>
(see <Ref Func="IsAdditiveMagma"/> with an operation <C>0*</C>
(or <Ref Func="Zero"/>) that yields the zero of <M>A</M>.
<P/>
So an additive magma-with-zero <M>A</M> does always contain a unique
additively neutral element <M>z</M>, i.e.,
<M>z + a = a = a + z</M> holds for all <M>a \in A</M>
(see&nbsp;<Ref Func="AdditiveNeutralElement"/>).
This element <M>z</M> can be computed with the operation
<Ref Func="Zero"/> as <C>Zero( </C><M>A</M><C> )</C>,
and <M>z</M> is also equal to <C>Zero( </C><M>a</M><C> )</C> and to
<C>0*</C><M>a</M> for each element <M>a</M> in <M>A</M>.
<P/>
<E>Note</E> that it may happen that
an additive magma containing a zero does <E>not</E> lie in the category
<Ref Func="IsAdditiveMagmaWithZero"/>
(see&nbsp;<Ref Sect="Domain Categories"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAdditiveGroup" Arg='obj' Type='Category'/>
<Filt Name="IsAdditiveMagmaWithInverses" Arg='obj' Type='Category'/>

<Description>
An <E>additive group</E> in &GAP; is an additive magma-with-zero <M>A</M>
with an operation <C>-1*</C><M>: A \rightarrow A</M> that maps
each element <M>a</M> of <M>A</M> to its additive inverse
<C>-1*</C><M>a</M> (or <C>AdditiveInverse( </C><M>a</M><C> )</C>,
see&nbsp;<Ref Func="AdditiveInverse"/>).
<P/>
The addition <C>+</C> of <M>A</M> is assumed to be commutative and
associative, so an additive group is not more than an
<E>additive magma-with-inverses</E>.
<Ref Func="IsAdditiveMagmaWithInverses"/> is just a synonym for
<Ref Func="IsAdditiveGroup"/>,
and can be used alternatively in all function names involving the string
<C>"AdditiveGroup"</C>.
<P/>
Note that not every trivial additive magma is an additive
magma-with-zero,
but every trivial additive magma-with-zero is an additive group.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="(Near-)Additive Magma Generation">
<Heading>(Near-)Additive Magma Generation</Heading>

This section describes
functions that create additive magmas from generators
(see <Ref Func="NearAdditiveMagma"/>,
<Ref Func="NearAdditiveMagmaWithZero"/>,
<Ref Func="NearAdditiveGroup"/>),
the underlying operations for which methods can be installed
(see <Ref Func="NearAdditiveMagmaByGenerators"/>,
<Ref Func="NearAdditiveMagmaWithZeroByGenerators"/>,
<Ref Func="NearAdditiveGroupByGenerators"/>)
and functions for forming additive submagmas
(see <Ref Func="SubnearAdditiveMagma"/>,
<Ref Func="SubnearAdditiveMagmaWithZero"/>,
<Ref Func="SubnearAdditiveGroup"/>).

<ManSection>
<Func Name="NearAdditiveMagma" Arg='[Fam, ]gens'/>

<Description>
returns the (near-)additive magma <M>A</M> that is generated by the
elements in the list <A>gens</A>, that is,
the closure of <A>gens</A> under addition <C>+</C>.
The family <A>Fam</A> of <M>A</M> can be entered as first argument;
this is obligatory if <A>gens</A> is empty
(and hence also <M>A</M> is empty).
</Description>
</ManSection>

<ManSection>
<Func Name="NearAdditiveMagmaWithZero" Arg='[Fam, ]gens'/>

<Description>
returns the (near-)additive magma-with-zero <M>A</M> that is generated by
the elements in the list <A>gens</A>, that is,
the closure of <A>gens</A> under addition <C>+</C> and
<Ref Func="Zero"/>.
The family <A>Fam</A> of <M>A</M> can be entered as first argument;
this is obligatory if <A>gens</A> is empty
(and hence <M>A</M> is trivial).
</Description>
</ManSection>

<ManSection>
<Func Name="NearAdditiveGroup" Arg='[Fam, ]gens'/>

<Description>
returns the (near-)additive group <M>A</M> that is generated by
the elements in the list <A>gens</A>, that is,
the closure of <A>gens</A> under addition <C>+</C>, <Ref Func="Zero"/>,
and <Ref Func="AdditiveInverse"/>.
The family <A>Fam</A> of <M>A</M> can be entered as first argument;
this is obligatory if <A>gens</A> is empty
(and hence <M>A</M> is trivial).
</Description>
</ManSection>

<ManSection>
<Oper Name="NearAdditiveMagmaByGenerators" Arg='[Fam, ]gens'/>

<Description>
An underlying operation for <Ref Func="NearAdditiveMagma"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="NearAdditiveMagmaWithZeroByGenerators" Arg='[Fam, ]gens'/>

<Description>
An underlying operation for <Ref Func="NearAdditiveMagmaWithZero"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="NearAdditiveGroupByGenerators" Arg='[Fam, ]gens'/>

<Description>
An underlying operation for <Ref Func="NearAdditiveGroup"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="SubnearAdditiveMagma" Arg='D, gens'/>
<Func Name="SubadditiveMagma" Arg='D, gens'/>
<Func Name="SubnearAdditiveMagmaNC" Arg='D, gens'/>
<Func Name="SubadditiveMagmaNC" Arg='D, gens'/>

<Description>
<Ref Func="SubnearAdditiveMagma"/> returns the near-additive magma
generated by the elements in the list <A>gens</A>,
with parent the domain <A>D</A>.
<Ref Func="SubnearAdditiveMagmaNC"/> does the same, except that it
does not check whether the elements of <A>gens</A> lie in <A>D</A>.
<P/>
<Ref Func="SubadditiveMagma"/> and <Ref Func="SubadditiveMagmaNC"/>
are just synonyms of these functions.
</Description>
</ManSection>

<ManSection>
<Func Name="SubnearAdditiveMagmaWithZero" Arg='D, gens'/>
<Func Name="SubadditiveMagmaWithZero" Arg='D, gens'/>
<Func Name="SubnearAdditiveMagmaWithZeroNC" Arg='D, gens'/>
<Func Name="SubadditiveMagmaWithZeroNC" Arg='D, gens'/>

<Description>
<Ref Func="SubnearAdditiveMagmaWithZero"/> returns the near-additive
magma-with-zero generated by the elements in the list <A>gens</A>,
with parent the domain <A>D</A>.
<Ref Func="SubnearAdditiveMagmaWithZeroNC"/> does the same, except that
it does not check whether the elements of <A>gens</A> lie in <A>D</A>.
<P/>
<Ref Func="SubadditiveMagmaWithZero"/> and
<Ref Func="SubadditiveMagmaWithZeroNC"/>
are just synonyms of these functions.
</Description>
</ManSection>

<ManSection>
<Func Name="SubnearAdditiveGroup" Arg='D, gens'/>
<Func Name="SubadditiveGroup" Arg='D, gens'/>
<Func Name="SubnearAdditiveGroupNC" Arg='D, gens'/>
<Func Name="SubadditiveGroupNC" Arg='D, gens'/>

<Description>
<Ref Func="SubnearAdditiveGroup"/> returns the near-additive group
generated by the elements in the list <A>gens</A>,
with parent the domain <A>D</A>.
<Ref Func="SubadditiveGroupNC"/> does the same, except that it does not
check whether the elements of <A>gens</A> lie in <A>D</A>.
<P/>
<Ref Func="SubadditiveGroup"/> and <Ref Func="SubadditiveGroupNC"/>
are just synonyms of these functions.
</Description>
</ManSection>


<!-- %The following functions can be used to regard a collection as an additive -->
<!-- %magma. -->
<!-- % -->
<!-- %Declaration{AsAdditiveMagma} -->
<!-- %Declaration{AsSubadditiveMagma} -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties for (Near-)Additive Magmas">
<Heading>Attributes and Properties for (Near-)Additive Magmas</Heading>

<ManSection>
<Prop Name="IsAdditivelyCommutative" Arg='A'/>

<Description>
A near-additive magma <A>A</A> in &GAP; is <E>additively commutative</E>
if for all elements <M>a, b \in <A>A</A></M> the equality
<M>a + b = b + a</M> holds.
<P/>
Note that the commutativity of the <E>multiplication</E> <C>*</C> in a
multiplicative structure can be tested with <Ref Func="IsCommutative"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfNearAdditiveMagma" Arg='A'/>
<Attr Name="GeneratorsOfAdditiveMagma" Arg='A'/>

<Description>
is a list of elements of the near-additive magma <A>A</A>
that generates <A>A</A> as a near-additive magma,
that is, the closure of this list under addition is <A>A</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfNearAdditiveMagmaWithZero" Arg='A'/>
<Attr Name="GeneratorsOfAdditiveMagmaWithZero" Arg='A'/>

<Description>
is a list of elements of the near-additive magma-with-zero
<A>A</A> that generates <A>A</A> as a near-additive magma-with-zero,
that is,
the closure of this list under addition and <Ref Func="Zero"/>
is <A>A</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfNearAdditiveGroup" Arg='A'/>
<Attr Name="GeneratorsOfAdditiveGroup" Arg='A'/>

<Description>
is a list of elements of the near-additive group <A>A</A>
that generates <A>A</A> as a near-additive group,
that is, the closure of this list under addition,
taking the zero element, and taking additive inverses
(see&nbsp;<Ref Func="AdditiveInverse"/>) is <A>A</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="AdditiveNeutralElement" Arg='A'/>

<Description>
returns the element <M>z</M> in the near-additive magma <A>A</A>
with the property that <M>z + a = a = a + z</M> holds for all
<M>a \in</M> <A>A</A>, if such an element exists.
Otherwise <K>fail</K> is returned.
<P/>
A near-additive magma that is not a near-additive magma-with-zero
can have an additive neutral element <M>z</M>;
in this case, <M>z</M> <E>cannot</E> be obtained as
<C>Zero( <A>A</A> )</C> or as <C>0*</C><M>a</M>
for an element <M>a</M> in <A>A</A>, see&nbsp;<Ref Func="Zero"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="TrivialSubnearAdditiveMagmaWithZero" Arg='A'/>

<Description>
is the additive magma-with-zero that has the zero of
the near-additive magma-with-zero <A>A</A> as its only element.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for (Near-)Additive Magmas">
<Heading>Operations for (Near-)Additive Magmas</Heading>

<ManSection>
<Heading>ClosureNearAdditiveGroup</Heading>
<Oper Name="ClosureNearAdditiveGroup" Arg='A, a'
 Label="for a near-additive group and an element"/>
<Oper Name="ClosureNearAdditiveGroup" Arg='A, B'
 Label="for two near-additive groups"/>

<Description>
returns the closure of the near-additive magma <A>A</A> with the element
<A>a</A> or with the near-additive magma <A>B</A>, w.r.t.&nbsp;addition,
taking the zero element, and taking additive inverses.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowAdditionTable" Arg='R'/>
<Func Name="ShowMultiplicationTable" Arg='M'/>

<Description>
For a structure <A>R</A> with an addition given by <C>+</C>,
respectively a structure <A>M</A> with a multiplication given by <C>*</C>,
this command displays the addition (multiplication) table of the structure
in a pretty way.
<Example><![CDATA[
gap> ShowAdditionTable(GF(4));
+        | 0*Z(2)   Z(2)^0   Z(2^2)   Z(2^2)^2
---------+------------------------------------
0*Z(2)   | 0*Z(2)   Z(2)^0   Z(2^2)   Z(2^2)^2
Z(2)^0   | Z(2)^0   0*Z(2)   Z(2^2)^2 Z(2^2)  
Z(2^2)   | Z(2^2)   Z(2^2)^2 0*Z(2)   Z(2)^0  
Z(2^2)^2 | Z(2^2)^2 Z(2^2)   Z(2)^0   0*Z(2)  

gap> ShowMultiplicationTable(GF(4));             
*        | 0*Z(2)   Z(2)^0   Z(2^2)   Z(2^2)^2
---------+------------------------------------
0*Z(2)   | 0*Z(2)   0*Z(2)   0*Z(2)   0*Z(2)  
Z(2)^0   | 0*Z(2)   Z(2)^0   Z(2^2)   Z(2^2)^2
Z(2^2)   | 0*Z(2)   Z(2^2)   Z(2^2)^2 Z(2)^0  
Z(2^2)^2 | 0*Z(2)   Z(2^2)^2 Z(2)^0   Z(2^2)  

]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  rings.msk                    GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: rings.msk,v 1.21 2005/03/07 10:25:16 stefan Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Rings">
<Heading>Rings</Heading>

This chapter deals with domains that are additive groups
(see <Ref Func="IsAdditiveGroup"/> closed under multiplication <C>*</C>.
Such a domain, if <C>*</C> and <C>+</C> are distributive,
is called a <E>ring</E> in &GAP;.
Each division ring, field (see&nbsp;<Ref Chap="Fields and Division Rings"/>),
or algebra (see&nbsp;<Ref Chap="Algebras"/>) is a ring.
Important examples of rings are the integers (see&nbsp;<Ref Chap="Integers"/>)
and matrix rings.
<!-- %(see&nbsp;<Ref Chap="???"/>). -->
<!-- % residue class rings ? -->
<P/>
In the case of a <E>ring-with-one</E>, additional multiplicative structure is
present, see&nbsp;<Ref Func="IsRingWithOne"/>. There is a little support in &GAP;
for rings that have no additional structure: it is possible to perform some
computations for small finite rings; infinite rings are handled by &GAP; in 
an acceptable way in the case that they are algebras. 
<P/>
Also, the <Package>SONATA</Package> package provides support for near-rings,
and a related functionality for multiplicative semigroups of near-rings is
available in the <Package>Smallsemi</Package> package.
<P/>
Several functions for ring elements,
such as <Ref Func="IsPrime"/> and <Ref Func="Factors"/>,
are defined only relative to a ring <A>R</A>,
which can be entered as an optional argument;
if <A>R</A> is omitted then a <E>default ring</E> is formed
from the ring elements given as arguments,
see&nbsp;<Ref Func="DefaultRing" Label="for ring elements"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Generating Rings">
<Heading>Generating Rings</Heading>

<ManSection>
<Prop Name="IsRing" Arg='R'/>

<Description>
A <E>ring</E> in &GAP; is an additive group
(see&nbsp;<Ref Func="IsAdditiveGroup"/>)
that is also a magma (see&nbsp;<Ref Func="IsMagma"/>),
such that addition <C>+</C> and multiplication <C>*</C> are distributive,
see <Ref Func="IsDistributive"/>.
<P/>
The multiplication need <E>not</E> be associative
(see&nbsp;<Ref Func="IsAssociative"/>).
For example, a Lie algebra (see&nbsp;<Ref Chap="Lie Algebras"/>)
is regarded as a ring in &GAP;.
</Description>
</ManSection>

<ManSection>
<Heading>Ring</Heading>
<Func Name="Ring" Arg='r, s, ...' Label="for ring elements"/>
<Func Name="Ring" Arg='coll' Label="for a collection"/>

<Description>
In the first form <Ref Func="Ring" Label="for ring elements"/>
returns the smallest ring that contains all the elements
<A>r</A>, <A>s</A>, <M>\ldots</M>
In the second form <Ref Func="Ring" Label="for a collection"/> returns
the smallest ring that contains all the elements in the collection
<A>coll</A>.
If any element is not an element of a ring or if the elements lie in no
common ring an error is raised.
<P/>
<Ref Func="Ring" Label="for ring elements"/> differs from
<Ref Func="DefaultRing" Label="for ring elements"/> in that it returns
the smallest ring in which the elements lie,
while <Ref Func="DefaultRing" Label="for ring elements"/>
may return a larger ring if that makes sense.
<Example><![CDATA[
gap> Ring( 2, E(4) );
<ring with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>DefaultRing</Heading>
<Func Name="DefaultRing" Arg='r, s, ...' Label="for ring elements"/>
<Func Name="DefaultRing" Arg='coll' Label="for a collection"/>

<Description>
In the first form <Ref Func="DefaultRing" Label="for ring elements"/>
returns a ring that contains all the elements <A>r</A>, <A>s</A>,
<M>\ldots</M> etc.
In the second form <Ref Func="DefaultRing" Label="for a collection"/>
returns a ring that contains all the elements in the collection
<A>coll</A>.
If any element is not an element of a ring or if the elements lie in no
common ring an error is raised.
<P/>
The ring returned by <Ref Func="DefaultRing" Label="for ring elements"/>
need not be the smallest ring in which the elements lie.
For example for elements from cyclotomic fields,
<Ref Func="DefaultRing" Label="for ring elements"/> may return the ring
of integers of the smallest cyclotomic field in which the elements lie,
which need not be the smallest ring overall,
because the elements may in fact lie in a smaller number field
which is itself not a cyclotomic field.
<P/>
(For the exact definition of the default ring of a certain type of
elements, look at the corresponding method installation.)
<P/>
<Ref Func="DefaultRing" Label="for ring elements"/> is used
by ring functions such as <Ref Func="Quotient"/>, <Ref Func="IsPrime"/>,
<Ref Func="Factors"/>,
or <Ref Func="Gcd" Label="for (a ring and) several elements"/>
if no explicit ring is given.
<P/>
<Ref Func="Ring" Label="for ring elements"/> differs from
<Ref Func="DefaultRing" Label="for ring elements"/> in that it returns
the smallest ring in which the elements lie,
while <Ref Func="DefaultRing" Label="for ring elements"/> may return
a larger ring if that makes sense.
<P/>
<Example><![CDATA[
gap> DefaultRing( 2, E(4) );
GaussianIntegers
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RingByGenerators" Arg='C'/>

<Description>
<Ref Func="RingByGenerators"/> returns the ring generated by the elements
in the collection <A>C</A>,
i.&nbsp;e., the closure of <A>C</A> under addition, multiplication,
and taking additive inverses.
<Example><![CDATA[
gap> RingByGenerators([ 2, E(4) ]);
<ring with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DefaultRingByGenerators" Arg='coll'/>

<Description>
For a collection <A>coll</A>, returns a default ring in which
<A>coll</A> is contained.
<Example><![CDATA[
gap> DefaultRingByGenerators([ 2, E(4) ]);
GaussianIntegers
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfRing" Arg='R'/>

<Description>
<Ref Func="GeneratorsOfRing"/> returns a list of elements such that the
ring <A>R</A> is the closure of these elements under addition,
multiplication, and taking additive inverses.
<Example><![CDATA[
gap> R:=Ring( 2, 1/2 );
<ring with 2 generators>
gap> GeneratorsOfRing( R );
[ 2, 1/2 ]
]]></Example>
</Description>
</ManSection>

<!-- %W <ManSection>
<Attr Name="AsRing" Arg='C'/>

<Description>
If the elements in the collection <A>C</A> form a ring then
<Ref Func="AsRing"/> returns this ring,
otherwise <K>fail</K> is returned.
</Description>
</ManSection>
 -->
<ManSection>
<Func Name="Subring" Arg='R, gens'/>
<Func Name="SubringNC" Arg='R, gens'/>

<Description>
returns the ring with parent <A>R</A> generated by the elements in
<A>gens</A>.
When the second form, <Ref Func="SubringNC"/> is used,
it is <E>not</E> checked whether all elements in <A>gens</A> lie in
<A>R</A>. 
<P/>
<Example><![CDATA[
gap> R:= Integers;
Integers
gap> S:= Subring( R, [ 4, 6 ] );
<ring with 1 generators>
gap> Parent( S );
Integers
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>ClosureRing</Heading>
<Oper Name="ClosureRing" Arg='R, r'
 Label="for a ring and a ring element"/>
<Oper Name="ClosureRing" Arg='R, S' Label="for two rings"/>

<Description>
For a ring <A>R</A> and either an element <A>r</A> of its elements family
or a ring <A>S</A>,
<Ref Func="ClosureRing" Label="for a ring and a ring element"/>
returns the ring generated by both arguments.
<P/>
<Example><![CDATA[
gap> ClosureRing( Integers, E(4) );
<ring-with-one, with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Quotient" Arg='[R, ]r, s'/>

<Description>
<Ref Oper="Quotient"/> returns the quotient of the two ring elements
<A>r</A> and <A>s</A> in the ring <A>R</A>, if given,
and otherwise in their default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
It returns <K>fail</K> if the quotient does not exist in the respective
ring.
<P/>
(To perform the division in the quotient field of a ring, use the
quotient operator <C>/</C>.)
<Example><![CDATA[
gap> Quotient( 2, 3 );
fail
gap> Quotient( 6, 3 );
2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Ideals of Rings">
<Heading>Ideals of Rings</Heading>

A <E>left ideal</E> in a ring <M>R</M> is a subring of <M>R</M> that
is closed under multiplication with elements of <M>R</M> from the left.
<P/>
A <E>right ideal</E> in a ring <M>R</M> is a subring of <M>R</M> that
is closed under multiplication with elements of <M>R</M> from the right.
<P/>
A <E>two-sided ideal</E> or simply <E>ideal</E> in a ring <M>R</M>
is both a left ideal and a right ideal in <M>R</M>.
<P/>
So being a (left/right/two-sided) ideal is not a property of a domain
but refers to the acting ring(s).
Hence we must ask, e.&nbsp;g., <C>IsIdeal( </C><M>R, I</M><C> )</C> if we
want to know whether the ring <M>I</M> is an ideal in the ring <M>R</M>.
The property <Ref Func="IsTwoSidedIdealInParent"/> can be used to store
whether a ring is an ideal in its parent.
<P/>
(Whenever the term <C>"Ideal"</C> occurs in an identifier without a
specifying prefix <C>"Left"</C> or <C>"Right"</C>,
this means the same as <C>"TwoSidedIdeal"</C>.
Conversely, any occurrence of <C>"TwoSidedIdeal"</C> can be substituted
by <C>"Ideal"</C>.)
<P/>
For any of the above kinds of ideals, there is a notion of generators,
namely <Ref Func="GeneratorsOfLeftIdeal"/>,
<Ref Func="GeneratorsOfRightIdeal"/>, and
<Ref Func="GeneratorsOfTwoSidedIdeal"/>.
The acting rings can be accessed as <Ref Func="LeftActingRingOfIdeal"/>
and <Ref Func="RightActingRingOfIdeal"/>, respectively.
Note that ideals are detected from known values of these attributes,
especially it is assumed that whenever a domain has both a left and a
right acting ring then these two are equal.
<P/>
Note that we cannot use <Ref Func="LeftActingDomain"/> and
<C>RightActingDomain</C> here,
since ideals in algebras are themselves vector spaces, and such a space
can of course also be a module for an action from the right.
In order to make the usual vector space functionality automatically
available for ideals, we have to distinguish the left and right module
structure from the additional closure properties of the ideal.
<P/>
Further note that the attributes denoting ideal generators and acting
ring are used to create ideals if this is explicitly wanted, but the
ideal relation in the sense of <Ref Func="IsTwoSidedIdeal"/> is of course
independent of the presence of the attribute values.
<P/>
Ideals are constructed with <Ref Func="LeftIdeal"/>,
<Ref Func="RightIdeal"/>, <Ref Func="TwoSidedIdeal"/>.
Principal ideals of the form <M>x * R</M>, <M>R * x</M>, <M>R * x * R</M>
can also be constructed with a simple multiplication.
<P/>
Currently many methods for dealing with ideals need linear algebra to
work, so they are mainly applicable to ideals in algebras.
<P/>

<ManSection>
<Func Name="TwoSidedIdeal" Arg='R, gens[, "basis"]'/>
<Func Name="Ideal" Arg='R, gens[, "basis"]'/>
<Func Name="LeftIdeal" Arg='R, gens[, "basis"]'/>
<Func Name="RightIdeal" Arg='R, gens[, "basis"]'/>

<Description>
Let <A>R</A> be a ring, and <A>gens</A> a list of collection of elements
in <A>R</A>.
<Ref Func="TwoSidedIdeal"/>, <Ref Func="LeftIdeal"/>,
and <Ref Func="RightIdeal"/> return the two-sided,
left, or right ideal, respectively,
<M>I</M> in <A>R</A> that is generated by <A>gens</A>.
The ring <A>R</A> can be accessed as <Ref Func="LeftActingRingOfIdeal"/>
or <Ref Func="RightActingRingOfIdeal"/> (or both) of <M>I</M>.
<P/>
If <A>R</A> is a left <M>F</M>-module then also <M>I</M> is a left
<M>F</M>-module,
in particular the <Ref Func="LeftActingDomain"/> values of
<A>R</A> and <M>I</M> are equal.
<P/>
If the optional argument <C>"basis"</C> is given then <A>gens</A> are
assumed to be a list of basis vectors of
<M>I</M> viewed as a free <M>F</M>-module.
(This is mainly applicable to ideals in algebras.)
In this case, it is <E>not</E> checked whether <A>gens</A> really is
linearly independent and whether <A>gens</A> is a subset of <A>R</A>.
<P/>
<Ref Func="Ideal"/> is simply a synonym of <Ref Func="TwoSidedIdeal"/>.
<P/>
<Example><![CDATA[
gap> R:= Integers;;
gap> I:= Ideal( R, [ 2 ] );
<two-sided ideal in Integers, (1 generators)>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TwoSidedIdealNC" Arg='R, gens[, "basis"]'/>
<Func Name="IdealNC" Arg='R, gens[, "basis"]'/>
<Func Name="LeftIdealNC" Arg='R, gens[, "basis"]'/>
<Func Name="RightIdealNC" Arg='R, gens[, "basis"]'/>

<Description>
The effects of <Ref Func="TwoSidedIdealNC"/>, <Ref Func="LeftIdealNC"/>,
and <Ref Func="RightIdealNC"/> are the same as
<Ref Func="TwoSidedIdeal"/>, <Ref Func="LeftIdeal"/>,
and <Ref Func="RightIdeal"/>, respectively,
but they do not check whether all entries of <A>gens</A> lie in <A>R</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsTwoSidedIdeal" Arg='R, I'/>
<Oper Name="IsLeftIdeal" Arg='R, I'/>
<Oper Name="IsRightIdeal" Arg='R, I'/>
<Prop Name="IsTwoSidedIdealInParent" Arg='I'/>
<Prop Name="IsLeftIdealInParent" Arg='I'/>
<Prop Name="IsRightIdealInParent" Arg='I'/>

<Description>
The properties <Ref Func="IsTwoSidedIdealInParent"/> etc., are attributes
of the ideal, and once known they are stored in the ideal.
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 3 );
( Rationals^[ 3, 3 ] )
gap> I:= Ideal( A, [ Random( A ) ] );
<two-sided ideal in ( Rationals^[ 3, 3 ] ), (1 generators)>
gap> IsTwoSidedIdeal( A, I );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TwoSidedIdealByGenerators" Arg='R, gens'/>
<Oper Name="IdealByGenerators" Arg='R, gens'/>

<Description>
<Ref Func="TwoSidedIdealByGenerators"/> returns the ring that is
generated by the elements of the collection <A>gens</A> under addition,
multiplication, and multiplication with elements of the ring <A>R</A>
from the left and from the right.
<P/>
<A>R</A> can be accessed by <Ref Func="LeftActingRingOfIdeal"/> or
<Ref Func="RightActingRingOfIdeal"/>,
<A>gens</A> can be accessed by <Ref Func="GeneratorsOfTwoSidedIdeal"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LeftIdealByGenerators" Arg='R, gens'/>

<Description>
<Ref Func="LeftIdealByGenerators"/> returns the ring that is generated by
the elements of the collection <A>gens</A> under addition,
multiplication, and multiplication with elements of the ring <A>R</A>
from the left.
<P/>
<A>R</A> can be accessed by <Ref Func="LeftActingRingOfIdeal"/>,
<A>gens</A> can be accessed by <Ref Func="GeneratorsOfLeftIdeal"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="RightIdealByGenerators" Arg='R, gens'/>

<Description>
<Ref Func="RightIdealByGenerators"/> returns the ring that is generated
by the elements of the collection <A>gens</A> under addition,
multiplication, and multiplication with elements of the ring <A>R</A>
from the right.
<P/>
<A>R</A> can be accessed by <Ref Func="RightActingRingOfIdeal"/>,
<A>gens</A> can be accessed by <Ref Func="GeneratorsOfRightIdeal"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfTwoSidedIdeal" Arg='I'/>
<Attr Name="GeneratorsOfIdeal" Arg='I'/>

<Description>
is a list of generators for the ideal <A>I</A>, with respect to
the action of the rings that are stored as the values of
<Ref Func="LeftActingRingOfIdeal"/> and
<Ref Func="RightActingRingOfIdeal"/>, from the left and from the right,
respectively.
<P/>
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 3 );;
gap> I:= Ideal( A, [ One( A ) ] );;
gap> GeneratorsOfIdeal( I );
[ [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfLeftIdeal" Arg='I'/>

<Description>
is a list of generators for the left ideal <A>I</A>, with respect to the
action from the left of the ring that is stored as the value of
<Ref Func="LeftActingRingOfIdeal"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfRightIdeal" Arg='I'/>

<Description>
is a list of generators for the right ideal <A>I</A>, with respect to the
action from the right of the ring that is stored as the value of
<Ref Func="RightActingRingOfIdeal"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="LeftActingRingOfIdeal" Arg='I'/>
<Attr Name="RightActingRingOfIdeal" Arg='I'/>

<Description>
returns the left (resp. right) acting ring of an ideal <A>I</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AsLeftIdeal" Arg='R, S'/>
<Oper Name="AsRightIdeal" Arg='R, S'/>
<Oper Name="AsTwoSidedIdeal" Arg='R, S'/>

<Description>
Let <A>S</A> be a subring of the ring <A>R</A>.
<P/>
If <A>S</A> is a left ideal in <A>R</A> then <Ref Func="AsLeftIdeal"/>
returns this left ideal, otherwise <K>fail</K> is returned.
<P/>
If <A>S</A> is a right ideal in <A>R</A> then <Ref Func="AsRightIdeal"/>
returns this right ideal, otherwise <K>fail</K> is returned.
<P/>
If <A>S</A> is a two-sided ideal in <A>R</A> then
<Ref Func="AsTwoSidedIdeal"/> returns this two-sided ideal,
otherwise <K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 3 );;
gap> B:= DirectSumOfAlgebras( A, A );
<algebra over Rationals, with 6 generators>
gap> C:= Subalgebra( B, Basis( B ){[1..9]} );
<algebra over Rationals, with 9 generators>
gap> I:= AsTwoSidedIdeal( B, C );
<two-sided ideal in <algebra of dimension 18 over Rationals>, 
  (9 generators)>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Rings With One">
<Heading>Rings With One</Heading>

<ManSection>
<Prop Name="IsRingWithOne" Arg='R'/>

<Description>
A <E>ring-with-one</E> in &GAP; is a ring (see&nbsp;<Ref Func="IsRing"/>)
that is also a magma-with-one (see&nbsp;<Ref Func="IsMagmaWithOne"/>).
<P/>
Note that the identity and the zero of a ring-with-one need <E>not</E> be
distinct.
This means that a ring that consists only of its zero element can be
regarded as a ring-with-one.
<!-- shall we force <E>every</E> trivial ring to be a ring-with-one-->
<!-- by installing an implication?-->
<P/>
This is especially useful in the case of finitely presented rings,
in the sense that each factor of a ring-with-one is again a
ring-with-one.
</Description>
</ManSection>

<ManSection>
<Heading>RingWithOne</Heading>
<Func Name="RingWithOne" Arg='r, s, ...' Label="for ring elements"/>
<Func Name="RingWithOne" Arg='coll' Label="for a collection"/>

<Description>
In the first form <Ref Func="RingWithOne" Label="for ring elements"/>
returns the smallest ring with one that contains all the elements
<A>r</A>, <A>s</A>, <M>\ldots</M>
In the second form <Ref Func="RingWithOne" Label="for a collection"/>
returns the smallest ring with one that contains all the elements
in the collection <A>C</A>.
If any element is not an element of a ring or if the elements lie in no
common ring an error is raised.
<Example><![CDATA[
gap> RingWithOne( [ 4, 6 ] );
Integers
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RingWithOneByGenerators" Arg='coll'/>

<Description>
<Ref Oper="RingWithOneByGenerators"/> returns the ring-with-one
generated by the elements in the collection <A>coll</A>,
i.&nbsp;e., the closure of <A>coll</A> under
addition, multiplication, taking additive inverses,
and taking the identity of an element.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfRingWithOne" Arg='R'/>

<Description>
<Ref Func="GeneratorsOfRingWithOne"/> returns a list of elements
such that the ring <A>R</A> is the closure of these elements
under addition, multiplication, taking additive inverses, and taking
the identity element <C>One( <A>R</A> )</C>.
<P/>
<A>R</A> itself need <E>not</E> be known to be a ring-with-one.
<P/>
<Example><![CDATA[
gap> R:= RingWithOne( [ 4, 6 ] );
Integers
gap> GeneratorsOfRingWithOne( R );
[ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubringWithOne" Arg='R, gens'/>
<Func Name="SubringWithOneNC" Arg='R, gens'/>

<Description>
returns the ring with one with parent <A>R</A> generated by the elements
in <A>gens</A>.
When the second form, <Ref Func="SubringWithOneNC"/> is used,
it is <E>not</E> checked whether all elements in <A>gens</A> lie in
<A>R</A>. 
<P/>
<Example><![CDATA[
gap> R:= SubringWithOne( Integers, [ 4, 6 ] );
Integers
gap> Parent( R );
Integers
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties of Rings">
<Heading>Properties of Rings</Heading>

<ManSection>
<Prop Name="IsIntegralRing" Arg='R'/>

<Description>
A ring-with-one <A>R</A> is integral if it is commutative,
contains no nontrivial zero divisors,
and if its identity is distinct from its zero.
<Example><![CDATA[
gap> IsIntegralRing( Integers );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsUniqueFactorizationRing" Arg='R' Type='Category'/>

<Description>
A ring <A>R</A> is called a <E>unique factorization ring</E> if it is an
integral ring (see&nbsp;<Ref Func="IsIntegralRing"/>),
and every nonzero element has a unique factorization into
irreducible elements,
i.e., a  unique representation as product of irreducibles
(see <Ref Func="IsIrreducibleRingElement"/>).
Unique in this context means unique up to permutations of the factors and
up to multiplication of the factors by units
(see&nbsp;<Ref Func="Units"/>).
<P/>
Mathematically, a field should therefore also be a unique factorization
ring, since every nonzero element is a unit.
In &GAP;, however,
at least at present fields do not lie in the filter
<Ref Func="IsUniqueFactorizationRing"/>,
since operations such as <Ref Func="Factors"/>,
<Ref Func="Gcd" Label="for (a ring and) several elements"/>,
<Ref Func="StandardAssociate"/> and so on do
not apply to fields (the results would be trivial, and not
especially useful) and methods which require their arguments to
lie in <Ref Func="IsUniqueFactorizationRing"/> expect these operations
to work.
<P/>
(Note that we cannot install a subset maintained method for this filter
since the factorization of an element needs not exist in a subring.
As an example, consider the subring <M>4 &NN; + 1</M> of the ring
<M>4 &ZZ; + 1</M>;
in the subring, the element <M>3 \cdot 3 \cdot 11 \cdot 7</M> has the two
factorizations <M>33 \cdot 21 = 9 \cdot 77</M>,
but in the large ring there is the unique factorization
<M>(-3) \cdot (-3) \cdot (-11) \cdot (-7)</M>,
and it is easy to see that every element in <M>4 &ZZ; + 1</M> has a
unique factorization.)
<P/>
<Example><![CDATA[
gap> IsUniqueFactorizationRing( PolynomialRing( Rationals, 1 ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLDistributive" Arg='C'/>

<Description>
is <K>true</K> if the relation
<M>a * ( b + c ) = ( a * b ) + ( a * c )</M>
holds for all elements <M>a</M>, <M>b</M>, <M>c</M> in the collection
<A>C</A>, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsRDistributive" Arg='C'/>

<Description>
is <K>true</K> if the relation
<M>( a + b ) * c = ( a * c ) + ( b * c )</M>
holds for all elements <M>a</M>, <M>b</M>, <M>c</M> in the collection
<A>C</A>, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsDistributive" Arg='C'/>

<Description>
is <K>true</K> if the collection <A>C</A> is both left and right
distributive
(see <Ref Func="IsLDistributive"/>, <Ref Func="IsRDistributive"/>),
and <K>false</K> otherwise.
<Example><![CDATA[
gap> IsDistributive( Integers );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAnticommutative" Arg='R'/>

<Description>
is <K>true</K> if the relation <M>a * b = - b * a</M>
holds for all elements <M>a</M>, <M>b</M> in the ring <A>R</A>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsZeroSquaredRing" Arg='R'/>

<Description>
is <K>true</K> if <M>a * a</M> is the zero element of the ring <A>R</A>
for all <M>a</M> in <A>R</A>, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsJacobianRing" Arg='R'/>

<Description>
is <K>true</K> if the Jacobi identity holds in the ring <A>R</A>,
and <K>false</K> otherwise.
The Jacobi identity means that
<M>x * (y * z) + z * (x * y) +  y * (z * x)</M>
is the zero element of <A>R</A>,
for all elements <M>x</M>, <M>y</M>, <M>z</M> in <A>R</A>.
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( GF( 5 ), 7 );
<Lie algebra over GF(5), with 13 generators>
gap> IsJacobianRing( L );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Units and Factorizations">
<Heading>Units and Factorizations</Heading>

<ManSection>
<Oper Name="IsUnit" Arg='[R, ]r'/>

<Description>
<Ref Oper="IsUnit"/> returns <K>true</K> if <A>r</A> is a unit in the
ring <A>R</A>, if given, and otherwise in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
If <A>r</A> is not a unit then <K>false</K> is returned.
<P/>
An element <A>r</A> is called a <E>unit</E> in a ring <A>R</A>,
if <A>r</A> has an inverse in <A>R</A>.
<P/>
<Ref Oper="IsUnit"/> may call <Ref Oper="Quotient"/>.
<!-- really?-->
</Description>
</ManSection>

<ManSection>
<Attr Name="Units" Arg='R'/>

<Description>
<Ref Attr="Units"/> returns the group of units of the ring <A>R</A>.
This may either be returned as a list or as a group.
<P/>
An element <M>r</M> is called a <E>unit</E> of a ring <M>R</M>
if <M>r</M> has an inverse in <M>R</M>.
It is easy to see that the set of units forms a multiplicative group.
<P/>
<Example><![CDATA[
gap> Units( GaussianIntegers );
[ -1, 1, -E(4), E(4) ]
gap> Units( GF( 16 ) );
<group with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsAssociated" Arg='[R, ]r, s'/>

<Description>
<Ref Oper="IsAssociated"/> returns <K>true</K> if the two ring elements
<A>r</A> and <A>s</A> are associated in the ring <A>R</A>, if given,
and otherwise in their default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
If the two elements are not associated then <K>false</K> is returned.
<P/>
Two elements <A>r</A> and <A>s</A> of a ring <A>R</A> are called
<E>associated</E> if there is a unit <M>u</M> of <A>R</A> such that
<A>r</A> <M>u = </M><A>s</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Associates" Arg='[R, ]r'/>

<Description>
<Ref Oper="Associates"/> returns the set of associates of <A>r</A> in
the ring <A>R</A>, if given,
and otherwise in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
<P/>
Two elements <A>r</A> and <M>s</M> of a ring <M>R</M> are called
<E>associated</E> if there is a unit <M>u</M> of <M>R</M> such that
<M><A>r</A> u = s</M>.
<P/>
<Example><![CDATA[
gap> Associates( Integers, 2 );
[ -2, 2 ]
gap> Associates( GaussianIntegers, 2 );
[ -2, 2, -2*E(4), 2*E(4) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="StandardAssociate" Arg='[R, ]r'/>

<Description>
<Ref Oper="StandardAssociate"/> returns the standard associate of the
ring element <A>r</A> in the ring <A>R</A>, if given,
and otherwise in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
<P/>
The <E>standard associate</E> of a ring element <A>r</A> of <A>R</A> is
an associated element of <A>r</A> which is, in a ring dependent way,
distinguished among the set of associates of <A>r</A>.
For example, in the ring of integers the standard associate is the
absolute value.
<P/>
<Example><![CDATA[
gap> x:= Indeterminate( Rationals, "x" );;
gap> StandardAssociate( -x^2-x+1 );
x^2+x-1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="StandardAssociateUnit" Arg='[R, ]r'/>

<Description>
<Ref Oper="StandardAssociateUnit"/> returns a unit in the ring <A>R</A>
such that the ring element <A>r</A> times this unit equals the
standard associate of <A>r</A> in <A>R</A>.
<P/>
If <A>R</A> is not given, the default ring of <A>r</A> is used instead.
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
<P/>
<P/>
<Example><![CDATA[
gap> y:= Indeterminate( Rationals, "y" );;
gap> r:= -y^2-y+1;
-y^2-y+1
gap> StandardAssociateUnit( r );
-1
gap> StandardAssociateUnit( r ) * r = StandardAssociate( r );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsIrreducibleRingElement" Arg='[R, ]r'/>

<Description>
<Ref Oper="IsIrreducibleRingElement"/> returns <K>true</K> if the ring
element <A>r</A> is irreducible in the ring <A>R</A>, if given,
and otherwise in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
If <A>r</A> is not irreducible then <K>false</K> is returned.
<P/>
An element <A>r</A> of a ring <A>R</A> is called <E>irreducible</E>
if <A>r</A> is not a unit in <A>R</A> and if there is no nontrivial
factorization of <A>r</A> in <A>R</A>,
i.e., if there is no representation of <A>r</A> as product <M>s t</M>
such that neither <M>s</M> nor <M>t</M> is a unit
(see <Ref Oper="IsUnit"/>).
Each prime element (see <Ref Oper="IsPrime"/>) is irreducible.
<Example><![CDATA[
gap> IsIrreducibleRingElement( Integers, 2 );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsPrime" Arg='[R, ]r'/>

<Description>
<Ref Oper="IsPrime"/> returns <K>true</K> if the ring element <A>r</A> is
a prime in the ring <A>R</A>, if given,
and otherwise in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
If <A>r</A> is not a prime then <K>false</K> is returned.
<P/>
An element <A>r</A> of a ring <A>R</A> is called <E>prime</E> if for each
pair <M>s</M> and <M>t</M> such that <A>r</A> divides <M>s t</M>
the element <A>r</A> divides either <M>s</M> or <M>t</M>.
Note that there are rings where not every irreducible element
(see <Ref Oper="IsIrreducibleRingElement"/>) is a prime.
</Description>
</ManSection>

<ManSection>
<Oper Name="Factors" Arg='[R, ]r'/>

<Description>
<Ref Oper="Factors"/> returns the factorization of the ring element
<A>r</A> in the ring <A>R</A>, if given,
and otherwise in in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
The factorization is returned as a list of primes
(see <Ref Func="IsPrime"/>).
Each element in the list is a standard associate
(see <Ref Func="StandardAssociate"/>) except the first one,
which is multiplied by a unit as necessary to have
<C>Product( Factors( <A>R</A>, <A>r</A> )  )  = <A>r</A></C>.
This list is usually also sorted, thus smallest prime factors come first.
If <A>r</A> is a unit or zero,
<C>Factors( <A>R</A>, <A>r</A> ) = [ <A>r</A> ]</C>.
<P/>
<!-- Who does really need the additive structure?
     We could define <C>Factors</C> for arbitrary commutative monoids.-->
<Example><![CDATA[
gap> x:= Indeterminate( GF(2), "x" );;
gap> pol:= x^2+x+1;
x^2+x+Z(2)^0
gap> Factors( pol );
[ x^2+x+Z(2)^0 ]
gap> Factors( PolynomialRing( GF(4) ), pol );
[ x+Z(2^2), x+Z(2^2)^2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PadicValuation" Arg='r, p'/>

<Description>
<Ref Oper="PadicValuation"/> is the operation to compute
the <A>p</A>-adic valuation of a ring element <A>r</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Euclidean Rings">
<Heading>Euclidean Rings</Heading>

<ManSection>
<Filt Name="IsEuclideanRing" Arg='R' Type='Category'/>

<Description>
A ring <M>R</M> is called a Euclidean ring if it is an integral ring and
there exists a function <M>\delta</M>, called the Euclidean degree, from
<M>R-\{0_R\}</M> to the nonnegative integers,
such that for every pair <M>r \in R</M> and <M>s \in  R-\{0_R\}</M> there
exists an element <M>q</M> such that either
<M>r - q s = 0_R</M> or <M>\delta(r - q s) &lt; \delta( s )</M>.
In &GAP; the Euclidean degree <M>\delta</M> is implicitly built into a
ring and cannot be changed.
The existence of this division with remainder implies that the
Euclidean algorithm can be applied to compute a greatest common divisor
of two elements,
which in turn implies that <M>R</M> is a unique factorization ring.
<P/>
<!-- more general: new category <Q>valuated domain</Q>?-->
<Example><![CDATA[
gap> IsEuclideanRing( GaussianIntegers );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EuclideanDegree" Arg='[R, ]r'/>

<Description>
<Ref Oper="EuclideanDegree"/> returns the Euclidean degree of the
ring element <A>r</A> in the ring <A>R</A>, if given,
and otherwise in its default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
<P/>
The ring <A>R</A> must be a Euclidean ring
(see <Ref Func="IsEuclideanRing"/>).
<Example><![CDATA[
gap> EuclideanDegree( GaussianIntegers, 3 );
9
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EuclideanQuotient" Arg='[R, ]r, m'/>

<Description>
<Ref Oper="EuclideanQuotient"/> returns the Euclidean quotient of the
ring elements <A>r</A> and <A>m</A> in the ring <A>R</A>, if given,
and otherwise in their default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
<P/>
The ring <A>R</A> must be a Euclidean ring
(see <Ref Func="IsEuclideanRing"/>), otherwise an error is signalled.
<Example><![CDATA[
gap> EuclideanQuotient( 8, 3 );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EuclideanRemainder" Arg='[R, ]r, m'/>

<Description>
<Ref Oper="EuclideanRemainder"/> returns the Euclidean remainder of the
ring element <A>r</A> modulo the ring element <A>m</A>
in the ring <A>R</A>, if given,
and otherwise in their default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
<P/>
The ring <A>R</A> must be a Euclidean ring
(see <Ref Func="IsEuclideanRing"/>), otherwise an error is signalled.
<Example><![CDATA[
gap> EuclideanRemainder( 8, 3 );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="QuotientRemainder" Arg='[R, ]r, m'/>

<Description>
<Ref Oper="QuotientRemainder"/> returns the Euclidean quotient
and the Euclidean remainder of the ring elements <A>r</A> and <A>m</A>
in the ring <A>R</A>, if given,
and otherwise in their default ring
(see <Ref Func="DefaultRing" Label="for ring elements"/>).
The result is a pair of ring elements.
<P/>
The ring <A>R</A> must be a Euclidean ring
(see <Ref Func="IsEuclideanRing"/>), otherwise an error is signalled.
<Example><![CDATA[
gap> QuotientRemainder( GaussianIntegers, 8, 3 );
[ 3, -1 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Gcd and Lcm">
<Heading>Gcd and Lcm</Heading>

<ManSection>
<Heading>Gcd</Heading>
<Func Name="Gcd" Arg='[R, ]r1, r2, ...'
 Label="for (a ring and) several elements"/>
<Func Name="Gcd" Arg='[R, ]list'
 Label="for (a ring and) a list of elements"/>

<Description>
<Ref Func="Gcd" Label="for (a ring and) several elements"/> returns
the greatest common divisor of the ring elements <A>r1</A>, <A>r2</A>,
<M>\ldots</M> resp. of the ring elements in the list <A>list</A>
in the ring <A>R</A>, if given, and otherwise in their default ring,
see <Ref Func="DefaultRing" Label="for ring elements"/>.
<P/>
<Ref Func="Gcd" Label="for (a ring and) several elements"/> returns
the standard associate (see <Ref Oper="StandardAssociate"/>) of the
greatest common divisors.
<P/>
A divisor of an element <M>r</M> in the ring <M>R</M> is an element
<M>d\in R</M> such that <M>r</M> is a multiple of <M>d</M>.
A common divisor of the elements <M>r_1, r_2, \ldots</M> in the
ring <M>R</M> is an element <M>d\in R</M> which is a divisor of
each <M>r_1, r_2, \ldots</M>.
A greatest common divisor <M>d</M> in addition has the property that every
other common divisor of <M>r_1, r_2, \ldots</M> is a divisor of <M>d</M>.
<P/>
Note that this in particular implies the following:
For the zero element <M>z</M> of <A>R</A>, we have 
<C>Gcd( <A>r</A>, </C><M>z</M><C> ) = Gcd( </C><M>z</M><C>, <A>r</A> )
= StandardAssociate( <A>r</A> )</C>
and <C>Gcd( </C><M>z</M><C>, </C><M>z</M><C> ) = </C><M>z</M>.
<Example><![CDATA[
gap> Gcd( Integers, [ 10, 15 ] );
5
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GcdOp" Arg='[R, ]r, s'/>

<Description>
<Ref Oper="GcdOp"/> is the operation to compute
the greatest common divisor of two ring elements <A>r</A>, <A>s</A>
in the ring <A>R</A> or in their default ring.
</Description>
</ManSection>

<ManSection>
<Heading>GcdRepresentation</Heading>
<Func Name="GcdRepresentation" Arg='[R, ]r1, r2, ...'
 Label="for (a ring and) several elements"/>
<Func Name="GcdRepresentation" Arg='[R, ]list'
 Label="for (a ring and) a list of elements"/>

<Description>
<Ref Func="GcdRepresentation" Label="for (a ring and) several elements"/>
returns a representation of
the greatest common divisor of the ring elements
<A>r1</A>, <A>r2</A>, <M>\ldots</M> resp. of the ring elements
in the list <A>list</A> in the Euclidean ring <A>R</A>, if given,
and otherwise in their default ring,
see <Ref Func="DefaultRing" Label="for ring elements"/>.
<P/>
A representation of the gcd <M>g</M> of the elements
<M>r_1, r_2, \ldots</M> of a ring <M>R</M> is a list of ring elements
<M>s_1, s_2, \ldots</M> of <M>R</M>,
such that <M>g = s_1 r_1 + s_2  r_2 + \cdots</M>.
Such representations do not exist in all rings, but they
do exist in Euclidean rings (see <Ref Func="IsEuclideanRing"/>),
which can be shown using the Euclidean algorithm, which in fact can
compute those coefficients.
<Example><![CDATA[
gap> a:= Indeterminate( Rationals, "a" );;
gap> GcdRepresentation( a^2+1, a^3+1 );
[ -1/2*a^2-1/2*a+1/2, 1/2*a+1/2 ]
]]></Example>
<P/>
<Ref Func="Gcdex"/> provides similar functionality over the integers.
</Description>
</ManSection>

<ManSection>
<Oper Name="GcdRepresentationOp" Arg='[R, ]r, s'/>

<Description>
<Ref Oper="GcdRepresentationOp"/> is the operation to compute
the representation of the greatest common divisor of two ring elements
<A>r</A>, <A>s</A> in the Euclidean ring <A>R</A> or in their default ring,
respectively.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowGcd" Arg='a,b'/>

<Description>
This function takes two elements <A>a</A> and <A>b</A> of an Euclidean
ring and returns their
greatest common divisor. It will print out the steps performed by the
Euclidean algorithm, as well as the rearrangement of these steps to
express the gcd as a ring combination of <A>a</A> and <A>b</A>.
<Example><![CDATA[
gap> ShowGcd(192,42);
192=4*42 + 24
42=1*24 + 18
24=1*18 + 6
18=3*6 + 0
The Gcd is 6
 = 1*24 -1*18
 = -1*42 + 2*24
 = 2*192 -9*42
6
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Lcm</Heading>
<Func Name="Lcm" Arg='[R, ]r1, r2, ...'
 Label="for (a ring and) several elements"/>
<Func Name="Lcm" Arg='[R, ]list'
 Label="for (a ring and) a list of elements"/>

<Description>
<Ref Func="Lcm" Label="for (a ring and) several elements"/> returns
the least common multiple of the ring elements
<A>r1</A>, <A>r2</A>, <M>\ldots</M> resp. of the ring elements
in the list <A>list</A> in the ring <A>R</A>, if given,
and otherwise in their default ring,
see <Ref Func="DefaultRing" Label="for ring elements"/>.
<P/>
<Ref Func="Lcm" Label="for (a ring and) several elements"/> returns
the standard associate (see&nbsp;<Ref Func="StandardAssociate"/>)
of the least common multiples.
<P/>
A least common multiple of the elements <M>r_1, r_2, \ldots</M> of the
ring <M>R</M> is an element <M>m</M> that is a multiple of <M>r_1, r_2, \ldots</M>,
and every other multiple of these elements is a multiple of <M>m</M>.
<P/>
Note that this in particular implies the following:
For the zero element <M>z</M> of <A>R</A>, we have 
<C>Lcm( <A>r</A>, </C><M>z</M><C> ) = Lcm( </C><M>z</M><C>, <A>r</A> )
= StandardAssociate( <A>r</A> )</C>
and <C>Lcm( </C><M>z</M><C>, </C><M>z</M><C> ) = </C><M>z</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LcmOp" Arg='[R, ]r, s'/>

<Description>
<Ref Oper="LcmOp"/> is the operation to compute the least common multiple
of two ring elements <A>r</A>, <A>s</A> in the ring <A>R</A>
or in their default ring, respectively.
<P/>
The default methods for this uses the equality
<M>lcm( m, n ) = m*n / gcd( m, n )</M> (see&nbsp;<Ref Func="GcdOp"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="QuotientMod" Arg='[R, ]r, s, m'/>

<Description>
<Ref Oper="QuotientMod"/> returns the quotient of the ring
elements <A>r</A> and <A>s</A> modulo the ring element <A>m</A>
in the ring <A>R</A>, if given,
and otherwise in their default ring, see
<Ref Func="DefaultRing" Label="for ring elements"/>.
<P/>
<A>R</A> must be a Euclidean ring (see <Ref Func="IsEuclideanRing"/>)
so that <Ref Func="EuclideanRemainder"/> can be applied.
If the modular quotient does not exist (i.e. when <A>s</A> and <A>m</A>
are not coprime), <K>fail</K> is returned.
<P/>
The quotient <M>q</M> of <A>r</A> and <A>s</A> modulo <A>m</A> is
an element of <A>R</A>
such that <M>q <A>s</A> = <A>r</A></M> modulo <M>m</M>, i.e.,
such that <M>q <A>s</A> - <A>r</A></M> is divisible by <A>m</A> in
<A>R</A> and that <M>q</M> is either zero (if <A>r</A> is divisible by
<A>m</A>) or the Euclidean degree of <M>q</M> is strictly smaller than
the Euclidean degree of <A>m</A>.
<Example><![CDATA[
gap> QuotientMod( 7, 2, 3 );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PowerMod" Arg='[R, ]r, e, m'/>

<Description>
<Ref Oper="PowerMod"/> returns the <A>e</A>-th power of the ring
element <A>r</A> modulo the ring element <A>m</A>
in the ring <A>R</A>, if given,
and otherwise in their default ring, see
<Ref Func="DefaultRing" Label="for ring elements"/>.
<A>e</A> must be an integer.
<P/>
<A>R</A> must be a Euclidean ring (see <Ref Func="IsEuclideanRing"/>)
so that <Ref Func="EuclideanRemainder"/> can be applied to its elements.
<P/>
If <A>e</A> is positive the result is <A>r</A><C>^</C><A>e</A> modulo
<A>m</A>.
If <A>e</A> is negative then <Ref Oper="PowerMod"/> first tries to find
the inverse of <A>r</A> modulo <A>m</A>, i.e.,
<M>i</M> such that <M>i <A>r</A> = 1</M> modulo <A>m</A>.
If the inverse does not exist an error is signalled.
If the inverse does exist <Ref Oper="PowerMod"/> returns
<C>PowerMod( <A>R</A>, <A>i</A>, -<A>e</A>, <A>m</A> )</C>.
<P/>
<Ref Oper="PowerMod"/> reduces the intermediate values modulo <A>m</A>,
improving performance drastically when <A>e</A> is large and <A>m</A>
small.
<Example><![CDATA[
gap> PowerMod( 12, 100000, 7 );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="InterpolatedPolynomial" Arg='R, x, y'/>

<Description>
<Ref Oper="InterpolatedPolynomial"/> returns, for given lists <A>x</A>,
<A>y</A> of elements in a ring <A>R</A> of the same length <M>n</M>, say,
the unique  polynomial of  degree less than <M>n</M> which has value
<A>y</A>[<M>i</M>] at <A>x</A><M>[i]</M>,
for all <M>i \in \{ 1, \ldots, n \}</M>. 
Note that the elements in <A>x</A> must be distinct.
<Example><![CDATA[
gap> InterpolatedPolynomial( Integers, [ 1, 2, 3 ], [ 5, 7, 0 ] );
-9/2*x^2+31/2*x-6
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Homomorphisms of Rings">
<Heading>Homomorphisms of Rings</Heading>

A <E>ring homomorphism</E> is a mapping between two rings
that respects addition and multiplication.

<P/>

Currently &GAP; supports ring homomorphisms between finite rings
(using straightforward methods)
and ring homomorphisms with additional structures,
where source and range are in fact algebras
and where also the linear structure is respected,
see <Ref Sect="Homomorphisms of Algebras"/>.

<ManSection>
<Oper Name="RingGeneralMappingByImages" Arg='R, S, gens, imgs'/>

<Description>
is a general mapping from the ring <A>A</A> to the ring <A>S</A>.
This general mapping is defined by mapping the entries in the list
<A>gens</A> (elements of <A>R</A>) to the entries in the list <A>imgs</A>
(elements of <A>S</A>),
and taking the additive and multiplicative closure.
<P/>
<A>gens</A> need not generate <A>R</A> as a ring,
and if the specification does not define an additive and multiplicative
mapping then the result will be multivalued.
Hence, in general it is not a mapping.
</Description>
</ManSection>

<ManSection>
<Func Name="RingHomomorphismByImages" Arg='R, S, gens, imgs'/>

<Description>
<Ref Func="RingHomomorphismByImages"/> returns the ring homomorphism with
source <A>R</A> and range <A>S</A> that is defined by mapping the list
<A>gens</A> of generators of <A>R</A> to the list <A>imgs</A> of images
in <A>S</A>.
<P/>
If <A>gens</A> does not generate <A>R</A> or if the homomorphism does not
exist (i.e., if mapping the generators describes only a multi-valued
mapping) then <K>fail</K> is returned.
<P/>
One can avoid the checks by calling
<Ref Oper="RingHomomorphismByImagesNC"/>,
and one can construct multi-valued mappings with
<Ref Func="RingGeneralMappingByImages"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="RingHomomorphismByImagesNC" Arg='R, S, gens, imgs'/>

<Description>
<Ref Oper="RingHomomorphismByImagesNC"/> is the operation that is called
by the function <Ref Func="RingHomomorphismByImages"/>.
Its methods may assume that <A>gens</A> generates <A>R</A> as a ring
and that the mapping of <A>gens</A> to <A>imgs</A> defines a ring
homomorphism.
Results are unpredictable if these conditions do not hold.
<P/>
For creating a possibly multi-valued mapping from <A>R</A> to <A>S</A>
that respects addition and multiplication,
<Ref Func="RingGeneralMappingByImages"/> can be used.
</Description>
</ManSection>

<!-- Are ring-with-one homomorphisms not supported? -->
<ManSection>
<Oper Name="NaturalHomomorphismByIdeal" Arg='R, I'/>

<Description>
is the homomorphism of rings provided by the natural
projection map of <A>R</A> onto the quotient ring <A>R</A>/<A>I</A>.
This map can be used to take pre-images in the original ring from
elements in the quotient.
</Description>
</ManSection>

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Small Rings">
<Heading>Small Rings</Heading>

&GAP; contains a library of small (order up to 15) rings.

<ManSection>
<Func Name="SmallRing" Arg='s n'/>

<Description>
returns the <M>n</M>-th ring of order <M>s</M> from a library of 
rings of small order (up to isomorphism).
<Example><![CDATA[
gap> R:=SmallRing(8,37);
<ring with 3 generators>
gap> ShowMultiplicationTable(R);                 
*     | 0*a   c     b     b+c   a     a+c   a+b   a+b+c
------+------------------------------------------------
0*a   | 0*a   0*a   0*a   0*a   0*a   0*a   0*a   0*a  
c     | 0*a   0*a   0*a   0*a   0*a   0*a   0*a   0*a  
b     | 0*a   0*a   0*a   0*a   b     b     b     b    
b+c   | 0*a   0*a   0*a   0*a   b     b     b     b    
a     | 0*a   c     b     b+c   a+b   a+b+c a     a+c  
a+c   | 0*a   c     b     b+c   a+b   a+b+c a     a+c  
a+b   | 0*a   c     b     b+c   a     a+c   a+b   a+b+c
a+b+c | 0*a   c     b     b+c   a     a+c   a+b   a+b+c
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NumberSmallRings" Arg='s'/>

<Description>
returns the number of (nonisomorphic) rings of order <M>s</M> 
stored in the library of small rings.
<Example><![CDATA[
gap> List([1..15],NumberSmallRings);
[ 1, 2, 2, 11, 2, 4, 2, 52, 11, 4, 2, 22, 2, 4, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Subrings" Arg='R'/>

<Description>
for a finite ring <A>R</A> this function returns a list of all 
subrings of <A>R</A>.
<Example><![CDATA[
gap> Subrings(SmallRing(8,37));     
[ <ring with 1 generators>, <ring with 1 generators>, 
  <ring with 1 generators>, <ring with 1 generators>, 
  <ring with 1 generators>, <ring with 1 generators>, 
  <ring with 2 generators>, <ring with 2 generators>, 
  <ring with 2 generators>, <ring with 2 generators>, 
  <ring with 3 generators> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Ideals" Arg='R'/>

<Description>
for a finite ring <A>R</A> this function returns a list of all
ideals of <A>R</A>.
<Example><![CDATA[
gap> Ideals(SmallRing(8,37));
[ <ring with 1 generators>, <ring with 1 generators>, 
  <ring with 1 generators>, <ring with 2 generators>, 
  <ring with 3 generators> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DirectSum" Arg='R{, S}'/>
<Oper Name="DirectSumOp" Arg='list, expl'/>

<Description>
These functions construct the direct sum of the rings given as
arguments.
<C>DirectSum</C> takes an arbitrary positive number of arguments
and calls the operation <C>DirectSumOp</C>, which takes exactly two
arguments, namely a nonempty list of rings and one of these rings.
(This somewhat strange syntax allows the method selection to choose
a reasonable method for special cases.)
<Example><![CDATA[
gap> DirectSum(SmallRing(5,1),SmallRing(5,1));
<ring with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RingByStructureConstants" Arg='moduli, sctable[, nameinfo]'/>

<Description>
returns a ring <M>R</M> whose additive group is described by the list
<A>moduli</A>,
with multiplication defined by the structure constants table
<A>sctable</A>.
The optional argument <A>nameinfo</A> can be used to prescribe names for
the elements of the canonical generators of <M>R</M>;
it can be either a string <A>name</A>
(then <A>name</A><C>1</C>, <A>name</A><C>2</C> etc. are chosen)
or a list of strings which are then chosen.
</Description>
</ManSection>



</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  module.msk                   GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: module.msk,v 1.12 2002/04/15 10:02:30 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Modules">
<Heading>Modules</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Generating modules">
<Heading>Generating modules</Heading>

<ManSection>
<Filt Name="IsLeftOperatorAdditiveGroup" Arg='D' Type='Category'/>

<Description>
A domain <A>D</A> lies in <C>IsLeftOperatorAdditiveGroup</C>
if it is an additive group that is closed under scalar multiplication
from the left, and such that
<M>\lambda * ( x + y ) = \lambda * x + \lambda * y</M>
for all scalars <M>\lambda</M> and elements <M>x, y \in D</M>
(here and below by scalars we mean elements of a domain acting
on <A>D</A> from left or right as appropriate).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLeftModule" Arg='M' Type='Category'/>

<Description>
A domain <A>M</A> lies in <C>IsLeftModule</C>
if it lies in <C>IsLeftOperatorAdditiveGroup</C>,
<E>and</E> the set of scalars forms a ring,
<E>and</E> <M>(\lambda + \mu) * x = \lambda * x + \mu * x</M>
for scalars <M>\lambda, \mu</M> and <M>x \in M</M>,
<E>and</E> scalar multiplication satisfies
<M>\lambda * (\mu * x) = (\lambda * \mu) * x</M>
for scalars <M>\lambda, \mu</M> and <M>x \in M</M>.
<Example><![CDATA[
gap> V:= FullRowSpace( Rationals, 3 );
( Rationals^3 )
gap> IsLeftModule( V );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfLeftOperatorAdditiveGroup" Arg='D'/>

<Description>
returns a list of elements of <A>D</A> that generates <A>D</A> as a left operator
additive group.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfLeftModule" Arg='M'/>

<Description>
returns a list of elements of <A>M</A> that generate <A>M</A> as a left module.
<Example><![CDATA[
gap> V:= FullRowSpace( Rationals, 3 );;
gap> GeneratorsOfLeftModule( V );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsLeftModule" Arg='R, D'/>

<Description>
if the domain <A>D</A> forms an additive group and is closed under left
multiplication by the elements of <A>R</A>, then <C>AsLeftModule( <A>R</A>, <A>D</A> )</C>
returns the domain <A>D</A> viewed as a left module.
<Example><![CDATA[
gap> coll:= [[0*Z(2),0*Z(2)], [Z(2),0*Z(2)], [0*Z(2),Z(2)], [Z(2),Z(2)]];
[ [ 0*Z(2), 0*Z(2) ], [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ], 
  [ Z(2)^0, Z(2)^0 ] ]
gap> AsLeftModule( GF(2), coll );
<vector space of dimension 2 over GF(2)>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRightOperatorAdditiveGroup" Arg='D' Type='Category'/>

<Description>
A domain <A>D</A> lies in <C>IsRightOperatorAdditiveGroup</C>
if it is an additive group that is closed under scalar multiplication
from the right,
and such that <M>( x + y ) * \lambda = x * \lambda + y * \lambda</M>
for all scalars <M>\lambda</M> and elements <M>x, y \in D</M>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRightModule" Arg='M' Type='Category'/>

<Description>
A domain <A>M</A> lies in <C>IsRightModule</C> if it lies in
<C>IsRightOperatorAdditiveGroup</C>,
<E>and</E> the set of scalars forms a ring,
<E>and</E> <M>x * (\lambda + \mu) = x * \lambda + x * \mu</M>
for scalars <M>\lambda, \mu</M> and <M>x \in M</M>,
<E>and</E> scalar multiplication satisfies
<M>(x * \mu) * \lambda = x * (\mu * \lambda)</M>
for scalars <M>\lambda, \mu</M> and <M>x \in M</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfRightOperatorAdditiveGroup" Arg='D'/>

<Description>
returns a list of elements of <A>D</A> that generates <A>D</A> as a right operator
additive group.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfRightModule" Arg='M'/>

<Description>
returns a list of elements of <A>M</A> that generate <A>M</A> as a left module.
</Description>
</ManSection>

<ManSection>
<Oper Name="LeftModuleByGenerators" Arg='R, gens[, zero]'/>

<Description>
returns the left module over <A>R</A> generated by <A>gens</A>.
<Example><![CDATA[
gap> coll:= [ [Z(2),0*Z(2)], [0*Z(2),Z(2)], [Z(2),Z(2)] ];;
gap> V:= LeftModuleByGenerators( GF(16), coll );
<vector space over GF(2^4), with 3 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LeftActingDomain" Arg='D'/>

<Description>
Let <A>D</A> be an external left set, that is, <A>D</A> is closed under the action
of a domain <M>L</M> by multiplication from the left.
Then <M>L</M> can be accessed as value of <C>LeftActingDomain</C> for <A>D</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Submodules">
<Heading>Submodules</Heading>

<ManSection>
<Func Name="Submodule" Arg='M, gens[, "basis"]'/>

<Description>
is the left module generated by the collection <A>gens</A>,
with parent module <A>M</A>.
If the string <C>"basis"</C> is entered as the third argument then
the submodule of <A>M</A> is created for which the list <A>gens</A>
is known to be a list of basis vectors;
in this case, it is <E>not</E> checked whether <A>gens</A> really is
linearly independent and whether all in <A>gens</A> lie in <A>M</A>.
<Example><![CDATA[
gap> coll:= [ [Z(2),0*Z(2)], [0*Z(2),Z(2)], [Z(2),Z(2)] ];;
gap> V:= LeftModuleByGenerators( GF(16), coll );;
gap> W:= Submodule( V, [ coll[1], coll[2] ] );
<vector space over GF(2^4), with 2 generators>
gap> Parent( W ) = V;
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubmoduleNC" Arg='M, gens[, "basis"]'/>

<Description>
<Ref Func="SubmoduleNC"/> does the same as <Ref Func="Submodule"/>,
except that it does not check whether all in <A>gens</A> lie in <A>M</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ClosureLeftModule" Arg='M, m'/>

<Description>
is the left module generated by the left module generators of <A>M</A> and the
element <A>m</A>.
<Example><![CDATA[
gap> V:= LeftModuleByGenerators(Rationals, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ]);
<vector space over Rationals, with 2 generators>
gap> ClosureLeftModule( V, [ 1, 1, 1 ] );
<vector space over Rationals, with 3 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TrivialSubmodule" Arg='M'/>

<Description>
returns the zero submodule of <A>M</A>.
<Example><![CDATA[
gap> V:= LeftModuleByGenerators(Rationals, [[ 1, 0, 0 ], [ 0, 1, 0 ]]);;
gap> TrivialSubmodule( V );
<vector space over Rationals, with 0 generators>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Free Modules">
<Heading>Free Modules</Heading>

<ManSection>
<Filt Name="IsFreeLeftModule" Arg='M' Type='Category'/>

<Description>
A left module is free as module if it is isomorphic to a direct sum of
copies of its left acting domain.
<P/>
Free left modules can have bases.
<P/>
The characteristic (see&nbsp;<Ref Func="Characteristic"/>) of a
free left module is defined as the characteristic of its left acting
domain (see&nbsp;<Ref Func="LeftActingDomain"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="FreeLeftModule" Arg='R, gens[, zero][, "basis"]'/>

<Description>
<C>FreeLeftModule( <A>R</A>, <A>gens</A> )</C> is the free left module
over the ring <A>R</A>, generated by the vectors in the collection
<A>gens</A>.
<P/>
If there are three arguments, a ring <A>R</A> and a collection
<A>gens</A> and an element <A>zero</A>,
then <C>FreeLeftModule( <A>R</A>, <A>gens</A>, <A>zero</A> )</C> is the
<A>R</A>-free left module generated by <A>gens</A>,
with zero element <A>zero</A>.
<P/>
If the last argument is the string <C>"basis"</C> then the vectors in
<A>gens</A> are known to form a basis of the free module.
<P/>
It should be noted that the generators <A>gens</A> must be vectors,
that is, they must support an addition and a scalar action of <A>R</A>
via left multiplication.
(See also Section&nbsp;<Ref Sect="Constructing Domains"/>
for the general meaning of <Q>generators</Q> in &GAP;.)
In particular, <Ref Func="FreeLeftModule"/> is <E>not</E> an equivalent
of commands such as <Ref Func="FreeGroup" Label="for given rank"/>
in the sense of a constructor of a free group on abstract generators.
Such a construction seems to be unnecessary for vector spaces,
for that one can use for example row spaces
(see&nbsp;<Ref Func="FullRowSpace"/>) in the finite dimensional case
and polynomial rings
(see&nbsp;<Ref Func="PolynomialRing" Label="for a ring and a rank (and an exclusion list)"/>)
in the infinite dimensional case.
Moreover, the definition of a <Q>natural</Q> addition for elements of a
given magma (for example a permutation group) is possible via the
construction of magma rings (see Chapter <Ref Chap="Magma Rings"/>).
<Example><![CDATA[
gap> V:= FreeLeftModule(Rationals, [[ 1, 0, 0 ], [ 0, 1, 0 ]], "basis");
<vector space of dimension 2 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Dimension" Arg='M'/>

<Description>
A free left module has dimension <M>n</M> if it is isomorphic to a direct sum
of <M>n</M> copies of its left acting domain.
<P/>
(We do <E>not</E> mark <Ref Attr="Dimension"/> as invariant under isomorphisms
since we want to call <Ref Oper="UseIsomorphismRelation"/> also for free left modules
over different left acting domains.)
<Example><![CDATA[
gap> V:= FreeLeftModule( Rationals, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ] );;
gap> Dimension( V );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFiniteDimensional" Arg='M'/>

<Description>
is <K>true</K> if <A>M</A> is a free left module that is finite dimensional
over its left acting domain, and <K>false</K> otherwise.
<Example><![CDATA[
gap> V:= FreeLeftModule( Rationals, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ] );;
gap> IsFiniteDimensional( V );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="UseBasis" Arg='V, gens'/>

<Description>
The vectors in the list <A>gens</A> are known to form a basis of the
free left module <A>V</A>.
<Ref Oper="UseBasis"/> stores information in <A>V</A> that can be derived form this fact,
namely
<List>
<Item>
  <A>gens</A> are stored as left module generators if no such generators were
  bound (this is useful especially if <A>V</A> is an algebra),
</Item>
<Item>
  the dimension of <A>V</A> is stored.
</Item>
</List>
<Example><![CDATA[
gap> V:= FreeLeftModule( Rationals, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ] );;
gap> UseBasis( V, [ [ 1, 0 ], [ 1, 1 ] ] );
gap> V;  # now V knows its dimension
<vector space of dimension 2 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsRowModule" Arg='V'/>

<Description>
A <E>row module</E> is a free left module whose elements are row vectors.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsMatrixModule" Arg='V'/>

<Description>
A <E>matrix module</E> is a free left module whose elements are matrices.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFullRowModule" Arg='M'/>

<Description>
A <E>full row module</E> is a module <M>R^n</M>,
for a ring <M>R</M> and a nonnegative integer <M>n</M>.
<P/>
More precisely, a full row module is a free left module over a ring
<M>R</M> such that the elements are row vectors of the same length
<M>n</M> and with entries in <M>R</M> and such that the dimension is
equal to <M>n</M>.
<P/>
Several functions delegate their tasks to full row modules,
for example <Ref Func="Iterator"/> and <Ref Func="Enumerator"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="FullRowModule" Arg='R, n'/>

<Description>
is the row module <C><A>R</A>^<A>n</A></C>,
for a ring <A>R</A> and a nonnegative integer <A>n</A>.
<Example><![CDATA[
gap> V:= FullRowModule( Integers, 5 );
( Integers^5 )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFullMatrixModule" Arg='M'/>

<Description>
A <E>full matrix module</E> is a module <M>R^{{[m,n]}}</M>,
for a ring <M>R</M> and two nonnegative integers <M>m</M>, <M>n</M>.
<P/>
More precisely, a full matrix module is a free left module over a ring
<M>R</M> such that the elements are <M>m</M> by <M>n</M> matrices with
entries in <M>R</M> and such that the dimension is equal to <M>m n</M>.
</Description>
</ManSection>

<ManSection>
<Func Name="FullMatrixModule" Arg='R, m, n'/>

<Description>
is the matrix module <C><A>R</A>^[<A>m</A>,<A>n</A>]</C>,
for a ring <A>R</A> and nonnegative integers <A>m</A> and <A>n</A>.
<Example><![CDATA[
gap> FullMatrixModule( GaussianIntegers, 3, 6 );
( GaussianIntegers^[ 3, 6 ] )
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  fields.msk                   GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: fields.msk,v 1.18 2005/04/21 09:38:23 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Fields and Division Rings">
<Heading>Fields and Division Rings</Heading>

<Index>fields</Index>
<Index>division rings</Index>
A <E>division ring</E> is a ring (see Chapter&nbsp;<Ref Chap="Rings"/>)
in which every non-zero element has an inverse.
The most important class of division rings are the commutative ones,
which are called <E>fields</E>.
<P/>
&GAP; supports finite fields
(see Chapter&nbsp;<Ref Chap="Finite Fields"/>) and
abelian number fields
(see Chapter&nbsp;<Ref Chap="Abelian Number Fields"/>),
in particular the field of rationals
(see Chapter&nbsp;<Ref Chap="Rational Numbers"/>).
<P/>
This chapter describes the general &GAP; functions for fields and
division rings.
<P/>
If a field <A>F</A> is a subfield of a commutative ring <A>C</A>,
<A>C</A> can be considered as a vector space over the (left) acting
domain <A>F</A> (see Chapter&nbsp;<Ref Chap="Vector Spaces"/>).
In this situation, we call <A>F</A> the <E>field of definition</E> of
<A>C</A>.
<P/>
Each field in &GAP; is represented as a vector space over a subfield
(see&nbsp;<Ref Func="IsField"/>), thus each field is in fact a
field extension in a natural way,
which is used by functions such as
<Ref Func="Norm"/> and <Ref Func="Trace" Label="for a field element"/>
(see&nbsp;<Ref Sect="Galois Action"/>).



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Generating Fields">
<Heading>Generating Fields</Heading>

<ManSection>
<Filt Name="IsDivisionRing" Arg='D' Type='Category'/>

<Description>
A <E>division ring</E> in &GAP; is a nontrivial associative algebra
<A>D</A> with a multiplicative inverse for each nonzero element.
In &GAP; every division ring is a vector space over a division ring
(possibly over itself).
Note that being a division ring is thus not a property that a ring can
get, because a ring is usually not represented as a vector space.
<P/>
The field of coefficients is stored as the value of the attribute
<Ref Func="LeftActingDomain"/> of <A>D</A>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsField" Arg='D'/>

<Description>
A <E>field</E> is a commutative division ring
(see&nbsp;<Ref Func="IsDivisionRing"/>
and&nbsp;<Ref Func="IsCommutative"/>).
<Example><![CDATA[
gap> IsField( GaloisField(16) );           # the field with 16 elements
true
gap> IsField( Rationals );                 # the field of rationals
true
gap> q:= QuaternionAlgebra( Rationals );;  # noncommutative division ring
gap> IsField( q );  IsDivisionRing( q );
false
true
gap> mat:= [ [ 1 ] ];;  a:= Algebra( Rationals, [ mat ] );;
gap> IsDivisionRing( a );   # algebra not constructed as a division ring
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Field" Arg='z, ...' Label="for several generators"/>
<Func Name="Field" Arg='[F, ]list'
 Label="for (a field and) a list of generators"/>

<Description>
<Ref Func="Field" Label="for several generators"/> returns the smallest
field <M>K</M> that contains all the elements <M><A>z</A>, \ldots</M>,
or the smallest field <M>K</M> that contains all elements in the list
<A>list</A>.
If no subfield <A>F</A> is given, <M>K</M> is constructed as a field over
itself, i.e. the left acting domain of <M>K</M> is <M>K</M>.
Called with a field <A>F</A> and a list <A>list</A>,
<Ref Func="Field" Label="for (a field and) a list of generators"/>
constructs the field generated by <A>F</A> and the elements in
<A>list</A>, as a vector space over <A>F</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="DefaultField" Arg='z, ...' Label="for several generators"/>
<Func Name="DefaultField" Arg='list' Label="for a list of generators"/>

<Description>
<Ref Func="DefaultField" Label="for several generators"/> returns a field
<M>K</M> that contains all the elements <M><A>z</A>, \ldots</M>,
or a field <M>K</M> that contains all elements in the list <A>list</A>.
<P/>
This field need not be the smallest field in which the elements lie,
cf.&nbsp;<Ref Func="Field" Label="for several generators"/>.
For example, for elements from cyclotomic fields
<Ref Func="DefaultField" Label="for several generators"/> returns
the smallest cyclotomic field in which the elements lie,
but the elements may lie in a smaller number field
which is not a cyclotomic field.
<Example><![CDATA[
gap> Field( Z(4) );  Field( [ Z(4), Z(8) ] );  # finite fields
GF(2^2)
GF(2^6)
gap> Field( E(9) );  Field( CF(4), [ E(9) ] ); # abelian number fields
CF(9)
AsField( GaussianRationals, CF(36) )
gap> f1:= Field( EB(5) );  f2:= DefaultField( EB(5) );
NF(5,[ 1, 4 ])
CF(5)
gap> f1 = f2;  IsSubset( f2, f1 );
false
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DefaultFieldByGenerators" Arg='[ z, ... ]'/>

<Description>
returns the default field containing the elements <A>z</A>, <M>\ldots</M>.
This field may be bigger than the smallest field containing these
elements.
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfDivisionRing" Arg='D'/>

<Description>
generators with respect to addition, multiplication, and taking inverses
(the identity cannot be omitted ...)
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfField" Arg='F'/>

<Description>
generators with respect to addition, multiplication, and taking
inverses.
This attribute is the same as <Ref Func="GeneratorsOfDivisionRing"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="DivisionRingByGenerators" Arg='[F, ]gens'/>
<Oper Name="FieldByGenerators" Arg='[F, ]gens'/>

<Description>
Called with a field <A>F</A> and a list <A>gens</A> of scalars,
<Ref Func="DivisionRingByGenerators"/> returns the division ring over
<A>F</A> generated by <A>gens</A>.
The unary version returns the division ring as vector space over
<C>FieldOverItselfByGenerators( <A>gens</A> )</C>.
<P/>
<Ref Oper="FieldByGenerators"/> is just a synonym for 
<Ref Oper="DivisionRingByGenerators"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="AsDivisionRing" Arg='[F, ]C'/>
<Oper Name="AsField" Arg='[F, ]C'/>

<Description>
If the collection <A>C</A> can be regarded as a division ring then
<C>AsDivisionRing( <A>C</A> )</C> is the division ring that consists of
the elements of <A>C</A>, viewed as a vector space over its prime field;
otherwise <K>fail</K> is returned.
<P/>
In the second form, if <A>F</A> is a division ring contained in <A>C</A>
then the returned division ring is viewed as a vector space over
<A>F</A>.
<P/>
<Ref Func="AsField"/> is just a synonym for <Ref Func="AsDivisionRing"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subfields of Fields">
<Heading>Subfields of Fields</Heading>

<ManSection>
<Func Name="Subfield" Arg='F, gens'/>
<Func Name="SubfieldNC" Arg='F, gens'/>

<Description>
Constructs the subfield of <A>F</A> generated by <A>gens</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="FieldOverItselfByGenerators" Arg='[ z, ... ]'/>

<Description>
This  operation is  needed for  the  call of
<Ref Func="Field" Label="for several generators"/> or
<Ref Oper="FieldByGenerators"/> without explicitly given subfield,
in order to construct a left acting domain for such a field.
</Description>
</ManSection>

<ManSection>
<Attr Name="PrimitiveElement" Arg='D'/>

<Description>
is an element of <A>D</A> that generates <A>D</A> as a division ring
together with the left acting domain.
</Description>
</ManSection>

<ManSection>
<Attr Name="PrimeField" Arg='D'/>

<Description>
The <E>prime field</E> of a division ring <A>D</A> is the smallest field
which is contained in <A>D</A>.
For example, the prime field of any field in characteristic zero
is isomorphic to the field of rational numbers.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPrimeField" Arg='D'/>

<Description>
A division ring is a prime field if it is equal to its prime field
(see&nbsp;<Ref Func="PrimeField"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="DegreeOverPrimeField" Arg='F'/>

<Description>
is the degree of the field <A>F</A> over its prime field
(see&nbsp;<Ref Func="PrimeField"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="DefiningPolynomial" Arg='F'/>

<Description>
is the defining polynomial of the field <A>F</A> as a field extension
over the left acting domain of <A>F</A>.
A root of the defining polynomial can be computed with
<Ref Func="RootOfDefiningPolynomial"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="RootOfDefiningPolynomial" Arg='F'/>

<Description>
is a root in the field <A>F</A> of its defining polynomial as a field
extension over the left acting domain of <A>F</A>.
The defining polynomial can be computed with
<Ref Func="DefiningPolynomial"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="FieldExtension" Arg='F, poly'/>

<Description>
is the field obtained on adjoining a root of the irreducible polynomial
<A>poly</A> to the field <A>F</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="Subfields" Arg='F'/>

<Description>
is the set of all subfields of the field <A>F</A>.
<!-- or shall we allow to ask, e.g., for subfields of quaternion algebras?-->
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Galois Action">
<Heading>Galois Action</Heading>

Let <M>L > K</M> be a field extension of finite degree.
Then to each element <M>\alpha \in L</M>, we can associate a
<M>K</M>-linear mapping <M>\varphi_{\alpha}</M> on <M>L</M>,
and for a fixed <M>K</M>-basis of <M>L</M>,
we can associate to <M>\alpha</M> the matrix <M>M_{\alpha}</M>
(over <M>K</M>) of this mapping.
<P/>
The <E>norm</E> of <M>\alpha</M> is defined as the determinant of
<M>M_{\alpha}</M>,
the <E>trace</E> of <M>\alpha</M> is defined as the trace of
<M>M_{\alpha}</M>,
the <E>minimal polynomial</E> <M>\mu_{\alpha}</M> and the
<E>trace polynomial</E> <M>\chi_{\alpha}</M> of <M>\alpha</M>
are defined as the minimal polynomial
(see&nbsp;<Ref Sect="MinimalPolynomial" Label="over a field"/>)
and the characteristic polynomial
(see&nbsp;<Ref Func="CharacteristicPolynomial"/> and
<Ref Func="TracePolynomial"/>) of <M>M_{\alpha}</M>.
(Note that <M>\mu_{\alpha}</M> depends only on <M>K</M> whereas
<M>\chi_{\alpha}</M> depends on both <M>L</M> and <M>K</M>.)
<P/>
Thus norm and trace of <M>\alpha</M> are elements of <M>K</M>,
and <M>\mu_{\alpha}</M> and <M>\chi_{\alpha}</M> are polynomials over
<M>K</M>, <M>\chi_{\alpha}</M> being a power of <M>\mu_{\alpha}</M>,
and the degree of <M>\chi_{\alpha}</M> equals the degree of the field
extension <M>L > K</M>.
<P/>
The <E>conjugates</E> of <M>\alpha</M> in <M>L</M> are those roots of
<M>\chi_{\alpha}</M> (with multiplicity) that lie in <M>L</M>;
note that if only <M>L</M> is given, there is in general no way to access
the roots outside <M>L</M>.
<P/>
Analogously, the <E>Galois group</E> of the extension <M>L > K</M> is
defined as the group of all those field automorphisms of <M>L</M> that
fix <M>K</M> pointwise.
<P/>
If <M>L > K</M> is a Galois extension then the conjugates of
<M>\alpha</M> are all roots of <M>\chi_{\alpha}</M> (with multiplicity),
the set of conjugates equals the roots of <M>\mu_{\alpha}</M>,
the norm of <M>\alpha</M> equals the product and the trace of
<M>\alpha</M> equals the sum of the conjugates of <M>\alpha</M>,
and the Galois group in the sense of the above definition equals
the usual Galois group,
<P/>
Note that <C>MinimalPolynomial( <A>F</A>, <A>z</A> )</C> is a polynomial
<E>over</E> <A>F</A>,
whereas <C>Norm( <A>F</A>, <A>z</A> )</C> is the norm of the element
<A>z</A> <E>in</E> <A>F</A>
w.r.t.&nbsp;the field extension
<C><A>F</A> &gt; LeftActingDomain( <A>F</A> )</C>.

<P/>
The default methods for field elements are as follows.
<Ref Func="MinimalPolynomial"/> solves a system of linear equations,
<Ref Func="TracePolynomial"/> computes the appropriate power of the
minimal
polynomial,
<Ref Func="Norm"/> and <Ref Func="Trace" Label="for a field element"/>
values are obtained as coefficients of the characteristic polynomial,
and <Ref Func="Conjugates"/> uses the factorization of the
characteristic polynomial.
<P/>
For elements in finite fields and cyclotomic fields, one wants to do the
computations in a different way since the field extensions in question
are Galois extensions, and the Galois groups are well-known in these
cases.
More general,
if a field is in the category
<C>IsFieldControlledByGaloisGroup</C> then
the default methods are the following.
<Ref Func="Conjugates"/> returns the sorted list of images
(with multiplicity) of the element under the Galois group,
<Ref Func="Norm"/> computes the product of the conjugates,
<Ref Func="Trace" Label="for a field element"/> computes the sum of the
conjugates,
<Ref Func="TracePolynomial"/> and <Ref Func="MinimalPolynomial"/> compute
the product of linear factors <M>x - c</M> with <M>c</M> ranging over the
conjugates and the set of conjugates, respectively.


<Index Key="IsFieldControlledByGaloisGroup"><C>IsFieldControlledByGaloisGroup</C></Index>
<ManSection>
<Attr Name="GaloisGroup" Arg='F' Label="of field"/>

<Description>
The <E>Galois group</E> of a field <A>F</A> is the group of all
field automorphisms of <A>F</A> that fix the subfield
<M>K = </M><C>LeftActingDomain( <A>F</A> )</C> pointwise.
<P/>
Note that the field extension <M><A>F</A> > K</M> need <E>not</E> be
a Galois extension.
<Example><![CDATA[
gap> g:= GaloisGroup( AsField( GF(2^2), GF(2^12) ) );;
gap> Size( g );  IsCyclic( g );
6
true
gap> h:= GaloisGroup( CF(60) );;
gap> Size( h );  IsAbelian( h );
16
true
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="MinimalPolynomial" Arg='F, z[, ind]' Label="over a field"/>

<Description>
returns the minimal polynomial of <A>z</A> over the field <A>F</A>.
This is a generator of the ideal in <M><A>F</A>[x]</M> of all polynomials
which vanish on <A>z</A>.
(This definition is consistent with the general definition of
<Ref Func="MinimalPolynomial"/> for rings.)
<P/>
<Example><![CDATA[
gap> MinimalPolynomial( Rationals, E(8) );
x_1^4+1
gap> MinimalPolynomial( CF(4), E(8) );
x_1^2+(-E(4))
gap> MinimalPolynomial( CF(8), E(8) );
x_1+(-E(8))
]]></Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="TracePolynomial" Arg='L, K, z[, inum]'/>

<Description>
<Index Subkey="for field elements">characteristic polynomial</Index>
returns the polynomial that is the product of <M>(X - c)</M>
where <M>c</M> runs over the conjugates of <A>z</A>
in the field extension <A>L</A> over <A>K</A>.
The polynomial is returned as a univariate polynomial over <A>K</A>
in the indeterminate number <A>inum</A> (defaulting to 1).
<P/>
This polynomial is sometimes also called the
<E>characteristic polynomial</E> of <A>z</A> w.r.t.&nbsp;the field
extension <M><A>L</A> > <A>K</A></M>.
Therefore methods are installed for
<Ref Func="CharacteristicPolynomial"/>
that call <Ref Oper="TracePolynomial"/> in the case of field extensions.
<P/>
<Example><![CDATA[
gap> TracePolynomial( CF(8), Rationals, E(8) );
x_1^4+1
gap> TracePolynomial( CF(16), Rationals, E(8) );
x_1^8+2*x_1^4+1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Norm" Arg='[L, [K, ]]z'/>

<Description>
<Ref Func="Norm"/> returns the norm of the field element <A>z</A>.
If two fields <A>L</A> and <A>K</A> are given then the norm is computed
w.r.t.&nbsp;the field extension <A>L</A><M> > </M><A>K</A>,
if only one field <A>L</A> is given then
<C>LeftActingDomain( <A>L</A> )</C> is taken as
default for the subfield <A>K</A>,
and if no field is given then <C>DefaultField( <A>z</A> )</C> is taken
as default for <A>L</A>.
</Description>
</ManSection>

<ManSection>
<Heading>Traces of field elements and matrices</Heading>
<Attr Name="Trace" Arg='[L, [K, ]]z' Label="for a field element"/>
<Attr Name="Trace" Arg='mat' Label="for a matrix"/>

<Description>
<Ref Func="Trace" Label="for a field element"/> returns the trace of the
field element <A>z</A>.
If two fields <A>L</A> and <A>K</A> are given then the trace is computed
w.r.t.&nbsp;the field extension <M><A>L</A> > <A>K</A></M>,
if only one field <A>L</A> is given then
<C>LeftActingDomain( <A>L</A> )</C> is taken as
default for the subfield <A>K</A>,
and if no field is given then <C>DefaultField( <A>z</A> )</C> is taken
as default for <A>L</A>.
<P/>
The <E>trace of a matrix</E> is the sum of its diagonal entries.
Note that this is <E>not</E> compatible with the definition of
<Ref Func="Trace" Label="for a field element"/> for field elements,
so the one-argument version is not suitable when matrices shall be
regarded as field elements.
<!-- forbid <C>Trace</C> as short form for <C>TraceMat</C>?-->
<!-- crossref. to <C>TraceMat</C>?-->
</Description>
</ManSection>

<ManSection>
<Attr Name="Conjugates" Arg='[L, [K, ]]z'/>

<Description>
<Ref Func="Conjugates"/> returns the list of <E>conjugates</E>
of the field element <A>z</A>.
If two fields <A>L</A> and <A>K</A> are given then the conjugates are
computed w.r.t.&nbsp;the field extension <A>L</A><M> > </M><A>K</A>,
if only one field <A>L</A> is given then
<C>LeftActingDomain( <A>L</A> )</C> is taken as default for the subfield
<A>K</A>,
and if no field is given then <C>DefaultField( <A>z</A> )</C> is taken
as default for <A>L</A>.
<P/>
The result list will contain duplicates if <A>z</A> lies in a
proper subfield of <A>L</A>, or of the default field of <A>z</A>,
respectively.
The result list need not be sorted.
<P/>
<Example><![CDATA[
gap> Norm( E(8) );  Norm( CF(8), E(8) );
1
1
gap> Norm( CF(8), CF(4), E(8) );
-E(4)
gap> Norm( AsField( CF(4), CF(8) ), E(8) );
-E(4)
gap> Trace( E(8) );  Trace( CF(8), CF(8), E(8) );
0
E(8)
gap> Conjugates( CF(8), E(8) );
[ E(8), E(8)^3, -E(8), -E(8)^3 ]
gap> Conjugates( CF(8), CF(4), E(8) );
[ E(8), -E(8) ]
gap> Conjugates( CF(16), E(8) );
[ E(8), E(8)^3, -E(8), -E(8)^3, E(8), E(8)^3, -E(8), -E(8)^3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NormalBase" Arg='F[, elm]'/>

<Description>
Let <A>F</A> be a field that is a Galois extension of its subfield
<C>LeftActingDomain( <A>F</A> )</C>.
Then <Ref Func="NormalBase"/> returns a list of elements in <A>F</A>
that form a normal basis of <A>F</A>, that is,
a vector space basis that is closed under the action of the Galois group
(see&nbsp;<Ref Oper="GaloisGroup" Label="of field"/>) of <A>F</A>.
<P/>
If a second argument <A>elm</A> is given,
it is used as a hint for the algorithm to find a normal basis with the
algorithm described in&nbsp;<Cite Key="Art68"/>.
<Example><![CDATA[
gap> NormalBase( CF(5) );
[ -E(5), -E(5)^2, -E(5)^3, -E(5)^4 ]
gap> NormalBase( CF(4) );
[ 1/2-1/2*E(4), 1/2+1/2*E(4) ]
gap> NormalBase( GF(3^6) );
[ Z(3^6)^2, Z(3^6)^6, Z(3^6)^18, Z(3^6)^54, Z(3^6)^162, Z(3^6)^486 ]
gap> NormalBase( GF( GF(8), 2 ) );
[ Z(2^6), Z(2^6)^8 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- <Section Label="Field Homomorphisms"> -->
<!-- <Heading>Field Homomorphisms</Heading> -->
<!-- </Section> -->

</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  fieldfin.msk                  GAP documentation             Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: fieldfin.msk,v 1.27 2006/03/07 22:57:27 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Finite Fields">
<Heading>Finite Fields</Heading>

This chapter describes the special functionality which exists in &GAP; for
finite fields and their elements.
Of course the general functionality for fields
(see Chapter&nbsp;<Ref Chap="Fields and Division Rings"/>) also applies
to finite fields.
<P/>
In the following, the term <E>finite field element</E> is used to denote
&GAP; objects in the category <Ref Func="IsFFE"/>,
and <E>finite field</E> means a field consisting of such elements.
Note that in principle we must distinguish these fields from (abstract)
finite fields.
For example, the image of the embedding of a finite field into a field of
rational functions in the same characteristic is of course a finite field
but its elements are not in <Ref Func="IsFFE"/>,
and in fact &GAP; does currently not support such fields.
<P/>
Special representations exist for row vectors and matrices over small
finite fields
(see sections&nbsp;<Ref Sect="Row Vectors over Finite Fields"/>
and&nbsp;<Ref Sect="Matrices over Finite Fields"/>).


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finite Field Elements">
<Heading>Finite Field Elements</Heading>

<ManSection>
<Filt Name="IsFFE" Arg='obj' Type='Category'/>
<Filt Name="IsFFECollection" Arg='obj' Type='Category'/>
<Filt Name="IsFFECollColl" Arg='obj' Type='Category'/>
<Filt Name="IsFFECollCollColl" Arg='obj' Type='Category'/>

<Description>
Objects in the category <Ref Func="IsFFE"/> are used to implement
elements of finite fields.
In this manual, the term <E>finite field element</E> always means an
object in <Ref Func="IsFFE"/>.
All finite field elements of the same characteristic form a family in
&GAP; (see&nbsp;<Ref Sect="Families"/>).
Any collection of finite field elements
(see&nbsp;<Ref Func="IsCollection"/>) lies in
<Ref Func="IsFFECollection"/>, and a collection of such collections
(e.g., a matrix of finite field elements) lies in
<Ref Func="IsFFECollColl"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="Z" Arg='p^d' Label="for field size"/>
<Func Name="Z" Arg='p, d' Label="for prime and degree"/>

<Description>
For creating elements of a finite field,
the function <Ref Func="Z" Label="for field size"/> can be used.
The call <C>Z(<A>p</A>,<A>d</A>)</C>
(alternatively <C>Z(<A>p</A>^<A>d</A>)</C>)
returns the designated generator of the multiplicative group of the
finite field with <A>p^d</A> elements.
<A>p</A> must be a prime integer.
<P/>
&GAP; can represent elements of all finite fields
<C>GF(<A>p^d</A>)</C> such that either
(1) <A>p^d</A> <M>&lt;= 65536</M> (in which case an extremely efficient
    internal representation is used);
(2) d = 1, (in which case, for large <A>p</A>, the field is represented
    using the machinery of residue class rings
    (see section&nbsp;<Ref Sect="Residue Class Rings"/>) or
(3) if the Conway polynomial of degree <A>d</A> over the field with
    <A>p</A> elements is known, or can be computed
    (see <Ref Oper="ConwayPolynomial"/>).
<P/>
If you attempt to construct an element of <C>GF(<A>p^d</A>)</C> for which
<A>d</A> <M>> 1</M> and the relevant Conway polynomial is not known,
and not necessarily easy to find
(see <Ref Func="IsCheapConwayPolynomial"/>),
then &GAP; will stop with an error and enter the break loop.
If you leave this break loop by entering <C>return;</C>
&GAP; will attempt to compute the Conway polynomial,
which may take a very long time.
<P/>
The root returned by <Ref Func="Z" Label="for field size"/> is a
generator of the multiplicative group of the finite field with <A>p^d</A>
elements, which is cyclic.
The order of the element is of course <A>p^d</A> <M>-1</M>.
The <A>p^d</A> <M>-1</M> different powers of the root
are exactly the nonzero elements of the finite field.
<P/>
Thus all nonzero elements of the finite field with <A>p^d</A> elements
can be entered as <C>Z(<A>p^d</A>)^</C><M>i</M>.
Note that this is also the form that &GAP; uses to output those elements
when they are stored in the internal representation.
In larger fields, it is more convenient to enter and print elements as
linear combinations of powers of the primitive element, see section
<Ref Sect="Printing, Viewing and Displaying Finite Field Elements"/>.
<P/>
The additive neutral element is <C>0 * Z(<A>p</A>)</C>.
It is different from the integer <C>0</C> in subtle ways.
First <C>IsInt( 0 * Z(<A>p</A>)  )</C> (see <Ref Func="IsInt"/>) is
<K>false</K> and <C>IsFFE( 0 * Z(<A>p</A>) )</C>
(see <Ref Func="IsFFE"/>) is <K>true</K>, whereas it is
just the other way around for the integer <C>0</C>.
<P/>
The multiplicative neutral element is <C>Z(<A>p</A>)^0</C>.
It is different from the integer <C>1</C> in subtle ways.
First <C>IsInt( Z(<A>p</A>)^0 )</C> (see <Ref Func="IsInt"/>)
is <K>false</K> and <C>IsFFE( Z(<A>p</A>)^0 )</C>
(see <Ref Func="IsFFE"/>) is <K>true</K>, whereas it
is just the other way around for the integer <C>1</C>.
Also <C>1+1</C> is <C>2</C>,
whereas, e.g., <C>Z(2)^0 + Z(2)^0</C> is <C>0 * Z(2)</C>.
<P/>
The various roots returned by <Ref Func="Z" Label="for field size"/>
for finite fields of the same characteristic are compatible in the
following sense.
If the field <C>GF(<A>p</A>,</C><M>n</M><C>)</C> is a subfield of the
field <C>GF(<A>p</A>,</C><M>m</M><C>)</C>, i.e.,
<M>n</M> divides <M>m</M>,
then <C>Z</C><M>(<A>p</A>^n) =
</M><C>Z</C><M>(<A>p</A>^m)^{{(<A>p</A>^m-1)/(<A>p</A>^n-1)}}</M>.
Note that this is the simplest relation that may hold between a generator
of <C>GF(<A>p</A>,</C><M>n</M><C>)</C> and
<C>GF(<A>p</A>,</C><M>m</M><C>)</C>,
since <C>Z</C><M>(<A>p</A>^n)</M> is an element of order
<M><A>p</A>^m-1</M> and <C>Z</C><M>(<A>p</A>^m)</M> is an element
of order <M><A>p</A>^n-1</M>.
This is achieved  by choosing <C>Z(<A>p</A>)</C> as the smallest
primitive root modulo <A>p</A> and <C>Z(</C><A>p^n</A><C>)</C> as a root
of the <M>n</M>-th <E>Conway polynomial</E>
(see&nbsp;<Ref Func="ConwayPolynomial"/>) of characteristic <A>p</A>.
Those polynomials were defined by J.&nbsp;H.&nbsp;Conway,
and many of them were computed by R.&nbsp;A.&nbsp;Parker.
<P/>
<Example><![CDATA[
gap> a:= Z( 32 );
Z(2^5)
gap> a+a;
0*Z(2)
gap> a*a;
Z(2^5)^2
gap> b := Z(3,12);
z
gap> b*b;
z2
gap> b+b;
2z
gap> Print(b^100,"\n");
Z(3)^0+Z(3,12)^5+Z(3,12)^6+2*Z(3,12)^8+Z(3,12)^10+Z(3,12)^11
]]></Example>
<Log><![CDATA[
gap> Z(11,40);
Error, Conway Polynomial 11^40 will need to computed and might be slow
return to continue called from
FFECONWAY.ZNC( p, d ) called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk>
]]></Log>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLexOrderedFFE" Arg='ffe' Type='Category'/>
<Filt Name="IsLogOrderedFFE" Arg='ffe' Type='Category'/>

<Description>
Elements of finite fields can be compared using the operators <C>=</C>
and <C>&lt;</C>.
The call <C><A>a</A> = <A>b</A></C> returns <K>true</K> if and only if
the finite field elements <A>a</A> and <A>b</A> are equal.
Furthermore <C><A>a</A> &lt; <A>b</A></C> tests whether <A>a</A> is
smaller than <A>b</A>.
The exact behaviour of this comparison depends on which of two categories
the field elements belong to:
<P/>
Finite field elements are ordered in &GAP; (by <Ref Func="\&lt;"/>)
first by characteristic and then by their degree
(i.e. the sizes of the smallest fields containing them).
Amongst irreducible elements of a given field, the ordering 
depends on which of these categories the elements of the field belong to
(all irreducible elements of a given field should belong to the same one)
<P/>
Elements in <Ref Filt="IsLexOrderedFFE"/> are ordered lexicographically
by their coefficients with respect to the canonical basis of the field.
<P/>
Elements in <Ref Filt="IsLogOrderedFFE"/> are ordered according to their
discrete logarithms with respect to the <Ref Func="PrimitiveElement"/>
attribute of the field.
For the comparison of finite field elements with other &GAP; objects,
see&nbsp;<Ref Sect="Comparisons"/>.
<P/>
<Example><![CDATA[
gap> Z( 16 )^10 = Z( 4 )^2;  # illustrates embedding of GF(4) in GF(16)
true
gap> 0 < 0*Z(101);
true
gap> Z(256) > Z(101);
false
gap> Z(2,20) < Z(2,20)^2; # this illustrates the lexicographic ordering
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Finite Field Elements">
<Heading>Operations for Finite Field Elements</Heading>

Since finite field elements are scalars,
the operations <Ref Func="Characteristic"/>,
<Ref Func="One"/>, <Ref Func="Zero"/>, <Ref Func="Inverse"/>,
<Ref Func="AdditiveInverse"/>, <Ref Func="Order"/> can be applied to
them (see&nbsp;<Ref Sect="Attributes and Properties of Elements"/>).
Contrary to the situation with other scalars,
<Ref Attr="Order"/> is defined also for the zero element
in a finite field, with value <C>0</C>.
<P/>
<Example><![CDATA[
gap> Characteristic( Z( 16 )^10 );  Characteristic( Z( 9 )^2 );
2
3
gap> Characteristic( [ Z(4), Z(8) ] );
2
gap> One( Z(9) );  One( 0*Z(4) );
Z(3)^0
Z(2)^0
gap> Inverse( Z(9) );  AdditiveInverse( Z(9) );
Z(3^2)^7
Z(3^2)^5
gap> Order( Z(9)^7 );
8
]]></Example>

<ManSection>
<Oper Name="DegreeFFE" Arg='z' Label="for a FFE"/>
<Oper Name="DegreeFFE" Arg='vec' Label="for a vector of FFEs"/>
<Oper Name="DegreeFFE" Arg='mat' Label="for a matrix of FFEs"/>

<Description>
<Ref Func="DegreeFFE" Label="for a FFE"/> returns the degree of the
smallest finite field <A>F</A> containing the element <A>z</A>,
respectively all elements of the row vector <A>vec</A> over a finite
field (see&nbsp;<Ref Chap="Row Vectors"/>),
or the matrix <A>mat</A> over a finite field
(see&nbsp;<Ref Chap="Matrices"/>).
<P/>
<Example><![CDATA[
gap> DegreeFFE( Z( 16 )^10 );
2
gap> DegreeFFE( Z( 16 )^11 );
4
gap> DegreeFFE( [ Z(2^13), Z(2^10) ] );
130
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LogFFE" Arg='z, r'/>

<Description>
<Ref Func="LogFFE"/> returns the discrete logarithm of the element
<A>z</A> in a finite field with respect to the root <A>r</A>.
An error is signalled if <A>z</A> is zero.
<K>fail</K> is returned if <A>z</A> is not a power of <A>r</A>.
<P/>
The <E>discrete logarithm</E> of the element <A>z</A> with respect to
the root <A>r</A> is the smallest nonnegative integer <M>i</M> such that
<M><A>r</A>^i = <A>z</A></M> holds.
<P/>
<Example><![CDATA[
gap> LogFFE( Z(409)^116, Z(409) );  LogFFE( Z(409)^116, Z(409)^2 );
116
58
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IntFFE" Arg='z'/>
<Meth Name="Int" Arg='z' Label="for a FFE"/>

<Description>
<Ref Attr="IntFFE"/> returns the integer corresponding to the element
<A>z</A>, which must lie in a finite prime field.
That is, <Ref Attr="IntFFE"/> returns the smallest nonnegative integer
<M>i</M> such that <M>i</M><C> * One( </C><A>z</A><C> ) = </C><A>z</A>.
<P/>
The  correspondence between elements from a finite prime field of
characteristic <M>p</M> (for <M>p &lt; 2^{16}</M>) and the integers
between <M>0</M> and <M>p-1</M> is defined by
choosing <C>Z(</C><M>p</M><C>)</C> the element corresponding to the
smallest primitive root mod <M>p</M>
(see&nbsp;<Ref Func="PrimitiveRootMod"/>).
<P/>
<Ref Attr="IntFFE"/> is installed as a method for the operation
<Ref Func="Int"/> with argument a finite field element.
<P/>
<Example><![CDATA[
gap> IntFFE( Z(13) );  PrimitiveRootMod( 13 );
2
2
gap> IntFFE( Z(409) );
21
gap> IntFFE( Z(409)^116 );  21^116 mod 409;
311
311
]]></Example>

See also <Ref Attr="IntFFESymm" Label="for a FFE"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="IntFFESymm" Arg='z' Label="for a FFE"/>
<Attr Name="IntFFESymm" Arg='vec' Label="for a vector of FFEs"/>

<Description>
For a finite prime field element <A>z</A>,
<Ref Func="IntFFESymm" Label="for a FFE"/> returns the corresponding
integer of smallest absolute value.
That is, <Ref Func="IntFFESymm" Label="for a FFE"/> returns the integer
<M>i</M> of smallest absolute value such that
<M>i</M><C> * One( </C><A>z</A><C> ) = </C><A>z</A> holds.
<P/>
For a vector <A>vec</A> of FFEs, the operation returns the result of
applying <Ref Func="IntFFESymm" Label="for a vector of FFEs"/>
to every entry of the vector.
<P/>
The  correspondence between elements from a finite prime field of
characteristic <M>p</M> (for <M>p &lt; 2^{16}</M>) and the integers
between <M>-p/2</M> and <M>p/2</M> is defined by
choosing <C>Z(</C><M>p</M><C>)</C> the element corresponding to the
smallest positive primitive root mod <M>p</M>
(see&nbsp;<Ref Func="PrimitiveRootMod"/>) and reducing results to the
<M>-p/2 .. p/2</M> range.
<P/>
<Example><![CDATA[
gap> IntFFE(Z(13)^2);IntFFE(Z(13)^3);
4
8
gap> IntFFESymm(Z(13)^2);IntFFESymm(Z(13)^3);
4
-5
]]></Example>

See also <Ref Attr="IntFFE"/>
</Description>
</ManSection>

<ManSection>
<Oper Name="IntVecFFE" Arg='vecffe'/>

<Description>
is the list of integers corresponding to the vector <A>vecffe</A> of
finite field elements in a prime field (see&nbsp;<Ref Func="IntFFE"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="AsInternalFFE" Arg='ffe'/>

<Description>
return an internal FFE equal to <A>ffe</A> if one exists, otherwise <C>fail</C>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Finite Fields">
<Heading>Creating Finite Fields</Heading>

<ManSection>
<Meth Name="DefaultField" Arg='list' Label="for finite field elements"/>
<Meth Name="DefaultRing" Arg='list' Label="for finite field elements"/>

<Description>
<Ref Func="DefaultField" Label="for finite field elements"/> and
<Ref Func="DefaultRing" Label="for finite field elements"/>
for finite field elements are defined to return the <E>smallest</E> field
containing the given elements.
<P/>
<Example><![CDATA[
gap> DefaultField( [ Z(4), Z(4)^2 ] );  DefaultField( [ Z(4), Z(8) ] );
GF(2^2)
GF(2^6)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GaloisField" Arg='p^d' Label="for field size"/>
<Func Name="GF" Arg='p^d' Label="for field size"/>
<Func Name="GaloisField" Arg='p, d'
 Label="for characteristic and degree"/>
<Func Name="GF" Arg='p, d' Label="for characteristic and degree"/>
<Func Name="GaloisField" Arg='subfield, d'
 Label="for subfield and degree"/>
<Func Name="GF" Arg='subfield, d' Label="for subfield and degree"/>
<Func Name="GaloisField" Arg='p, pol'
 Label="for characteristic and polynomial"/>
<Func Name="GF" Arg='p, pol' Label="for characteristic and polynomial"/>
<Func Name="GaloisField" Arg='subfield, pol'
 Label="for subfield and polynomial"/>
<Func Name="GF" Arg='subfield, pol' Label="for subfield and polynomial"/>

<Description>
<Ref Func="GaloisField" Label="for field size"/> returns a finite field.
It takes two arguments.
The form <C>GaloisField( <A>p</A>, <A>d</A> )</C>,
where <A>p</A>, <A>d</A> are integers,
can also be given as <C>GaloisField( <A>p</A>^<A>d</A> )</C>.
<Ref Func="GF" Label="for field size"/> is an abbreviation for
<Ref Func="GaloisField" Label="for field size"/>.
<P/>
The first argument specifies the subfield <M>S</M> over which the new
field is to be taken.
It can be a prime integer or a finite field.
If it is a prime <A>p</A>, the subfield is the prime field of this
characteristic.
<P/>
The second argument specifies the extension.
It can be an integer or an irreducible polynomial over the field
<M>S</M>.
If it is an integer <A>d</A>, the new field is constructed as the
polynomial extension w.r.t. the Conway polynomial
(see&nbsp;<Ref Func="ConwayPolynomial"/>)
of degree <A>d</A> over <M>S</M>.
If it is an irreducible polynomial <A>pol</A> over <M>S</M>,
the new field is constructed as polynomial extension of <M>S</M>
with this polynomial;
in this case, <A>pol</A> is accessible as the value of
<Ref Func="DefiningPolynomial"/> for the new field,
and a root of <A>pol</A> in the new field is accessible as the value of
<Ref Func="RootOfDefiningPolynomial"/>.
<P/>
Note that the subfield over which a field was constructed determines over
which  field  the  Galois  group,  conjugates,   norm,   trace,   minimal
polynomial, and trace polynomial are  computed
(see&nbsp;<Ref Oper="GaloisGroup" Label="of field"/>,
<Ref Func="Conjugates"/>, <Ref Func="Norm"/>,
<Ref Attr="Trace" Label="for a field element"/>,
<Ref Oper="MinimalPolynomial" Label="over a field"/>,
<Ref Func="TracePolynomial"/>).
<P/>
The field is regarded as a vector space
(see&nbsp;<Ref Chap="Vector Spaces"/>) over the given subfield,
so this determines the dimension and the canonical basis of the field.
<P/>
<Example><![CDATA[
gap> f1:= GF( 2^4 );
GF(2^4)
gap> Size( GaloisGroup ( f1 ) );
4
gap> BasisVectors( Basis( f1 ) );
[ Z(2)^0, Z(2^4), Z(2^4)^2, Z(2^4)^3 ]
gap> f2:= GF( GF(4), 2 );
AsField( GF(2^2), GF(2^4) )
gap> Size( GaloisGroup( f2 ) );
2
gap> BasisVectors( Basis( f2 ) );
[ Z(2)^0, Z(2^4) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PrimitiveRoot" Arg='F'/>

<Description>
A <E>primitive root</E> of a finite field is a generator of its
multiplicative group.
A primitive root is always a primitive element
(see&nbsp;<Ref Func="PrimitiveElement"/>),
the converse is in general not true.
<!-- % For example, <C>Z(9)^2</C> is a primitive element for <C>GF(9)</C> but not a -->
<!-- % primitive root. -->
<Example><![CDATA[
gap> f:= GF( 3^5 );
GF(3^5)
gap> PrimitiveRoot( f );
Z(3^5)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Frobenius Automorphisms">
<Heading>Frobenius Automorphisms</Heading>

<ManSection>
<Attr Name="FrobeniusAutomorphism" Arg='F'/>

<Description>
<Index Subkey="Frobenius, field">homomorphisms</Index>
<Index Subkey="Frobenius">field homomorphisms</Index>
<Index Key="CompositionMapping" Subkey="for Frobenius automorphisms">
<C>CompositionMapping</C></Index>
returns the Frobenius automorphism of the finite field <A>F</A>
as a field homomorphism (see&nbsp;<Ref Sect="Ring Homomorphisms"/>).
<P/>
<Index>Frobenius automorphism</Index>
The <E>Frobenius automorphism</E> <M>f</M> of a finite field <M>F</M> of
characteristic <M>p</M> is the function that takes each element <M>z</M>
of <M>F</M> to its <M>p</M>-th power.
Each field automorphism of <M>F</M> is a power of <M>f</M>.
Thus <M>f</M> is a generator for the Galois group of <M>F</M> relative to
the prime field of <M>F</M>,
and an appropriate power of <M>f</M> is a generator of the Galois group
of <M>F</M> over a subfield
(see&nbsp;<Ref Oper="GaloisGroup" Label="of field"/>).
<P/>
<Example><![CDATA[
gap> f := GF(16);
GF(2^4)
gap> x := FrobeniusAutomorphism( f );
FrobeniusAutomorphism( GF(2^4) )
gap> Z(16) ^ x;
Z(2^4)^2
gap> x^2;
FrobeniusAutomorphism( GF(2^4) )^2
]]></Example>
<P/>
<Index Key="Image" Subkey="for Frobenius automorphisms"><C>Image</C>
</Index>
The image of an element <M>z</M> under the <M>i</M>-th power of <M>f</M>
is computed as the <M>p^i</M>-th power of <M>z</M>.
The product of the <M>i</M>-th power and the <M>j</M>-th power of
<M>f</M> is the <M>k</M>-th power of <M>f</M>, where <M>k</M> is
<M>i j \bmod </M> <C>Size(<A>F</A>)</C><M>-1</M>.
The zeroth power of <M>f</M> is <C>IdentityMapping( <A>F</A> )</C>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Conway Polynomials">
<Heading>Conway Polynomials</Heading>

<ManSection>
<Func Name="ConwayPolynomial" Arg='p, n'/>

<Description>
is the Conway polynomial of the finite field <M>GF(p^n)</M> as
polynomial over the prime field in characteristic <A>p</A>.
<P/>
The <E>Conway polynomial</E> <M>\Phi_{{n,p}}</M> of <M>GF(p^n)</M>
is defined by the following properties.
<P/>
First define an ordering of polynomials of degree <M>n</M> over
<M>GF(p)</M>, as follows.
<M>f = \sum_{{i = 0}}^n (-1)^i f_i x^i</M> is smaller than
<M>g = \sum_{{i = 0}}^n (-1)^i g_i x^i</M> if and only if there is an index
<M>m \leq n</M> such that <M>f_i = g_i</M> for all <M>i > m</M>, and
<M>\tilde{{f_m}} &lt; \tilde{{g_m}}</M>,
where <M>\tilde{{c}}</M> denotes the integer value in
<M>\{ 0, 1, \ldots, p-1 \}</M> that is mapped to <M>c \in GF(p)</M> under
the canonical epimorphism that maps the integers onto <M>GF(p)</M>.
<P/>
<M>\Phi_{{n,p}}</M> is <E>primitive</E> over <M>GF(p)</M>
(see&nbsp;<Ref Func="IsPrimitivePolynomial"/>).
That is, <M>\Phi_{{n,p}}</M> is irreducible, monic,
and is the minimal polynomial of a primitive root of <M>GF(p^n)</M>.
<P/>
For all divisors <M>d</M> of <M>n</M> the compatibility condition
<M>\Phi_{{d,p}}( x^{{\frac{{p^n-1}}{{p^m-1}}}} ) \equiv 0
\pmod{{\Phi_{{n,p}}(x)}}</M>
holds. (That is, the appropriate power of a zero of <M>\Phi_{{n,p}}</M>
is a zero of the Conway polynomial <M>\Phi_{{d,p}}</M>.)
<P/>
With respect to the ordering defined above, <M>\Phi_{{n,p}}</M> shall be
minimal.
<P/>
The computation of Conway polynomials can be time consuming. Therefore,
&GAP; comes with a list of precomputed polynomials. If a requested
polynomial is not stored then &GAP; prints a warning and computes it by
checking all polynomials in the order defined above for the defining
conditions.
If <M>n</M> is not a prime this is probably a very long computation.
(Some previously known polynomials with prime <M>n</M> are not stored in
&GAP; because they are quickly recomputed.)
Use the function <Ref Func="IsCheapConwayPolynomial"/> to check in
advance if <Ref Func="ConwayPolynomial"/> will give a result after a
short time.
<P/>
Note that primitivity of a polynomial can only be checked if &GAP; can
factorize <M>p^n-1</M>.
A sufficiently new version of the <Package>FactInt</Package>
package contains many precomputed factors of such numbers from various
factorization projects.
<P/>
See&nbsp;<Cite Key="L03"/> for further information on known
Conway polynomials.
<P/>
An interactive overview of the Conway polynomials known to &GAP; is
provided by the function <C>BrowseConwayPolynomials</C> from the
&GAP; package <Package>Browse</Package>,
see <Ref Func="BrowseGapData" BookName="browse"/>.
<P/>
<Index Key="InfoText"
       Subkey="(for Conway polynomials)"><C>InfoText</C></Index>
If <A>pol</A> is a result returned by <Ref Func="ConwayPolynomial"/> the
command <C>Print( InfoText( <A>pol</A> ) );</C> will print some info on
the origin of that particular polynomial.
<P/>
For some purposes it may be enough to have any primitive polynomial for
an extension of a finite field instead of the Conway polynomial, 
see&nbsp;<Ref Func="RandomPrimitivePolynomial"/> below.
<Example><![CDATA[
gap> ConwayPolynomial( 2, 5 );  ConwayPolynomial( 3, 7 );
x_1^5+x_1^2+Z(2)^0
x_1^7-x_1^2+Z(3)^0
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsCheapConwayPolynomial" Arg='p, n'/>

<Description>
Returns <K>true</K> if <C>ConwayPolynomial( <A>p</A>, <A>n</A> )</C>
will give a result in <E>reasonable</E> time.
This is either the case when this polynomial is pre-computed,
or if <A>n</A> is a not too big prime.
</Description>
</ManSection>

<ManSection>
<Func Name="RandomPrimitivePolynomial" Arg='F, n[, i ]'/>

<Description>
For a finite field <A>F</A> and a positive integer <A>n</A> this function
returns a primitive polynomial of degree <A>n</A> over <A>F</A>,
that is a zero of  this polynomial has maximal multiplicative order
<M>|<A>F</A>|^n-1</M>. 
If <A>i</A> is given then the polynomial is written in variable number
<A>i</A> over <A>F</A>
(see&nbsp;<Ref Func="Indeterminate" Label="for a ring (and a number)"/>),
the default for <A>i</A> is 1.
<P/>
Alternatively, <A>F</A> can be a prime power q, then <A>F</A> = GF(q) is
assumed.
And <A>i</A> can be a univariate polynomial over <A>F</A>,
then the result is a polynomial in the same variable.
<P/>
This function can work for much larger fields than those for which
Conway polynomials are available, of course &GAP; must be able to
factorize <M>|<A>F</A>|^n-1</M>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Printing, Viewing and Displaying Finite Field Elements">
<Heading>Printing, Viewing and Displaying Finite Field Elements</Heading>

<ManSection>
<Meth Name="ViewObj" Arg="z" Label="for a ffe"/>
<Meth Name="PrintObj" Arg="z" Label="for a ffe"/>
<Meth Name="Display" Arg="z" Label="for a ffe"/>

<Description>
Internal finite field elements are viewed, printed and displayed (see
section <Ref Sect="View and Print"/> for the distinctions between these
operations) as powers of the primitive root (except for the zero
element, which is displayed as 0 times the primitive root). Thus:
<P/>
<Example><![CDATA[
gap> Z(2);
Z(2)^0
gap> Z(5)+Z(5);
Z(5)^2
gap> Z(256);
Z(2^8)
gap> Zero(Z(125));
0*Z(5)
]]></Example>
<P/>
Note also that each element is displayed as an element of the field it
generates, and that the size of the field is printed as a power
of the characteristic.
<P/>
Elements of larger fields are printed as &GAP; expressions which
represent them as sums of low powers of the primitive root:
<P/>
<Example><![CDATA[
gap> Print( Z(3,20)^100, "\n" );
2*Z(3,20)^2+Z(3,20)^4+Z(3,20)^6+Z(3,20)^7+2*Z(3,20)^9+2*Z(3,20)^10+2*Z\
(3,20)^12+2*Z(3,20)^15+2*Z(3,20)^17+Z(3,20)^18+Z(3,20)^19
gap> Print( Z(3,20)^((3^20-1)/(3^10-1)), "\n" );
Z(3,20)^3+2*Z(3,20)^4+2*Z(3,20)^7+Z(3,20)^8+2*Z(3,20)^10+Z(3,20)^11+2*\
Z(3,20)^12+Z(3,20)^13+Z(3,20)^14+Z(3,20)^15+Z(3,20)^17+Z(3,20)^18+2*Z(\
3,20)^19
gap> Z(3,20)^((3^20-1)/(3^10-1)) = Z(3,10);
true
]]></Example>
<P/>
Note from the second example above, that these elements are not always
written over the smallest possible field before being output.
<P/>
The <Ref Func="ViewObj" Label="for a ffe"/> and
<Ref Func="Display" Label="for a ffe"/> methods
for these large finite field elements use a slightly more compact,
but mathematically equivalent representation.
The primitive root is represented by <C>z</C>; its <M>i</M>-th power by
<C>z</C><M>i</M> and <M>k</M> times this power by <M>k</M><C>z</C><M>i</M>. 
<P/>
<Example><![CDATA[
gap> Z(5,20)^100;
z2+z4+4z5+2z6+z8+3z9+4z10+3z12+z13+2z14+4z16+3z17+2z18+2z19
]]></Example>
<P/>
This output format is always used for <Ref Func="Display" Label="for a ffe"/>.
For <Ref Func="ViewObj" Label="for a ffe"/> it is used only if its length
would not exceed the number of lines specified in the user preference 
<C>ViewLength</C> (see <Ref Func="SetUserPreference"/>. Longer output is 
replaced by <C>&lt;&lt;an element of GF(<A>p</A>, <A>d</A>)>></C>.
<P/>
<Example><![CDATA[
gap> Z(2,409)^100000;
<<an element of GF(2, 409)>>
gap> Display(Z(2,409)^100000);
z2+z3+z4+z5+z6+z7+z8+z10+z11+z13+z17+z19+z20+z29+z32+z34+z35+z37+z40+z\
45+z46+z48+z50+z52+z54+z55+z58+z59+z60+z66+z67+z68+z70+z74+z79+z80+z81\
+z82+z83+z86+z91+z93+z94+z95+z96+z98+z99+z100+z101+z102+z104+z106+z109\
+z110+z112+z114+z115+z118+z119+z123+z126+z127+z135+z138+z140+z142+z143\
+z146+z147+z154+z159+z161+z162+z168+z170+z171+z173+z174+z181+z182+z183\
+z186+z188+z189+z192+z193+z194+z195+z196+z199+z202+z204+z205+z207+z208\
+z209+z211+z212+z213+z214+z215+z216+z218+z219+z220+z222+z223+z229+z232\
+z235+z236+z237+z238+z240+z243+z244+z248+z250+z251+z256+z258+z262+z263\
+z268+z270+z271+z272+z274+z276+z282+z286+z288+z289+z294+z295+z299+z300\
+z301+z302+z303+z304+z305+z306+z307+z308+z309+z310+z312+z314+z315+z316\
+z320+z321+z322+z324+z325+z326+z327+z330+z332+z335+z337+z338+z341+z344\
+z348+z350+z352+z353+z356+z357+z358+z360+z362+z364+z366+z368+z372+z373\
+z374+z375+z378+z379+z380+z381+z383+z384+z386+z387+z390+z395+z401+z402\
+z406+z408
]]></Example>
<P/>
Finally note that elements of large prime fields are stored and
displayed as residue class objects. So
<P/>
<Example><![CDATA[
gap> Z(65537);
ZmodpZObj( 3, 65537 )
]]></Example>
</Description>
</ManSection>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  fldabnum.msk                 GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: fldabnum.msk,v 1.12 2003/10/28 07:47:33 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Abelian Number Fields">
<Heading>Abelian Number Fields</Heading>

An <E>abelian number field</E> is a field in characteristic zero
that is a finite dimensional normal extension of its prime field
such that the Galois group is abelian.
In &GAP;, one implementation of abelian number fields is given by fields
of cyclotomic numbers (see Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/>).
Note that abelian number fields can also be constructed with
the more general <Ref Func="AlgebraicExtension"/>,
a discussion of advantages and disadvantages can be found
in&nbsp;<Ref Sect="Internally Represented Cyclotomics"/>.
The functions described in this chapter have been developed for fields
whose elements are in the filter <Ref Func="IsCyclotomic"/>,
they may or may not work well for abelian number fields consisting of
other kinds of elements.
<P/>
Throughout this chapter, <M>&QQ;_n</M> will denote the cyclotomic field
generated by the field <M>&QQ;</M> of rationals together with <M>n</M>-th
roots of unity.
<P/>
In&nbsp;<Ref Sect="Construction of Abelian Number Fields"/>,
constructors for abelian number fields are described,
<Ref Sect="Operations for Abelian Number Fields"/> introduces operations
for abelian number fields,
<Ref Sect="Integral Bases of Abelian Number Fields"/> deals with the
vector space structure of abelian number fields, and
<Ref Sect="Galois Groups of Abelian Number Fields"/> describes field
automorphisms of abelian number fields,
<!-- % section about Gaussians here? -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Construction of Abelian Number Fields">
<Heading>Construction of Abelian Number Fields</Heading>

Besides the usual construction using
<Ref Func="Field" Label="for several generators"/> or
<Ref Func="DefaultField" Label="for cyclotomics"/>
(see&nbsp;<Ref Meth="DefaultField" Label="for cyclotomics"/>),
abelian number fields consisting of cyclotomics can be created with
<Ref Func="CyclotomicField" Label="for (subfield and) conductor"/>
and <Ref Func="AbelianNumberField"/>.

<ManSection>
<Func Name="CyclotomicField" Arg='[subfield, ]n'
 Label="for (subfield and) conductor"/>
<Func Name="CyclotomicField" Arg='[subfield, ]gens'
 Label="for (subfield and) generators"/>
<Func Name="CF" Arg='[subfield, ]n'
 Label="for (subfield and) conductor"/>
<Func Name="CF" Arg='[subfield, ]gens'
 Label="for (subfield and) generators"/>

<Description>
The first version creates the <A>n</A>-th cyclotomic field <M>&QQ;_n</M>.
The second version creates the smallest cyclotomic field containing the
elements in the list <A>gens</A>.
In both cases the field can be generated as an extension of a designated
subfield <A>subfield</A>
(cf.&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>).
<P/>
<Ref Func="CyclotomicField" Label="for (subfield and) conductor"/> can be
abbreviated to <Ref Func="CF" Label="for (subfield and) conductor"/>,
this form is used also when &GAP; prints cyclotomic fields.
<P/>
Fields constructed with the one argument version of
<Ref Func="CF" Label="for (subfield and) conductor"/>
are stored in the global list <C>CYCLOTOMIC_FIELDS</C>,
so repeated calls of
<Ref Func="CF" Label="for (subfield and) conductor"/> just fetch these
field objects after they have been created once.
<!--  The cache can be flushed by ...-->
<P/>
<Example><![CDATA[
gap> CyclotomicField( 5 );  CyclotomicField( [ Sqrt(3) ] );
CF(5)
CF(12)
gap> CF( CF(3), 12 );  CF( CF(4), [ Sqrt(7) ] );
AsField( CF(3), CF(12) )
AsField( GaussianRationals, CF(28) )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AbelianNumberField" Arg='n, stab'/>
<Func Name="NF" Arg='n, stab'/>

<Description>
For a positive integer <A>n</A> and a list <A>stab</A> of prime residues
modulo <A>n</A>,
<Ref Func="AbelianNumberField"/> returns the fixed field of the group
described by <A>stab</A> (cf.&nbsp;<Ref Func="GaloisStabilizer"/>),
in the <A>n</A>-th cyclotomic field.
<Ref Func="AbelianNumberField"/> is mainly thought for internal use
and for printing fields in a standard way;
<Ref Func="Field" Label="for several generators"/>
(cf.&nbsp;also&nbsp;<Ref Sect="Operations for Abelian Number Fields"/>)
is probably more suitable if one knows generators of the field in
question.
<P/>
<Ref Func="AbelianNumberField"/> can be abbreviated to <Ref Func="NF"/>,
this form is used also when &GAP; prints abelian number fields.
<P/>
Fields constructed with <Ref Func="NF"/> are stored in the global list
<C>ABELIAN_NUMBER_FIELDS</C>,
so repeated calls of <Ref Func="NF"/> just fetch these field objects
after they have been created once.
<!--  The cache can be flushed by ...-->
<P/>
<Example><![CDATA[
gap> NF( 7, [ 1 ] );
CF(7)
gap> f:= NF( 7, [ 1, 2 ] );  Sqrt(-7); Sqrt(-7) in f;
NF(7,[ 1, 2, 4 ])
E(7)+E(7)^2-E(7)^3+E(7)^4-E(7)^5-E(7)^6
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="GaussianRationals"/>
<Filt Name="IsGaussianRationals" Arg='obj' Type='Category'/>

<Description>
<Ref Func="GaussianRationals"/> is the field
<M>&QQ;_4 = &QQ;(\sqrt{{-1}})</M> of Gaussian rationals,
as a set of cyclotomic numbers,
see Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/> for basic operations.
This field can also be obtained as <C>CF(4)</C>
(see <Ref Func="CyclotomicField" Label="for (subfield and) conductor"/>).
<P/>
The filter <Ref Func="IsGaussianRationals"/> returns <K>true</K> for the
&GAP; object <Ref Var="GaussianRationals"/>,
and <K>false</K> for all other &GAP; objects.
<P/>
(For details about the field of rationals,
see Chapter&nbsp;<Ref Func="Rationals"/>.)
<P/>
<Example><![CDATA[
gap> CF(4) = GaussianRationals;
true
gap> Sqrt(-1) in GaussianRationals;
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Abelian Number Fields">
<Heading>Operations for Abelian Number Fields</Heading>

For operations for elements of abelian number fields, e.g.,
<Ref Func="Conductor" Label="for a cyclotomic"/> or
<Ref Func="ComplexConjugate"/>,
see Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/>.

<ManSection>
<Meth Name="Factors" Arg='F'
 Label="for polynomials over abelian number fields"/>

<Description>
Factoring of polynomials over abelian number fields consisting of cyclotomics
works in principle but is not very efficient if the degree of the field
extension is large.
<P/>
<Example><![CDATA[
gap> x:= Indeterminate( CF(5) );
x_1
gap> Factors( PolynomialRing( Rationals ), x^5-1 );
[ x_1-1, x_1^4+x_1^3+x_1^2+x_1+1 ]
gap> Factors( PolynomialRing( CF(5) ), x^5-1 );
[ x_1-1, x_1+(-E(5)), x_1+(-E(5)^2), x_1+(-E(5)^3), x_1+(-E(5)^4) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNumberField" Arg='F'/>

<Description>
<Index>number field</Index>
returns <K>true</K> if the field <A>F</A> is a finite dimensional
extension of a prime field in characteristic zero,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsAbelianNumberField" Arg='F'/>

<Description>
<Index>abelian number field</Index>
returns <K>true</K> if the field <A>F</A> is a number field
(see&nbsp;<Ref Func="IsNumberField"/>)
that is a Galois extension of the prime field, with abelian Galois group
(see&nbsp;<Ref Oper="GaloisGroup" Label="of field"/>).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsCyclotomicField" Arg='F'/>

<Description>
returns <K>true</K> if the field <A>F</A> is a <E>cyclotomic field</E>,
i.e., an abelian number field
(see&nbsp;<Ref Func="IsAbelianNumberField"/>)
that can be generated by roots of unity.
<P/>
<Example><![CDATA[
gap> IsNumberField( CF(9) ); IsAbelianNumberField( Field( [ ER(3) ] ) );
true
true
gap> IsNumberField( GF(2) );
false
gap> IsCyclotomicField( CF(9) );
true
gap> IsCyclotomicField( Field( [ Sqrt(-3) ] ) );
true
gap> IsCyclotomicField( Field( [ Sqrt(3) ] ) );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GaloisStabilizer" Arg='F'/>

<Description>
Let <A>F</A> be an abelian number field
(see&nbsp;<Ref Func="IsAbelianNumberField"/>) with conductor <M>n</M>,
say.
(This means that the <M>n</M>-th cyclotomic field is the smallest
cyclotomic field containing <A>F</A>,
see&nbsp;<Ref Func="Conductor" Label="for a cyclotomic"/>.)
<Ref Func="GaloisStabilizer"/> returns the set of all those integers
<M>k</M> in the range <M>[ 1 .. n ]</M> such that the field automorphism
induced by raising <M>n</M>-th roots of unity to the <M>k</M>-th power
acts trivially on <A>F</A>.
<P/>
<Example><![CDATA[
gap> r5:= Sqrt(5);
E(5)-E(5)^2-E(5)^3+E(5)^4
gap> GaloisCyc( r5, 4 ) = r5;  GaloisCyc( r5, 2 ) = r5;
true
false
gap> GaloisStabilizer( Field( [ r5 ] ) );
[ 1, 4 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Integral Bases of Abelian Number Fields">
<Heading>Integral Bases of Abelian Number Fields</Heading>

Each abelian number field is naturally a vector space over <M>&QQ;</M>.
Moreover, if the abelian number field <M>F</M> contains the <M>n</M>-th
cyclotomic field <M>&QQ;_n</M> then <M>F</M> is a vector space over
<M>&QQ;_n</M>.
In &GAP;, each field object represents a vector space object over a
certain subfield <M>S</M>, which depends on the way <M>F</M> was
constructed.
The subfield <M>S</M> can be accessed as the value of the attribute
<Ref Func="LeftActingDomain"/>.
<P/>
The return values of <Ref Func="NF"/> and of the one argument
versions of <Ref Func="CF" Label="for (subfield and) conductor"/>
represent vector spaces over <M>&QQ;</M>,
and the return values of the two argument version of
<Ref Func="CF" Label="for (subfield and) conductor"/>
represent vector spaces over the field that is given as the first
argument.
For an abelian number field <A>F</A> and a subfield <A>S</A> of <A>F</A>,
a &GAP; object representing <A>F</A> as a vector space over <A>S</A> can
be constructed using <Ref Func="AsField"/>.
<P/>
<Index Subkey="CanonicalBasis">cyclotomic fields</Index>
Let <A>F</A> be the cyclotomic field <M>&QQ;_n</M>,
represented as a vector space over the subfield <A>S</A>.
If <A>S</A> is the cyclotomic field <M>&QQ;_m</M>,
with <M>m</M> a divisor of <M>n</M>,
then <C>CanonicalBasis( <A>F</A> )</C> returns the Zumbroich basis of
<A>F</A> relative to <A>S</A>,
which consists of the roots of unity <C>E(<A>n</A>)</C>^<A>i</A>
where <A>i</A> is an element of the list
<C>ZumbroichBase( <A>n</A>, <A>m</A> )</C>
(see&nbsp;<Ref Func="ZumbroichBase"/>).
If <A>S</A> is an abelian number field that is not a cyclotomic field
then <C>CanonicalBasis( <A>F</A> )</C> returns a normal <A>S</A>-basis
of <A>F</A>, i.e., a basis that is closed under the field automorphisms
of <A>F</A>.
<P/>
<Index Subkey="CanonicalBasis">abelian number fields</Index>
Let <A>F</A> be the abelian number field
<C>NF( <A>n</A>, <A>stab</A> )</C>, with conductor
<A>n</A>, that is itself not a cyclotomic field,
represented as a vector space over the subfield <A>S</A>.
If <A>S</A> is the cyclotomic field <M>&QQ;_m</M>,
with <M>m</M> a divisor of <M>n</M>,
then <C>CanonicalBasis( <A>F</A> )</C> returns the Lenstra basis of
<A>F</A> relative to <A>S</A> that consists of the sums of roots of unity
described by
<C>LenstraBase( <A>n</A>, <A>stab</A>, <A>stab</A>, <A>m</A> )</C>
(see&nbsp;<Ref Func="LenstraBase"/>).
If <A>S</A> is an abelian number field that is not a cyclotomic field
then <C>CanonicalBasis( <A>F</A> )</C> returns a normal <A>S</A>-basis
of <A>F</A>.
<P/>
<Example><![CDATA[
gap> f:= CF(8);;   # a cycl. field over the rationals
gap> b:= CanonicalBasis( f );;  BasisVectors( b );
[ 1, E(8), E(4), E(8)^3 ]
gap> Coefficients( b, Sqrt(-2) );
[ 0, 1, 0, 1 ]
gap> f:= AsField( CF(4), CF(8) );;  # a cycl. field over a cycl. field
gap> b:= CanonicalBasis( f );;  BasisVectors( b );
[ 1, E(8) ]
gap> Coefficients( b, Sqrt(-2) );
[ 0, 1+E(4) ]
gap> f:= AsField( Field( [ Sqrt(-2) ] ), CF(8) );;
gap> # a cycl. field over a non-cycl. field
gap> b:= CanonicalBasis( f );;  BasisVectors( b );
[ 1/2+1/2*E(8)-1/2*E(8)^2-1/2*E(8)^3, 
  1/2-1/2*E(8)+1/2*E(8)^2+1/2*E(8)^3 ]
gap> Coefficients( b, Sqrt(-2) );
[ E(8)+E(8)^3, E(8)+E(8)^3 ]
gap> f:= Field( [ Sqrt(-2) ] );   # a non-cycl. field over the rationals
NF(8,[ 1, 3 ])
gap> b:= CanonicalBasis( f );;  BasisVectors( b );
[ 1, E(8)+E(8)^3 ]
gap> Coefficients( b, Sqrt(-2) );
[ 0, 1 ]
]]></Example>

<ManSection>
<Func Name="ZumbroichBase" Arg='n, m'/>

<Description>
Let <A>n</A> and <A>m</A> be positive integers,
such that <A>m</A> divides <A>n</A>.
<Ref Func="ZumbroichBase"/> returns the set of exponents <M>i</M>
for which <C>E(<A>n</A>)^</C><M>i</M> belongs to the (generalized)
Zumbroich basis of the cyclotomic field <M>&QQ;_n</M>,
viewed as a vector space over <M>&QQ;_m</M>.
<P/>
This basis is defined as follows.
Let <M>P</M> denote the set of prime divisors of <A>n</A>,
<M><A>n</A> = \prod_{{p \in P}} p^{{\nu_p}}</M>, and
<M><A>m</A> = \prod_{{p \in P}} p^{{\mu_p}}</M>
with <M>\mu_p \leq \nu_p</M>.
Let <M>e_l =</M> <C>E</C><M>(l)</M> for any positive integer <M>l</M>, 
and
<M>\{ e_{{n_1}}^j \}_{{j \in J}} \otimes \{ e_{{n_2}}^k \}_{{k \in K}} =
\{ e_{{n_1}}^j \cdot e_{{n_2}}^k \}_{{j \in J, k \in K}}</M>.
<P/>
Then the basis is
<Display Mode="M">
B_{{n,m}} = \bigotimes_{{p \in P}}
  \bigotimes_{{k = \mu_p}}^{{\nu_p-1}}
     \{ e_{{p^{{k+1}}}}^j \}_{{j \in J_{{k,p}}}}
</Display>
where <M>J_{{k,p}} =</M>
<Table Align="lcl">
<Row>
   <Item><M>\{ 0 \}</M></Item>
   <Item>;</Item>
   <Item><M>k = 0, p = 2</M></Item>
</Row>
<Row>
   <Item><M>\{ 0, 1 \}</M></Item>
   <Item>;</Item>
   <Item><M>k &gt; 0, p = 2</M></Item>
</Row>
<Row>
   <Item><M>\{ 1, \ldots, p-1 \}</M></Item>
   <Item>;</Item>
   <Item><M>k = 0, p \neq 2</M></Item>
</Row>
<Row>
   <Item><M>\{ -(p-1)/2, \ldots, (p-1)/2 \}</M></Item>
   <Item>;</Item>
   <Item><M>k &gt; 0, p \neq 2</M></Item>
</Row>
</Table>
<P/>
<M>B_{{n,1}}</M> is equal to the basis of <M>&QQ;_n</M>
over the rationals which is introduced in&nbsp;<Cite Key="Zum89"/>.
Also the conversion of arbitrary sums of roots of unity into its
basis representation, and the reduction to the minimal cyclotomic field
are described in this thesis.
(Note that the notation here is slightly different from that there.)
<P/>
<M>B_{{n,m}}</M> consists of roots of unity, it is an integral basis
(that is, exactly the integral elements in <M>&QQ;_n</M> have integral
coefficients w.r.t.&nbsp;<M>B_{{n,m}}</M>,
cf.&nbsp;<Ref Func="IsIntegralCyclotomic"/>),
it is a normal basis for squarefree <M>n</M>
and closed under complex conjugation for odd <M>n</M>.
<P/>
<E>Note:</E>
For <M><A>n</A> \equiv 2 \pmod 4</M>, we have
<C>ZumbroichBase(<A>n</A>, 1) = 2 * ZumbroichBase(<A>n</A>/2, 1)</C> and
<C>List( ZumbroichBase(<A>n</A>, 1), x -> E(<A>n</A>)^x ) =
 List( ZumbroichBase(<A>n</A>/2, 1), x -> E(<A>n</A>/2)^x )</C>.
<P/>
<Example><![CDATA[
gap> ZumbroichBase( 15, 1 ); ZumbroichBase( 12, 3 );
[ 1, 2, 4, 7, 8, 11, 13, 14 ]
[ 0, 3 ]
gap> ZumbroichBase( 10, 2 ); ZumbroichBase( 32, 4 );
[ 2, 4, 6, 8 ]
[ 0, 1, 2, 3, 4, 5, 6, 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LenstraBase" Arg='n, stabilizer, super, m'/>

<Description>
Let <A>n</A> and <A>m</A> be positive integers
such that <A>m</A> divides <A>n</A>,
<A>stabilizer</A> be a list of prime residues modulo <A>n</A>,
which describes a subfield of the <A>n</A>-th cyclotomic field
(see&nbsp;<Ref Func="GaloisStabilizer"/>),
and <A>super</A> be a list representing a supergroup of the group given by
<A>stabilizer</A>.
<P/>
<Ref Func="LenstraBase"/> returns a list <M>[ b_1, b_2, \ldots, b_k ]</M>
of lists, each <M>b_i</M> consisting of integers such that the elements
<M>\sum_{{j \in b_i}} </M><C>E(n)</C><M>^j</M> form a basis of the
abelian number field <C>NF( <A>n</A>, <A>stabilizer</A> )</C>,
as a vector space over the <A>m</A>-th cyclotomic field
(see&nbsp;<Ref Func="AbelianNumberField"/>).
<P/>
This basis is an integral basis,
that is, exactly the integral elements in
<C>NF( <A>n</A>, <A>stabilizer</A> )</C>
have integral coefficients.
(For details about this basis, see&nbsp;<Cite Key="Bre97"/>.)
<P/>
If possible then the result is chosen such that the group described by
<A>super</A> acts on it,
consistently with the action of <A>stabilizer</A>, i.e.,
each orbit of <A>super</A> is a union of orbits of <A>stabilizer</A>.
(A usual case is <A>super</A><C> = </C><A>stabilizer</A>,
so there is no additional condition.
<P/>
<E>Note:</E>
The <M>b_i</M> are in general not sets,
since for <C><A>stabilizer</A> = <A>super</A></C>,
the first entry is always an element of
<C>ZumbroichBase( <A>n</A>, <A>m</A> )</C>;
this property is used by <Ref Func="NF"/> and <Ref Func="Coefficients"/>
(see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>).
<P/>
<A>stabilizer</A> must not contain the stabilizer of a proper
cyclotomic subfield of the <A>n</A>-th cyclotomic field, i.e.,
the result must describe a basis for a field with conductor <A>n</A>.
<P/>
<Example><![CDATA[
gap> LenstraBase( 24, [ 1, 19 ], [ 1, 19 ], 1 );
[ [ 1, 19 ], [ 8 ], [ 11, 17 ], [ 16 ] ]
gap> LenstraBase( 24, [ 1, 19 ], [ 1, 5, 19, 23 ], 1 );
[ [ 1, 19 ], [ 5, 23 ], [ 8 ], [ 16 ] ]
gap> LenstraBase( 15, [ 1, 4 ], PrimeResidues( 15 ), 1 );
[ [ 1, 4 ], [ 2, 8 ], [ 7, 13 ], [ 11, 14 ] ]
]]></Example>
<P/>
The first two results describe two bases of the field
<M>&QQ;_3(\sqrt{{6}})</M>,
the third result describes a normal basis of <M>&QQ;_3(\sqrt{{5}})</M>.
</Description>
</ManSection>

<!-- %T missing: <C>IsIntegralBasis</C>, <C>NormalBasis</C>, <C>IsNormalBasis</C>, -->
<!-- %T rings of integers in abelian number fields -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Galois Groups of Abelian Number Fields">
<Heading>Galois Groups of Abelian Number Fields</Heading>

<Index Subkey="Galois group">abelian number fields</Index>
<Index Subkey="Galois group">number fields</Index>
<Index Subkey="of number fields">automorphism group</Index>
The field automorphisms of the cyclotomic field <M>&QQ;_n</M>
(see Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/>)
are given by the linear maps <M>*k</M> on <M>&QQ;_n</M>
that are defined by <C>E</C><M>(n)^{{*k}} = </M><C>E</C><M>(n)^k</M>,
where <M>1 \leq k &lt; n</M> and <C>Gcd</C><M>( n, k ) = 1</M> hold
(see&nbsp;<Ref Func="GaloisCyc" Label="for a cyclotomic"/>).
Note that this action is <E>not</E> equal to exponentiation of cyclotomics,
i.e., for general cyclotomics <M>z</M>, <M>z^{{*k}}</M> is different from
<M>z^k</M>.
<P/>
(In &GAP;, the image of a cyclotomic <M>z</M> under <M>*k</M> can be
computed as <C>GaloisCyc( </C><M>z, k</M><C> )</C>.)
<P/>
<Example><![CDATA[
gap> ( E(5) + E(5)^4 )^2; GaloisCyc( E(5) + E(5)^4, 2 );
-2*E(5)-E(5)^2-E(5)^3-2*E(5)^4
E(5)^2+E(5)^3
]]></Example>
<P/>
For <C>Gcd</C><M>( n, k ) \neq 1</M>,
the map <C>E</C><M>(n) \mapsto</M> <C>E</C><M>(n)^k</M> does <E>not</E>
define a field automorphism of <M>&QQ;_n</M>
but only a <M>&QQ;</M>-linear map.
<P/>
<Example><![CDATA[
gap> GaloisCyc( E(5)+E(5)^4, 5 ); GaloisCyc( ( E(5)+E(5)^4 )^2, 5 );
2
-6
]]></Example>

<ManSection>
<Meth Name="GaloisGroup" Arg='F' Label="for abelian number fields"/>

<Description>
The Galois group <M>Gal( &QQ;_n, &QQ; )</M> of the field extension
<M>&QQ;_n / &QQ;</M> is isomorphic to the group
<M>(&ZZ; / n &ZZ;)^{*}</M>
of prime residues modulo <M>n</M>, via the isomorphism
<M>(&ZZ; / n &ZZ;)^{*} \rightarrow Gal( &QQ;_n, &QQ; )</M>
that is defined by
<M>k + n &ZZ; \mapsto ( z \mapsto z^{*k} )</M>.
<P/>
The Galois group of the field extension <M>&QQ;_n / L</M> with
any abelian number field <M>L \subseteq &QQ;_n</M> is simply the
factor group of <M>Gal( &QQ;_n, &QQ; )</M> modulo the stabilizer of <M>L</M>,
and the Galois group of <M>L / L'</M>, with <M>L'</M> an abelian
number field contained in <M>L</M>, is the subgroup in this group that stabilizes
<M>L'</M>.
These groups are easily described in terms of <M>(&ZZ; / n &ZZ;)^{*}</M>.
Generators of <M>(&ZZ; / n &ZZ;)^{*}</M> can be computed using
<Ref Func="GeneratorsPrimeResidues"/>.
<P/>
In &GAP;, a field extension <M>L / L'</M> is given by the field
object <M>L</M> with <Ref Func="LeftActingDomain"/> value <M>L'</M>
(see&nbsp;<Ref Sect="Integral Bases of Abelian Number Fields"/>).
<P/>
<Example><![CDATA[
gap> f:= CF(15);
CF(15)
gap> g:= GaloisGroup( f );
<group with 2 generators>
gap> Size( g ); IsCyclic( g ); IsAbelian( g );
8
false
true
gap> Action( g, NormalBase( f ), OnPoints );
Group([ (1,6)(2,4)(3,8)(5,7), (1,4,3,7)(2,8,5,6) ])
]]></Example>
<P/>
The following example shows Galois groups of a cyclotomic field
and of a proper subfield that is not a cyclotomic field.
<P/>
<Example><![CDATA[
gap> gens1:= GeneratorsOfGroup( GaloisGroup( CF(5) ) );
[ ANFAutomorphism( CF(5), 2 ) ]
gap> gens2:= GeneratorsOfGroup( GaloisGroup( Field( Sqrt(5) ) ) );
[ ANFAutomorphism( NF(5,[ 1, 4 ]), 2 ) ]
gap> Order( gens1[1] );  Order( gens2[1] );
4
2
gap> Sqrt(5)^gens1[1] = Sqrt(5)^gens2[1];
true
]]></Example>
<P/>
The following example shows the Galois group of a cyclotomic field
over a non-cyclotomic field.
<P/>
<Example><![CDATA[
gap> g:= GaloisGroup( AsField( Field( [ Sqrt(5) ] ), CF(5) ) );
<group with 1 generators>
gap> gens:= GeneratorsOfGroup( g );
[ ANFAutomorphism( AsField( NF(5,[ 1, 4 ]), CF(5) ), 4 ) ]
gap> x:= last[1];;  x^2;
IdentityMapping( AsField( NF(5,[ 1, 4 ]), CF(5) ) )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ANFAutomorphism" Arg='F, k'/>

<Description>
Let <A>F</A> be an abelian number field and <A>k</A> be an integer
that is coprime to the conductor
(see <Ref Func="Conductor" Label="for a collection of cyclotomics"/>)
of <A>F</A>.
Then <Ref Func="ANFAutomorphism"/> returns the automorphism of <A>F</A>
that is defined as the linear extension of the map that raises each root
of unity in <A>F</A> to its <A>k</A>-th power.
<P/>
<Example><![CDATA[
gap> f:= CF(25);
CF(25)
gap> alpha:= ANFAutomorphism( f, 2 );
ANFAutomorphism( CF(25), 2 )
gap> alpha^2;
ANFAutomorphism( CF(25), 4 )
gap> Order( alpha );
20
gap> E(5)^alpha;
E(5)^2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Gaussians">
<Heading>Gaussians</Heading>

<ManSection>
<Var Name="GaussianIntegers"/>

<Description>
<Ref Var="GaussianIntegers"/> is the ring <M>&ZZ;[\sqrt{{-1}}]</M>
of Gaussian integers.
This is a subring of the cyclotomic field
<Ref Func="GaussianRationals"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsGaussianIntegers" Arg='obj' Type='Category'/>

<Description>
is the defining category for the domain <Ref Var="GaussianIntegers"/>.
</Description>
</ManSection>


<!-- % Gcd and Euclidean... for the rings of integers in CF(4) and CF(3) ! -->

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  vspc.msk                     GAP documentation            Willem de Graaf -->
<!-- %A                                                              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: vspc.msk,v 1.23 2003/07/21 19:49:06 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Vector Spaces">
<Heading>Vector Spaces</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsLeftVectorSpace">
<Heading>IsLeftVectorSpace (Filter)</Heading>

<ManSection>
<Filt Name="IsLeftVectorSpace" Arg='V' Type='Category'/>
<Filt Name="IsVectorSpace" Arg='V' Type='Category'/>

<Description>
A <E>vector space</E> in &GAP; is a free left module
(see&nbsp;<Ref Func="IsFreeLeftModule"/>) over a division ring
(see Chapter&nbsp;<Ref Chap="Fields and Division Rings"/>).
<P/>
Whenever we talk about an <M>F</M>-vector space <A>V</A> then <A>V</A> is
an additive group (see&nbsp;<Ref Func="IsAdditiveGroup"/>) on which the
division ring <M>F</M> acts via multiplication from the left such that
this action and the addition in <A>V</A> are left and right distributive.
The division ring <M>F</M> can be accessed as value of the attribute
<Ref Func="LeftActingDomain"/>.
<P/>
Vector spaces in &GAP; are always <E>left</E> vector spaces,
<Ref Filt="IsLeftVectorSpace"/> and <Ref Filt="IsVectorSpace"/> are
synonyms.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Vector Spaces">
<Heading>Constructing Vector Spaces</Heading>

<ManSection>
<Func Name="VectorSpace" Arg='F, gens[, zero][, "basis"]'/>

<Description>
For a field <A>F</A> and a collection <A>gens</A> of vectors,
<Ref Func="VectorSpace"/> returns the <A>F</A>-vector space spanned by
the elements in <A>gens</A>.
<P/>
The optional argument <A>zero</A> can be used to specify the zero element
of the space; <A>zero</A> <E>must</E> be given if <A>gens</A> is empty.
The optional string <C>"basis"</C> indicates that <A>gens</A> is known to
be linearly independent over <A>F</A>, in particular the dimension of the
vector space is immediately set;
note that <Ref Func="Basis"/> need <E>not</E> return the basis formed by
<A>gens</A> if the string <C>"basis"</C> is given as an argument.
<!-- crossref. to <C>FreeLeftModule</C> as soon as the modules chapter
     is reliable!-->
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 3 ], [ 1, 1, 1 ] ] );
<vector space over Rationals, with 2 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Subspace" Arg='V, gens[, "basis"]'/>
<Func Name="SubspaceNC" Arg='V, gens[, "basis"]'/>

<Description>
For an <M>F</M>-vector space <A>V</A> and a list or collection
<A>gens</A> that is a subset of <A>V</A>,
<Ref Func="Subspace"/> returns the <M>F</M>-vector space spanned by
<A>gens</A>; if <A>gens</A> is empty then the trivial subspace
(see&nbsp;<Ref Func="TrivialSubspace"/>) of <A>V</A> is returned.
The parent (see&nbsp;<Ref Sect="Parents"/>) of the returned vector space
is set to <A>V</A>.
<P/>
<Ref Func="SubspaceNC"/> does the same as <Ref Func="Subspace"/>,
except that it omits the check whether <A>gens</A> is a subset of
<A>V</A>.
<P/>
The optional string <A>"basis"</A> indicates that <A>gens</A> is known to
be linearly independent over <M>F</M>.
In this case the dimension of the subspace is immediately set,
and both <Ref Func="Subspace"/> and <Ref Func="SubspaceNC"/> do
<E>not</E> check whether <A>gens</A> really is linearly independent and
whether <A>gens</A> is a subset of <A>V</A>.
<!-- crossref. to <C>Submodule</C> as soon as the modules chapter
     is reliable!-->
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 3 ], [ 1, 1, 1 ] ] );;
gap> W:= Subspace( V, [ [ 0, 1, 2 ] ] );
<vector space over Rationals, with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsVectorSpace" Arg='F, D'/>

<Description>
Let <A>F</A> be a division ring and <A>D</A> a domain.
If the elements in <A>D</A> form an <A>F</A>-vector space then
<Ref Oper="AsVectorSpace"/> returns this <A>F</A>-vector space,
otherwise <K>fail</K> is returned.
<P/>
<Ref Oper="AsVectorSpace"/> can be used for example to view a given
vector space as a vector space over a smaller or larger division ring.
<Example><![CDATA[
gap> V:= FullRowSpace( GF( 27 ), 3 );
( GF(3^3)^3 )
gap> Dimension( V );  LeftActingDomain( V );
3
GF(3^3)
gap> W:= AsVectorSpace( GF( 3 ), V );
<vector space over GF(3), with 9 generators>
gap> Dimension( W );  LeftActingDomain( W );
9
GF(3)
gap> AsVectorSpace( GF( 9 ), V );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsSubspace" Arg='V, U'/>

<Description>
Let <A>V</A> be an <M>F</M>-vector space, and <A>U</A> a collection.
If <A>U</A> is a subset of <A>V</A> such that the elements of <A>U</A>
form an <M>F</M>-vector space then <Ref Oper="AsSubspace"/> returns this
vector space, with parent set to <A>V</A>
(see&nbsp;<Ref Func="AsVectorSpace"/>).
Otherwise <K>fail</K> is returned.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 3 ], [ 1, 1, 1 ] ] );;
gap> W:= VectorSpace( Rationals, [ [ 1/2, 1/2, 1/2 ] ] );;
gap> U:= AsSubspace( V, W );
<vector space over Rationals, with 1 generators>
gap> Parent( U ) = V;
true
gap> AsSubspace( V, [ [ 1, 1, 1 ] ] );
fail
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations and Attributes for Vector Spaces">
<Heading>Operations and Attributes for Vector Spaces</Heading>

<ManSection>
<Attr Name="GeneratorsOfLeftVectorSpace" Arg='V'/>
<Attr Name="GeneratorsOfVectorSpace" Arg='V'/>

<Description>
For an <M>F</M>-vector space <A>V</A>,
<Ref Attr="GeneratorsOfLeftVectorSpace"/> returns a list of vectors in
<A>V</A> that generate <A>V</A> as an <M>F</M>-vector space.
<Example><![CDATA[
gap> GeneratorsOfVectorSpace( FullRowSpace( Rationals, 3 ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TrivialSubspace" Arg='V'/>

<Description>
For a vector space <A>V</A>, <Ref Attr="TrivialSubspace"/> returns the
subspace of <A>V</A> that consists of the zero vector in <A>V</A>.
<Example><![CDATA[
gap> V:= GF(3)^3;;
gap> triv:= TrivialSubspace( V );
<vector space over GF(3), with 0 generators>
gap> AsSet( triv );
[ [ 0*Z(3), 0*Z(3), 0*Z(3) ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Domains of Subspaces of Vector Spaces">
<Heading>Domains of Subspaces of Vector Spaces</Heading>

<ManSection>
<Attr Name="Subspaces" Arg='V[, k]'/>

<Description>
Called with a finite vector space <A>v</A>,
<Ref Oper="Subspaces"/> returns the domain of all subspaces of <A>V</A>.
<P/>
Called with <A>V</A> and a nonnegative integer <A>k</A>,
<Ref Oper="Subspaces"/> returns the domain of all <A>k</A>-dimensional
subspaces of <A>V</A>.
<P/>
Special <Ref Attr="Size"/> and <Ref Oper="Iterator"/> methods are
provided for these domains.
<!-- <C>Enumerator</C> would also be good ...
     (special treatment for full row spaces,
     other spaces delegate to this)-->
</Description>
</ManSection>

<ManSection>
<Filt Name="IsSubspacesVectorSpace" Arg='D' Type='Category'/>

<Description>
The domain of all subspaces of a (finite) vector space or of all
subspaces of fixed dimension, as returned by <Ref Func="Subspaces"/>
(see&nbsp;<Ref Func="Subspaces"/>) lies in the category
<Ref Filt="IsSubspacesVectorSpace"/>.
<Example><![CDATA[
gap> D:= Subspaces( GF(3)^3 );
Subspaces( ( GF(3)^3 ) )
gap> Size( D );
28
gap> iter:= Iterator( D );;
gap> NextIterator( iter );
<vector space over GF(3), with 0 generators>
gap> NextIterator( iter );
<vector space of dimension 1 over GF(3)>
gap> IsSubspacesVectorSpace( D );
true
]]></Example>
</Description>
</ManSection>


<!-- %T The domains of subspaces are useful for example because groups and algebras -->
<!-- %T act on their sets of elements. -->
<!-- %T (show an example) -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Bases of Vector Spaces">
<Heading>Bases of Vector Spaces</Heading>

In &GAP;, a <E>basis</E> of a free left <M>F</M>-module <M>V</M> is a list of vectors
<M>B = [ v_1, v_2, \ldots, v_n ]</M> in <M>V</M> such that <M>V</M> is generated as a
left <M>F</M>-module by these vectors and such that <M>B</M> is linearly
independent over <M>F</M>.
The integer <M>n</M> is the dimension of <M>V</M> (see&nbsp;<Ref Func="Dimension"/>).
In particular, as each basis is a list (see Chapter&nbsp;<Ref Chap="Lists"/>),
it has a length (see&nbsp;<Ref Func="Length"/>), and the <M>i</M>-th vector of <M>B</M> can be
accessed as <M>B[i]</M>.
<Example><![CDATA[
gap> V:= Rationals^3;
( Rationals^3 )
gap> B:= Basis( V );
CanonicalBasis( ( Rationals^3 ) )
gap> Length( B );
3
gap> B[1];
[ 1, 0, 0 ]
]]></Example>
<P/>
The operations described below make sense only for bases of <E>finite</E>
dimensional vector spaces.
(In practice this means that the vector spaces must be <E>low</E> dimensional,
that is, the dimension should not exceed a few hundred.)
<P/>
Besides the basic operations for lists
(see&nbsp;<Ref Sect="Basic Operations for Lists"/>),
the <E>basic operations for bases</E> are <Ref Func="BasisVectors"/>,
<Ref Func="Coefficients"/>,
<Ref Func="LinearCombination"/>,
and <Ref Func="UnderlyingLeftModule"/>.
These and other operations for arbitrary bases are described
in&nbsp;<Ref Sect="Operations for Vector Space Bases"/>.
<P/>
For special kinds of bases, further operations are defined
(see&nbsp;<Ref Sect="Operations for Special Kinds of Bases"/>).
<P/>
&GAP; supports the following three kinds of bases.
<P/>
<E>Relative bases</E> delegate the work to other bases of the same
free left module, via basechange matrices (see&nbsp;<Ref Func="RelativeBasis"/>).
<P/>
<E>Bases handled by nice bases</E> delegate the work to bases
of isomorphic left modules over the same left acting domain
(see&nbsp;<Ref Sect="Vector Spaces Handled By Nice Bases"/>).
<P/>
Finally, of course there must be bases in &GAP; that really do the work.
<P/>
For example, in the case of a Gaussian row or matrix space <A>V</A>
(see&nbsp;<Ref Sect="Row and Matrix Spaces"/>),
<C>Basis( <A>V</A> )</C> is a semi-echelonized basis (see&nbsp;<Ref Func="IsSemiEchelonized"/>)
that uses Gaussian elimination; such a basis is of the third kind.
<C>Basis( <A>V</A>, <A>vectors</A> )</C> is either semi-echelonized or a relative basis.
Other examples of bases of the third kind are canonical bases of finite
fields and of abelian number fields.
<P/>
Bases handled by nice bases are described
in&nbsp;<Ref Sect="Vector Spaces Handled By Nice Bases"/>.
Examples are non-Gaussian row and matrix spaces, and subspaces of finite
fields and abelian number fields that are themselves not fields.

<ManSection>
<Filt Name="IsBasis" Arg='obj' Type='Category'/>

<Description>
In &GAP;, a <E>basis</E> of a free left module is an object that knows
how to compute coefficients w.r.t.&nbsp;its basis vectors
(see&nbsp;<Ref Func="Coefficients"/>).
Bases are constructed by <Ref Func="Basis"/>.
Each basis is an immutable list,
the <M>i</M>-th entry being the <M>i</M>-th basis vector.
<P/>
(See&nbsp;<Ref Sect="Mutable Bases"/> for mutable bases.)
<P/>
<Example><![CDATA[
gap> V:= GF(2)^2;;
gap> B:= Basis( V );;
gap> IsBasis( B );
true
gap> IsBasis( [ [ 1, 0 ], [ 0, 1 ] ] );
false
gap> IsBasis( Basis( Rationals^2, [ [ 1, 0 ], [ 0, 1 ] ] ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Basis" Arg='V[, vectors]'/>
<Oper Name="BasisNC" Arg='V, vectors'/>

<Description>
Called with a free left <M>F</M>-module <A>V</A> as the only argument,
<Ref Attr="Basis"/> returns an <M>F</M>-basis of <A>V</A>
whose vectors are not further specified.
<P/>
If additionally a list <A>vectors</A> of vectors in <A>V</A> is given
that forms an <M>F</M>-basis of <A>V</A>
then <Ref Attr="Basis"/> returns this basis;
if <A>vectors</A> is not linearly independent over <M>F</M>
or does not generate <A>V</A> as a free left <M>F</M>-module
then <K>fail</K> is returned.
<P/>
<Ref Oper="BasisNC"/> does the same as the two argument version of
<Ref Attr="Basis"/>, except that it does not check
whether <A>vectors</A> form a basis.
<P/>
If no basis vectors are prescribed then <Ref Attr="Basis"/> need not
compute basis vectors; in this case, the vectors are computed
in the first call to <Ref Attr="BasisVectors"/>.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 7 ], [ 1/2, 1/3, 5 ] ] );;
gap> B:= Basis( V );
SemiEchelonBasis( <vector space over Rationals, with 
2 generators>, ... )
gap> BasisVectors( B );
[ [ 1, 2, 7 ], [ 0, 1, -9/4 ] ]
gap> B:= Basis( V, [ [ 1, 2, 7 ], [ 3, 2, 30 ] ] );
Basis( <vector space over Rationals, with 2 generators>, 
[ [ 1, 2, 7 ], [ 3, 2, 30 ] ] )
gap> Basis( V, [ [ 1, 2, 3 ] ] );
fail
]]></Example>
</Description>
</ManSection>

<!-- %T show the use of the <Q>no check</Q> version -->
<ManSection>
<Attr Name="CanonicalBasis" Arg='V'/>

<Description>
If the vector space <A>V</A> supports a <E>canonical basis</E> then
<Ref Attr="CanonicalBasis"/> returns this basis,
otherwise <K>fail</K> is returned.
<P/>
The defining property of a canonical basis is that its vectors are
uniquely determined by the vector space.
If canonical bases exist for two vector spaces over the same left acting
domain (see&nbsp;<Ref Func="LeftActingDomain"/>) then the equality of
these vector spaces can be decided by comparing the canonical bases.
<P/>
The exact meaning of a canonical basis depends on the type of <A>V</A>.
Canonical bases are defined for example for Gaussian row and matrix
spaces (see&nbsp;<Ref Sect="Row and Matrix Spaces"/>).
<P/>
If one designs a new kind of vector spaces
(see&nbsp;<Ref Sect="How to Implement New Kinds of Vector Spaces"/>) and
defines a canonical basis for these spaces then the
<Ref Attr="CanonicalBasis"/> method one installs
(see&nbsp;<Ref Func="InstallMethod"/>)
must <E>not</E> call <Ref Func="Basis"/>.
On the other hand, one probably should install a <Ref Func="Basis"/>
method that simply calls <Ref Attr="CanonicalBasis"/>,
the value of the method
(see&nbsp;<Ref Sect="Method Installation"/> and
<Ref Sect="Applicable Methods and Method Selection"/>)
being <C>CANONICAL_BASIS_FLAGS</C>.
<Example><![CDATA[
gap> vecs:= [ [ 1, 2, 3 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ];;
gap> V:= VectorSpace( Rationals, vecs );;
gap> B:= CanonicalBasis( V );
CanonicalBasis( <vector space over Rationals, with 3 generators> )
gap> BasisVectors( B );
[ [ 1, 0, -1 ], [ 0, 1, 2 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RelativeBasis" Arg='B, vectors'/>
<Oper Name="RelativeBasisNC" Arg='B, vectors'/>

<Description>
A relative basis is a basis of the free left module <A>V</A> that delegates
the computation of coefficients etc. to another basis of <A>V</A> via
a basechange matrix.
<P/>
Let <A>B</A> be a basis of the free left module <A>V</A>,
and <A>vectors</A> a list of vectors in <A>V</A>.
<P/>
<Ref Oper="RelativeBasis"/> checks whether <A>vectors</A> form a basis of <A>V</A>,
and in this case a basis is returned in which <A>vectors</A> are
the basis vectors; otherwise <K>fail</K> is returned.
<P/>
<Ref Oper="RelativeBasisNC"/> does the same, except that it omits the check.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Vector Space Bases">
<Heading>Operations for Vector Space Bases</Heading>

<ManSection>
<Attr Name="BasisVectors" Arg='B'/>

<Description>
For a vector space basis <A>B</A>, <C>BasisVectors</C> returns the list of basis
vectors of <A>B</A>.
The lists <A>B</A> and <C>BasisVectors( <A>B</A> )</C> are equal; the main purpose of
<C>BasisVectors</C> is to provide access to a list of vectors that does <E>not</E>
know about an underlying vector space.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 7 ], [ 1/2, 1/3, 5 ] ] );;
gap> B:= Basis( V, [ [ 1, 2, 7 ], [ 0, 1, -9/4 ] ] );;
gap> BasisVectors( B );
[ [ 1, 2, 7 ], [ 0, 1, -9/4 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingLeftModule" Arg='B'/>

<Description>
For a basis <A>B</A> of a free left module <M>V</M>, say,
<Ref Attr="UnderlyingLeftModule"/> returns <M>V</M>.
<P/>
The reason why a basis stores a free left module is that otherwise one
would have to store the basis vectors and the coefficient domain
separately.
Storing the module allows one for example to deal with bases whose basis
vectors have not yet been computed yet (see&nbsp;<Ref Func="Basis"/>);
furthermore, in some cases it is convenient to test membership of a
vector in the module before computing coefficients w.r.t.&nbsp;a basis.
<!-- this happens for example for finite fields and cyclotomic fields-->
<Example><![CDATA[
gap> B:= Basis( GF(2)^6 );;  UnderlyingLeftModule( B );
( GF(2)^6 )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Coefficients" Arg='B, v'/>

<Description>
Let <M>V</M> be the underlying left module of the basis <A>B</A>, and <A>v</A> a vector
such that the family of <A>v</A> is the elements family of the family of <M>V</M>.
Then <C>Coefficients( <A>B</A>, <A>v</A> )</C> is the list of coefficients of <A>v</A> w.r.t.
<A>B</A> if <A>v</A> lies in <M>V</M>, and <K>fail</K> otherwise.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 7 ], [ 1/2, 1/3, 5 ] ] );;
gap> B:= Basis( V, [ [ 1, 2, 7 ], [ 0, 1, -9/4 ] ] );;
gap> Coefficients( B, [ 1/2, 1/3, 5 ] );
[ 1/2, -2/3 ]
gap> Coefficients( B, [ 1, 0, 0 ] );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LinearCombination" Arg='B, coeff'/>

<Description>
If <A>B</A> is a basis object (see <Ref Func="IsBasis"/>)
or a homogeneous list of length <M>n</M>, say,
and <A>coeff</A> is a row vector of the same length,
<Ref Oper="LinearCombination"/> returns the vector
<M>\sum_{{i = 1}}^n <A>coeff</A>[i] * <A>B</A>[i]</M>.
<P/>
Perhaps the most important usage is the case where <A>B</A> forms a 
basis.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 7 ], [ 1/2, 1/3, 5 ] ] );;
gap> B:= Basis( V, [ [ 1, 2, 7 ], [ 0, 1, -9/4 ] ] );;
gap> LinearCombination( B, [ 1/2, -2/3 ] );
[ 1/2, 1/3, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="EnumeratorByBasis" Arg='B'/>

<Description>
For a basis <A>B</A> of the free left <M>F</M>-module <M>V</M> of dimension <M>n</M>, say,
<C>EnumeratorByBasis</C> returns an enumerator that loops over the elements of
<M>V</M> as linear combinations of the vectors of <A>B</A> with coefficients the
row vectors in the full row space (see&nbsp;<Ref Func="FullRowSpace"/>) of dimension <M>n</M>
over <M>F</M>, in the succession given by the default enumerator of this row
space.
<Example><![CDATA[
gap> V:= GF(2)^3;;
gap> enum:= EnumeratorByBasis( CanonicalBasis( V ) );;
gap> Print( enum{ [ 1 .. 4 ] }, "\n" );
[ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0 ], 
  [ 0*Z(2), Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0, Z(2)^0 ] ]
gap> B:= Basis( V, [ [ 1, 1, 1 ], [ 1, 1, 0 ], [ 1, 0, 0 ] ] * Z(2) );;
gap> enum:= EnumeratorByBasis( B );;
gap> Print( enum{ [ 1 .. 4 ] }, "\n" );
[ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ Z(2)^0, Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2) ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IteratorByBasis" Arg='B'/>

<Description>
For a basis <A>B</A> of the free left <M>F</M>-module <M>V</M> of dimension <M>n</M>, say,
<C>IteratorByBasis</C> returns an iterator that loops over the elements of <M>V</M>
as linear combinations of the vectors of <A>B</A> with coefficients the row
vectors in the full row space (see&nbsp;<Ref Func="FullRowSpace"/>) of dimension <M>n</M> over
<M>F</M>, in the succession given by the default enumerator of this row space.
<Example><![CDATA[
gap> V:= GF(2)^3;;
gap> iter:= IteratorByBasis( CanonicalBasis( V ) );;
gap> for i in [ 1 .. 4 ] do Print( NextIterator( iter ), "\n" ); od;
[ 0*Z(2), 0*Z(2), 0*Z(2) ]
[ 0*Z(2), 0*Z(2), Z(2)^0 ]
[ 0*Z(2), Z(2)^0, 0*Z(2) ]
[ 0*Z(2), Z(2)^0, Z(2)^0 ]
gap> B:= Basis( V, [ [ 1, 1, 1 ], [ 1, 1, 0 ], [ 1, 0, 0 ] ] * Z(2) );;
gap> iter:= IteratorByBasis( B );;
gap> for i in [ 1 .. 4 ] do Print( NextIterator( iter ), "\n" ); od;
[ 0*Z(2), 0*Z(2), 0*Z(2) ]
[ Z(2)^0, 0*Z(2), 0*Z(2) ]
[ Z(2)^0, Z(2)^0, 0*Z(2) ]
[ 0*Z(2), Z(2)^0, 0*Z(2) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Special Kinds of Bases">
<Heading>Operations for Special Kinds of Bases</Heading>

<ManSection>
<Prop Name="IsCanonicalBasis" Arg='B'/>

<Description>
If the underlying free left module <M>V</M> of the basis <A>B</A>
supports a canonical basis (see&nbsp;<Ref Func="CanonicalBasis"/>) then
<Ref Func="IsCanonicalBasis"/> returns <K>true</K> if <A>B</A> is equal
to the canonical basis of <M>V</M>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsIntegralBasis" Arg='B'/>

<Description>
Let <A>B</A> be an <M>S</M>-basis of a <E>field</E> <M>F</M>, say, for a subfield <M>S</M> of <M>F</M>,
and let <M>R</M> and <M>M</M> be the rings of algebraic integers in <M>S</M> and <M>F</M>,
respectively.
<C>IsIntegralBasis</C> returns <K>true</K> if <A>B</A> is also an <M>R</M>-basis of <M>M</M>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsNormalBasis" Arg='B'/>

<Description>
Let <A>B</A> be an <M>S</M>-basis of a <E>field</E> <M>F</M>, say,
for a subfield <M>S</M> of <M>F</M>.
<C>IsNormalBasis</C> returns <K>true</K> if <A>B</A> is invariant under
the Galois group
(see&nbsp;<Ref Attr="GaloisGroup" Label="of field"/>)
of the field extension <M>F / S</M>, and <K>false</K> otherwise.
<Example><![CDATA[
gap> B:= CanonicalBasis( GaussianRationals );
CanonicalBasis( GaussianRationals )
gap> IsIntegralBasis( B );  IsNormalBasis( B );
true
false
]]></Example>
</Description>
</ManSection>

<!-- % add an example of a non-integral basis; -->
<!-- % for that, add a method that takes an integral basis, -->
<!-- % and inspects the basechange matrix -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mutable Bases">
<Heading>Mutable Bases</Heading>

It is useful to have a <E>mutable basis</E> of a free module when successively
closures with new vectors are formed, since one does not want to create
a new module and a corresponding basis for each step.
<P/>
Note that the situation here is different from the situation with
stabilizer chains, which are (mutable or immutable) records that do not
need to know about the groups they describe,
whereas each (immutable) basis stores the underlying left module
(see&nbsp;<Ref Func="UnderlyingLeftModule"/>).
<P/>
So immutable bases and mutable bases are different categories of objects.
The only thing they have in common is that one can ask both for
their basis vectors and for the coefficients of a given vector.
<P/>
Since <C>Immutable</C> produces an immutable copy of any &GAP; object,
it would in principle be possible to construct a mutable basis that
is in fact immutable.
In the sequel, we will deal only with mutable bases that are in fact
<E>mutable</E> &GAP; objects,
hence these objects are unable to store attribute values.
<P/>
Basic operations for immutable bases are
<Ref Func="NrBasisVectors"/>, <Ref Func="IsContainedInSpan"/>,
<Ref Func="CloseMutableBasis"/>,
<Ref Func="ImmutableBasis"/>,
<Ref Func="Coefficients"/>, and <Ref Func="BasisVectors"/>.
<Ref Func="ShallowCopy"/> for a mutable basis returns a mutable
plain list containing the current basis vectors.
<!-- Also <Ref Attr="LeftActingDomain"/> (or the analogy for it) should be a basic-->
<!-- operation; up to now, apparantly one can avoid it,-->
<!-- but conceptually it should be available!-->
<P/>
Since mutable bases do not admit arbitrary changes of their lists of
basis vectors, a mutable basis is <E>not</E> a list.
It is, however, a collection, more precisely its family (see&nbsp;<Ref Sect="Families"/>)
equals the family of its collection of basis vectors.
<P/>
Mutable bases can be constructed with <C>MutableBasis</C>.
<P/>
Similar to the situation with bases (cf.&nbsp;<Ref Sect="Bases of Vector Spaces"/>),
&GAP; supports the following three kinds of mutable bases.
<P/>
The <E>generic method</E> of <C>MutableBasis</C> returns a mutable basis that
simply stores an immutable basis;
clearly one wants to avoid this whenever possible with reasonable effort.
<P/>
There are mutable bases that store a mutable basis for a nicer module.
<!--  This works if we have access to the mechanism of computing nice vectors,-->
<!--  and requires the construction with-->
<!--  <C>MutableBasisViaNiceMutableBasisMethod2</C> or-->
<!--  <C>MutableBasisViaNiceMutableBasisMethod3</C>!-->
Note that this is meaningful only if the mechanism of computing nice and
ugly vectors (see&nbsp;<Ref Sect="Vector Spaces Handled By Nice Bases"/>) is invariant
under closures of the basis;
this is the case for example if the vectors are matrices, Lie objects,
or elements of structure constants algebras. 
<P/>
There are mutable bases that use special information to perform their
tasks; examples are mutable bases of Gaussian row and matrix spaces.

<ManSection>
<Filt Name="IsMutableBasis" Arg='MB' Type='Category'/>

<Description>
Every mutable basis lies in the category <C>IsMutableBasis</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="MutableBasis" Arg='R, vectors[, zero]'/>

<Description>
<C>MutableBasis</C> returns a mutable basis for the <A>R</A>-free module generated
by the vectors in the list <A>vectors</A>.
The optional argument <A>zero</A> is the zero vector of the module;
it must be given if <A>vectors</A> is empty.
<P/>
<E>Note</E> that <A>vectors</A> will in general <E>not</E> be the basis vectors of the
mutable basis!
<!-- provide <C>AddBasisVector</C> to achieve this?-->
<Example><![CDATA[
gap> MB:= MutableBasis( Rationals, [ [ 1, 2, 3 ], [ 0, 1, 0 ] ] );
<mutable basis over Rationals, 2 vectors>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="NrBasisVectors" Arg='MB'/>

<Description>
For a mutable basis <A>MB</A>, <C>NrBasisVectors</C> returns the current number of
basis vectors of <A>MB</A>.
Note that this operation is <E>not</E> an attribute, as it makes no sense to
store the value.
<C>NrBasisVectors</C> is used mainly as an equivalent of <C>Dimension</C> for the
underlying left module in the case of immutable bases.
<Example><![CDATA[
gap> MB:= MutableBasis( Rationals, [ [ 1, 1], [ 2, 2 ] ] );;
gap> NrBasisVectors( MB );
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ImmutableBasis" Arg='MB[, V]'/>

<Description>
<Ref Oper="ImmutableBasis"/> returns the immutable basis <M>B</M>, say,
with the same basis vectors as in the mutable basis <A>MB</A>.
<P/>
If the second argument <A>V</A> is present then <A>V</A> is the value of
<Ref Attr="UnderlyingLeftModule"/> for <M>B</M>.
The second variant is used mainly for the case that one knows the module
for the desired basis in advance, and if it has a nicer structure than
the module known to <A>MB</A>, for example if it is an algebra.
<!--  This happens for example if one constructs a basis of an ideal using-->
<!--  iterated closures of a mutable basis, and the final basis <M>B</M> shall-->
<!--  have the initial ideal as underlying module.-->
<Example><![CDATA[
gap> MB:= MutableBasis( Rationals, [ [ 1, 1 ], [ 2, 2 ] ] );;
gap> B:= ImmutableBasis( MB );
SemiEchelonBasis( <vector space of dimension 1 over Rationals>, 
[ [ 1, 1 ] ] )
gap> UnderlyingLeftModule( B );
<vector space of dimension 1 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsContainedInSpan" Arg='MB, v'/>

<Description>
For a mutable basis <A>MB</A> over the coefficient ring <M>R</M>, say,
and a vector <A>v</A>, <C>IsContainedInSpan</C> returns <K>true</K> is <A>v</A> lies in the
<M>R</M>-span of the current basis vectors of <A>MB</A>,
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Oper Name="CloseMutableBasis" Arg='MB, v'/>

<Description>
For a mutable basis <A>MB</A> over the coefficient ring <M>R</M>, say,
and a vector <A>v</A>, <C>CloseMutableBasis</C> changes <A>MB</A> such that afterwards
it describes the <M>R</M>-span of the former basis vectors together with <A>v</A>.
<P/>
<E>Note</E> that if <A>v</A> enlarges the dimension then this does in general <E>not</E>
mean that <A>v</A> is simply added to the basis vectors of <A>MB</A>.
Usually a linear combination of <A>v</A> and the other basis vectors is added,
and also the old basis vectors may be modified, for example in order to
keep the list of basis vectors echelonized (see&nbsp;<Ref Func="IsSemiEchelonized"/>).
<Example><![CDATA[
gap> MB:= MutableBasis( Rationals, [ [ 1, 1, 3 ], [ 2, 2, 1 ] ] );
<mutable basis over Rationals, 2 vectors>
gap> IsContainedInSpan( MB, [ 1, 0, 0 ] );
false
gap> CloseMutableBasis( MB, [ 1, 0, 0 ] );
gap> MB;
<mutable basis over Rationals, 3 vectors>
gap> IsContainedInSpan( MB, [ 1, 0, 0 ] );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Row and Matrix Spaces">
<Heading>Row and Matrix Spaces</Heading>

<Index>row spaces</Index>
<Index>matrix spaces</Index>

<ManSection>
<Func Name="IsRowSpace" Arg='V'/>

<Description>
A <E>row space</E> in &GAP; is a vector space that consists of
row vectors (see Chapter&nbsp;<Ref Chap="Row Vectors"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="IsMatrixSpace" Arg='V'/>

<Description>
A <E>matrix space</E> in &GAP; is a vector space that consists of matrices
(see Chapter&nbsp;<Ref Chap="Matrices"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="IsGaussianSpace" Arg='V'/>

<Description>
The filter <Ref Filt="IsGaussianSpace"/> (see&nbsp;<Ref Sect="Filters"/>)
for the row space (see&nbsp;<Ref Func="IsRowSpace"/>)
or matrix space (see&nbsp;<Ref Func="IsMatrixSpace"/>) <A>V</A>
over the field <M>F</M>, say,
indicates that the entries of all row vectors or matrices in <A>V</A>,
respectively, are all contained in <M>F</M>.
In this case, <A>V</A> is called a <E>Gaussian</E> vector space.
Bases for Gaussian spaces can be computed using Gaussian elimination for
a given list of vector space generators.
<Example><![CDATA[
gap> mats:= [ [[1,1],[2,2]], [[3,4],[0,1]] ];;
gap> V:= VectorSpace( Rationals, mats );;
gap> IsGaussianSpace( V );
true
gap> mats[1][1][1]:= E(4);;   # an element in an extension field
gap> V:= VectorSpace( Rationals, mats );;
gap> IsGaussianSpace( V );
false
gap> V:= VectorSpace( Field( Rationals, [ E(4) ] ), mats );;
gap> IsGaussianSpace( V );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FullRowSpace" Arg='F, n'/>
<Meth Name="\^" Arg='F, n' Label="for a field and an integer"/>

<Description>
For a field <A>F</A> and a nonnegative integer <A>n</A>,
<Ref Func="FullRowSpace"/> returns the <A>F</A>-vector space that
consists of all row vectors (see&nbsp;<Ref Func="IsRowVector"/>) of
length <A>n</A> with entries in <A>F</A>.
<P/>
An alternative to construct this vector space is via
<A>F</A><C>^</C><A>n</A>.
<Example><![CDATA[
gap> FullRowSpace( GF( 9 ), 3 );
( GF(3^2)^3 )
gap> GF(9)^3;           # the same as above
( GF(3^2)^3 )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FullMatrixSpace" Arg='F, m, n'/>
<Meth Name="\^" Arg='F, dims'
 Label="for a field and a pair of integers"/>

<Description>
For a field <A>F</A> and two positive integers <A>m</A> and <A>n</A>,
<Ref Func="FullMatrixSpace"/> returns the <A>F</A>-vector space that
consists of all <A>m</A> by <A>n</A> matrices
(see&nbsp;<Ref Func="IsMatrix"/>) with entries in <A>F</A>.
<P/>
If <A>m</A><C> = </C><A>n</A> then the result is in fact an algebra
(see&nbsp;<Ref Func="FullMatrixAlgebra"/>).
<P/>
An alternative to construct this vector space is via
<A>F</A><C>^[</C><A>m</A>,<A>n</A><C>]</C>.
<Example><![CDATA[
gap> FullMatrixSpace( GF(2), 4, 5 );
( GF(2)^[ 4, 5 ] )
gap> GF(2)^[ 4, 5 ];    # the same as above
( GF(2)^[ 4, 5 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DimensionOfVectors" Arg='M'/>

<Description>
For a left module <A>M</A> that consists of row vectors
(see&nbsp;<Ref Func="IsRowModule"/>),
<Ref Func="DimensionOfVectors"/> returns the common length of all row
vectors in <A>M</A>.
For a left module <A>M</A> that consists of matrices
(see&nbsp;<Ref Func="IsMatrixModule"/>),
<Ref Func="DimensionOfVectors"/> returns the common matrix dimensions
(see&nbsp;<Ref Func="DimensionsMat"/>) of all matrices in <A>M</A>.
<Example><![CDATA[
gap> DimensionOfVectors( GF(2)^5 );
5
gap> DimensionOfVectors( GF(2)^[2,3] );
[ 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSemiEchelonized" Arg='B'/>

<Description>
Let <A>B</A> be a basis of a Gaussian row or matrix space <M>V</M>, say
(see&nbsp;<Ref Func="IsGaussianSpace"/>) over the field <M>F</M>.
<P/>
If <M>V</M> is a row space then <A>B</A> is semi-echelonized if the matrix formed
by its basis vectors has the property that the first nonzero element in
each row is the identity of <M>F</M>,
and all values exactly below these pivot elements are the zero of <M>F</M>
(cf.&nbsp;<Ref Func="SemiEchelonMat"/>).
<P/>
If <M>V</M> is a matrix space then <A>B</A> is semi-echelonized if the matrix
obtained by replacing each basis vector by the concatenation of its rows
is semi-echelonized (see above, cf.&nbsp;<Ref Func="SemiEchelonMats"/>).
<Example><![CDATA[
gap> V:= GF(2)^2;;
gap> B1:= Basis( V, [ [ 0, 1 ], [ 1, 0 ] ] * Z(2) );;
gap> IsSemiEchelonized( B1 );
true
gap> B2:= Basis( V, [ [ 0, 1 ], [ 1, 1 ] ] * Z(2) );;
gap> IsSemiEchelonized( B2 );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SemiEchelonBasis" Arg='V[, vectors]'/>
<Oper Name="SemiEchelonBasisNC" Arg='V, vectors'/>

<Description>
Let <A>V</A> be a Gaussian row or matrix vector space over the field
<M>F</M> (see&nbsp;<Ref Func="IsGaussianSpace"/>,
<Ref Func="IsRowSpace"/>, <Ref Func="IsMatrixSpace"/>).
<P/>
Called with <A>V</A> as the only argument,
<Ref Attr="SemiEchelonBasis"/> returns a basis of <A>V</A>
that has the property <Ref Func="IsSemiEchelonized"/>.
<P/>
If additionally a list <A>vectors</A> of vectors in <A>V</A> is given
that forms a semi-echelonized basis of <A>V</A>
then <Ref Attr="SemiEchelonBasis"/> returns this basis;
if <A>vectors</A> do not form a basis of <A>V</A>
then <K>fail</K> is returned.
<P/>
<Ref Oper="SemiEchelonBasisNC"/> does the same as the two argument
version of <Ref Attr="SemiEchelonBasis"/>,
except that it is not checked whether <A>vectors</A> form
a semi-echelonized basis.
<Example><![CDATA[
gap> V:= GF(2)^2;;
gap> B:= SemiEchelonBasis( V );
SemiEchelonBasis( ( GF(2)^2 ), ... )
gap> Print( BasisVectors( B ), "\n" );
[ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ]
gap> B:= SemiEchelonBasis( V, [ [ 1, 1 ], [ 0, 1 ] ] * Z(2) );
SemiEchelonBasis( ( GF(2)^2 ), <an immutable 2x2 matrix over GF2> )
gap> Print( BasisVectors( B ), "\n" );
[ [ Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0 ] ]
gap> Coefficients( B, [ 0, 1 ] * Z(2) );
[ 0*Z(2), Z(2)^0 ]
gap> Coefficients( B, [ 1, 0 ] * Z(2) );
[ Z(2)^0, Z(2)^0 ]
gap> SemiEchelonBasis( V, [ [ 0, 1 ], [ 1, 1 ] ] * Z(2) );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsCanonicalBasisFullRowModule" Arg='B'/>

<Description>
<Index Subkey="for row spaces">canonical basis</Index>
<Ref Func="IsCanonicalBasisFullRowModule"/> returns <K>true</K> if
<A>B</A> is the canonical basis (see&nbsp;<Ref Func="IsCanonicalBasis"/>)
of a full row module (see&nbsp;<Ref Func="IsFullRowModule"/>),
and <K>false</K> otherwise.
<P/>
The <E>canonical basis</E> of a Gaussian row space is defined as the
unique semi-echelonized (see&nbsp;<Ref Func="IsSemiEchelonized"/>) basis
with the additional property that for <M>j > i</M> the position of the
pivot of row <M>j</M> is bigger than the position of the pivot of row
<M>i</M>, and that each pivot column contains exactly one nonzero entry.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsCanonicalBasisFullMatrixModule" Arg='B'/>

<Description>
<Index Subkey="for matrix spaces">canonical basis</Index>
<Ref Func="IsCanonicalBasisFullMatrixModule"/> returns <K>true</K> if
<A>B</A> is the canonical basis (see&nbsp;<Ref Func="IsCanonicalBasis"/>)
of a full matrix module (see&nbsp;<Ref Func="IsFullMatrixModule"/>),
and <K>false</K> otherwise.
<P/>
The <E>canonical basis</E> of a Gaussian matrix space is defined as the
unique semi-echelonized (see&nbsp;<Ref Func="IsSemiEchelonized"/>) basis
for which the list of concatenations of the basis vectors forms the
canonical basis of the corresponding Gaussian row space.
</Description>
</ManSection>

<ManSection>
<Attr Name="NormedRowVectors" Arg='V'/>

<Description>
For a finite Gaussian row space <A>V</A>
(see&nbsp;<Ref Func="IsRowSpace"/>, <Ref Func="IsGaussianSpace"/>),
<Ref Attr="NormedRowVectors"/> returns a list of those nonzero
vectors in <A>V</A> that have a one in the first nonzero component.
<P/>
The result list can be used as action domain for the action of a matrix
group via <Ref Func="OnLines"/>, which yields the natural action on
one-dimensional subspaces of <A>V</A>
(see also&nbsp;<Ref Func="Subspaces"/>).
<Example><![CDATA[
gap> vecs:= NormedRowVectors( GF(3)^2 );
[ [ 0*Z(3), Z(3)^0 ], [ Z(3)^0, 0*Z(3) ], [ Z(3)^0, Z(3)^0 ], 
  [ Z(3)^0, Z(3) ] ]
gap> Action( GL(2,3), vecs, OnLines );
Group([ (3,4), (1,2,4) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SiftedVector" Arg='B, v'/>

<Description>
Let <A>B</A> be a semi-echelonized basis (see&nbsp;<Ref Func="IsSemiEchelonized"/>) of a
Gaussian row or matrix space <M>V</M> (see&nbsp;<Ref Func="IsGaussianSpace"/>),
and <A>v</A> a row vector or matrix, respectively, of the same dimension as
the elements in <M>V</M>.
<C>SiftedVector</C> returns the <E>residuum</E> of <A>v</A> with respect to <A>B</A>, which
is obtained by successively cleaning the pivot positions in <A>v</A> by
subtracting multiples of the basis vectors in <A>B</A>.
So the result is the zero vector in <M>V</M> if and only if <A>v</A> lies in <M>V</M>.
<P/>
<A>B</A> may also be a mutable basis (see&nbsp;<Ref Sect="Mutable Bases"/>) of a Gaussian row
or matrix space.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ [ 1, 2, 7 ], [ 1/2, 1/3, 5 ] ] );;
gap> B:= Basis( V );;
gap> SiftedVector( B, [ 1, 2, 8 ] );
[ 0, 0, 1 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Vector Space Homomorphisms">
<Heading>Vector Space Homomorphisms</Heading>

<E>Vector space homomorphisms</E> (or <E>linear mappings</E>) are defined
in Section&nbsp;<Ref Sect="Linear Mappings"/>.
&GAP; provides special functions to construct a particular linear
mapping from images of given elements in the source,
from a matrix of coefficients, or as a natural epimorphism.
<P/>
<M>F</M>-linear mappings with same source and same range can be added,
so one can form vector spaces of linear mappings.

<ManSection>
<Oper Name="LeftModuleGeneralMappingByImages" Arg='V, W, gens, imgs'/>

<Description>
Let <A>V</A> and <A>W</A> be two left modules over the same left acting
domain <M>R</M>, say, and <A>gens</A> and <A>imgs</A> lists
(of the same length) of elements in <A>V</A> and <A>W</A>, respectively.
<Ref Oper="LeftModuleGeneralMappingByImages"/> returns
the general mapping with source <A>V</A> and range <A>W</A>
that is defined by mapping the elements in <A>gens</A> to the
corresponding elements in <A>imgs</A>,
and taking the <M>R</M>-linear closure.
<P/>
<A>gens</A> need not generate <A>V</A> as a left <M>R</M>-module,
and if the specification does not define a linear mapping then the result
will be multi-valued; hence in general it is not a mapping
(see&nbsp;<Ref Func="IsMapping"/>).
<Example><![CDATA[
gap> V:= Rationals^2;;
gap> W:= VectorSpace( Rationals, [ [1,2,3], [1,0,1] ] );;
gap> f:= LeftModuleGeneralMappingByImages( V, W,
>                                [[1,0],[2,0]], [[1,0,1],[1,0,1] ] );
[ [ 1, 0 ], [ 2, 0 ] ] -> [ [ 1, 0, 1 ], [ 1, 0, 1 ] ]
gap> IsMapping( f );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LeftModuleHomomorphismByImages" Arg='V, W, gens, imgs'/>
<Oper Name="LeftModuleHomomorphismByImagesNC" Arg='V, W, gens, imgs'/>

<Description>
Let <A>V</A> and <A>W</A> be two left modules over the same left acting
domain <M>R</M>, say, and <A>gens</A> and <A>imgs</A> lists (of the same
length) of elements in <A>V</A> and <A>W</A>, respectively.
<Ref Func="LeftModuleHomomorphismByImages"/> returns
the left <M>R</M>-module homomorphism with source <A>V</A> and range
<A>W</A> that is defined by mapping the elements in <A>gens</A> to the
corresponding elements in <A>imgs</A>.
<P/>
If <A>gens</A> does not generate <A>V</A> or if the homomorphism does not
exist (i.e., if mapping the generators describes only a multi-valued
mapping) then <K>fail</K> is returned.
For creating a possibly multi-valued mapping from <A>V</A> to <A>W</A>
that respects addition, multiplication, and scalar multiplication,
<Ref Func="LeftModuleGeneralMappingByImages"/> can be used.
<P/>
<Ref Oper="LeftModuleHomomorphismByImagesNC"/> does the same as
<Ref Func="LeftModuleHomomorphismByImages"/>,
except that it omits all checks.
<Example><![CDATA[
gap> V:=Rationals^2;;
gap> W:=VectorSpace( Rationals, [ [ 1, 0, 1 ], [ 1, 2, 3 ] ] );;
gap> f:=LeftModuleHomomorphismByImages( V, W,
> [ [ 1, 0 ], [ 0, 1 ] ], [ [ 1, 0, 1 ], [ 1, 2, 3 ] ] );
[ [ 1, 0 ], [ 0, 1 ] ] -> [ [ 1, 0, 1 ], [ 1, 2, 3 ] ]
gap> Image( f, [1,1] );
[ 2, 2, 4 ]
]]></Example>
</Description>
</ManSection>

<!-- % add an example for fin. fields! -->
<ManSection>
<Oper Name="LeftModuleHomomorphismByMatrix" Arg='BS, matrix, BR'/>

<Description>
Let <A>BS</A> and <A>BR</A> be bases of the left <M>R</M>-modules
<M>V</M> and <M>W</M>, respectively.
<Ref Oper="LeftModuleHomomorphismByMatrix"/> returns the <M>R</M>-linear
mapping from <M>V</M> to <M>W</M> that is defined by the matrix
<A>matrix</A>, as follows.
The image of the <M>i</M>-th basis vector of <A>BS</A> is the linear
combination of the basis vectors of <A>BR</A> with coefficients the
<M>i</M>-th row of <A>matrix</A>.
<Example><![CDATA[
gap> V:= Rationals^2;;
gap> W:= VectorSpace( Rationals, [ [ 1, 0, 1 ], [ 1, 2, 3 ] ] );;
gap> f:= LeftModuleHomomorphismByMatrix( Basis( V ),
> [ [ 1, 2 ], [ 3, 1 ] ], Basis( W ) );
<linear mapping by matrix, ( Rationals^
2 ) -> <vector space over Rationals, with 2 generators>>
]]></Example>
</Description>
</ManSection>

<!-- % show images! -->
<ManSection>
<Oper Name="NaturalHomomorphismBySubspace" Arg='V, W'/>

<Description>
For an <M>R</M>-vector space <A>V</A> and a subspace <A>W</A> of
<A>V</A>,
<Ref Oper="NaturalHomomorphismBySubspace"/> returns the <M>R</M>-linear
mapping that is the natural projection of <A>V</A> onto the factor space
<C><A>V</A> / <A>W</A></C>.
<Example><![CDATA[
gap> V:= Rationals^3;;
gap> W:= VectorSpace( Rationals, [ [ 1, 1, 1 ] ] );;
gap> f:= NaturalHomomorphismBySubspace( V, W );
<linear mapping by matrix, ( Rationals^3 ) -> ( Rationals^2 )>
]]></Example>
</Description>
</ManSection>

<!-- % show the computation of images etc.! -->
<ManSection>
<Oper Name="Hom" Arg='F, V, W'/>

<Description>
For a field <A>F</A> and two vector spaces <A>V</A> and <A>W</A>
that can be regarded as <A>F</A>-modules
(see&nbsp;<Ref Func="AsLeftModule"/>),
<Ref Oper="Hom"/> returns the <A>F</A>-vector space of
all <A>F</A>-linear mappings from <A>V</A> to <A>W</A>.
<Example><![CDATA[
gap> V:= Rationals^2;;
gap> W:= VectorSpace( Rationals, [ [ 1, 0, 1 ], [ 1, 2, 3 ] ] );;
gap> H:= Hom( Rationals, V, W );
Hom( Rationals, ( Rationals^2 ), <vector space over Rationals, with 
2 generators> )
gap> Dimension( H );
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="End" Arg='F, V'/>

<Description>
For a field <A>F</A> and a vector space <A>V</A> that can be regarded as
an <A>F</A>-module (see&nbsp;<Ref Func="AsLeftModule"/>),
<Ref Oper="End"/> returns the <A>F</A>-algebra of all <A>F</A>-linear
mappings from <A>V</A> to <A>V</A>.
<Example><![CDATA[
gap> A:= End( Rationals, Rationals^2 );
End( Rationals, ( Rationals^2 ) )
gap> Dimension( A );
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsFullHomModule" Arg='M'/>

<Description>
A <E>full hom module</E> is a module of all <M>R</M>-linear mappings
between two left <M>R</M>-modules.
The function <Ref Oper="Hom"/> can be used to construct a full hom
module.
<Example><![CDATA[
gap> V:= Rationals^2;;
gap> W:= VectorSpace( Rationals, [ [ 1, 0, 1 ], [ 1, 2, 3 ] ] );;
gap> H:= Hom( Rationals, V, W );;
gap> IsFullHomModule( H );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPseudoCanonicalBasisFullHomModule" Arg='B'/>

<Description>
A basis of a full hom module is called pseudo canonical basis
if the matrices of its basis vectors w.r.t. the stored bases of source
and range contain exactly one identity entry and otherwise zeros.
<P/>
Note that this is not a canonical basis
(see&nbsp;<Ref Func="CanonicalBasis"/>)
because it depends on the stored bases of source and range.
<Example><![CDATA[
gap> IsPseudoCanonicalBasisFullHomModule( Basis( H ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLinearMappingsModule" Arg='V'/>

<Description>
If an <M>F</M>-vector space <A>V</A> is in the filter
<Ref Filt="IsLinearMappingsModule"/> then
this expresses that <A>V</A> consists of linear mappings,
and that <A>V</A> is handled via the mechanism of nice bases
(see&nbsp;<Ref Sect="Vector Spaces Handled By Nice Bases"/>),
in the following way.
Let <M>S</M> and <M>R</M> be the source and the range, respectively,
of each mapping in <M>V</M>.
Then the <Ref Attr="NiceFreeLeftModuleInfo"/> value of <A>V</A> is
a record with the components <C>basissource</C> (a basis <M>B_S</M> of
<M>S</M>) and <C>basisrange</C> (a basis <M>B_R</M> of <M>R</M>),
and the <Ref Func="NiceVector"/> value of <M>v \in <A>V</A></M>
is defined as the matrix of the <M>F</M>-linear mapping <M>v</M>
w.r.t.&nbsp;the bases <M>B_S</M> and <M>B_R</M>.
</Description>
</ManSection>

<!-- % example: Create a space, show some computations! -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Vector Spaces Handled By Nice Bases">
<Heading>Vector Spaces Handled By Nice Bases</Heading>

There are kinds of free <M>R</M>-modules for which efficient computations
are possible because the elements are <Q>nice</Q>,
for example subspaces of full row modules or of full matrix modules.
In other cases, a <Q>nice</Q> canonical basis is known that allows one
to do the necessary computations in the corresponding row module,
for example algebras given by structure constants.
<P/>
In many other situations, one knows at least an isomorphism from the
given module <M>V</M> to a <Q>nicer</Q> free left module <M>W</M>,
in the sense that for each vector in <M>V</M>,
the image in <M>W</M> can easily be computed,
and analogously for each vector in <M>W</M>,
one can compute the preimage in <M>V</M>.
<P/>
This allows one to delegate computations w.r.t.&nbsp;a basis <M>B</M>,
say, of <M>V</M> to the corresponding basis <M>C</M>, say, of <M>W</M>.
We call <M>W</M> the <E>nice free left module</E> of <M>V</M>,
and <M>C</M> the <E>nice basis</E> of <M>B</M>.
(Note that it may happen that also <M>C</M> delegates questions to a
<Q>nicer</Q> basis.)
The basis <M>B</M> indicates the intended behaviour by the filter
<Ref Func="IsBasisByNiceBasis"/>,
and stores <M>C</M> as value of the attribute <Ref Attr="NiceBasis"/>.
<M>V</M> indicates the intended behaviour by the filter
<Ref Filt="IsHandledByNiceBasis"/>, and stores <M>W</M> as value
of the attribute <Ref Func="NiceFreeLeftModule"/>.
<P/>
The bijection between <M>V</M> and <M>W</M> is implemented by the
functions <Ref Func="NiceVector"/> and <Ref Func="UglyVector"/>;
additional data needed to compute images and preimages can be stored
as value of <Ref Func="NiceFreeLeftModuleInfo"/>.

<ManSection>
<Attr Name="NiceFreeLeftModule" Arg='V'/>

<Description>
For a free left module <A>V</A> that is handled via the mechanism of nice
bases, this attribute stores the associated free left module to which the
tasks are delegated.
</Description>
</ManSection>

<ManSection>
<Oper Name="NiceVector" Arg='V, v'/>
<Oper Name="UglyVector" Arg='V, r'/>

<Description>
<Ref Oper="NiceVector"/> and <Ref Oper="UglyVector"/> provide the linear bijection between the
free left module <A>V</A> and <C><A>W</A>:= NiceFreeLeftModule( <A>V</A> )</C>.
<P/>
If <A>v</A> lies in the elements family of the family of <A>V</A> then
<C>NiceVector( <A>v</A> )</C> is either <K>fail</K> or an element in the elements family
of the family of <A>W</A>.
<P/>
If <A>r</A> lies in the elements family of the family of <A>W</A> then
<C>UglyVector( <A>r</A> )</C> is either <K>fail</K> or an element in the elements family
of the family of <A>V</A>.
<P/>
If <A>v</A> lies in <A>V</A> (which usually <E>cannot</E> be checked without using <A>W</A>)
then <C>UglyVector( <A>V</A>, NiceVector( <A>V</A>, <A>v</A> ) ) = <A>v</A></C>.
If <A>r</A> lies in <A>W</A> (which usually <E>can</E> be checked)
then <C>NiceVector( <A>V</A>, UglyVector( <A>V</A>, <A>r</A> ) ) = <A>r</A></C>.
<P/>
(This allows one to implement for example a membership test for <A>V</A>
using the membership test in <A>W</A>.)
</Description>
</ManSection>

<ManSection>
<Attr Name="NiceFreeLeftModuleInfo" Arg='V'/>

<Description>
For a free left module <A>V</A> that is handled via the mechanism of nice
bases, this operation has to provide the necessary information (if any)
for calls of <Ref Oper="NiceVector"/> and <Ref Oper="UglyVector"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="NiceBasis" Arg='B'/>

<Description>
Let <A>B</A> be a basis of a free left module <A>V</A> that is handled via
nice bases.
If <A>B</A> has no basis vectors stored at the time of the first call to
<C>NiceBasis</C> then <C>NiceBasis( <A>B</A> )</C> is obtained as
<C>Basis( NiceFreeLeftModule( <A>V</A> ) )</C>.
If basis vectors are stored then <C>NiceBasis( <A>B</A> )</C> is the result of the
call of <C>Basis</C> with arguments <C>NiceFreeLeftModule( <A>V</A> )</C>
and the <C>NiceVector</C> values of the basis vectors of <A>B</A>.
<P/>
Note that the result is <K>fail</K> if and only if the <Q>basis vectors</Q>
stored in <A>B</A> are in fact not basis vectors.
<P/>
The attributes <C>GeneratorsOfLeftModule</C> of the underlying left modules
of <A>B</A> and the result of <C>NiceBasis</C> correspond via <Ref Func="NiceVector"/> and
<Ref Func="UglyVector"/>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsBasisByNiceBasis" Arg='B' Type='Category'/>

<Description>
This filter indicates that the basis <A>B</A> delegates tasks such as the
computation of coefficients (see&nbsp;<Ref Func="Coefficients"/>) to a basis of an
isomorphic <Q>nicer</Q> free left module.
<!--  Any object in <C>IsBasisByNiceBasis</C> must be a <E>small</E> list in the sense of-->
<!--  <Ref Prop="IsSmallList"/>.-->
</Description>
</ManSection>

<ManSection>
<Filt Name="IsHandledByNiceBasis" Arg='M' Type='Category'/>

<Description>
For a free left module <A>M</A> in this category, essentially all operations
are performed using a <Q>nicer</Q> free left module,
which is usually a row module.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="How to Implement New Kinds of Vector Spaces">
<Heading>How to Implement New Kinds of Vector Spaces</Heading>

<!-- % put this into the <C>prg</C> or <C>ext</C> manual? -->
<ManSection>
<Func Name="DeclareHandlingByNiceBasis" Arg='name, info'/>
<Func Name="InstallHandlingByNiceBasis" Arg='name, record'/>

<Description>
These functions are used to implement a new kind of free left modules
that shall be handled via the mechanism of nice bases
(see&nbsp;<Ref Sect="Vector Spaces Handled By Nice Bases"/>).
<P/>
<A>name</A> must be a string,
a filter <M>f</M> with this name is created, and
a logical implication from <M>f</M> to <Ref Filt="IsHandledByNiceBasis"/>
is installed.
<P/>
<A>record</A> must be a record with the following components.
<List>
<Mark><C>detect</C> </Mark>
<Item>
    a function of four arguments <M>R</M>, <M>l</M>, <M>V</M>, and <M>z</M>,
    where <M>V</M> is a free left module over the ring <M>R</M> with generators
    the list or collection <M>l</M>, and <M>z</M> is either the zero element of
    <M>V</M> or <K>false</K> (then <M>l</M> is nonempty);
    the function returns <K>true</K> if <M>V</M> shall lie in the filter <M>f</M>,
    and <K>false</K> otherwise;
    the return value may also be <K>fail</K>, which indicates that <M>V</M> is
    <E>not</E> to be handled via the mechanism of nice bases at all,
</Item>
<Mark><C>NiceFreeLeftModuleInfo</C> </Mark>
<Item>
    the <C>NiceFreeLeftModuleInfo</C> method for left modules in <M>f</M>,
</Item>
<Mark><C>NiceVector</C> </Mark>
<Item>
    the <C>NiceVector</C> method for left modules <M>V</M> in <M>f</M>;
    called with <M>V</M> and a vector <M>v \in V</M>, this function returns the
    nice vector <M>r</M> associated with <M>v</M>, and
</Item>
<Mark><C>UglyVector</C></Mark>
<Item>
    the <Ref Func="UglyVector"/> method for left modules <M>V</M> in <M>f</M>;
    called with <M>V</M> and a vector <M>r</M> in the <C>NiceFreeLeftModule</C> value
    of <M>V</M>, this function returns the vector <M>v \in V</M> to which <M>r</M> is
    associated.
</Item>
</List>
<P/>
The idea is that all one has to do for implementing a new kind of free
left modules handled by the mechanism of nice bases is to call
<C>DeclareHandlingByNiceBasis</C> and <C>InstallHandlingByNiceBasis</C>,
which causes the installation of the necessary methods and adds the pair
<M>[ f, </M><C><A>record</A>.detect</C><M> ]</M> to the global list <C>NiceBasisFiltersInfo</C>.
The <Ref Func="LeftModuleByGenerators"/> methods call
<Ref Func="CheckForHandlingByNiceBasis"/>, which sets the appropriate filter
for the desired left module if applicable.
</Description>
</ManSection>

<ManSection>
<Var Name="NiceBasisFiltersInfo"/>

<Description>
An overview of all kinds of vector spaces that are currently handled by
nice bases is given by the global list <C>NiceBasisFiltersInfo</C>.
Examples of such vector spaces are vector spaces of field elements
(but not the fields themselves) and non-Gaussian row and matrix spaces
(see&nbsp;<Ref Func="IsGaussianSpace"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="CheckForHandlingByNiceBasis" Arg='R, gens, M, zero'/>

<Description>
Whenever a free left module is constructed for which the filter
<C>IsHandledByNiceBasis</C> may be useful,
<C>CheckForHandlingByNiceBasis</C> should be called.
(This is done in the methods for <C>VectorSpaceByGenerators</C>,
<C>AlgebraByGenerators</C>, <C>IdealByGenerators</C> etc.&nbsp;in the &GAP; library.)
<P/>
The arguments of this function are the coefficient ring <A>R</A>, the list
<A>gens</A> of generators, the constructed module <A>M</A> itself, and the zero
element <A>zero</A> of <A>M</A>;
if <A>gens</A> is nonempty then the <A>zero</A> value may also be <K>false</K>.
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  algebra.msk                  GAP documentation            Willem de Graaf -->
<!-- %% -->
<!-- %A  @(#)<M>Id: algebra.msk,v 1.35 2006/03/10 08:55:52 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Algebras">
<Heading>Algebras</Heading>

An algebra is a vector space equipped with a bilinear map
(multiplication).
This chapter describes the functions in &GAP; that deal with 
general algebras and associative algebras. 
<P/>
Algebras in &GAP; are vector spaces in a natural way.
So all the functionality for vector spaces
(see Chapter&nbsp;<Ref Chap="Vector Spaces"/>)
is also applicable to algebras.


<!-- %%  The algebra functionality was designed and implemented by Thomas Breuer and -->
<!-- %%  Willem de Graaf. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:InfoAlgebra">
<Heading>InfoAlgebra (Info Class)</Heading>

<ManSection>
<InfoClass Name="InfoAlgebra"/>

<Description>
is the info class for the functions dealing with algebras
(see&nbsp;<Ref Sect="Info Functions"/>).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Algebras by Generators">
<Heading>Constructing Algebras by Generators</Heading>

<!-- % AlgebraByGenerators( <A>F</A>, <A>gens</A>, <A>zero</A> ) Left out... -->

<ManSection>
<Func Name="Algebra" Arg='F, gens[, zero][, "basis"]'/>

<Description>
<C>Algebra( <A>F</A>, <A>gens</A> )</C> is the algebra over the division
ring <A>F</A>, generated by the vectors in the list <A>gens</A>.
<P/>
If there are three arguments, a division ring <A>F</A> and a list
<A>gens</A> and an element <A>zero</A>,
then <C>Algebra( <A>F</A>, <A>gens</A>, <A>zero</A> )</C> is the
<A>F</A>-algebra generated by <A>gens</A>, with zero element <A>zero</A>.
<P/>
If the last argument is the string <C>"basis"</C> then the vectors in
<A>gens</A> are known to form a basis of the algebra
(as an <A>F</A>-vector space).
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap> A:= Algebra( Rationals, [ m ] );
<algebra over Rationals, with 1 generators>
gap> Dimension( A );
2
]]></Example>
</Description>
</ManSection>

<!-- %  AlgebraWithOneByGenerators( <A>F</A>, <A>gens</A>, <A>zero</A> ) Left out... -->
<ManSection>
<Func Name="AlgebraWithOne" Arg='F, gens[, zero][, "basis"]'/>

<Description>
<C>AlgebraWithOne( <A>F</A>, <A>gens</A> )</C> is the algebra-with-one
over the division ring <A>F</A>,
generated by the vectors in the list <A>gens</A>.
<P/>
If there are three arguments, a division ring <A>F</A>
and a list <A>gens</A> and an element <A>zero</A>,
then <C>AlgebraWithOne( <A>F</A>, <A>gens</A>, <A>zero</A> )</C> is the
<A>F</A>-algebra-with-one generated by <A>gens</A>,
with zero element <A>zero</A>.
<P/>
If the last argument is the string <C>"basis"</C> then the vectors in
<A>gens</A> are known to form a basis of the algebra
(as an <A>F</A>-vector space).
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap> A:= AlgebraWithOne( Rationals, [ m ] );
<algebra-with-one over Rationals, with 1 generators>
gap> Dimension( A );
3
gap> One(A);
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Algebras as Free Algebras">
<Heading>Constructing Algebras as Free Algebras</Heading>

<ManSection>
<Func Name="FreeAlgebra" Arg='R, rank[, name]'
 Label="for ring, rank (and name)"/>
<Func Name="FreeAlgebra" Arg='R, name1, name2, ...'
 Label="for ring and several names"/>

<Description>
is a free (nonassociative) algebra of rank <A>rank</A>
over the division ring <A>R</A>.
Here <A>name</A>, and <A>name1</A>, <A>name2</A>, ... are optional strings
that can be used to provide names for the generators.
<Example><![CDATA[
gap> A:= FreeAlgebra( Rationals, "a", "b" );
<algebra over Rationals, with 2 generators>
gap> g:= GeneratorsOfAlgebra( A );
[ (1)*a, (1)*b ]
gap> (g[1]*g[2])*((g[2]*g[1])*g[1]);
(1)*((a*b)*((b*a)*a))
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeAlgebraWithOne" Arg='R, rank[, name]'
 Label="for ring, rank (and name)"/>
<Func Name="FreeAlgebraWithOne" Arg='R, name1, name2, ...'
 Label="for ring and several names"/>

<Description>
is a free (nonassociative) algebra-with-one of rank <A>rank</A>
over the division ring <A>R</A>.
Here <A>name</A>, and <A>name1</A>, <A>name2</A>, ... are optional strings
that can be used to provide names for the generators.
<Example><![CDATA[
gap> A:= FreeAlgebraWithOne( Rationals, 4, "q" );
<algebra-with-one over Rationals, with 4 generators>
gap> GeneratorsOfAlgebra( A );
[ (1)*<identity ...>, (1)*q.1, (1)*q.2, (1)*q.3, (1)*q.4 ]
gap> One( A );
(1)*<identity ...>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeAssociativeAlgebra" Arg='R, rank[, name]'
 Label="for ring, rank (and name)"/>
<Func Name="FreeAssociativeAlgebra" Arg='R, name1, name2, ...'
 Label="for ring and several names"/>

<Description>
is a free associative algebra of rank <A>rank</A> over the
division ring <A>R</A>.
Here <A>name</A>, and <A>name1</A>, <A>name2</A>, ... are optional strings
that can be used to provide names for the generators.
<Example><![CDATA[
gap> A:= FreeAssociativeAlgebra( GF( 5 ), 4, "a" );
<algebra over GF(5), with 4 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeAssociativeAlgebraWithOne" Arg='R, rank[, name]'
 Label="for ring, rank (and name)"/>
<Func Name="FreeAssociativeAlgebraWithOne" Arg='R, name1, name2, ...'
 Label="for ring and several names"/>

<Description>
is a free associative algebra-with-one of rank <A>rank</A> over the
division ring <A>R</A>.
Here <A>name</A>, and <A>name1</A>, <A>name2</A>, ... are optional strings
that can be used to provide names for the generators.
<Example><![CDATA[
gap> A:= FreeAssociativeAlgebraWithOne( Rationals, "a", "b", "c" );
<algebra-with-one over Rationals, with 3 generators>
gap> GeneratorsOfAlgebra( A );
[ (1)*<identity ...>, (1)*a, (1)*b, (1)*c ]
gap> One( A );
(1)*<identity ...>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Algebras by Structure Constants">
<Heading>Constructing Algebras by Structure Constants</Heading>

For an introduction into structure constants and how they are handled
by &GAP;, we refer to Section <Ref Sect="Algebras" BookName="tut"/>
of the user's tutorial.

<ManSection>
<Func Name="AlgebraByStructureConstants" Arg='R, sctable[, nameinfo]'/>

<Description>
returns a free left module <M>A</M> over the division ring <A>R</A>,
with multiplication defined by the structure constants table
<A>sctable</A>.
The optional argument <A>nameinfo</A> can be used to prescribe names for
the elements of the canonical basis of <M>A</M>;
it can be either a string <A>name</A>
(then <A>name</A><C>1</C>, <A>name</A><C>2</C> etc. are chosen)
or a list of strings which are then chosen.
The vectors of the canonical basis of <M>A</M> correspond to the vectors
of the basis given by <A>sctable</A>.
<P/>
<!-- The algebra generators of <M>A</M> are linearly independent
  abstract vector space generators
  <M>x_1, x_2, \ldots, x_n</M> which are multiplied according to the
  formula <M> x_i x_j = \sum_{k=1}^n c_{ijk} x_k</M>
  where <C><M>c_{ijk}</M> = <A>sctable</A>[i][j][1][i_k]</C>
  and <C><A>sctable</A>[i][j][2][i_k] = k</C>. -->
It is <E>not</E> checked whether the coefficients in <A>sctable</A>
are really elements in <A>R</A>.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [ 1/2, 1, 2/3, 2 ] );
gap> A:= AlgebraByStructureConstants( Rationals, T );
<algebra of dimension 2 over Rationals>
gap> b:= BasisVectors( Basis( A ) );;
gap> b[1]^2;
(1/2)*v.1+(2/3)*v.2
gap> b[1]*b[2];
0*v.1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="StructureConstantsTable" Arg='B'/>

<Description>
Let <A>B</A> be a basis of a free left module <M>R</M>, say,
that is also a ring.
In this case <Ref Func="StructureConstantsTable"/> returns
a structure constants table <M>T</M> in sparse representation,
as used for structure constants algebras
(see Section&nbsp;<Ref Sect="Algebras" BookName="tut"/>
of the &GAP; User's Tutorial).
<P/>
If <A>B</A> has length <M>n</M> then <M>T</M> is a list of length
<M>n+2</M>.
The first <M>n</M> entries of <M>T</M> are lists of length <M>n</M>.
<M>T[ n+1 ]</M> is one of <M>1</M>, <M>-1</M>, or <M>0</M>;
in the case of <M>1</M> the table is known to be symmetric,
in the case of <M>-1</M> it is known to be antisymmetric,
and <M>0</M> occurs in all other cases.
<M>T[ n+2 ]</M> is the zero element of the coefficient domain.
<P/>
The coefficients w.r.t.&nbsp;<A>B</A> of the product of the <M>i</M>-th
and <M>j</M>-th basis vector of <A>B</A> are stored in <M>T[i][j]</M>
as a list of length <M>2</M>;
its first entry is the list of positions of nonzero coefficients,
the second entry is the list of these coefficients themselves.
<P/>
The multiplication in an algebra <M>A</M> with vector space basis
<A>B</A> with basis vectors <M>[ v_1, \ldots, v_n ]</M>
is determined by the so-called structure matrices
<M>M_k = [ m_{ijk} ]_{ij}</M>, <M>1 \leq k \leq n</M>.
The <M>M_k</M> are defined by <M>v_i v_j = \sum_k m_{ijk} v_k</M>.
Let <M>a = [ a_1, \ldots, a_n ]</M> and <M>b = [ b_1, \ldots, b_n ]</M>.
Then
<Display Mode="M">
\left( \sum_i a_i v_i \right) \left( \sum_j b_j v_j \right)
   = \sum_{{i,j}} a_i b_j \left( v_i v_j \right)
   = \sum_k \left( \sum_j \left( \sum_i a_i m_{ijk} \right) b_j \right) v_k
   = \sum_k \left( a M_k b^{tr} \right) v_k.
</Display>
<P/>
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> StructureConstantsTable( Basis( A ) );
[ [ [ [ 1 ], [ 1 ] ], [ [ 2 ], [ 1 ] ], [ [ 3 ], [ 1 ] ], 
      [ [ 4 ], [ 1 ] ] ], 
  [ [ [ 2 ], [ 1 ] ], [ [ 1 ], [ -1 ] ], [ [ 4 ], [ 1 ] ], 
      [ [ 3 ], [ -1 ] ] ], 
  [ [ [ 3 ], [ 1 ] ], [ [ 4 ], [ -1 ] ], [ [ 1 ], [ -1 ] ], 
      [ [ 2 ], [ 1 ] ] ], 
  [ [ [ 4 ], [ 1 ] ], [ [ 3 ], [ 1 ] ], [ [ 2 ], [ -1 ] ], 
      [ [ 1 ], [ -1 ] ] ], 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="EmptySCTable" Arg='dim, zero[, flag]'/>

<Description>
<Ref Func="EmptySCTable"/> returns a structure constants table for an
algebra of dimension <A>dim</A>, describing trivial multiplication.
<A>zero</A> must be the zero of the coefficients domain.
If the multiplication is known to be (anti)commutative then
this can be indicated by the optional third argument <A>flag</A>,
which must be one of the strings <C>"symmetric"</C>,
<C>"antisymmetric"</C>.
<P/>
For filling up the structure constants table,
see <Ref Func="SetEntrySCTable"/>.
<Example><![CDATA[
gap> EmptySCTable( 2, Zero( GF(5) ), "antisymmetric" );
[ [ [ [  ], [  ] ], [ [  ], [  ] ] ], 
  [ [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 0*Z(5) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SetEntrySCTable" Arg='T, i, j, list'/>

<Description>
sets the entry of the structure constants table <A>T</A> that describes
the product of the <A>i</A>-th basis element with the <A>j</A>-th
basis element to the value given by the list <A>list</A>.
<P/>
If <A>T</A> is known to be antisymmetric or symmetric then also the value
<C><A>T</A>[<A>j</A>][<A>i</A>]</C> is set.
<P/>
<A>list</A> must be of the form
<M>[ c_{ij}^{{k_1}}, k_1, c_{ij}^{{k_2}}, k_2, \ldots ]</M>.
<P/>
The entries at the odd positions of <A>list</A> must be compatible with
the zero element stored in <A>T</A>.
For convenience, these entries may also be rational numbers that are
automatically replaced by the corresponding elements in the appropriate
prime field in finite characteristic if necessary.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [ 1/2, 1, 2/3, 2 ] );
gap> T;
[ [ [ [ 1, 2 ], [ 1/2, 2/3 ] ], [ [  ], [  ] ] ], 
  [ [ [  ], [  ] ], [ [  ], [  ] ] ], 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GapInputSCTable" Arg='T, varname'/>

<Description>
is a string that describes the structure constants table <A>T</A>
in terms of <Ref Func="EmptySCTable"/> and <Ref Func="SetEntrySCTable"/>.
The assignments are made to the variable <A>varname</A>.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 2 ] );
gap> SetEntrySCTable( T, 2, 1, [ 1, 2 ] );
gap> GapInputSCTable( T, "T" );
"T:= EmptySCTable( 2, 0 );\nSetEntrySCTable( T, 1, 2, [1,2] );\nSetEnt\
rySCTable( T, 2, 1, [1,2] );\n"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TestJacobi" Arg='T'/>

<Description>
tests whether the structure constants table <A>T</A> satisfies the Jacobi
identity
<M>v_i * (v_j * v_k) + v_j * (v_k * v_i) + v_k * (v_i * v_j) = 0</M>
for all basis vectors <M>v_i</M> of the underlying algebra,
where <M>i \leq j \leq k</M>.
(Thus antisymmetry is assumed.)
<P/>
The function returns <K>true</K> if the Jacobi identity is satisfied,
and a failing triple <M>[ i, j, k ]</M> otherwise.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 2 ] );;
gap> TestJacobi( T );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IdentityFromSCTable" Arg='T'/>

<Description>
Let <A>T</A> be a structure constants table of an algebra <M>A</M>
of dimension <M>n</M>.
<C>IdentityFromSCTable( <A>T</A> )</C> is either <K>fail</K> or
the vector of length <M>n</M> that contains the coefficients of the
multiplicative identity of <M>A</M>
with respect to the basis that belongs to <A>T</A>.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [ 1, 1 ] );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 2 ] );;
gap> SetEntrySCTable( T, 2, 1, [ 1, 2 ] );;
gap> IdentityFromSCTable( T );
[ 1, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="QuotientFromSCTable" Arg='T, num, den'/>

<Description>
Let <A>T</A> be a structure constants table of an algebra <M>A</M>
of dimension <M>n</M>.
<C>QuotientFromSCTable( <A>T</A> )</C> is either <K>fail</K> or
the vector of length <M>n</M> that contains the coefficients of the
quotient of <A>num</A> and <A>den</A> with respect to the basis
that belongs to <A>T</A>.
<P/>
We solve the equation system <A>num</A><M> = x *</M> <A>den</A>.
If no solution exists, <K>fail</K> is returned.
<P/>
In terms of the basis <M>B</M> with vectors <M>b_1, \ldots, b_n</M>
this means
for <M><A>num</A> = \sum_{{i = 1}}^n a_i b_i</M>,
    <M><A>den</A> = \sum_{{i = 1}}^n c_i b_i</M>,
    <M>x = \sum_{{i = 1}}^n x_i b_i</M> that
<M>a_k = \sum_{{i,j}} c_i x_j c_{ijk}</M> for all <M>k</M>.
Here <M>c_{ijk}</M> denotes the structure constants
with respect to <M>B</M>.
This means that (as a vector) <M>a = x M</M> with
<M>M_{jk} = \sum_{{i = 1}}^n c_{ijk} c_i</M>.
<P/>
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [ 1, 1 ] );;
gap> SetEntrySCTable( T, 2, 1, [ 1, 2 ] );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 2 ] );;
gap> QuotientFromSCTable( T, [0,1], [1,0] );
[ 0, 1 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Some Special Algebras">
<Heading>Some Special Algebras</Heading>

<ManSection>
<Func Name="QuaternionAlgebra" Arg='F[, a, b]'/>

<Returns>
a quaternion algebra over <A>F</A>,
with parameters <A>a</A> and <A>b</A>.
</Returns>
<Description>
Let <A>F</A> be a field or a list of field elements,
let <M>F</M> be the field generated by <A>F</A>,
and let <A>a</A> and <A>b</A> two elements in <M>F</M>.
<Ref Func="QuaternionAlgebra"/> returns a quaternion algebra over
<M>F</M>, with parameters <A>a</A> and <A>b</A>,
i.e., a four-dimensional associative <M>F</M>-algebra with basis
<M>(e,i,j,k)</M> and multiplication defined by
<M>e e = e</M>, <M>e i = i e = i</M>, <M>e j = j e = j</M>,
<M>e k = k e = k</M>, <M>i i = <A>a</A> e</M>, <M>i j = - j i = k</M>,
<M>i k = - k i = <A>a</A> j</M>, <M>j j = <A>b</A> e</M>,
<M>j k = - k j = <A>b</A> i</M>, <M>k k = - <A>a</A> <A>b</A> e</M>.
The default value for both <A>a</A> and <A>b</A> is
<M>-1 \in F</M>.
<P/>
The <Ref Attr="GeneratorsOfAlgebra"/> and <Ref Attr="CanonicalBasis"/>
value of an algebra constructed with <Ref Func="QuaternionAlgebra"/>
is the list <M>[ e, i, j, k ]</M>.
<P/>
Two quaternion algebras with the same parameters <A>a</A>, <A>b</A>
lie in the same family, so it makes sense to consider their intersection
or to ask whether they are contained in each other.
(This is due to the fact that the results of
<Ref Func="QuaternionAlgebra"/> are cached,
in the global variable <C>QuaternionAlgebraData</C>.)
<P/>
The embedding of the field <Ref Var="GaussianRationals"/> into
a quaternion algebra <M>A</M> over <Ref Var="Rationals"/>
is not uniquely determined.
One can specify one embedding as a vector space homomorphism
that maps <C>1</C> to the first algebra generator of <M>A</M>,
and <C>E(4)</C> to one of the others.
<Example><![CDATA[
gap> QuaternionAlgebra( Rationals );
<algebra-with-one of dimension 4 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ComplexificationQuat" Arg='vector' Label="for a vector"/>
<Func Name="ComplexificationQuat" Arg='matrix' Label="for a matrix"/>

<Description>
Let <M>A = e F \oplus i F \oplus j F \oplus k F</M> be
a quaternion algebra over the field <M>F</M> of cyclotomics,
with basis <M>(e,i,j,k)</M>.
<P/>
If <M>v = v_1 + v_2 j</M> is a row vector over <M>A</M>
with <M>v_1 = e w_1 + i w_2</M>
and <M>v_2 = e w_3 + i w_4</M> then
<Ref Func="ComplexificationQuat" Label="for a vector"/>
called with argument <M>v</M> returns the
concatenation of <M>w_1 + </M><C>E(4)</C><M> w_2</M> and
<M>w_3 + </M><C>E(4)</C><M> w_4</M>.
<P/>
If <M>M = M_1 + M_2 j</M> is a matrix over <M>A</M>
with <M>M_1 = e N_1 + i N_2</M>
and <M>M_2 = e N_3 + i N_4</M> then
<Ref Func="ComplexificationQuat" Label="for a matrix"/>
called with argument <M>M</M> returns the
block matrix <M>A</M> over <M>e F \oplus i F</M> such that
<M>A(1,1) = N_1 + </M><C>E(4)</C><M> N_2</M>,
<M>A(2,2) = N_1 - </M><C>E(4)</C><M> N_2</M>,
<M>A(1,2) = N_3 + </M><C>E(4)</C><M> N_4</M>, and
<M>A(2,1) = - N_3 + </M><C>E(4)</C><M> N_4</M>.
<P/>
Then <C>ComplexificationQuat(<A>v</A>) * ComplexificationQuat(<A>M</A>)=
      ComplexificationQuat(<A>v</A> * <A>M</A>)</C>, since
<Display Mode="M">
v M = v_1 M_1 + v_2 j M_1 + v_1 M_2 j + v_2 j M_2 j
    =   ( v_1 M_1 - v_2 \overline{{M_2}} )
      + ( v_1 M_2 + v_2 \overline{{M_1}} ) j.
</Display>
</Description>
</ManSection>

<ManSection>
<Func Name="OctaveAlgebra" Arg='F'/>

<Description>
The algebra of octonions over <A>F</A>.
<Example><![CDATA[
gap> OctaveAlgebra( Rationals );
<algebra of dimension 8 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FullMatrixAlgebra" Arg='R, n'/>
<Func Name="MatrixAlgebra" Arg='R, n'/>
<Func Name="MatAlgebra" Arg='R, n'/>

<Description>
is the full matrix algebra of <M><A>n</A> \times <A>n</A></M> matrices
over the ring <A>R</A>,
for a nonnegative integer <A>n</A>.
<Example><![CDATA[
gap> A:=FullMatrixAlgebra( Rationals, 20 );
( Rationals^[ 20, 20 ] )
gap> Dimension( A );
400
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NullAlgebra" Arg='R'/>

<Description>
The zero-dimensional algebra over <A>R</A>.
<!-- or store this in the family ?-->
<Example><![CDATA[
gap> A:= NullAlgebra( Rationals );
<algebra over Rationals>
gap> Dimension( A );
0
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subalgebras">
<Heading>Subalgebras</Heading>

<ManSection>
<Func Name="Subalgebra" Arg='A, gens[, "basis"]'/>

<Description>
is the <M>F</M>-algebra generated by <A>gens</A>,
with parent algebra <A>A</A>,
where <M>F</M> is the left acting domain of <A>A</A>.
<P/>
<E>Note</E> that being a subalgebra of <A>A</A> means to be an algebra,
to be contained in <A>A</A>,
<E>and</E> to have the same left acting domain as <A>A</A>.
<P/>
An optional argument <C>"basis"</C> may be added if it is known that
the generators already form a basis of the algebra.
Then it is <E>not</E> checked whether <A>gens</A> really are linearly
independent and whether all elements in <A>gens</A> lie in <A>A</A>.
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap> A:= Algebra( Rationals, [ m ] );
<algebra over Rationals, with 1 generators>
gap> B:= Subalgebra( A, [ m^2 ] );
<algebra over Rationals, with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubalgebraNC" Arg='A, gens[, "basis"]'/>

<Description>
<Ref Func="SubalgebraNC"/> does the same as
<Ref Func="Subalgebra"/>, except that it does not check
whether all elements in <A>gens</A> lie in <A>A</A>.
<Example><![CDATA[
gap> m:= RandomMat( 3, 3 );;
gap> A:= Algebra( Rationals, [ m ] );
<algebra over Rationals, with 1 generators>
gap> SubalgebraNC( A, [ IdentityMat( 3, 3 ) ], "basis" );
<algebra of dimension 1 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubalgebraWithOne" Arg='A, gens[, "basis"]'/>

<Description>
is the algebra-with-one generated by <A>gens</A>,
with parent algebra <A>A</A>.
<P/>
The optional third argument, the string <C>"basis"</C>, may be added if
it is known that the elements from <A>gens</A> are linearly independent.
Then it is <E>not</E> checked whether <A>gens</A> really are linearly
independent and whether all elements in <A>gens</A> lie in <A>A</A>.
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap> A:= AlgebraWithOne( Rationals, [ m ] );
<algebra-with-one over Rationals, with 1 generators>
gap> B1:= SubalgebraWithOne( A, [ m ] );;
gap> B2:= Subalgebra( A, [ m ] );;
gap> Dimension( B1 );
3
gap> Dimension( B2 );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SubalgebraWithOneNC" Arg='A, gens[, "basis"]'/>

<Description>
<Ref Func="SubalgebraWithOneNC"/> does the same as
<Ref Func="SubalgebraWithOne"/>, except that it does not check
whether all elements in <A>gens</A> lie in <A>A</A>.
<Example><![CDATA[
gap> m:= RandomMat( 3, 3 );; A:= Algebra( Rationals, [ m ] );;
gap> SubalgebraWithOneNC( A, [ m ] );
<algebra-with-one over Rationals, with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TrivialSubalgebra" Arg='A'/>

<Description>
The zero dimensional subalgebra of the algebra <A>A</A>.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> B:= TrivialSubalgebra( A );
<algebra over Rationals>
gap> Dimension( B );
0
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Ideals of Algebras">
<Heading>Ideals of Algebras</Heading>

For constructing and working with ideals in algebras the same functions
are available as for ideals in rings. So for the precise description of
these functions we refer to Chapter <Ref Chap="Rings"/>. Here we give examples
demonstrating the use of ideals in algebras.
For an introduction into the construction of quotient algebras
we refer to Chapter <Ref Sect="Algebras" BookName="tut"/>
of the user's tutorial.
<P/>
<Example><![CDATA[
gap> m:= [ [ 0, 2, 3 ], [ 0, 0, 4 ], [ 0, 0, 0] ];;
gap> A:= AlgebraWithOne( Rationals, [ m ] );;
gap> I:= Ideal( A, [ m ] );  # the two-sided ideal of `A' generated by `m'
<two-sided ideal in <algebra-with-one of dimension 3 over Rationals>, 
  (1 generators)>
gap> Dimension( I );
2
gap> GeneratorsOfIdeal( I );
[ [ [ 0, 2, 3 ], [ 0, 0, 4 ], [ 0, 0, 0 ] ] ]
gap> BasisVectors( Basis( I ) );
[ [ [ 0, 1, 3/2 ], [ 0, 0, 2 ], [ 0, 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ] ]
gap> A:= FullMatrixAlgebra( Rationals, 4 );;
gap> m:= NullMat( 4, 4 );; m[1][4]:=1;;
gap> I:= LeftIdeal( A, [ m ] );
<left ideal in ( Rationals^[ 4, 4 ] ), (1 generators)>
gap> Dimension( I );
4
gap> GeneratorsOfLeftIdeal( I );
[ [ [ 0, 0, 0, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ] ]
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> A:= Algebra( Rationals, mats );;
gap> # Form the two-sided ideal for which `mats[2]' is known to be
gap> # the unique basis element.
gap> I:= Ideal( A, [ mats[2] ], "basis" );
<two-sided ideal in <algebra of dimension 3 over Rationals>, 
  (dimension 1)>
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Categories and Properties of Algebras">
<Heading>Categories and Properties of Algebras</Heading>

<ManSection>
<Filt Name="IsFLMLOR" Arg='obj' Type='Category'/>

<Description>
A FLMLOR (<Q>free left module left operator ring</Q>) in &GAP; is a ring
that is also a free left module.
<P/>
Note that this means that being a FLMLOR is not a property a
ring can get,
since a ring is usually not represented as an external left set.
<P/>
Examples are magma rings (e.g. over the integers) or algebras.
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 2 );;
gap> IsFLMLOR ( A );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFLMLORWithOne" Arg='obj' Type='Category'/>

<Description>
A FLMLOR-with-one in &GAP; is a ring-with-one that is also a free left
module.
<P/>
Note that this means that being a FLMLOR-with-one is not a property a
ring-with-one can get,
since a ring-with-one is usually not represented as an external left set.
<P/>
Examples are magma rings-with-one or algebras-with-one (but also over the
integers).
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 2 );;
gap> IsFLMLORWithOne ( A );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAlgebra" Arg='obj' Type='Category'/>

<Description>
An algebra in &GAP; is a ring that is also a left vector space.
Note that this means that being an algebra is not a property a ring can
get, since a ring is usually not represented as an external left set.
<Example><![CDATA[
gap> A:= MatAlgebra( Rationals, 3 );;
gap> IsAlgebra( A );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAlgebraWithOne" Arg='obj' Type='Category'/>

<Description>
An algebra-with-one in &GAP; is a ring-with-one that is also
a left vector space.
Note that this means that being an algebra-with-one is not a property a
ring-with-one can get,
since a ring-with-one is usually not represented as an external left set.
<Example><![CDATA[
gap> A:= MatAlgebra( Rationals, 3 );;
gap> IsAlgebraWithOne( A );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLieAlgebra" Arg='A'/>

<Description>
An algebra <A>A</A> is called Lie algebra if <M>a * a = 0</M>
for all <M>a</M> in <A>A</A>
and <M>( a * ( b * c ) ) + ( b * ( c * a ) ) + ( c * ( a * b ) ) = 0</M>
for all <M>a, b, c \in </M><A>A</A> (Jacobi identity).
<Example><![CDATA[
gap> A:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> IsLieAlgebra( A );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsSimpleAlgebra" Arg='A'/>

<Description>
is <K>true</K> if the algebra <A>A</A> is simple,
and <K>false</K> otherwise.
This  function is only implemented for the cases where <A>A</A> is
an associative or a Lie algebra.
And for Lie algebras it is only implemented for the
case where the ground field is of characteristic zero.
<Example><![CDATA[
gap> A:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> IsSimpleAlgebra( A );
false
gap> A:= MatAlgebra( Rationals, 3 );;
gap> IsSimpleAlgebra( A );
true
]]></Example>
</Description>
</ManSection>

<!-- % IsMatrixFLMLOR left out... -->

<ManSection>
<Meth Name="IsFiniteDimensional" Arg='matalg' Label="for matrix algebras"/>

<Description>
returns <K>true</K> (always) for a matrix algebra <A>matalg</A>, since
matrix algebras are always finite dimensional.
<P/>
<Example><![CDATA[
gap> A:= MatAlgebra( Rationals, 3 );;
gap> IsFiniteDimensional( A );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsQuaternion" Arg='obj' Type='Category'/>
<Filt Name="IsQuaternionCollection" Arg='obj' Type='Category'/>
<Filt Name="IsQuaternionCollColl" Arg='obj' Type='Category'/>

<Description>
<Ref Filt="IsQuaternion"/> is the category of elements in an algebra
constructed by <Ref Func="QuaternionAlgebra"/>.
A collection of quaternions lies in the category
<Ref Filt="IsQuaternionCollection"/>.
Finally, a collection of quaternion collections
(e.g., a matrix of quaternions) lies in the category
<Ref Filt="IsQuaternionCollColl"/>.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> b:= BasisVectors( Basis( A ) );
[ e, i, j, k ]
gap> IsQuaternion( b[1] );
true
gap> IsQuaternionCollColl( [ [ b[1], b[2] ], [ b[3], b[4] ] ] );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Operations for Algebras">
<Heading>Attributes and Operations for Algebras</Heading>

<!-- % GeneratorsOfLeftOperatorRing left out.... -->
<!-- % GeneratorsOfLeftOperatorRingWithOne left out.... -->
<ManSection>
<Attr Name="GeneratorsOfAlgebra" Arg='A'/>

<Description>
returns a list of elements that generate <A>A</A> as an algebra.
<P/>
For a free algebra, each generator can also be accessed using 
the <C>.</C> operator (see <Ref Attr="GeneratorsOfDomain"/>).
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ];;
gap> A:= AlgebraWithOne( Rationals, [ m ] );
<algebra-with-one over Rationals, with 1 generators>
gap> GeneratorsOfAlgebra( A );
[ [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfAlgebraWithOne" Arg='A'/>

<Description>
returns a list of elements of <A>A</A>
that generate <A>A</A> as an algebra with one. 
<P/>
For a free algebra with one, each generator can also be accessed using 
the <C>.</C> operator (see <Ref Attr="GeneratorsOfDomain"/>).
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ];;
gap> A:= AlgebraWithOne( Rationals, [ m ] );
<algebra-with-one over Rationals, with 1 generators>
gap> GeneratorsOfAlgebraWithOne( A );
[ [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ProductSpace" Arg='U, V'/>

<Description>
is the vector space <M>\langle u * v ; u \in U, v \in V \rangle</M>,
where <M>U</M> and <M>V</M> are subspaces of the same algebra.
<P/>
If <M><A>U</A> = <A>V</A></M> is known to be an algebra
then the product space is also an algebra,
moreover it is an ideal in <A>U</A>.
If <A>U</A> and <A>V</A> are known to be ideals in an algebra <M>A</M>
then the product space is known to be an algebra and an ideal
in <M>A</M>.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> b:= BasisVectors( Basis( A ) );;
gap> B:= Subalgebra( A, [ b[4] ] );
<algebra over Rationals, with 1 generators>
gap> ProductSpace( A, B );
<vector space of dimension 4 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PowerSubalgebraSeries" Arg='A'/>

<Description>
returns a list of subalgebras of <A>A</A>,
the first term of which is <A>A</A>;
and every next term is the product space of the previous term with itself.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );
<algebra-with-one of dimension 4 over Rationals>
gap> PowerSubalgebraSeries( A );
[ <algebra-with-one of dimension 4 over Rationals> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AdjointBasis" Arg='B'/>

<Description>
The <E>adjoint map</E> <M>ad(x)</M> of an element <M>x</M> in an
<M>F</M>-algebra <M>A</M>, say, is the left multiplication by <M>x</M>.
This map is <M>F</M>-linear and thus, w.r.t. the given basis
<A>B</A><M> = (x_1, x_2, \ldots, x_n)</M> of <M>A</M>,
<M>ad(x)</M> can be represented by a matrix over <M>F</M>.
Let <M>V</M> denote the <M>F</M>-vector space of the matrices
corresponding to <M>ad(x)</M>, for <M>x \in A</M>.
Then <Ref Attr="AdjointBasis"/> returns the basis of <M>V</M> that
consists of the matrices for <M>ad(x_1), \ldots, ad(x_n)</M>.
<P/>
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> AdjointBasis( Basis( A ) );
Basis( <vector space over Rationals, with 4 generators>, 
[ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], 
  [ [ 0, -1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, -1 ], [ 0, 0, 1, 0 ] ]
    , 
  [ [ 0, 0, -1, 0 ], [ 0, 0, 0, 1 ], [ 1, 0, 0, 0 ], [ 0, -1, 0, 0 ] ]
    , 
  [ [ 0, 0, 0, -1 ], [ 0, 0, -1, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ] 
     ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IndicesOfAdjointBasis" Arg='B'/>

<Description>
Let <A>A</A> be an algebra and let <A>B</A>
be the basis that is output by <C>AdjointBasis( Basis( <A>A</A> ) )</C>. 
This function returns a list of indices.
If <M>i</M> is an index belonging to this list,
then <M>ad x_i</M> is a basis vector of the matrix space
spanned by <M>ad A</M>,
where <M>x_i</M> is the <M>i</M>-th basis vector of the basis <A>B</A>.
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> B:= AdjointBasis( Basis( L ) );;
gap> IndicesOfAdjointBasis( B );
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsAlgebra" Arg='F, A'/>

<Description>
Returns the algebra over <A>F</A> generated by <A>A</A>.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap> AsAlgebra( Rationals, V );
<algebra of dimension 1 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsAlgebraWithOne" Arg='F, A'/>

<Description>
If the algebra <A>A</A> has an identity, then it can be viewed as an
algebra with one over <A>F</A>.
This function returns this algebra with one.
<Example><![CDATA[
gap> V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap> A:= AsAlgebra( Rationals, V );;
gap> AsAlgebraWithOne( Rationals, A );
<algebra-with-one over Rationals, with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsSubalgebra" Arg='A, B'/>

<Description>
If all elements of the algebra <A>B</A> happen to be contained in the
algebra <A>A</A>,
then <A>B</A> can be viewed as a subalgebra of <A>A</A>.
This  function returns this subalgebra.
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 2 );;
gap> V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap> B:= AsAlgebra( Rationals, V );;
gap> BA:= AsSubalgebra( A, B );
<algebra of dimension 1 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AsSubalgebraWithOne" Arg='A, B'/>

<Description>
If <A>B</A> is an algebra with one, all elements of which happen to be
contained in the algebra with one <A>A</A>, then <A>B</A> can be viewed
as a subalgebra with one of <A>A</A>.
This function returns this subalgebra with one.
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 2 );;
gap> V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap> B:= AsAlgebra( Rationals, V );;
gap> C:= AsAlgebraWithOne( Rationals, B );;
gap> AC:= AsSubalgebraWithOne( A, C );
<algebra-with-one over Rationals, with 1 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MutableBasisOfClosureUnderAction"
 Arg='F, Agens, from, init, opr, zero, maxdim'/>

<Description>
Let <A>F</A> be a ring, <A>Agens</A> a list of generators for an
<A>F</A>-algebra <M>A</M>, and <A>from</A> one of <C>"left"</C>,
<C>"right"</C>, <C>"both"</C>; this means that elements
of <M>A</M> act via multiplication from the respective side(s).
<A>init</A> must be a list of initial generating vectors,
and <A>opr</A> the operation (a function of two arguments).
<P/>
<Ref Func="MutableBasisOfClosureUnderAction"/> returns a mutable basis of
the <A>F</A>-free left module generated by the vectors in <A>init</A>
and their images under the action of <A>Agens</A>
from the respective side(s).
<P/>
<A>zero</A> is the zero element of the desired module.
<A>maxdim</A> is an upper bound for the dimension of the closure;
if no such upper bound is known then the value of <A>maxdim</A>
must be <Ref Var="infinity"/>.
<P/>
<Ref Func="MutableBasisOfClosureUnderAction"/> can be used to compute
a basis of an <E>associative</E> algebra generated by the elements in
<A>Agens</A>.
In this  case <A>from</A> may be <C>"left"</C> or <C>"right"</C>,
<A>opr</A> is the multiplication <C>*</C>,
and <A>init</A> is a list containing either the identity of the algebra
or a list of algebra generators.
(Note that if the algebra has an identity then it is in general not
sufficient to take algebra-with-one generators as <A>init</A>,
whereas of course <A>Agens</A> need not contain the identity.)
<P/>
(Note that bases of <E>not</E> necessarily associative algebras can be
computed using <Ref Func="MutableBasisOfNonassociativeAlgebra"/>.)
<P/>
Other applications of <Ref Func="MutableBasisOfClosureUnderAction"/> are
the computations of bases for (left/ right/ two-sided) ideals <M>I</M> in
an <E>associative</E> algebra <M>A</M> from ideal generators of <M>I</M>;
in these cases <A>Agens</A> is a list of algebra generators of <M>A</M>,
<A>from</A> denotes the appropriate side(s),
<A>init</A> is a list of ideal generators of <M>I</M>,
and <A>opr</A> is again <C>*</C>.
<P/>
(Note that bases of ideals in <E>not</E> necessarily associative algebras
can be computed using
<Ref Func="MutableBasisOfIdealInNonassociativeAlgebra"/>.)
<P/>
Finally, bases of right <M>A</M>-modules also can be computed using
<Ref Func="MutableBasisOfClosureUnderAction"/>.
The only difference to the ideal case is that <A>init</A> is now a list
of right module generators,
and <A>opr</A> is the operation of the module.
<P/>
<!--  (Remark:
      It would be possible to use vector space generators of the algebra
      <M>A</M> if they are known; but in the associative case,
      it is cheaper to multiply only with generators
      until the vector space becomes stable.) -->
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> g:= GeneratorsOfAlgebra( A );;
gap> B:= MutableBasisOfClosureUnderAction( Rationals, 
>                                g, "left", [ g[1] ], \*, Zero(A), 4 );
<mutable basis over Rationals, 4 vectors>
gap> BasisVectors( B );
[ e, i, j, k ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MutableBasisOfNonassociativeAlgebra"
 Arg='F, Agens, zero, maxdim'/>

<Description>
is a mutable basis of the (not necessarily associative) <A>F</A>-algebra
that is generated by <A>Agens</A>, has zero element <A>zero</A>,
and has dimension at most <A>maxdim</A>.
If no finite bound for the dimension is known then <Ref Var="infinity"/> must be
the value of <A>maxdim</A>.
<P/>
The difference to <Ref Func="MutableBasisOfClosureUnderAction"/> is that
in general it is not sufficient to multiply just with algebra generators.
(For special cases of nonassociative algebras, especially for Lie
algebras, multiplying with algebra generators suffices.)
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( Rationals, 4 );;
gap> m1:= Random( L );;
gap> m2:= Random( L );;
gap> MutableBasisOfNonassociativeAlgebra( Rationals, [ m1, m2 ], 
> Zero( L ), 16 );
<mutable basis over Rationals, 16 vectors>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MutableBasisOfIdealInNonassociativeAlgebra"
 Arg='F, Vgens, Igens, zero, from, maxdim'/>

<Description>
is a mutable basis of the ideal generated by <A>Igens</A> under the
action of the (not necessarily associative) <A>F</A>-algebra with
vector space generators <A>Vgens</A>.
The zero element of the ideal is <A>zero</A>,
<A>from</A> is one of <C>"left"</C>, <C>"right"</C>, <C>"both"</C>
(with the same meaning as in
<Ref Func="MutableBasisOfClosureUnderAction"/>),
and <A>maxdim</A> is a known upper bound on the dimension of the ideal;
if no finite bound for the dimension is known then <Ref Var="infinity"/> must be
the value of <A>maxdim</A>.
<P/>
The difference to <Ref Func="MutableBasisOfClosureUnderAction"/> is that
in general it is not sufficient to multiply just with algebra generators.
(For special cases of nonassociative algebras, especially for Lie
algebras, multiplying with algebra generators suffices.)
<Example><![CDATA[
gap> mats:= [  [[ 1, 0 ], [ 0, -1 ]], [[0,1],[0,0]] ];;
gap> A:= Algebra( Rationals, mats );;
gap> basA:= BasisVectors( Basis( A ) );;
gap> B:= MutableBasisOfIdealInNonassociativeAlgebra( Rationals, basA,
> [ mats[2] ], 0*mats[1], "both", infinity );
<mutable basis over Rationals, 1 vectors>
gap> BasisVectors( B );
[ [ [ 0, 1 ], [ 0, 0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DirectSumOfAlgebras" Arg='A1, A2'
 Label="for two algebras"/>
<Oper Name="DirectSumOfAlgebras" Arg='list'
 Label="for a list of algebras"/>

<Description>
is the direct sum of the two algebras <A>A1</A> and <A>A2</A>
respectively of the algebras in the list <A>list</A>.
<P/>
If all involved algebras are associative algebras then the result is also
known to be associative.
If all involved algebras are Lie algebras then the result is also known
to be a Lie algebra.
<P/>
All involved algebras must have the same left acting domain.
<P/>
The default case is that the result is a structure constants algebra.
If all involved algebras are matrix algebras, and either both are Lie
algebras or both are associative then the result is again a
matrix algebra of the appropriate type.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> DirectSumOfAlgebras( [A, A, A] );
<algebra of dimension 12 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FullMatrixAlgebraCentralizer" Arg='F, lst'/>

<Description>
Let <A>lst</A>  be a nonempty list of square matrices of the same
dimension <M>n</M>, say, with entries in the field <A>F</A>.
<Ref Func="FullMatrixAlgebraCentralizer"/> returns
the (pointwise) centralizer of all matrices in <A>lst</A>, inside
the full matrix algebra of <M>n \times n</M> matrices over <A>F</A>.
<P/>
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> b:= Basis( A );;
gap> mats:= List( BasisVectors( b ), x -> AdjointMatrix( b, x ) );;
gap> FullMatrixAlgebraCentralizer( Rationals, mats );
<algebra-with-one of dimension 4 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RadicalOfAlgebra" Arg='A'/>

<Description>
is the maximal nilpotent ideal of <A>A</A>,
where <A>A</A> is an associative algebra.
<Example><![CDATA[
gap> m:= [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ];;
gap> A:= AlgebraWithOneByGenerators( Rationals, [ m ] );
<algebra-with-one over Rationals, with 1 generators>
gap> RadicalOfAlgebra( A );
<algebra of dimension 2 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CentralIdempotentsOfAlgebra" Arg='A'/>

<Description>
For an associative algebra <A>A</A>, this function returns
a list of central primitive idempotents such that their sum is
the identity element of <A>A</A>.
Therefore <A>A</A> is required to have an identity.
<P/>
(This is a synonym of <C>CentralIdempotentsOfSemiring</C>.)
<!-- add crossref. as soon as this is available -->
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> B:= DirectSumOfAlgebras( [A, A, A] );
<algebra of dimension 12 over Rationals>
gap> CentralIdempotentsOfAlgebra( B );
[ v.9, v.5, v.1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DirectSumDecomposition" Arg='L' Label="for Lie algebras"/>

<Description>
This function calculates a list of ideals of the algebra <A>L</A> such
that <A>L</A> is equal to their direct sum.
Currently this is only implemented for semisimple associative algebras,
and for Lie algebras (semisimple or not).
<Example><![CDATA[
gap> G:= SymmetricGroup( 4 );;
gap> A:= GroupRing( Rationals, G );
<algebra-with-one over Rationals, with 2 generators>
gap> dd:= DirectSumDecomposition( A );
[ <two-sided ideal in 
      <algebra-with-one of dimension 24 over Rationals>, 
      (1 generators)>, 
  <two-sided ideal in 
      <algebra-with-one of dimension 24 over Rationals>, 
      (1 generators)>, 
  <two-sided ideal in 
      <algebra-with-one of dimension 24 over Rationals>, 
      (1 generators)>, 
  <two-sided ideal in 
      <algebra-with-one of dimension 24 over Rationals>, 
      (1 generators)>, 
  <two-sided ideal in 
      <algebra-with-one of dimension 24 over Rationals>, 
      (1 generators)> ]
gap> List( dd, Dimension );
[ 1, 1, 4, 9, 9 ]
]]></Example>
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( Rationals, 5 );;
gap> DirectSumDecomposition( L );
[ <two-sided ideal in 
      <two-sided ideal in <Lie algebra of dimension 25 over Rationals>
            , (dimension 1)>, (dimension 1)>, 
  <two-sided ideal in 
      <two-sided ideal in <Lie algebra of dimension 25 over Rationals>
            , (dimension 24)>, (dimension 24)> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LeviMalcevDecomposition" Arg='L' Label="for Lie algebras"/>

<Description>
A Levi-Malcev subalgebra of the algebra <A>L</A> is a semisimple
subalgebra complementary to the radical of <A>L</A>.
This function returns a list with two components.
The first component is a Levi-Malcev subalgebra, the second the radical.
This function is implemented for associative and Lie algebras. 
<Example><![CDATA[
gap> m:= [ [ 1, 2, 0 ], [ 0, 1, 3 ], [ 0, 0, 1] ];;
gap> A:= Algebra( Rationals, [ m ] );;
gap> LeviMalcevDecomposition( A );
[ <algebra of dimension 1 over Rationals>, 
  <algebra of dimension 2 over Rationals> ]
]]></Example>
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( Rationals, 5 );;
gap> LeviMalcevDecomposition( L );
[ <Lie algebra of dimension 24 over Rationals>, 
  <two-sided ideal in <Lie algebra of dimension 25 over Rationals>, 
      (dimension 1)> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Grading" Arg='A'/>

<Description>
Let <M>G</M> be an Abelian group and <M>A</M> an algebra.
Then <M>A</M> is said to be graded over <M>G</M> if for every
<M>g \in G</M> there is a subspace <M>A_g</M> of <M>A</M> such that
<M>A_g \cdot A_h \subset A_{{g+h}}</M> for <M>g, h \in G</M>. 
In &GAP;&nbsp;4 a <E>grading</E> of an algebra is a record containing the
following components.
<List>
<Mark><C>source</C></Mark>
<Item>
  the Abelian group over which the algebra is graded.
</Item>
<Mark><C>hom_components</C></Mark>
<Item>
  a function assigning to each element from the
  source a subspace of the algebra.
</Item>
<Mark><C>min_degree</C></Mark>
<Item>
  in the case where the algebra is graded over the integers
  this is the minimum number for which <C>hom_components</C> returns
  a nonzero subspace.
</Item>
<Mark><C>max_degree</C></Mark>
<Item>
  is analogous to <C>min_degree</C>.
</Item>
</List>
We note that there are no methods to compute a grading of an 
arbitrary algebra; however some algebras get a natural grading when
they are constructed (see <Ref Func="JenningsLieAlgebra"/>, 
<Ref Func="NilpotentQuotientOfFpLieAlgebra"/>).
<P/>
We note also that these components may be not enough to handle 
the grading efficiently, and another record component may be needed.
For instance in a Lie algebra <M>L</M> constructed by 
<Ref Func="JenningsLieAlgebra"/>, the length of the of the range
<C>[ Grading(L)!.min_degree .. Grading(L)!.max_degree ]</C> may be 
non-polynomial in the dimension of <M>L</M>.
To handle efficiently this situation, an optional component can be 
used:
<List>
<Mark><C>non_zero_hom_components</C></Mark>
<Item>
  the subset of <C>source</C> for which <C>hom_components</C> returns
  a nonzero subspace.
</Item>
</List>
<Example><![CDATA[
gap> G:= SmallGroup(3^6, 100 );
<pc group of size 729 with 6 generators>
gap> L:= JenningsLieAlgebra( G );
<Lie algebra of dimension 6 over GF(3)>
gap> g:= Grading( L );
rec( hom_components := function( d ) ... end, max_degree := 9, 
  min_degree := 1, source := Integers )
gap> g.hom_components( 3 );
<vector space over GF(3), with 1 generators>
gap> g.hom_components( 14 );
<vector space over GF(3), with 0 generators>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Homomorphisms of Algebras">
<Heading>Homomorphisms of Algebras</Heading>

Algebra homomorphisms are vector space homomorphisms that preserve the
multiplication.
So the default methods for vector space homomorphisms work,
and in fact there is not much use of the fact that source and range are
algebras, except that preimages and images are algebras (or even ideals)
in certain cases.

<ManSection>
<Oper Name="AlgebraGeneralMappingByImages" Arg='A, B, gens, imgs'/>

<Description>
is a general mapping from the <M>F</M>-algebra <A>A</A> to the <M>F</M>-algebra <A>B</A>.
This general mapping is defined by mapping the entries in the list <A>gens</A>
(elements of <A>A</A>) to the entries in the list <A>imgs</A> (elements of <A>B</A>),
and taking the <M>F</M>-linear and multiplicative closure.
<P/>
<A>gens</A> need not generate <A>A</A> as an <M>F</M>-algebra, and if the
specification does not define a linear and multiplicative mapping then
the result will be multivalued.
Hence, in general it is not a mapping.
For constructing a linear map that is not
necessarily multiplicative, we refer to
<Ref Func="LeftModuleHomomorphismByImages"/>.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> B:= FullMatrixAlgebra( Rationals, 2 );;
gap> bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap> f:= AlgebraGeneralMappingByImages( A, B, bA, bB );
[ e, i, j, k ] -> [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 1 ], [ 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ]
gap> Images( f, bA[1] );
<add. coset of <algebra over Rationals, with 16 generators>>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AlgebraHomomorphismByImages" Arg='A, B, gens, imgs'/>

<Description>
<Ref Func="AlgebraHomomorphismByImages"/> returns the algebra homomorphism with
source <A>A</A> and range <A>B</A> that is defined by mapping the list <A>gens</A> of
generators of <A>A</A> to the list <A>imgs</A> of images in <A>B</A>.
<P/>
If <A>gens</A> does not generate <A>A</A> or if the homomorphism does not exist
(i.e., if mapping the generators describes only a multi-valued mapping)
then <K>fail</K> is returned.
<P/>
One can avoid the checks by calling <Ref Oper="AlgebraHomomorphismByImagesNC"/>,
and one can construct multi-valued mappings with
<Ref Func="AlgebraGeneralMappingByImages"/>.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [1,1] ); SetEntrySCTable( T, 2, 2, [1,2] );
gap> A:= AlgebraByStructureConstants( Rationals, T );;
gap> m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap> B:= AlgebraByGenerators( Rationals, [ m1, m2 ] );;
gap> bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap> f:= AlgebraHomomorphismByImages( A, B, bA, bB );
[ v.1, v.2 ] -> [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ]
gap> Image( f, bA[1]+bA[2] );
[ [ 1, 0 ], [ 0, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AlgebraHomomorphismByImagesNC" Arg='A, B, gens, imgs'/>

<Description>
<Ref Oper="AlgebraHomomorphismByImagesNC"/> is the operation that is called by the
function <Ref Func="AlgebraHomomorphismByImages"/>.
Its methods may assume that <A>gens</A> generates <A>A</A> and that the mapping of
<A>gens</A> to <A>imgs</A> defines an algebra homomorphism.
Results are unpredictable if these conditions do not hold.
<P/>
For creating a possibly multi-valued mapping from <A>A</A> to <A>B</A> that
respects addition, multiplication, and scalar multiplication,
<Ref Func="AlgebraGeneralMappingByImages"/> can be used.
<!-- see the comment in the declaration of <Ref Func="GroupHomomorphismByImagesNC"/>!-->
<P/>
For the definitions of the algebras <C>A</C> and <C>B</C> in the next example we refer
to the previous example.
<P/>
<Example><![CDATA[
gap> f:= AlgebraHomomorphismByImagesNC( A, B, bA, bB );
[ v.1, v.2 ] -> [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AlgebraWithOneGeneralMappingByImages" Arg='A, B, gens, imgs'/>

<Description>
This function is analogous to <Ref Func="AlgebraGeneralMappingByImages"/>;
the only difference being that the identity of <A>A</A> is automatically
mapped to the identity of <A>B</A>.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );;
gap> B:= FullMatrixAlgebra( Rationals, 2 );;
gap> bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap> f:=AlgebraWithOneGeneralMappingByImages(A,B,bA{[2,3,4]},bB{[1,2,3]});
[ i, j, k, e ] -> [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 1 ], [ 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0 ] ], [ [ 1, 0 ], [ 0, 1 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AlgebraWithOneHomomorphismByImages" Arg='A, B, gens, imgs'/>

<Description>
<Ref Func="AlgebraWithOneHomomorphismByImages"/> returns the
algebra-with-one homomorphism with source <A>A</A> and range <A>B</A>
that is defined by mapping the list <A>gens</A> of generators of <A>A</A>
to the list <A>imgs</A> of images in <A>B</A>.
<P/>
The difference between an algebra homomorphism and an algebra-with-one
homomorphism is that in the latter case,
it is assumed that the identity of <A>A</A> is mapped to the identity of
<A>B</A>,
and therefore <A>gens</A> needs to generate <A>A</A> only as an
algebra-with-one.
<P/>
If <A>gens</A> does not generate <A>A</A> or if the homomorphism does not
exist
(i.e., if mapping the generators describes only a multi-valued mapping)
then <K>fail</K> is returned.
<P/>
One can avoid the checks by calling
<Ref Func="AlgebraWithOneHomomorphismByImagesNC"/>,
and one can construct multi-valued mappings with
<Ref Func="AlgebraWithOneGeneralMappingByImages"/>.
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:=1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:=1;;
gap> A:= AlgebraByGenerators( Rationals, [m1,m2] );;
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [1,1] );
gap> SetEntrySCTable( T, 2, 2, [1,2] );
gap> B:= AlgebraByStructureConstants(Rationals, T);;
gap> bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap> f:= AlgebraWithOneHomomorphismByImages( A, B, bA{[1]}, bB{[1]} );
[ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 1, 0 ], [ 0, 1 ] ] ] -> [ v.1, v.1+v.2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="AlgebraWithOneHomomorphismByImagesNC" Arg='A, B, gens, imgs'/>

<Description>
<Ref Func="AlgebraWithOneHomomorphismByImagesNC"/> is the operation that
is called by the function
<Ref Func="AlgebraWithOneHomomorphismByImages"/>.
Its methods may assume that <A>gens</A> generates <A>A</A> and that the
mapping of <A>gens</A> to <A>imgs</A> defines an algebra-with-one
homomorphism.
Results are unpredictable if these conditions do not hold.
<P/>
For creating a possibly multi-valued mapping from <A>A</A> to <A>B</A>
that respects addition, multiplication, identity, and scalar
multiplication,
<Ref Func="AlgebraWithOneGeneralMappingByImages"/> can be used.
<P/>
<!-- see the comment in the declaration of <C>GroupHomomorphismByImagesNC</C>!-->
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:=1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:=1;;
gap> A:= AlgebraByGenerators( Rationals, [m1,m2] );;
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [1,1] );
gap> SetEntrySCTable( T, 2, 2, [1,2] );
gap> B:= AlgebraByStructureConstants( Rationals, T);;
gap> bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap> f:= AlgebraWithOneHomomorphismByImagesNC( A, B, bA{[1]}, bB{[1]} );
[ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 1, 0 ], [ 0, 1 ] ] ] -> [ v.1, v.1+v.2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="NaturalHomomorphismByIdeal" Arg='A, I'
 Label="for an algebra and an ideal"/>

<Description>
For an algebra <A>A</A> and an ideal <A>I</A> in <A>A</A>,
the return value of <Ref Func="NaturalHomomorphismByIdeal"/>
is a homomorphism of algebras, in particular the range of this mapping
is also an algebra.
<P/>
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> C:= LieCentre( L );
<two-sided ideal in <Lie algebra of dimension 9 over Rationals>, 
  (dimension 1)>
gap> hom:= NaturalHomomorphismByIdeal( L, C );
<linear mapping by matrix, <Lie algebra of dimension 
9 over Rationals> -> <Lie algebra of dimension 8 over Rationals>>
gap> ImagesSource( hom );
<Lie algebra of dimension 8 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="OperationAlgebraHomomorphism" Arg='A, B[, opr]'
 Label="action w.r.t. a basis of the module"/>
<Oper Name="OperationAlgebraHomomorphism" Arg='A, V[, opr]'
 Label="action on a free left module"/>

<Description>
<Ref Func="OperationAlgebraHomomorphism" Label="action w.r.t. a basis of the module"/>
returns an algebra homomorphism from the <M>F</M>-algebra <A>A</A> into
a matrix algebra over <M>F</M> that describes the <M>F</M>-linear action
of <A>A</A> on the basis <A>B</A> of a free left module
respectively on the free left module <A>V</A>
(in which case some basis of <A>V</A> is chosen),
via the operation <A>opr</A>.
<P/>
The homomorphism need not be surjective.
The default value for <A>opr</A> is <Ref Func="OnRight"/>.
<P/>
If <A>A</A> is an algebra-with-one then the operation homomorphism is an
algebra-with-one homomorphism because the identity of <A>A</A> must act
as the identity.
<P/>
<!--  (Of course this holds especially if <A>D</A> is in the kernel of the action.)-->
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap> B:= AlgebraByGenerators( Rationals, [ m1, m2 ] );;
gap> V:= FullRowSpace( Rationals, 2 );
( Rationals^2 )
gap> f:=OperationAlgebraHomomorphism( B, Basis( V ), OnRight );
<op. hom. Algebra( Rationals, 
[ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] 
 ] ) -> matrices of dim. 2>
gap> Image( f, m1 );
[ [ 1, 0 ], [ 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NiceAlgebraMonomorphism" Arg='A'/>
<Description>
If <A>A</A> is an associative algebra with one, returns 
an isomorphism from <A>A</A> onto a matrix algebra
(see <Ref Attr="IsomorphismMatrixAlgebra"/> for an example).
If <A>A</A> is a finitely presented Lie algebra, returns an isomorphism 
from <A>A</A> onto a Lie algebra defined by a structure constants table 
(see <Ref Sect="Finitely Presented Lie Algebras"/> for an example).
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismFpAlgebra" Arg='A'/>

<Description>
isomorphism from the algebra <A>A</A> onto a finitely presented algebra.
Currently this is only implemented for associative algebras with one.
<Example><![CDATA[
gap> A:= QuaternionAlgebra( Rationals );
<algebra-with-one of dimension 4 over Rationals>
gap> f:= IsomorphismFpAlgebra( A );
[ e, i, j, k, e ] -> [ [(1)*x.1], [(1)*x.2], [(1)*x.3], [(1)*x.4], 
  [(1)*<identity ...>] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismMatrixAlgebra" Arg='A'/>

<Description>
isomorphism from the algebra <A>A</A> onto a matrix algebra.
Currently this is only implemented for associative algebras with one.
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> SetEntrySCTable( T, 1, 1, [1,1] ); SetEntrySCTable( T, 2, 2, [1,2] );
gap> A:= AlgebraByStructureConstants( Rationals, T );;
gap> A:= AsAlgebraWithOne( Rationals, A );;
gap> f:=IsomorphismMatrixAlgebra( A );
<op. hom. AlgebraWithOne( Rationals, ... ) -> matrices of dim. 2>
gap> Image( f, BasisVectors( Basis( A ) )[1] );
[ [ 1, 0 ], [ 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IsomorphismSCAlgebra" Arg='B' Label="w.r.t. a given basis"/>
<Attr Name="IsomorphismSCAlgebra" Arg='A' Label="for an algebra"/>

<Description>
For a basis <A>B</A> of an algebra <M>A</M>, say,
<Ref Func="IsomorphismSCAlgebra" Label="w.r.t. a given basis"/> returns
an algebra isomorphism from <M>A</M> to an algebra <M>S</M> given by
structure constants
(see&nbsp;<Ref Sect="Constructing Algebras by Structure Constants"/>),
such that the canonical basis of <M>S</M> is the image of <A>B</A>.
<P/>
For an algebra <A>A</A>,
<Ref Func="IsomorphismSCAlgebra" Label="for an algebra"/> chooses
a basis of <A>A</A> and returns the
<Ref Func="IsomorphismSCAlgebra" Label="w.r.t. a given basis"/>
value for that basis.
<P/>
<Example><![CDATA[
gap> IsomorphismSCAlgebra( GF(8) );
CanonicalBasis( GF(2^3) ) -> CanonicalBasis( <algebra of dimension 
3 over GF(2)> )
gap> IsomorphismSCAlgebra( GF(2)^[2,2] );
CanonicalBasis( ( GF(2)^
[ 2, 2 ] ) ) -> CanonicalBasis( <algebra of dimension 4 over GF(2)> )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RepresentativeLinearOperation" Arg='A, v, w, opr'/>

<Description>
is an element of the algebra <A>A</A> that maps the vector <A>v</A>
to the vector <A>w</A> under the linear operation described by the function
<A>opr</A>. If no such element exists then <K>fail</K> is returned.
<P/>
<!-- Would it be desirable to put this under <C>RepresentativeOperation</C>?-->
<!-- (look at the code before you agree ...)-->
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap> B:= AlgebraByGenerators( Rationals, [ m1, m2 ] );;
gap> RepresentativeLinearOperation( B, [1,0], [1,0], OnRight );
[ [ 1, 0 ], [ 0, 0 ] ]
gap> RepresentativeLinearOperation( B, [1,0], [0,1], OnRight );
fail
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Representations of Algebras">
<Heading>Representations of Algebras</Heading>

An algebra module is a vector space together with an action of an
algebra. So a module over an algebra is constructed by giving generators
of a vector space, and a function for calculating the action of
algebra elements on elements of the vector space. When creating an
algebra module, the generators of the vector space are wrapped up and
given the category <C>IsLeftAlgebraModuleElement</C> or
<C>IsRightModuleElement</C> if the algebra acts from the left, or right
respectively. (So in the case of a bi-module the elements get
both categories.) Most linear algebra computations are delegated to
the original vector space.
<P/>
The transition between the original vector space and the corresponding
algebra module is handled by <C>ExtRepOfObj</C> and <C>ObjByExtRep</C>.
For an element <C>v</C> of the algebra module, <C>ExtRepOfObj( v )</C> returns
the underlying element of the original vector space. Furthermore, if <C>vec</C>
is an element of the original vector space, and <C>fam</C> the elements
family of the corresponding algebra module, then <C>ObjByExtRep( fam, vec )</C>
returns the corresponding element of the algebra module. Below is an
example of this.
<P/>
The action of the algebra on elements of the algebra module is constructed
by using the operator <C>^</C>. If <C>x</C> is an element of an algebra <C>A</C>, and
<C>v</C> an element of a left <C>A</C>-module, then <C>x^v</C> calculates the result
of the action of <C>x</C> on <C>v</C>. Similarly, if <C>v</C> is an element of
a right <C>A</C>-module, then <C>v^x</C> calculates the action of <C>x</C> on <C>v</C>.

<ManSection>
<Oper Name="LeftAlgebraModuleByGenerators" Arg='A, op, gens'/>

<Description>
Constructs the left algebra module over <A>A</A> generated by the list of
vectors
<A>gens</A>. The action of <A>A</A> is described by the function <A>op</A>. This must
be a function of two arguments; the first argument is the algebra element,
and the second argument is a vector; it outputs the result of applying
the algebra element to the vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="RightAlgebraModuleByGenerators" Arg='A, op, gens'/>

<Description>
Constructs the right algebra module over <A>A</A> generated by the list of
vectors
<A>gens</A>. The action of <A>A</A> is described by the function <A>op</A>. This must
be a function of two arguments; the first argument is a vector, and the
second argument is the algebra element; it outputs the result of applying
the algebra element to the vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="BiAlgebraModuleByGenerators" Arg='A, B, opl, opr, gens'/>

<Description>
Constructs the algebra bi-module over <A>A</A> and <A>B</A> generated by the list of
vectors
<A>gens</A>. The left action of <A>A</A> is described by the function <A>opl</A>,
and the right action of <A>B</A> by the function <A>opr</A>. <A>opl</A> must be a
function of two arguments; the first argument is the algebra element,
and the second argument is a vector; it outputs the result of applying
the algebra element on the left to the vector. <A>opr</A> must
be a function of two arguments; the first argument is a vector, and the
second argument is the algebra element; it outputs the result of applying
the algebra element on the right to the vector.
<Example><![CDATA[
gap> A:= Rationals^[3,3];
( Rationals^[ 3, 3 ] )
gap> V:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );
<left-module over ( Rationals^[ 3, 3 ] )>
gap> W:= RightAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );
<right-module over ( Rationals^[ 3, 3 ] )>
gap> M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );
<bi-module over ( Rationals^[ 3, 3 ] ) (left) and ( Rationals^
[ 3, 3 ] ) (right)>
]]></Example>
<P/>
In the above examples, the modules <C>V</C>, <C>W</C>, and <C>M</C> are
<M>3</M>-dimensional vector spaces over the rationals.
The algebra <C>A</C> acts from the left on <C>V</C>, from the right on
<C>W</C>, and from the left and from the right on <C>M</C>.
</Description>
</ManSection>

<ManSection>
<Oper Name="LeftAlgebraModule" Arg='A, op, V'/>

<Description>
Constructs the left algebra module over <A>A</A> with underlying space <A>V</A>.
The action of <A>A</A> is described by the function <A>op</A>. This must
be a function of two arguments; the first argument is the algebra element,
and the second argument is a vector from <A>V</A>; it outputs the result of 
applying the algebra element to the vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="RightAlgebraModule" Arg='A, op, V'/>

<Description>
Constructs the right algebra module over <A>A</A> with underlying space <A>V</A>.
The action of <A>A</A> is described by the function <A>op</A>. This must
be a function of two arguments; the first argument is a vector, from <A>V</A>
and the
second argument is the algebra element; it outputs the result of applying
the algebra element to the vector.
</Description>
</ManSection>

<ManSection>
<Oper Name="BiAlgebraModule" Arg='A, B, opl, opr, V'/>

<Description>
Constructs the algebra bi-module over <A>A</A> and <A>B</A> with underlying space 
<A>V</A>. The left action of <A>A</A> is described by the function <A>opl</A>,
and the right action of <A>B</A> by the function <A>opr</A>. <A>opl</A> must be a
function of two arguments; the first argument is the algebra element,
and the second argument is a vector from <A>V</A>; it outputs the result of 
applying
the algebra element on the left to the vector. <A>opr</A> must
be a function of two arguments; the first argument is a vector from <A>V</A>, 
and the
second argument is the algebra element; it outputs the result of applying
the algebra element on the right to the vector.
<Example><![CDATA[
gap> A:= Rationals^[3,3];;
gap> V:= Rationals^3;
( Rationals^3 )
gap> V:= Rationals^3;;
gap> M:= BiAlgebraModule( A, A, \*, \*, V );
<bi-module over ( Rationals^[ 3, 3 ] ) (left) and ( Rationals^
[ 3, 3 ] ) (right)>
gap> Dimension( M );
3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="GeneratorsOfAlgebraModule" Arg='M'/>

<Description>
A list of elements of <A>M</A> that generate <A>M</A> as an algebra module.
<Example><![CDATA[
gap> A:= Rationals^[3,3];;
gap> V:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap> GeneratorsOfAlgebraModule( V );
[ [ 1, 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAlgebraModuleElement" Arg='obj' Type='Category'/>
<Filt Name="IsAlgebraModuleElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsAlgebraModuleElementFamily" Arg='fam' Type='Category'/>

<Description>
Category of algebra module elements. If an object has
<C>IsAlgebraModuleElementCollection</C>, then it is an algebra module.
If a family has <C>IsAlgebraModuleElementFamily</C>, then it is a family
of algebra module elements (every algebra module has its own elements
family).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLeftAlgebraModuleElement" Arg='obj' Type='Category'/>
<Filt Name="IsLeftAlgebraModuleElementCollection" Arg='obj' Type='Category'/>

<Description>
Category of left algebra module elements. If an object has
<C>IsLeftAlgebraModuleElementCollection</C>, then it is a left-algebra module.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRightAlgebraModuleElement" Arg='obj' Type='Category'/>
<Filt Name="IsRightAlgebraModuleElementCollection" Arg='obj' Type='Category'/>

<Description>
Category of right algebra module elements. If an object has
<C>IsRightAlgebraModuleElementCollection</C>, then it is a right-algebra module.
<Example><![CDATA[
gap> A:= Rationals^[3,3];
( Rationals^[ 3, 3 ] )
gap> M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );
<bi-module over ( Rationals^[ 3, 3 ] ) (left) and ( Rationals^
[ 3, 3 ] ) (right)>
gap> vv:= BasisVectors( Basis( M ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> IsLeftAlgebraModuleElement( vv[1] );
true
gap> IsRightAlgebraModuleElement( vv[1] );
true
gap> vv[1] = [ 1, 0, 0 ];
false
gap> ExtRepOfObj( vv[1] ) = [ 1, 0, 0 ];
true
gap> ObjByExtRep( ElementsFamily( FamilyObj( M ) ), [ 1, 0, 0 ] ) in M;
true
gap> xx:= BasisVectors( Basis( A ) );;
gap> xx[4]^vv[1];  # left action
[ 0, 1, 0 ]
gap> vv[1]^xx[2];  # right action
[ 0, 1, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LeftActingAlgebra" Arg='V'/>

<Description>
Here <A>V</A> is a left-algebra module; this function returns the algebra
that acts from the left on <A>V</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="RightActingAlgebra" Arg='V'/>

<Description>
Here <A>V</A> is a right-algebra module; this function returns the algebra
that acts from the right on <A>V</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ActingAlgebra" Arg='V'/>

<Description>
Here <A>V</A> is an algebra module; this function returns the algebra
that acts on <A>V</A> (this is the same as <C>LeftActingAlgebra( <A>V</A> )</C> if <A>V</A> is
a left module, and <C>RightActingAlgebra( <A>V</A> )</C> if <A>V</A> is a right module;
it will signal an error if <A>V</A> is a bi-module).
<Example><![CDATA[
gap> A:= Rationals^[3,3];;
gap> M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );;
gap> LeftActingAlgebra( M );
( Rationals^[ 3, 3 ] )
gap> RightActingAlgebra( M );
( Rationals^[ 3, 3 ] )
gap> V:= RightAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap> ActingAlgebra( V );
( Rationals^[ 3, 3 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsBasisOfAlgebraModuleElementSpace" Arg='B' Type='Category'/>

<Description>
If a basis <A>B</A> lies in the category <C>IsBasisOfAlgebraModuleElementSpace</C>,
then
<A>B</A> is a basis of a subspace of an algebra module. This means that
<A>B</A> has the record field <C><A>B</A>!.delegateBasis</C> set. This last object
is a basis of the corresponding subspace of the vector space underlying
the algebra module (i.e., the vector
space spanned by all <C>ExtRepOfObj( v )</C> for <C>v</C> in
the algebra module).
<Example><![CDATA[
gap> A:= Rationals^[3,3];;
gap> M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );;
gap> B:= Basis( M );
Basis( <3-dimensional bi-module over ( Rationals^
[ 3, 3 ] ) (left) and ( Rationals^[ 3, 3 ] ) (right)>, 
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] )
gap> IsBasisOfAlgebraModuleElementSpace( B );
true
gap> B!.delegateBasis;
SemiEchelonBasis( <vector space of dimension 3 over Rationals>, 
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="MatrixOfAction" Arg='B, x[, side]'/>

<Description>
Here <A>B</A> is a basis of an algebra module and <A>x</A> is an element
of the algebra that acts on this module. This function returns
the matrix of the action of <A>x</A> with respect to <A>B</A>.
If <A>x</A> acts from the left, then the coefficients of the images of
the basis elements of <A>B</A> (under the action of <A>x</A>) are the
columns of the output.
If <A>x</A> acts from the right, then they are the rows of the output.
<P/>
If the module is a bi-module, then the third parameter <A>side</A> must
be specified.
This is the string <C>"left"</C>, or <C>"right"</C> depending whether
<A>x</A> acts from the left or the right.
<Example><![CDATA[
gap> M:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap> x:= Basis(A)[3];
[ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
gap> MatrixOfAction( Basis( M ), x );
[ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SubAlgebraModule" Arg='M, gens [,"basis"]'/>

<Description>
is the sub-module of the algebra module <A>M</A>, generated by the vectors
in <A>gens</A>. If as an optional argument the string <C>basis</C> is added, then
it is
assumed that the vectors in <A>gens</A> form a basis of the submodule.
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap> A:= Algebra( Rationals, [ m1, m2 ] );;
gap> M:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0 ], [ 0, 1 ] ] );
<left-module over <algebra over Rationals, with 2 generators>>
gap> bb:= BasisVectors( Basis( M ) );
[ [ 1, 0 ], [ 0, 1 ] ]
gap> V:= SubAlgebraModule( M, [ bb[1] ] );
<left-module over <algebra over Rationals, with 2 generators>>
gap> Dimension( V );
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LeftModuleByHomomorphismToMatAlg" Arg='A, hom'/>

<Description>
Here <A>A</A> is an algebra and <A>hom</A> a homomorphism from <A>A</A> into a matrix
algebra. This function returns the left <A>A</A>-module defined by the
homomorphism <A>hom</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="RightModuleByHomomorphismToMatAlg" Arg='A, hom'/>

<Description>
Here <A>A</A> is an algebra and <A>hom</A> a homomorphism from <A>A</A> into a matrix
algebra. This function returns the right <A>A</A>-module defined by the
homomorphism <A>hom</A>.
<P/>
First we produce a structure constants algebra with basis elements
<M>x</M>, <M>y</M>, <M>z</M> such that <M>x^2 = x</M>, <M>y^2 = y</M>, <M>xz = z</M>, <M>zy = z</M>
and all other products are zero.
<P/>
<Example><![CDATA[
gap> T:= EmptySCTable( 3, 0 );;
gap> SetEntrySCTable( T, 1, 1, [ 1, 1 ]);
gap> SetEntrySCTable( T, 2, 2, [ 1, 2 ]);
gap> SetEntrySCTable( T, 1, 3, [ 1, 3 ]);
gap> SetEntrySCTable( T, 3, 2, [ 1, 3 ]);
gap> A:= AlgebraByStructureConstants( Rationals, T );
<algebra of dimension 3 over Rationals>
]]></Example>
<P/>
Now we construct an isomorphic matrix algebra.
<P/>
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap> m3:= NullMat( 2, 2 );; m3[1][2]:= 1;;
gap> B:= Algebra( Rationals, [ m1, m2, m3 ] );
<algebra over Rationals, with 3 generators>
]]></Example>
<P/>
Finally we construct the homomorphism and the corresponding right module.
<P/>
<Example><![CDATA[
gap> f:= AlgebraHomomorphismByImages( A, B, Basis(A), [ m1, m2, m3 ] );;
gap> RightModuleByHomomorphismToMatAlg( A, f );
<right-module over <algebra of dimension 3 over Rationals>>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AdjointModule" Arg='A'/>

<Description>
returns the <A>A</A>-module defined by the left action of <A>A</A> on itself.
<Example><![CDATA[
gap> m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap> m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap> m3:= NullMat( 2, 2 );; m3[1][2]:= 1;;
gap> A:= Algebra( Rationals, [ m1, m2, m3 ] );
<algebra over Rationals, with 3 generators>
gap> V:= AdjointModule( A );
<3-dimensional left-module over <algebra of dimension 
3 over Rationals>>
gap> v:= Basis( V )[3];
[ [ 0, 1 ], [ 0, 0 ] ]
gap> W:= SubAlgebraModule( V, [ v ] );
<left-module over <algebra of dimension 3 over Rationals>>
gap> Dimension( W );
1
]]></Example>
</Description>
</ManSection>

<!-- % One would be tempted to call <C>W</C> a left ideal in <C>V</C>, -->
<!-- % but in the current implementation, neither <C>V</C> nor <C>W</C> are themselves -->
<!-- % algebras; note that the element <C>v</C>, although looking like a matrix, -->
<!-- % cannot be multiplied with itself. -->
<ManSection>
<Attr Name="FaithfulModule" Arg='A' Label="for Lie algebras"/>

<Description>
returns a faithful finite-dimensional left-module over the algebra <A>A</A>.
This is only implemented for associative algebras, and for Lie algebras
of characteristic <M>0</M>. (It may also work for certain Lie algebras
of characteristic <M>p > 0</M>.)
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0 );;
gap> A:= AlgebraByStructureConstants( Rationals, T );
<algebra of dimension 2 over Rationals>
]]></Example>
<Example><![CDATA[
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 3 ]);
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 3 over Rationals>
gap> V:= FaithfulModule( L );
<left-module over <Lie algebra of dimension 3 over Rationals>>
gap> vv:= BasisVectors( Basis( V ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> x:= Basis( L )[3];
v.3
gap> List( vv, v -> x^v );
[ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 0, 0 ] ]
]]></Example>
<P/>
<C>A</C> is a <M>2</M>-dimensional algebra where all products are zero.
<P/>
<Example><![CDATA[
gap> V:= FaithfulModule( A );
<left-module over <algebra of dimension 2 over Rationals>>
gap> vv:= BasisVectors( Basis( V ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> xx:= BasisVectors( Basis( A ) );
[ v.1, v.2 ]
gap> xx[1]^vv[3];
[ 1, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ModuleByRestriction" Arg='V, sub1[, sub2]'/>

<Description>
Here <A>V</A> is an algebra module and <A>sub1</A> is a subalgebra
of the acting algebra of <A>V</A>. This function returns the
module that is the restriction of <A>V</A> to <A>sub1</A>.
So it has the same underlying vector space as <A>V</A>,
but the acting algebra is <A>sub</A>.
If two subalgebras <A>sub1</A>, <A>sub2</A> are given then <A>V</A> is
assumed to be a bi-module, and <A>sub1</A> a subalgebra of the algebra
acting on the left, and <A>sub2</A> a subalgebra of the algebra acting
on the right.
<Example><![CDATA[
gap> A:= Rationals^[3,3];;
gap> V:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap> B:= Subalgebra( A, [ Basis(A)[1] ] );
<algebra over Rationals, with 1 generators>
gap> W:= ModuleByRestriction( V, B );
<left-module over <algebra over Rationals, with 1 generators>>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="NaturalHomomorphismBySubAlgebraModule" Arg='V, W'/>

<Description>
Here <A>V</A> must be a sub-algebra module of <A>V</A>. This function returns
the projection from <A>V</A> onto <C><A>V</A>/<A>W</A></C>. It is a linear map, that is
also a module homomorphism. As usual images can be formed with
<C>Image( f, v )</C> and pre-images with <C>PreImagesRepresentative( f, u )</C>.
<P/>
The quotient module can also be formed
by entering <C><A>V</A>/<A>W</A></C>.
<Example><![CDATA[
gap> A:= Rationals^[3,3];;
gap> B:= DirectSumOfAlgebras( A, A );
<algebra over Rationals, with 6 generators>
gap> T:= StructureConstantsTable( Basis( B ) );;
gap> C:= AlgebraByStructureConstants( Rationals, T );
<algebra of dimension 18 over Rationals>
gap> V:= AdjointModule( C );
<left-module over <algebra of dimension 18 over Rationals>>
gap> W:= SubAlgebraModule( V, [ Basis(V)[1] ] );
<left-module over <algebra of dimension 18 over Rationals>>
gap> f:= NaturalHomomorphismBySubAlgebraModule( V, W );
<linear mapping by matrix, <
18-dimensional left-module over <algebra of dimension 
18 over Rationals>> -> <
9-dimensional left-module over <algebra of dimension 
18 over Rationals>>>
gap> quo:= ImagesSource( f );  # i.e., the quotient module
<9-dimensional left-module over <algebra of dimension 
18 over Rationals>>
gap> v:= Basis( quo )[1];
[ 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
gap> PreImagesRepresentative( f, v );
v.4
gap> Basis( C )[4]^v;
[ 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DirectSumOfAlgebraModules" Arg='list'
 Label="for a list of Lie algebra modules"/>
<Oper Name="DirectSumOfAlgebraModules" Arg='V, W'
 Label="for two Lie algebra modules"/>

<Description>
Here <A>list</A> must be a list of algebra modules. This function returns the
direct sum of the elements in the list (as an algebra module).
The modules must be defined over the same algebras.
<P/>
In the second form is short for <C>DirectSumOfAlgebraModules( [ <A>V</A>, <A>W</A> ] )</C>
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 3 );;
gap> V:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [1,0,0] ] );;
gap> W:= DirectSumOfAlgebraModules( V, V );
<6-dimensional left-module over ( Rationals^[ 3, 3 ] )>
gap> BasisVectors( Basis( W ) );
[ ( [ 1, 0, 0 ] )(+)( [ 0, 0, 0 ] ), ( [ 0, 1, 0 ] )(+)( [ 0, 0, 0 ] )
    , ( [ 0, 0, 1 ] )(+)( [ 0, 0, 0 ] ), 
  ( [ 0, 0, 0 ] )(+)( [ 1, 0, 0 ] ), ( [ 0, 0, 0 ] )(+)( [ 0, 1, 0 ] )
    , ( [ 0, 0, 0 ] )(+)( [ 0, 0, 1 ] ) ]
]]></Example>
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "C", 3, Rationals );;
gap> V:= HighestWeightModule( L, [ 1, 1, 0 ] );
<64-dimensional left-module over <Lie algebra of dimension 
21 over Rationals>>
gap> W:= HighestWeightModule( L, [ 0, 0, 2 ] );
<84-dimensional left-module over <Lie algebra of dimension 
21 over Rationals>>
gap> U:= DirectSumOfAlgebraModules( V, W );
<148-dimensional left-module over <Lie algebra of dimension 
21 over Rationals>>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TranslatorSubalgebra" Arg='M, U, W'/>

<Description>
 Here <A>M</A> is an algebra module, and <A>U</A> and <A>W</A> are two subspaces of <A>M</A>. 
 Let <A>A</A> be the algebra acting on <A>M</A>. This function returns the subspace
 of elements of <A>A</A> that map <A>U</A> into <A>W</A>. If <A>W</A> is a sub-algebra-module
 (i.e., closed under the action of <A>A</A>), then this space is a subalgebra
 of <A>A</A>. 
<P/>
 This function works for left, or right modules over a
 finite-dimensional algebra. We
 stress that it is not checked whether <A>U</A> and <A>W</A> are indeed subspaces
 of <A>M</A>. If this is not the case nothing is guaranteed about the behaviour
 of the function.
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( Rationals, 3 );
( Rationals^[ 3, 3 ] )
gap> V:= Rationals^[3,2];
( Rationals^[ 3, 2 ] )
gap> M:= LeftAlgebraModule( A, \*, V );
<left-module over ( Rationals^[ 3, 3 ] )>
gap> bm:= Basis(M);;
gap> U:= SubAlgebraModule( M, [ bm[1] ] );   
<left-module over ( Rationals^[ 3, 3 ] )>
gap> TranslatorSubalgebra( M, U, M );
<algebra of dimension 9 over Rationals>
gap> W:= SubAlgebraModule( M, [ bm[4] ] );
<left-module over ( Rationals^[ 3, 3 ] )>
gap> T:=TranslatorSubalgebra( M, U, W );
<algebra of dimension 0 over Rationals>
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  algfp.msk                    GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: algfp.msk,v 1.2 2002/04/15 10:02:26 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 2001 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Finitely Presented Algebras">
<Heading>Finitely Presented Algebras</Heading>

Currently the &GAP; library contains only few functions dealing with
general finitely presented algebras,
so this chapter is merely a placeholder.
<P/>
The special case of finitely presented <E>Lie</E> algebras is described
in&nbsp;<Ref Sect="Finitely Presented Lie Algebras"/>,
and there is also a &GAP; package <C>fplsa</C> for computing structure constants
of <E>f</E>initely <E>p</E>resented <E>L</E>ie (<E>s</E>uper)<E>a</E>lgebras.
<P/>
<!-- % Finitely presented <E>associative</E> algebras will eventually be handled by -->
<!-- % vector enumeration techniques. -->

</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  alglie.msk                  GAP documentation             Willem de Graaf -->
<!-- %% -->
<!-- %A  @(#)<M>Id: alglie.msk,v 1.42 2005/11/28 11:43:42 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Lie Algebras">
<Heading>Lie Algebras</Heading>

A Lie algebra <M>L</M> is an algebra such that 
<M>x x = 0</M> and <M>x(yz) + y(zx) + z(xy) = 0</M>
for all <M>x, y, z \in L</M>.
A common way of creating a Lie algebra is by taking an associative
algebra together with the commutator as product.
Therefore the product of two elements <M>x, y</M> of a Lie algebra
is usually denoted by  <M>[x,y]</M>,
but in &GAP; this denotes the list of the elements <M>x</M> and <M>y</M>;
hence the product of elements is made by the usual <C>*</C>.
This gives no problems when dealing with Lie algebras given by a 
table of structure constants.
However, for matrix Lie algebras the situation is not so easy
as <C>*</C> denotes the ordinary (associative) matrix multiplication.
In &GAP; this problem is solved by wrapping 
elements of a matrix Lie algebra up as <C>LieObject</C>s,
and then define  the <C>*</C> for <C>LieObject</C>s to be the commutator
(see <Ref Sect="Lie Objects"/>).


<!-- %%  The algorithms for Lie algebras are due to Willem de Graaf. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Lie Objects">
<Heading>Lie Objects</Heading>

Let <C>x</C> be a ring element, then <C>LieObject(x)</C> 
(see&nbsp;<Ref Func="LieObject"/>) wraps <C>x</C> up into an
object that contains the same data (namely <C>x</C>). The multiplication
<C>*</C> for Lie objects is formed by taking the commutator. More exactly,
if <C>l1</C> and <C>l2</C> are the Lie objects corresponding to
the ring elements <C>r1</C> and <C>r2</C>, then <C>l1 * l2</C> 
is equal to the Lie object corresponding to <C>r1 * r2 - r2 * r1</C>. 
Two rules for Lie objects are worth noting:
<P/>
<List>
<Item>
  An element is <E>not</E> equal to its Lie element.
</Item>
<Item>
  If we take the Lie object of an ordinary (associative) matrix
  then this is again a matrix;
  it is therefore a collection (of its rows) and a list.
  But it is <E>not</E> a collection of collections of its entries,
  and its family is <E>not</E> a collections family.
</Item>
</List>
<P/>
Given a family <C>F</C> of ring elements, we can form its Lie family 
<C>L</C>. The elements of <C>F</C> and <C>L</C> are in bijection, only 
the multiplications via <C>*</C> differ for both families.
More exactly, if <C>l1</C> and <C>l2</C> are the Lie elements 
corresponding to the elements <C>f1</C> and <C>f2</C> in <C>F</C>, 
we have <C>l1 * l2</C> equal to the Lie element corresponding to 
<C>f1 * f2 - f2 * f1</C>.
Furthermore, the product of Lie elements <C>l1</C>, <C>l2</C> and
<C>l3</C> is left-normed, that is <C>l1*l2*l3</C> is equal to
<C>(l1*l2)*l3</C>.  
<P/>
The main reason to distinguish elements and Lie elements on the family
level is that this helps to avoid forming domains that contain
elements of both types.
For example, if we could form vector spaces of matrices then at first
glance it would be no problem to have both ordinary and Lie matrices
in it, but as soon as we find out that the space is in fact an algebra
(e.g., because its dimension is that of the full matrix algebra),
we would run into strange problems.
<P/>
Note that the family situation with Lie families may be not familiar.
<P/>
<List>
<Item>
  We have to be careful when installing methods for certain types
  of domains that may involve Lie elements.
  For example, the zero element of a matrix space is either an ordinary
  matrix or its Lie element, depending on the space.
  So either the method must be aware of both cases, or the method
  selection must distinguish the two cases.
  In the latter situation, only one method may be applicable to each
  case; this means that it is not sufficient to treat the Lie case
  with the additional requirement <C>IsLieObjectCollection</C> but that
  we must explicitly require non-Lie elements for the non-Lie case.
</Item>
<Item>
  Being a full matrix space is a property that may hold for a space
  of ordinary matrices or a space of Lie matrices.
  So methods for full matrix spaces must also be aware of Lie matrices.
</Item>
</List>

<ManSection>
<Attr Name="LieObject" Arg='obj'/>

<Description>
Let <A>obj</A> be a ring element. Then <C>LieObject( <A>obj</A> )</C> is the
corresponding Lie object. If <A>obj</A> lies in the family <C>F</C>,
then <C>LieObject( <A>obj</A> )</C> lies in the family <C>LieFamily( F )</C>
(see&nbsp;<Ref Func="LieFamily"/>).
<Example><![CDATA[
gap> m:= [ [ 1, 0 ], [ 0, 1 ] ];;
gap> lo:= LieObject( m );
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> m*m;
[ [ 1, 0 ], [ 0, 1 ] ]
gap> lo*lo;
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLieObject" Arg='obj' Type='Category'/>
<Filt Name="IsLieObjectCollection" Arg='obj' Type='Category'/>
<Filt Name="IsRestrictedLieObject" Arg='obj' Type='Category'/>
<Filt Name="IsRestrictedLieObjectCollection" Arg='obj' Type='Category'/>

<Description>
An object lies in <Ref Filt="IsLieObject"/> if and only if 
it lies in a family constructed by <Ref Attr="LieFamily"/>.
<Example><![CDATA[
gap> m:= [ [ 1, 0 ], [ 0, 1 ] ];;
gap> lo:= LieObject( m );
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> IsLieObject( m );
false
gap> IsLieObject( lo );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LieFamily" Arg='Fam'/>

<Description>
is a family <C>F</C> in bijection with the family <A>Fam</A>,
but with the Lie bracket as infix multiplication.
That is, for <C>x</C>, <C>y</C> in <A>Fam</A>, the product of 
the images in <C>F</C> will be the image of <C>x * y - y * x</C>.
<P/>
The standard type of objects in a Lie family <C>F</C> is 
<C><A>F</A>!.packedType</C>.
<P/>
<Index Key="Embedding" Subkey="for Lie algebras"><C>Embedding</C></Index>
The bijection from <A>Fam</A> to <C>F</C> is given by 
<C>Embedding( <A>Fam</A>, F )</C> 
(see&nbsp;<Ref Oper="Embedding" Label="for two domains"/>);
this bijection respects addition and additive inverses.
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingFamily" Arg='Fam'/>

<Description>
If <A>Fam</A> is a Lie family then <C>UnderlyingFamily( <A>Fam</A> )</C>
is a family <C>F</C> such that <C><A>Fam</A> = LieFamily( F )</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingRingElement" Arg='obj'/>

<Description>
Let <A>obj</A> be a Lie object constructed from a ring element
<C>r</C> by calling <C>LieObject( r )</C>.
Then <C>UnderlyingRingElement( <A>obj</A> )</C> returns
the ring element <C>r</C> used to construct <A>obj</A>.
If <C>r</C> lies in the family <C>F</C>, then <A>obj</A>
lies in the family <C>LieFamily( F )</C>
(see&nbsp;<Ref Func="LieFamily"/>).
<Example><![CDATA[
gap> lo:= LieObject( [ [ 1, 0 ], [ 0, 1 ] ] );
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> m:=UnderlyingRingElement(lo);
[ [ 1, 0 ], [ 0, 1 ] ]
gap> lo*lo;
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
gap> m*m;
[ [ 1, 0 ], [ 0, 1 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Lie algebras">
<Heading>Constructing Lie algebras</Heading>

In this section we describe functions that create Lie algebras. Creating
and working with subalgebras goes exactly in the same way as for general
algebras; so for that we refer to Chapter <Ref Chap="Algebras"/>.

<ManSection>
<Func Name="LieAlgebraByStructureConstants"
 Arg='R, sct[, nameinfo]'/>

<Description>
<Ref Func="LieAlgebraByStructureConstants"/> does the same as
<Ref Func="AlgebraByStructureConstants"/>, and has the same meaning
of arguments, except that the result is assumed to be a Lie algebra.
Note that the function does not check whether
<A>sct</A> satisfies the Jacobi identity.
(So if one creates a Lie algebra this way with a table that does not
satisfy the Jacobi identity, errors may occur later on.)
<Example><![CDATA[
gap> T:= EmptySCTable( 2, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1/2, 1 ] );
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 2 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RestrictedLieAlgebraByStructureConstants"
 Arg='R, sct[, nameinfo], pmapping'/>

<Description>
<Ref Func="RestrictedLieAlgebraByStructureConstants"/> does the same as
<Ref Func="LieAlgebraByStructureConstants"/>, and has the same meaning of
all arguments, except that the result is assumed to be a restricted Lie 
algebra (see <Ref Label="Restricted Lie algebras"/>) with the <M>p</M>-map 
given by the additional argument <A>pmapping</A>. This last argument is a
list of the length equal to the dimension of the algebra; its <M>i</M>-th 
entry specifies the <M>p</M>-th power of the <M>i</M>-th basis vector
in the same format <C>[ coeff1, position1, coeff2, position2, ... ]</C> as 
<Ref Func="SetEntrySCTable"/> uses to specify entries of the structure 
constants table.
<P/>
Note that the function does not check whether
<A>sct</A> satisfies the Jacobi identity, of whether <A>pmapping</A>
specifies a legitimate <M>p</M>-mapping.
<P/>
The following example creates a commutative restricted Lie algebra of dimension
3, in which the <M>p</M>-th power of the <M>i</M>-th basis element is 
the <M>i+1</M>-th basis element (except for the 3rd basis element which
goes to zero).
<Example><![CDATA[
gap> T:= EmptySCTable( 3, Zero(GF(5)), "antisymmetric" );;
gap> L:= RestrictedLieAlgebraByStructureConstants( 
>                                     GF(5), T, [[1,2],[1,3],[]] );
<Lie algebra of dimension 3 over GF(5)>
gap> List(Basis(L),PthPowerImage);
[ v.2, v.3, 0*v.1 ]
gap> PthPowerImage(L.1+L.2);
v.2+v.3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LieAlgebra" Arg='L' Label="for an associative algebra"/>
<Func Name="LieAlgebra" Arg='F, gens[, zero][, "basis"]'
 Label="for field and generators"/>

<Description>
For an associative algebra <A>L</A>, <C>LieAlgebra( <A>L</A> )</C> is the
Lie algebra isomorphic to <A>L</A> as a vector space
but with the Lie bracket as product.
<P/>
<C>LieAlgebra( <A>F</A>, <A>gens</A> )</C> is the Lie algebra over the
division ring <A>F</A>, generated <E>as Lie algebra</E>
by the Lie objects corresponding to the vectors in the list <A>gens</A>.
<P/>
<E>Note</E> that the algebra returned by
<Ref Func="LieAlgebra" Label="for field and generators"/>
does not contain the vectors in <A>gens</A>.
The elements in <A>gens</A> are wrapped up as Lie objects
(see <Ref Sect="Lie Objects"/>).
This allows one to create Lie algebras from ring elements with respect to
the Lie bracket as product.  But of course the product in the Lie
algebra is the usual <C>*</C>.
<P/>
If there are three arguments, a division ring <A>F</A> and a list
<A>gens</A> and an element <A>zero</A>,
then <C>LieAlgebra( <A>F</A>, <A>gens</A>, <A>zero</A> )</C> is the
corresponding <A>F</A>-Lie algebra with zero element the Lie object
corresponding to <A>zero</A>.
<P/>
If the last argument is the string <C>"basis"</C> then the vectors in
<A>gens</A> are known to form a basis of the algebra
(as an <A>F</A>-vector space).
<P/>
<E>Note</E> that even if each element in <A>gens</A> is already
a Lie element, i.e., is of the form <C>LieElement( <A>elm</A> )</C>
for an object <A>elm</A>,
the elements of the result lie in the Lie family of the family that
contains <A>gens</A> as a subset.
<Example><![CDATA[
gap> A:= FullMatrixAlgebra( GF( 7 ), 4 );;
gap> L:= LieAlgebra( A );
<Lie algebra of dimension 16 over GF(7)>
gap> mats:= [ [ [ 1, 0 ], [ 0, -1 ] ], [ [ 0, 1 ], [ 0, 0 ] ], 
>             [ [ 0, 0 ], [ 1, 0] ] ];;
gap> L:= LieAlgebra( Rationals, mats );
<Lie algebra over Rationals, with 3 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeLieAlgebra" Arg='R, rank[, name]'
 Label="for ring, rank (and name)"/>
<Func Name="FreeLieAlgebra" Arg='R, name1, name2, ...'
 Label="for ring and several names"/>

<Description>
Returns a free Lie algebra of rank <A>rank</A> over the ring <A>R</A>. 
<C>FreeLieAlgebra( <A>R</A>, <A>name1</A>, <A>name2</A>,...)</C> returns
a free Lie algebra over <A>R</A> with generators named <A>name1</A>,
<A>name2</A>, and so on.
The elements of a free Lie algebra are written on the Hall-Lyndon
basis.
<Example><![CDATA[
gap> L:= FreeLieAlgebra( Rationals, "x", "y", "z" );
<Lie algebra over Rationals, with 3 generators>
gap> g:= GeneratorsOfAlgebra( L );; x:= g[1];; y:=g[2];; z:= g[3];;
gap> z*(y*(x*(z*y)));
(-1)*((x*(y*z))*(y*z))+(-1)*((x*((y*z)*z))*y)+(-1)*(((x*z)*(y*z))*y)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FullMatrixLieAlgebra" Arg='R, n'/>
<Func Name="MatrixLieAlgebra" Arg='R, n'/>
<Func Name="MatLieAlgebra" Arg='R, n'/>

<Description>
is the full matrix Lie algebra of <M><A>n</A> \times <A>n</A></M>
matrices over the ring <A>R</A>,
for a nonnegative integer <A>n</A>.
<Example><![CDATA[
gap> FullMatrixLieAlgebra( GF(9), 10 );
<Lie algebra over GF(3^2), with 19 generators>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RightDerivations" Arg='B'/>
<Attr Name="LeftDerivations" Arg='B'/>
<Attr Name="Derivations" Arg='B'/>

<Description>
These functions all return the matrix Lie algebra of derivations 
of the algebra <M>A</M> with basis <A>B</A>.
<P/>
<C>RightDerivations( <A>B</A> )</C> returns the algebra of derivations
represented by their right action on the algebra <M>A</M>.
This means that with respect to the basis <M>B</M> of <M>A</M>,
the derivation <M>D</M> is described by the matrix <M>[ d_{{i,j}} ]</M>
which means that <M>D</M> maps the <M>i</M>-th basis element <M>b_i</M>
to  <M>\sum_{{j = 1}}^n d_{{i,j}} b_j</M>.
<P/>
<C>LeftDerivations( <A>B</A> )</C> returns the Lie algebra of derivations
represented by their left action on the algebra <M>A</M>.
So the matrices contained in the algebra output by
<C>LeftDerivations( <A>B</A> )</C> are the transposes of the 
matrices contained in the output of <C>RightDerivations( <A>B</A> )</C>.
<P/>
<Ref Attr="Derivations"/> is just a synonym for
<Ref Attr="RightDerivations"/>.
<Example><![CDATA[
gap> A:= OctaveAlgebra( Rationals );
<algebra of dimension 8 over Rationals>
gap> L:= Derivations( Basis( A ) );
<Lie algebra of dimension 14 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SimpleLieAlgebra" Arg='type, n, F'/>

<Description>
This function constructs the simple Lie algebra of type given by the
string <A>type</A> and rank <A>n</A> over the field <A>F</A>. The string
<A>type</A> must be one of <C>"A"</C>, <C>"B"</C>, <C>"C"</C>, <C>"D"</C>, 
<C>"E"</C>, <C>"F"</C>, <C>"G"</C>, <C>"H"</C>, <C>"K"</C>, <C>"S"</C>, 
<C>"W"</C> or <C>"M"</C>. For the types <C>A</C> to <C>G</C>, <A>n</A> 
must be a positive integer. The last five types only exist over fields of 
characteristic <M>p>0</M>. If the type is <C>H</C>, then <A>n</A> must be 
a list of positive integers of even length.
If the type is <C>K</C>, then <A>n</A> must be a list of positive 
integers of odd length.
For the types <C>S</C> and <C>W</C>, <A>n</A> must be a list of positive 
integers of any length. 
If the type is <C>M</C>, then the Melikyan algebra is constructed.
In this case <A>n</A> must be a list of two positive integers.
This Lie algebra only exists over fields of characteristic <M>5</M>.
This Lie algebra is <M>&ZZ; \times &ZZ;</M> graded;
and the grading can be accessed via the attribute <C>Grading(L)</C>
(see&nbsp;<Ref Attr="Grading"/>).
In some cases the Lie algebra returned by this function is not simple.
Examples are the Lie algebras of type <M>A_n</M> over a field
of characteristic <M>p>0</M> where <M>p</M> divides <M>n+1</M>,
and the Lie algebras of type <M>K_n</M> where <M>n</M> is a list of
length 1.
<P/>
If <A>type</A> is one of <C>A</C>, <C>B</C>, <C>C</C>, <C>D</C>, 
<C>E</C>, <C>F</C>, <C>G</C>, and <A>F</A> is a field of characteristic 
zero, then the basis of the returned Lie algebra is a Chevalley basis. 
<P/>
<Example><![CDATA[
gap> SimpleLieAlgebra( "E", 6, Rationals );
<Lie algebra of dimension 78 over Rationals>
gap> SimpleLieAlgebra( "A", 6, GF(5) );
<Lie algebra of dimension 48 over GF(5)>
gap> SimpleLieAlgebra( "W", [1,2], GF(5) );
<Lie algebra of dimension 250 over GF(5)>
gap> SimpleLieAlgebra( "H", [1,2], GF(5) );
<Lie algebra of dimension 123 over GF(5)>
gap> L:= SimpleLieAlgebra( "M", [1,1], GF(5) );
<Lie algebra of dimension 125 over GF(5)>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Distinguished Subalgebras">
<Heading>Distinguished Subalgebras</Heading>

Here we describe functions that calculate well-known subalgebras
and ideals of a Lie algebra (such as the centre, the centralizer of a
subalgebra, etc.).

<ManSection>
<Attr Name="LieCentre" Arg='L'/>
<Attr Name="LieCenter" Arg='L'/>

<Description>
The <E>Lie</E> centre of the Lie algebra <A>L</A> is the kernel of the
adjoint mapping, that is,
the set <M>\{ a \in L : \forall x \in L: a x = 0 \}</M>.
<P/>
In characteristic <M>2</M> this may differ from the usual centre 
(that is the set of all <M>a \in L</M> such that <M>a x = x a</M> 
for all <M>x \in L</M>). 
Therefore, this operation is named <Ref Attr="LieCentre"/>
and not <Ref Attr="Centre"/>. 
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( GF(3), 3 );
<Lie algebra over GF(3), with 5 generators>
gap> LieCentre( L );
<two-sided ideal in <Lie algebra of dimension 9 over GF(3)>, 
  (dimension 1)>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LieCentralizer" Arg='L, S'/>

<Description>
is the annihilator of <A>S</A> in the Lie algebra <A>L</A>, that is,
the set <M>\{ a \in L : \forall s \in S: a*s = 0 \}</M>.
Here <A>S</A> may be a subspace or a subalgebra of <A>L</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVectors( Basis( L ) );;
gap> LieCentralizer( L, Subalgebra( L, [ b[1], b[2] ] ) );
<Lie algebra of dimension 1 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LieNormalizer" Arg='L, U'/>

<Description>
is the normalizer of the subspace <A>U</A> in the Lie algebra <A>L</A>,
that is, the set <M>N_L(U) = \{ x \in L : [x,U] \subset U \}</M>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVectors( Basis( L ) );;
gap> LieNormalizer( L, Subalgebra( L, [ b[1], b[2] ] ) );
<Lie algebra of dimension 8 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LieDerivedSubalgebra" Arg='L'/>

<Description>
is the (Lie) derived subalgebra of the Lie algebra <A>L</A>.  
<Example><![CDATA[
gap>  L:= FullMatrixLieAlgebra( GF( 3 ), 3 );
<Lie algebra over GF(3), with 5 generators>
gap> LieDerivedSubalgebra( L );
<Lie algebra of dimension 8 over GF(3)>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LieNilRadical" Arg='L'/>

<Description>
This function calculates the (Lie) nil radical of the Lie algebra
<A>L</A>.
<P/>
<Example><![CDATA[
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:= LieAlgebra( Rationals, mats );;
gap> LieNilRadical( L );
<two-sided ideal in <Lie algebra of dimension 3 over Rationals>, 
  (dimension 2)>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LieSolvableRadical" Arg='L'/>

<Description>
Returns the (Lie) solvable radical of the Lie algebra <A>L</A>.
<Example><![CDATA[
gap> L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> LieSolvableRadical( L );
<two-sided ideal in <Lie algebra of dimension 9 over Rationals>, 
  (dimension 1)>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CartanSubalgebra" Arg='L'/>

<Description>
A Cartan subalgebra of a Lie algebra <A>L</A> is defined as a nilpotent
subalgebra of <A>L</A> equal to its own Lie normalizer in <A>L</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> CartanSubalgebra( L );
<Lie algebra of dimension 2 over Rationals>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Series of Ideals">
<Heading>Series of Ideals</Heading>

<ManSection>
<Attr Name="LieDerivedSeries" Arg='L'/>

<Description>
is the (Lie) derived series of the Lie algebra <A>L</A>.  
<Example><![CDATA[
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:= LieAlgebra( Rationals, mats );;
gap> LieDerivedSeries( L );
[ <Lie algebra of dimension 3 over Rationals>, 
  <Lie algebra of dimension 1 over Rationals>, 
  <Lie algebra of dimension 0 over Rationals> ]
]]></Example>
</Description>
</ManSection>
 
<ManSection>
<Attr Name="LieLowerCentralSeries" Arg='L'/>

<Description>
is the (Lie) lower central series of the Lie algebra <A>L</A>.  
<Example><![CDATA[
gap> mats:= [ [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:=LieAlgebra( Rationals, mats );;
gap> LieLowerCentralSeries( L );
[ <Lie algebra of dimension 3 over Rationals>, 
  <Lie algebra of dimension 1 over Rationals> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LieUpperCentralSeries" Arg='L'/>

<Description>
is the (Lie) upper central series of the Lie algebra <A>L</A>.
<Example><![CDATA[
gap> mats:= [ [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:=LieAlgebra( Rationals, mats );;
gap> LieUpperCentralSeries( L );
[ <two-sided ideal in <Lie algebra of dimension 3 over Rationals>, 
      (dimension 1)>, <Lie algebra over Rationals, with 0 generators> 
 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties of a Lie Algebra">
<Heading>Properties of a Lie Algebra</Heading>

<ManSection>
<Prop Name="IsLieAbelian" Arg='L'/>

<Description>
returns <K>true</K> if <A>L</A> is a Lie algebra such that each 
product of elements in <A>L</A> is zero, and <K>false</K> otherwise.
<Example><![CDATA[
gap>  T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap>  L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieAbelian( L );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLieNilpotent" Arg='L'/>

<Description>
A Lie algebra <A>L</A> is defined to be (Lie) <E>nilpotent</E>
when its (Lie) lower central series reaches the trivial subalgebra.
<Example><![CDATA[
gap> T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieNilpotent( L );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLieSolvable" Arg='L'/>

<Description>
A Lie algebra <A>L</A> is defined to be (Lie) <E>solvable</E>
when its (Lie) derived series reaches the trivial subalgebra.
<Example><![CDATA[
gap> T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieSolvable( L );
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Semisimple Lie Algebras and Root Systems">
<Heading>Semisimple Lie Algebras and Root Systems</Heading>

This section contains some functions for dealing with
semisimple Lie algebras and their root systems.

<ManSection>
<Attr Name="SemiSimpleType" Arg='L'/>

<Description>
Let <A>L</A> be a semisimple Lie algebra, i.e., a direct sum of simple
Lie algebras.
Then <Ref Attr="SemiSimpleType"/> returns the type of <A>L</A>, i.e.,
a string containing the types of the simple summands of <A>L</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "E", 8, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> K:= LieCentralizer(L, Subalgebra(L, [ b[61]+b[79]+b[101]+b[102] ]));
<Lie algebra of dimension 102 over Rationals>
gap> lev:= LeviMalcevDecomposition(K);;
gap> SemiSimpleType( lev[1] );
"B3 A1"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ChevalleyBasis" Arg='L'/>

<Description>
Here <A>L</A> must be a semisimple Lie algebra with a split Cartan 
subalgebra. Then <C>ChevalleyBasis(<A>L</A>)</C> returns a list 
consisting of three sublists.
Together these sublists form a Chevalley basis of <A>L</A>. The first
list contains the positive root vectors, the second list contains the
negative root vectors, and the third list the Cartan elements of the
Chevalley basis.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> ChevalleyBasis( L );
[ [ v.1, v.2, v.3, v.4, v.5, v.6 ], 
  [ v.7, v.8, v.9, v.10, v.11, v.12 ], [ v.13, v.14 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRootSystem" Arg='obj' Type='Category'/>

<Description>
Category of root systems.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRootSystemFromLieAlgebra" Arg='obj' Type='Category'/>

<Description>
Category of root systems that come from (semisimple) Lie algebras. 
They often have special attributes such as 
<Ref Func="UnderlyingLieAlgebra"/>, 
<Ref Attr="PositiveRootVectors"/>,
<Ref Attr="NegativeRootVectors"/>, 
<Ref Attr="CanonicalGenerators"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="RootSystem" Arg='L'/>

<Description>
<Ref Attr="RootSystem"/> calculates the root system of the semisimple 
Lie algebra <A>L</A> with a split Cartan subalgebra.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> R:= RootSystem( L );
<root system of rank 2>
gap> IsRootSystem( R );
true
gap> IsRootSystemFromLieAlgebra( R );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingLieAlgebra" Arg='R'/>

<Description>
For a root system <A>R</A> coming from a semisimple Lie algebra <C>L</C>,
returns the Lie algebra <C>L</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="PositiveRoots" Arg='R'/>

<Description>
The list of positive roots of the root system <A>R</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="NegativeRoots" Arg='R'/>

<Description>
The list of negative roots of the root system <A>R</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="PositiveRootVectors" Arg='R'/>

<Description>
A list of positive root vectors of the root system <A>R</A> that comes
from a Lie algebra <C>L</C>. This is a list in bijection with the list
<C>PositiveRoots( L )</C> (see&nbsp;<Ref Attr="PositiveRoots"/>). The 
root vector is a non-zero element of the root space (in <C>L</C>) of 
the corresponding root.
</Description>
</ManSection>

<ManSection>
<Attr Name="NegativeRootVectors" Arg='R'/>

<Description>
A list of negative root vectors of the root system <A>R</A> that comes
from a Lie algebra <C>L</C>. This is a list in bijection with the list
<C>NegativeRoots( L )</C> (see&nbsp;<Ref Attr="NegativeRoots"/>). The 
root vector is a non-zero element of the root space (in <C>L</C>) of 
the corresponding root.
</Description>
</ManSection>

<ManSection>
<Attr Name="SimpleSystem" Arg='R'/>

<Description>
A list of simple roots of the root system <A>R</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CartanMatrix" Arg='R'/>

<Description>
The Cartan matrix of the root system <A>R</A>, relative to the simple 
roots in <C>SimpleSystem( <A>R</A> )</C> (see&nbsp;<Ref Attr="SimpleSystem"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="BilinearFormMat" Arg='R'/>

<Description>
The matrix of the bilinear form of the root system <A>R</A>.
If we denote this matrix by <M>B</M>, then we have
<M>B(i,j) = (\alpha_i, \alpha_j)</M>,
where the <M>\alpha_i</M> are the simple roots of <A>R</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CanonicalGenerators" Arg='R'/>

<Description>
Here <A>R</A> must be a root system coming from a semisimple Lie algebra
<C>L</C>.
This function returns <M>3l</M> generators of <A>L</A>,
<M>x_1, \ldots, x_l, y_1, \ldots, y_l, h_1, \ldots, h_l</M>,
where <M>x_i</M> lies in the root space corresponding to the 
<M>i</M>-th simple root of the root system of <A>L</A>,
<M>y_i</M> lies in the root space corresponding to <M>-</M> the
<M>i</M>-th simple root,
and the <M>h_i</M> are elements of the Cartan subalgebra.
These elements satisfy the relations
<M>h_i * h_j = 0</M>,
<M>x_i * y_j = \delta_{ij} h_i</M>,
<M>h_j * x_i = c_{ij} x_i</M>,
<M>h_j * y_i = -c_{ij} y_i</M>,
where <M>c_{ij}</M> is the entry of the Cartan matrix on position
<M>ij</M>.
<P/>
Also if <M>a</M> is a root of the root system <A>R</A>
(so <M>a</M> is a list of numbers),
then we have the relation <M>h_i * x = a[i] x</M>,
where <M>x</M> is a root vector corresponding to <M>a</M>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> R:= RootSystem( L );;
gap> UnderlyingLieAlgebra( R );
<Lie algebra of dimension 14 over Rationals>
gap> PositiveRoots( R );
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
gap> x:= PositiveRootVectors( R );
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> g:=CanonicalGenerators( R );
[ [ v.1, v.2 ], [ v.7, v.8 ], [ v.13, v.14 ] ]
gap> g[3][1]*x[1];
(2)*v.1
gap> g[3][2]*x[1];
(-1)*v.1
gap> # i.e., x[1] is the root vector belonging to the root [ 2, -1 ]
gap> BilinearFormMat( R );
[ [ 1/12, -1/8 ], [ -1/8, 1/4 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Semisimple Lie Algebras and Weyl Groups of Root Systems">
<Heading>Semisimple Lie Algebras and Weyl Groups of Root Systems</Heading>

This section deals with the Weyl group of a root system. 
A Weyl group is represented by its action on the weight lattice. 
A <E>weight</E> is by definition a linear function
<M>\lambda: H \rightarrow F</M> (where <M>F</M> is the ground field), such 
that the values <M>\lambda(h_i)</M> are all integers (where the <M>h_i</M> 
are the Cartan elements of the <Ref Attr="CanonicalGenerators"/>). 
On the other hand each weight is determined by these values. 
Therefore we represent a weight by a vector of integers;
the <M>i</M>-th entry of this vector is the value <M>\lambda(h_i)</M>.
Now the elements of the Weyl group are represented by matrices, and
if <C>g</C> is an element of a Weyl group and <C>w</C> a weight, then 
<C>w*g</C> gives the result of applying <C>g</C> to <C>w</C>.  
Another way of applying the <M>i</M>-th simple reflection to a weight is 
by using the function <Ref Oper="ApplySimpleReflection"/>.
<P/>
A Weyl group is generated by the simple reflections. 
So <Ref Attr="GeneratorsOfGroup"/> for a Weyl group <C>W</C>  gives a list 
of matrices and the <M>i</M>-th entry of this list is the simple reflection 
corresponding to the <M>i</M>-th simple root of the corresponding root system.

<ManSection>
<Prop Name="IsWeylGroup" Arg='G'/>

<Description>
A Weyl group is a group generated by reflections, with the attribute
<Ref Attr="SparseCartanMatrix"/> set.
</Description>
</ManSection>

<ManSection>
<Attr Name="SparseCartanMatrix" Arg='W'/>

<Description>
This is a sparse form of the Cartan matrix of the corresponding root 
system. If we denote the Cartan matrix by <C>C</C>, then the sparse 
Cartan matrix of <A>W</A> is a list (of length equal to the length of 
the Cartan matrix), where the <C>i</C>-th entry is a list consisting 
of elements <C>[ j, C[i][j] ]</C>, where <C>j</C> is such that
<C>C[i][j]</C> is non-zero.
</Description>
</ManSection>

<ManSection>
<Attr Name="WeylGroup" Arg='R'/>

<Description>
The Weyl group of the root system <A>R</A>. It is generated by the simple
reflections. A simple reflection is represented by a matrix, and the
result of letting a simple reflection <C>m</C> act on a weight <C>w</C> 
is obtained by <C>w*m</C>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> R:= RootSystem( L );;
gap> W:= WeylGroup( R );
<matrix group with 4 generators>
gap> IsWeylGroup( W );
true
gap> SparseCartanMatrix( W );
[ [ [ 1, 2 ], [ 3, -1 ] ], [ [ 2, 2 ], [ 4, -1 ] ], 
  [ [ 1, -1 ], [ 3, 2 ], [ 4, -1 ] ], 
  [ [ 2, -1 ], [ 3, -2 ], [ 4, 2 ] ] ]
gap> g:= GeneratorsOfGroup( W );;
gap> [ 1, 1, 1, 1 ]*g[2];
[ 1, -1, 1, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ApplySimpleReflection" Arg='SC, i, wt'/>

<Description>
Here <A>SC</A> is the sparse Cartan matrix of a Weyl group. This
function applies the <A>i</A>-th simple reflection to the weight
<A>wt</A>, thus changing <A>wt</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> C:= SparseCartanMatrix( W );;
gap> w:= [ 1, 1, 1, 1 ];;
gap> ApplySimpleReflection( C, 2, w );
gap> w;
[ 1, -1, 1, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LongestWeylWordPerm" Arg='W'/>

<Description>
Let <M>g_0</M> be the longest element in the Weyl group <A>W</A>,
and let <M>\{ \alpha_1, \ldots, \alpha_l \}</M> be a simple system 
of the corresponding root system.
Then <M>g_0</M> maps <M>\alpha_i</M> to <M>-\alpha_{{\sigma(i)}}</M>,
where <M>\sigma</M> is a permutation of <M>(1, \ldots, l)</M>.
This function returns that permutation.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> LongestWeylWordPerm( W );
(1,6)(3,5)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ConjugateDominantWeight" Arg='W, wt'/>
<Oper Name="ConjugateDominantWeightWithWord" Arg='W, wt'/>

<Description>
Here <A>W</A> is a Weyl group and <A>wt</A> a weight (i.e., a list of 
integers). <Ref Oper="ConjugateDominantWeight"/> returns the unique 
dominant weight conjugate to <A>wt</A> under <A>W</A>.
<P/>
<Ref Oper="ConjugateDominantWeightWithWord"/> returns a list of two 
elements. The first of these is the dominant weight conjugate to <A>wt</A>.
The second element is a list of indices of simple reflections that have to
be applied to <A>wt</A> in order to get the dominant weight conjugate to it.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> C:= SparseCartanMatrix( W );;
gap> w:= [ 1, -1, 2, -2, 3, -3 ];;
gap> ConjugateDominantWeight( W, w );
[ 2, 1, 0, 0, 0, 0 ]
gap> c:= ConjugateDominantWeightWithWord( W, w );
[ [ 2, 1, 0, 0, 0, 0 ], [ 2, 4, 2, 3, 6, 5, 4, 2, 3, 1 ] ]
gap> for i in [1..Length(c[2])] do
> ApplySimpleReflection( C, c[2][i], w );
> od;
gap> w;
[ 2, 1, 0, 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="WeylOrbitIterator" Arg='W, wt'/>

<Description>
Returns an iterator for the orbit of the weight <A>wt</A> under the
action of the Weyl group <A>W</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );
<iterator>
gap> NextIterator( orb );
[ 1, 1, 1, 1, 1, 1 ]
gap> NextIterator( orb );
[ -1, -1, -1, -1, -1, -1 ]
gap> orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );
<iterator>
gap> k:= 0;
0
gap> while not IsDoneIterator( orb ) do
> w:= NextIterator( orb ); k:= k+1;
> od;
gap> k;  # this is the size of the Weyl group of E6
51840
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Restricted Lie algebras">
<Heading>Restricted Lie algebras</Heading>

A Lie algebra <M>L</M> over a field of characteristic <M>p>0</M> is called
restricted if there is a map <M>x \mapsto x^p</M> from <M>L</M> into <M>L</M> 
(called a <M>p</M>-map) such that
ad <M>x^p = (</M>ad<M> x)^p</M>,
<M>(\alpha x)^p = \alpha^p x^p</M> and
<M>(x+y)^p = x^p + y^p + \sum_{{i=1}}^{{p-1}} s_i(x,y)</M>,
where <M>s_i: L \times L \rightarrow L</M> 
are certain Lie polynomials in two variables.
Using these relations we can calculate <M>y^p</M> for all <M>y \in L</M>,
once we know <M>x^p</M> for <M>x</M> in a basis of <M>L</M>.
Therefore a <M>p</M>-map is represented in &GAP;&nbsp; by a list 
containing the images of the basis vectors of a basis <M>B</M> of <M>L</M>.
For this reason this list is an attribute of the basis <M>B</M>. 
<P/>
<ManSection>
<Prop Name="IsRestrictedLieAlgebra" Arg='L'/>

<Description>
Test whether <A>L</A> is restricted.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "W", [2], GF(5));
<Lie algebra of dimension 25 over GF(5)>
gap> IsRestrictedLieAlgebra( L );
false
gap> L:= SimpleLieAlgebra( "W", [1], GF(5));
<Lie algebra of dimension 5 over GF(5)>
gap> IsRestrictedLieAlgebra( L );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PthPowerImages" Arg='B'/>

<Description>
Here <A>B</A> is a basis of a restricted Lie algebra.
This function returns the list of the images of the basis vectors of
<A>B</A> under the <M>p</M>-map.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "W", [1], GF(11) );
<Lie algebra of dimension 11 over GF(11)>
gap> B:= Basis( L );
CanonicalBasis( <Lie algebra of dimension 11 over GF(11)> )
gap> PthPowerImages( B );
[ 0*v.1, v.2, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 
  0*v.1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PthPowerImage" Arg='B, x' Label="for basis and element" />
<Oper Name="PthPowerImage" Arg='x'    Label="for element" />
<Oper Name="PthPowerImage" Arg='x, n' Label="for element and integer" />

<Description>
This function computes the image of an element <A>x</A> of a restricted 
Lie algebra under its <M>p</M>-map.
<P/>
In the first form, a basis of the Lie algebra is provided; this basis 
stores the <M>p</M>th powers of its elements. It is the traditional 
form, provided for backwards compatibility.
<P/> 
In its second form, only the element <A>x</A> is provided. It is the only
form for elements of Lie algebras with no predetermined basis, such as 
those constructed by <Ref Attr="LieObject"/>.
<P/> 
In its third form, an extra non-negative integer <A>n</A> is specified; 
the <M>p</M>-mapping is iterated <A>n</A> times on the element <A>x</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "W", [1], GF(11) );;
gap> B:= Basis( L );;
gap> x:= B[1]+B[11];
v.1+v.11
gap> PthPowerImage( B, x );
v.1+v.11
gap> PthPowerImage( x, 2 );
v.1+v.11
gap> f := FreeAssociativeAlgebra(GF(2),"x","y");
<algebra over GF(2), with 2 generators>
gap> x := LieObject(f.1);; y := LieObject(f.2);;
gap> x*y; x^2; PthPowerImage(x);
LieObject( (Z(2)^0)*x*y+(Z(2)^0)*y*x )
LieObject( <zero> of ... )
LieObject( (Z(2)^0)*x^2 )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="JenningsLieAlgebra" Arg='G'/>

<Description>
Let <A>G</A> be a nontrivial <M>p</M>-group,
and let <M><A>G</A> = G_1 \supset G_2 \supset \cdots \supset G_m = 1</M>
be its Jennings series (see&nbsp;<Ref Func="JenningsSeries"/>).
Then the quotients <M>G_i / G_{{i+1}}</M> are elementary abelian
<M>p</M>-groups,
i.e., they can be viewed as vector spaces over <C>GF</C><M>(p)</M>.
Now the Jennings-Lie algebra <M>L</M> of <A>G</A> is the direct sum
of those vector spaces.
The Lie bracket on <M>L</M> is induced by the commutator in <A>G</A>. 
Furthermore, the map <M>g \mapsto g^p</M> in <A>G</A> induces a
<M>p</M>-map in <M>L</M> making <M>L</M> into a restricted Lie algebra.
In the canonical basis of <M>L</M> this <M>p</M>-map is added as an
attribute.
A Lie algebra created by <Ref Attr="JenningsLieAlgebra"/> is naturally
graded. The attribute <Ref Attr="Grading"/> is set.
</Description>
</ManSection>

<ManSection>
<Attr Name="PCentralLieAlgebra" Arg='G'/>

<Description>
Here <A>G</A> is a nontrivial <M>p</M>-group.
<C>PCentralLieAlgebra( <A>G</A> )</C> does the same as 
<Ref Attr="JenningsLieAlgebra"/> except that the
<M>p</M>-central series is used instead of the Jennings series
(see&nbsp;<Ref Func="PCentralSeries"/>). This function also returns 
a graded Lie algebra. However, it is not necessarily restricted.
<Example><![CDATA[
gap> G:= SmallGroup( 3^6, 123 );
<pc group of size 729 with 6 generators>
gap> L:= JenningsLieAlgebra( G );
<Lie algebra of dimension 6 over GF(3)>
gap> HasPthPowerImages( Basis( L ) );
true
gap> PthPowerImages( Basis( L ) );
[ v.6, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
gap> g:= Grading( L );
rec( hom_components := function( d ) ... end, max_degree := 3, 
  min_degree := 1, source := Integers )
gap> List( [1,2,3], g.hom_components );
[ <vector space over GF(3), with 3 generators>, 
  <vector space over GF(3), with 2 generators>, 
  <vector space over GF(3), with 1 generators> ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NaturalHomomorphismOfLieAlgebraFromNilpotentGroup" Arg='L'/>

<Description>
This is an attribute of Lie algebras created by 
<Ref Attr="JenningsLieAlgebra"/> or <Ref Attr="PCentralLieAlgebra"/>. 
Then <A>L</A> is the direct sum of quotients of successive terms of the 
Jennings, or <M>p</M>-central series of a <M>p</M>-group G. Let <C>Gi</C> 
be the <M>i</M>-th term in this series, and let
<C>f = NaturalHomomorphismOfLieAlgebraFromNilpotentGroup( <A>L</A> )</C>,
then for <C>g</C> in <C>Gi</C>, <C>f( <A>g</A>, <A>i</A> )</C> returns the 
element of <A>L</A> (lying in the <M>i</M>-th homogeneous component) 
corresponding to <C>g</C>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Adjoint Representation">
<Heading>The Adjoint Representation</Heading>

In this section we show functions for calculating with the adjoint
representation of a Lie algebra (and the corresponding trace form,
called the Killing form) (see also <Ref Func="AdjointBasis"/> and 
<Ref Func="IndicesOfAdjointBasis"/>).
<P/>
<ManSection>
<Oper Name="AdjointMatrix" Arg='B, x'/>

<Description>
is the matrix of the adjoint representation of the element <A>x</A>
w.r.t. the basis <A>B</A>.
The adjoint map is the left multiplication by <A>x</A>.
The <M>i</M>-th column of the resulting matrix represents the image of
the <M>i</M>-th basis vector of <A>B</A> under left multiplication by
<A>x</A>. 
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> AdjointMatrix( Basis( L ), Basis( L )[1] );
[ [ 0, 0, -2 ], [ 0, 0, 0 ], [ 0, 1, 0 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AdjointAssociativeAlgebra" Arg='L, K'/>

<Description>
is the associative matrix algebra (with 1) generated by the matrices of
the adjoint representation of the subalgebra <A>K</A> on the Lie
algebra <A>L</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> AdjointAssociativeAlgebra( L, L );
<algebra of dimension 9 over Rationals>
gap> AdjointAssociativeAlgebra( L, CartanSubalgebra( L ) );
<algebra of dimension 3 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="KillingMatrix" Arg='B'/>

<Description>
is the matrix of the Killing form <M>\kappa</M> with respect to the basis
<A>B</A>, i.e., the matrix <M>( \kappa( b_i, b_j ) )</M>
where <M>b_1, b_2, \ldots</M> are the basis vectors of <A>B</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> KillingMatrix( Basis( L ) );
[ [ 0, 4, 0 ], [ 4, 0, 0 ], [ 0, 0, 8 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="KappaPerp" Arg='L, U'/>

<Description>
is the orthogonal complement of the subspace <A>U</A> of the Lie algebra
<A>L</A> with respect to the Killing form <M>\kappa</M>, that is,
the set <M>U^{{\perp}} = \{ x \in L; \kappa( x, y ) = 0 \hbox{ for all } 
y \in L \}</M>.
<P/>
<M>U^{{\perp}}</M> is a subspace of <A>L</A>, and if <A>U</A> is an ideal
of <A>L</A> then <M>U^{{\perp}}</M> is a subalgebra of <A>L</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> V:= VectorSpace( Rationals, [b[1],b[2]] );;
gap> KappaPerp( L, V );
<vector space of dimension 1 over Rationals>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IsNilpotentElement" Arg='L, x'/>

<Description>
<A>x</A> is nilpotent in <A>L</A> if its adjoint matrix is
a nilpotent matrix.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> IsNilpotentElement( L, Basis( L )[1] );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NonNilpotentElement" Arg='L'/>

<Description>
A non-nilpotent element of a Lie algebra <A>L</A> is an element <M>x</M>
such that ad<M>x</M> is not nilpotent.
If <A>L</A> is not nilpotent, then by Engel's theorem non-nilpotent
elements exist in <A>L</A>.
In this case this function returns a non-nilpotent element of <A>L</A>,
otherwise (if <A>L</A> is nilpotent) <K>fail</K> is returned.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> NonNilpotentElement( L );
v.13
gap> IsNilpotentElement( L, last );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="FindSl2" Arg='L, x'/>

<Description>
This function tries to find a subalgebra <M>S</M> of the Lie algebra 
<A>L</A> with <M>S</M> isomorphic to <M>sl_2</M> and such that the 
nilpotent element <A>x</A> of <A>L</A> is contained in <M>S</M>.
If such an algebra exists then it is returned,
otherwise <K>fail</K> is returned.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> IsNilpotentElement( L, b[1] );
true
gap> FindSl2( L, b[1] );
<Lie algebra of dimension 3 over Rationals>
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Universal Enveloping Algebras">
<Heading>Universal Enveloping Algebras</Heading>

<ManSection>
<Attr Name="UniversalEnvelopingAlgebra" Arg='L[, B]'/>

<Description>
Returns the universal enveloping algebra of the Lie algebra <A>L</A>.
The elements of this algebra are written on a Poincare-Birkhoff-Witt
basis.
<P/>
If a second argument <A>B</A> is given, it must be a basis of <A>L</A>,
and an isomorphic copy of the universal enveloping algebra
is returned, generated by the images (in the universal enveloping
algebra) of the elements of <A>B</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> UL:= UniversalEnvelopingAlgebra( L );
<algebra-with-one of dimension infinity over Rationals>
gap> g:= GeneratorsOfAlgebraWithOne( UL );
[ [(1)*x.1], [(1)*x.2], [(1)*x.3] ]
gap> g[3]^2*g[2]^2*g[1]^2;
[(-4)*x.1*x.2*x.3^3+(1)*x.1^2*x.2^2*x.3^2+(2)*x.3^3+(2)*x.3^4]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finitely Presented Lie Algebras">
<Heading>Finitely Presented Lie Algebras</Heading>

Finitely presented Lie algebras can be constructed from free Lie algebras by 
using the <C>/</C> constructor, i.e., <C>FL/[r1, ..., rk]</C> is the quotient 
of the free Lie algebra <C>FL</C> by the ideal generated by the elements
<C>r1, ..., rk</C> of <C>FL</C>. If the finitely presented Lie algebra 
<C>K</C> happens to be finite dimensional then an isomorphic structure 
constants Lie algebra can be constructed by <C>NiceAlgebraMonomorphism(K)</C>
(see&nbsp;<Ref Attr="NiceAlgebraMonomorphism"/>), which returns a surjective
homomorphism. The structure constants Lie algebra can then be accessed by 
calling <Ref Attr="Range" Label="of a general mapping"/> for this map. 
Also limited computations with elements of the finitely presented Lie 
algebra are possible.
<P/>
<Example><![CDATA[
gap> L:= FreeLieAlgebra( Rationals, "s", "t" );
<Lie algebra over Rationals, with 2 generators>
gap> gL:= GeneratorsOfAlgebra( L );; s:= gL[1];; t:= gL[2];;
gap> K:= L/[ s*(s*t), t*(t*(s*t)), s*(t*(s*t))-t*(s*t) ];
<Lie algebra over Rationals, with 2 generators>
gap> h:= NiceAlgebraMonomorphism( K );
[ [(1)*s], [(1)*t] ] -> [ v.1, v.2 ]
gap> U:= Range( h );
<Lie algebra of dimension 3 over Rationals>
gap> IsLieNilpotent( U );
true
gap> gK:= GeneratorsOfAlgebra( K );
[ [(1)*s], [(1)*t] ]
gap> gK[1]*(gK[2]*gK[1]) = Zero( K );
true
]]></Example>
<P/>
<ManSection>
<Func Name="FpLieAlgebraByCartanMatrix" Arg='C'/>

<Description>
Here <A>C</A> must be a Cartan matrix. The function returns the 
finitely-presented Lie algebra over the field of rational numbers 
defined by this Cartan matrix. By Serre's theorem, this Lie algebra is a 
semisimple Lie algebra, and its root system has Cartan matrix <A>C</A>.
<Example><![CDATA[
gap> C:= [ [ 2, -1 ], [ -3, 2 ] ];;
gap> K:= FpLieAlgebraByCartanMatrix( C );
<Lie algebra over Rationals, with 6 generators>
gap> h:= NiceAlgebraMonomorphism( K );
[ [(1)*x1], [(1)*x2], [(1)*x3], [(1)*x4], [(1)*x5], [(1)*x6] ] -> 
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> SemiSimpleType( Range( h ) );
"G2"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NilpotentQuotientOfFpLieAlgebra" Arg='FpL, max[, weights]'/>

<Description>

Here <A>FpL</A> is a finitely presented Lie algebra.
Let <M>K</M> be the quotient of <A>FpL</A> by the <A>max</A>+1-th term
of its lower central series.
This function calculates a surjective homomorphism from <A>FpL</A>
onto <M>K</M>.
When called with the third argument <A>weights</A>,
the <M>k</M>-th generator of <A>FpL</A> gets assigned the <M>k</M>-th
element of the list <A>weights</A>.
In that case a quotient is calculated of <A>FpL</A>
by the ideal generated by all elements of weight <A>max</A>+1.
If the list <A>weights</A> only consists of <M>1</M>'s
then the two calls are equivalent.
The default value of <A>weights</A> is a list (of length equal to the
number of generators of <A>FpL</A>) consisting of <M>1</M>'s.
<P/>
If the relators of <A>FpL</A> are homogeneous,
then the resulting  algebra is naturally graded. 
<Example><![CDATA[
gap> L:= FreeLieAlgebra( Rationals, "x", "y" );;
gap> g:= GeneratorsOfAlgebra(L);; x:= g[1]; y:= g[2];
(1)*x
(1)*y
gap> rr:=[ ((y*x)*x)*x-6*(y*x)*y, 
>          3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];
[ (-1)*(x*(x*(x*y)))+(6)*((x*y)*y), 
  (-3)*(x*(x*(x*(x*(x*y)))))+(20)*(x*(x*((x*y)*y)))+(
    -20)*((x*(x*y))*(x*y)) ]
gap> K:= L/rr;
<Lie algebra over Rationals, with 2 generators>
gap> h:=NilpotentQuotientOfFpLieAlgebra(K, 50, [1,2] );
[ [(1)*x], [(1)*y] ] -> [ v.1, v.2 ]
gap> L:= Range( h );
<Lie algebra of dimension 50 over Rationals>
gap> Grading( L );
rec( hom_components := function( d ) ... end, max_degree := 50, 
  min_degree := 1, source := Integers )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Modules over Lie Algebras and Their Cohomology">
<Heading>Modules over Lie Algebras and Their Cohomology</Heading>

Representations of Lie algebras are dealt with in the same way as 
representations of ordinary algebras
(see <Ref Sect="Representations of Algebras"/>).
In this section we mainly deal with modules over general Lie algebras
and their cohomology. The next section is devoted to modules over
semisimple Lie algebras.


An <M>s</M>-cochain of a module <M>V</M> over a Lie algebra <M>L</M>
is an <M>s</M>-linear map
<Display Mode="M">
c: L \times \cdots \times L \rightarrow V ,
</Display>
with <M>s</M> factors <M>L</M>,
that is skew-symmetric (meaning that if any of the arguments are
interchanged, <M>c</M> changes to <M>-c</M>).
<P/>
Let <M>(x_1, \ldots, x_n)</M> be a basis of <M>L</M>.
Then any <M>s</M>-cochain is 
determined by the values <M>c( x_{{i_1}}, \ldots, x_{{i_s}} )</M>,
where <M>1 \leq i_1 &lt; i_2 &lt; \cdots &lt; i_s \leq \dim L</M>.
Now this value again is a linear combination of basis elements of <M>V</M>:
<M>c( x_{{i_1}}, \ldots, x_{{i_s}} ) =
\sum \lambda^k_{{i_1,\ldots, i_s}} v_k</M>.
Denote the dimension of <M>V</M> by <M>r</M>.
Then we represent an <M>s</M>-cocycle by a list of <M>r</M> lists.
The <M>j</M>-th of those lists consists of entries of the form
<Display Mode="M">
[ [ i_1, i_2, \ldots, i_s ], \lambda^j_{{i_1, \ldots, i_s}} ]
</Display>
where the coefficient on the second position is non-zero.
(We only store those entries for which this coefficient is non-zero.)
It follows that every <M>s</M>-tuple <M>(i_1, \ldots, i_s)</M> gives rise
to <M>r</M>  basis elements.
<P/>
So the zero cochain is represented by a list of the form
<C>[ [ ], [ ], \ldots, [ ] ]</C>. Furthermore, if <M>V</M> is, e.g., 
<M>4</M>-dimensional, then the <M>2</M>-cochain represented by
<P/>
<Log><![CDATA[
[ [ [ [1,2], 2] ], [ ], [ [ [1,2], 1/2 ] ], [ ] ]
]]></Log>
<P/>
maps the pair <M>(x_1, x_2)</M> to <M>2v_1 + 1/2 v_3</M>
(where <M>v_1</M> is the first basis element of <M>V</M>,
and <M>v_3</M> the third), and all other pairs to zero.
<P/>
By definition, <M>0</M>-cochains are constant maps
<M>c( x ) = v_c \in V</M> for all <M>x \in L</M>.
So <M>0</M>-cochains have a different representation: they are just
represented by the list <C>[ v_c ]</C>.
<P/>
Cochains are constructed using the function <Ref Func="Cochain"/>,
if <A>c</A> is a cochain, then its corresponding list is returned by
<C>ExtRepOfObj( <A>c</A> )</C>.

<ManSection>
<Filt Name="IsCochain" Arg='obj' Type='Category'/>
<Filt Name="IsCochainCollection" Arg='obj' Type='Category'/>

<Description>
Categories of cochains and of collections of cochains.
</Description>
</ManSection>

<ManSection>
<Oper Name="Cochain" Arg='V, s, obj'/>

<Description>
Constructs a <A>s</A>-cochain given by the data in <A>obj</A>, with 
respect to the Lie algebra module <A>V</A>. If <A>s</A> is non-zero, 
then <A>obj</A> must be a list.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );
<3-dimensional left-module over <Lie algebra of dimension 
3 over Rationals>>
gap> c1:= Cochain( V, 2, 
>               [ [ [ [ 1, 3 ], -1 ] ], [ ], [ [ [ 2, 3 ], 1/2 ] ] ]);
<2-cochain>
gap> ExtRepOfObj( c1 );
[ [ [ [ 1, 3 ], -1 ] ], [  ], [ [ [ 2, 3 ], 1/2 ] ] ]
gap> c2:= Cochain( V, 0, Basis( V )[1] );
<0-cochain>
gap> ExtRepOfObj( c2 );
v.1
gap> IsCochain( c2 );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CochainSpace" Arg='V, s'/>

<Description>
Returns the space of all <A>s</A>-cochains with respect to <A>V</A>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:=CochainSpace( V, 2 );
<vector space of dimension 9 over Rationals>
gap> BasisVectors( Basis( C ) );
[ <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain>, 
  <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain> ]
gap> ExtRepOfObj( last[1] );
[ [ [ [ 1, 2 ], 1 ] ], [  ], [  ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ValueCochain" Arg='c, y1, y2,...,ys'/>

<Description>
Here <A>c</A> is an <C>s</C>-cochain. This function returns the value of
<A>c</A> when applied to the <C>s</C> elements <A>y1</A> to <A>ys</A> 
(that lie in the Lie algebra acting on the module corresponding to 
<A>c</A>). It is also possible to call this function with two arguments: 
first <A>c</A> and then the list containing <C><A>y1</A>,...,<A>ys</A></C>.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:= CochainSpace( V, 2 );;
gap> c:= Basis( C )[1];
<2-cochain>
gap>  ValueCochain( c, Basis(L)[2], Basis(L)[1] );
(-1)*v.1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LieCoboundaryOperator" Arg='c'/>

<Description>
This is a function that takes an <C>s</C>-cochain <A>c</A>, 
and returns an <C>s+1</C>-cochain. The coboundary operator is applied.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:= CochainSpace( V, 2 );;
gap> c:= Basis( C )[1];;
gap> c1:= LieCoboundaryOperator( c );
<3-cochain>
gap> c2:= LieCoboundaryOperator( c1 );
<4-cochain>
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Cocycles" Arg='V, s' Label="for Lie algebra module"/>

<Description>
is the space of all <A>s</A>-cocycles with respect to the Lie algebra 
module <A>V</A>. That is the kernel of the coboundary operator when 
restricted to the space of <A>s</A>-cochains.
</Description>
</ManSection>

<ManSection>
<Oper Name="Coboundaries" Arg='V, s'/>

<Description>
is the space of all <A>s</A>-coboundaries with respect to the Lie algebra
module <A>V</A>. That is the image of the coboundary operator, when applied
to the space of <A>s</A>-1-cochains. By definition the space of all
0-coboundaries is zero.
<Example><![CDATA[
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 3 ] );
gap> L:= LieAlgebraByStructureConstants( Rationals, T );;
gap> V:= FaithfulModule( L );
<left-module over <Lie algebra of dimension 3 over Rationals>>
gap> Cocycles( V, 2 );
<vector space of dimension 7 over Rationals>
gap> Coboundaries( V, 2 );
<vector space over Rationals, with 9 generators>
gap> Dimension( last );
5
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Modules over Semisimple Lie Algebras">
<Heading>Modules over Semisimple Lie Algebras</Heading>

This section contains functions for calculating information on
representations of semisimple Lie algebras. First we have some functions
for calculating some combinatorial data (set of dominant weights, 
the dominant character, the decomposition of a tensor product, the dimension
of a highest-weight module). Then 
there is a function for creating an admissible lattice in the universal
enveloping algebra of a semisimple Lie algebra. Finally we have a function
for constructing a highest-weight module over a semisimple Lie algebra.
<P/>
<ManSection>
<Oper Name="DominantWeights" Arg='R, maxw'/>

<Description>
Returns a list consisting of two lists. The first of these contains
the dominant weights (written on the basis of fundamental weights)
of the irreducible highest-weight module, with highest weight <A>maxw</A>, 
over the Lie algebra with the root system <A>R</A>.
The <M>i</M>-th element of the second list is the level of the
<M>i</M>-th dominant weight.
(Where the level is defined as follows.
For a weight <M>\mu</M> we write
<M>\mu = \lambda - \sum_i k_i \alpha_i</M>, where
the <M>\alpha_i</M> are the simple roots,
and <M>\lambda</M> the highest weight.
Then the level of <M>\mu</M> is <M>\sum_i k_i</M>.)
</Description>
</ManSection>

<ManSection>
<Oper Name="DominantCharacter" Arg='L, maxw'
 Label="for a semisimple Lie algebra and a highest weight"/>
<Oper Name="DominantCharacter" Arg='R, maxw'
 Label="for a root system and a highest weight"/>

<Description>
For a highest weight <A>maxw</A> and a semisimple Lie algebra <A>L</A>,
this returns the dominant weights of the highest-weight module over
<A>L</A>, with highest weight <A>maxw</A>.
The output is a list of two lists,
the first list contains the dominant weights;
the second list contains their multiplicities.
<P/>
The first argument can also be a root system, in which case 
the dominant character of the highest-weight module over the
corresponding semisimple Lie algebra is returned. 
</Description>
</ManSection>

<ManSection>
<Oper Name="DecomposeTensorProduct" Arg='L, w1, w2'/>

<Description>
Here <A>L</A> is a semisimple Lie algebra and <A>w1</A>, <A>w2</A> are
dominant weights.
Let <M>V_i</M> be the irreducible highest-weight module over <A>L</A>
with highest weight <M>w_i</M> for <M>i = 1, 2</M>.
Let <M>W = V_1 \otimes V_2</M>.
Then in general <M>W</M> is a reducible <A>L</A>-module. Now this function
returns a list of two lists. The first of these is the list of highest
weights of the irreducible modules occurring in the decomposition of
<M>W</M> as a direct sum of irreducible modules. The second list contains
the multiplicities of these weights (i.e., the number of copies of
the irreducible module with the corresponding highest weight that occur
in <M>W</M>). The algorithm uses Klimyk's formula 
(see&nbsp;<Cite Key="Klimyk68"/> or <Cite Key="Klimyk66"/> 
for the original Russian version).
</Description>
</ManSection>

<ManSection>
<Oper Name="DimensionOfHighestWeightModule" Arg='L, w'/>

<Description>
Here <A>L</A> is a semisimple Lie algebra, and <A>w</A> a dominant weight.
This function returns the dimension of the highest-weight module
over <A>L</A> with highest weight <A>w</A>. The algorithm
uses Weyl's dimension formula.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> R:= RootSystem( L );;
gap> DominantWeights( R, [ 1, 1, 0, 0 ] );
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 0, 3, 4, 8, 11, 19 ] ]
gap> DominantCharacter( L, [ 1, 1, 0, 0 ] );
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 1, 1, 4, 6, 14, 21 ] ]
gap> DecomposeTensorProduct( L, [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ] );
[ [ [ 1, 0, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 1, 0, 0 ], 
      [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ] ], 
  [ 1, 1, 1, 1, 1, 1, 1 ] ]
gap> DimensionOfHighestWeightModule( L, [ 1, 2, 3, 4 ] );
79316832731136
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Admissible Lattices in UEA">
<Heading>Admissible Lattices in UEA</Heading>

Let <M>L</M> be a semisimple Lie algebra over a field of characteristic
<M>0</M>, and let <M>R</M> be its root system.
For a positive root <M>\alpha</M> we let <M>x_{\alpha}</M> and
<M>y_{\alpha}</M> be positive and negative root vectors,
respectively, both from a fixed Chevalley basis of <M>L</M>. Furthermore,
<M>h_1, \ldots, h_l</M> are the Cartan elements from the same Chevalley
basis. Also we set
<Display Mode="M">
x_{\alpha}^{(n)} = {{x_{\alpha}^n \over n!}},
y_{\alpha}^{(n)} = {{y_{\alpha}^n \over n!}} .
</Display>
Furthermore, let <M>\alpha_1, \ldots, \alpha_s</M> denote the positive
roots of <M>R</M>.
For multi-indices <M>N = (n_1, \ldots, n_s)</M>,
<M>M = (m_1, \ldots, m_s)</M>
and <M>K = (k_1, \ldots, k_s)</M> (where <M>n_i, m_i, k_i \geq 0</M>) set
<Table Align="lcl">
<Row>
  <Item><M>x^N</M></Item>
  <Item>=</Item>
  <Item><M>x_{{\alpha_1}}^{(n_1)} \cdots x_{{\alpha_s}}^{(n_s)}</M>,</Item>
</Row>
<Row>
  <Item><M>y^M</M></Item>
  <Item>=</Item>
  <Item><M>y_{{\alpha_1}}^{(m_1)} \cdots y_{{\alpha_s}}^{(m_s)}</M>,</Item>
</Row>
<Row>
  <Item><M>h^K</M></Item>
  <Item>=</Item>
  <Item><M>{{h_1 \choose k_1}} \cdots {{h_l \choose k_l}}</M></Item>
</Row>
</Table>
Then by a theorem of Kostant, the <M>x_{\alpha}^{(n)}</M> and
<M>y_{\alpha}^{(n)}</M> generate a subring of the universal enveloping algebra
<M>U(L)</M> spanned (as a free <M>Z</M>-module) by the elements
<Display Mode="M">
y^M h^K x^N
</Display>
(see, e.g., <Cite Key="Hum72"/> or <Cite Key="Hum78" Where="Section 26"/>)
So by the Poincare-Birkhoff-Witt theorem
this subring is a lattice in <M>U(L)</M>. Furthermore, this lattice is
invariant under the <M>x_{\alpha}^{(n)}</M> and <M>y_{\alpha}^{(n)}</M>.
Therefore, it is called an admissible lattice in <M>U(L)</M>.
<P/>
The next functions enable us to construct the generators of such an
admissible lattice.

<ManSection>
<Filt Name="IsUEALatticeElement" Arg='obj' Type='Category'/>
<Filt Name="IsUEALatticeElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsUEALatticeElementFamily" Arg='fam' Type='Category'/>

<Description>
is the category of elements of an admissible lattice in the universal
enveloping algebra of a semisimple Lie algebra <C>L</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="LatticeGeneratorsInUEA" Arg='L'/>

<Description>
Here <A>L</A> must be a semisimple Lie algebra of characteristic <M>0</M>.
This function returns a list of generators of an admissible lattice
in the universal enveloping algebra of <A>L</A>, relative to the 
Chevalley basis contained in <C>ChevalleyBasis( <A>L</A> )</C>
(see&nbsp;<Ref Attr="ChevalleyBasis"/>). First are listed the negative 
root vectors (denoted by <M>y_1, \ldots, y_s</M>),
then the positive root vectors (denoted by <M>x_1, \ldots, x_s</M>).
At the end of the list there are the Cartan elements. They are printed as
<C>( hi/1 )</C>, which means
<Display Mode="M">
{{h_i \choose 1}}.
</Display>
In general the printed form <C>( hi/ k )</C> means 
<Display Mode="M">
{{h_i \choose k}}.
</Display>
<P/>
Also <M>y_i^{(m)}</M> is printed as <C>yi^(m)</C>, which means that entering
<C>yi^m</C> at the &GAP; prompt results in the output <C>m!*yi^(m)</C>.
<P/>
Products of lattice generators are collected using the following order:
first come the <M>y_i^{(m_i)}</M>
(in the same order as the positive roots),
then the <M>{h_i \choose k_i}</M>,
and then the <M>x_i^{(n_i)}</M>
(in the same order as the positive roots).
</Description>
</ManSection>


<ManSection>
<Func Name="ObjByExtRep" Arg="F, descr"
 Label="for creating a UEALattice element"/>

<Description>
An UEALattice element is represented by a list of the form
<C>[ m1, c1, m2, c2, ... ]</C>, where the <C>c1</C>, <C>c2</C> etc. are 
coefficients, and the <C>m1</C>, <C>m2</C> etc. are monomials. A monomial 
is a list of the form <C>[ ind1, e1, ind2, e2, ... ]</C> where <C>ind1</C>, 
<C>ind2</C> are indices, and <C>e1</C>, <C>e2</C> etc. are exponents. Let
<M>N</M> be the number of positive roots of the underlying Lie algebra 
<C>L</C>. The indices lie between 1 and <M>dim(L)</M>. If an index lies 
between 1 and <C>N</C>, then it represents a negative root vector 
(corresponding to the root <C>NegativeRoots( R )[ind]</C>, where <C>R</C> 
is the root system of <C>L</C>; see&nbsp;<Ref Attr="NegativeRoots"/>). This 
leads to a factor <C>yind1^(e1)</C> in the printed form of the monomial 
(which equals <C>z^e1/e1!</C>, where <C>z</C> is a basis element of <C>L</C>). 
If an index lies between <M>N+1</M> and <M>2N</M>, then it represents a 
positive root vector. Finally, if ind lies between <M>2N+1</M> and 
<M>2N+rank</M>, then it represents an element of the Cartan subalgebra.
This is printed as <M>( h_1/ e_1 )</M>, meaning <M>{h_1 \choose e_1}</M>,
where <M>h_1, \ldots, h_{rank}</M> are the canonical Cartan generators.
<P/>
The zero element is represented by the empty list, the identity
element by the list <C>[ [], 1 ]</C>.
<P/>
<Example><![CDATA[
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> g:=LatticeGeneratorsInUEA( L );
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), 
  ( h14/1 ) ]
gap> IsUEALatticeElement( g[1] );
true
gap> g[1]^3;
6*y1^(3)
gap> q:= g[7]*g[1]^2;
-2*y1+2*y1*( h13/1 )+2*y1^(2)*x1
gap> ExtRepOfObj( q );
[ [ 1, 1 ], -2, [ 1, 1, 13, 1 ], 2, [ 1, 2, 7, 1 ], 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsWeightRepElement" Arg='obj' Type='Category'/>
<Filt Name="IsWeightRepElementCollection" Arg='obj' Type='Category'/>
<Filt Name="IsWeightRepElementFamily" Arg='fam' Type='Category'/>

<Description>
Is a category of vectors, that is used to construct elements of
highest-weight modules (by <Ref Oper="HighestWeightModule"/>).
<P/>
<C>WeightRepElement</C>s are represented by a list of the form
<C>[ v1, c1, v2, c2, ....]</C>, where the <C>vi</C> are basis vectors, 
and the <C>ci</C> are coefficients. Furthermore a basis vector <C>v</C> 
is a weight vector. It is represented by a list of the form 
<C>[ k, mon, wt ]</C>, where <C>k</C> is an integer (the basis vectors
are numbered from <M>1</M> to <M>\dim V</M>, where <M>V</M> is the highest 
weight module), <C>mon</C> is an <C>UEALatticeElement</C> (which means 
that the result of applying <C>mon</C> to a highest weight vector is <C>v</C>; 
see&nbsp;<Ref Filt="IsUEALatticeElement"/>) and <C>wt</C> is the weight
of <C>v</C>. A <C>WeightRepElement</C> is printed as <C>mon*v0</C>, 
where <C>v0</C> denotes a fixed highest weight vector.
<P/>
If <C>v</C> is a <C>WeightRepElement</C>, then <C>ExtRepOfObj( v )</C> 
returns the corresponding list, and if <C>list</C> is such a list and 
<A>fam</A> a <C>WeightRepElementFamily</C>, then 
<C>ObjByExtRep( <A>list</A>, <A>fam</A> )</C> returns the corresponding 
<C>WeightRepElement</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="HighestWeightModule" Arg='L, wt'/>

<Description>
returns the highest weight module with highest weight <A>wt</A> of the
semisimple Lie algebra <A>L</A> of characteristic <M>0</M>.
<P/>
Note that the elements of such a module lie in the category
<Ref Filt="IsLeftAlgebraModuleElement"/> (and in particular they do not 
lie in the category <Ref Filt="IsWeightRepElement"/>). However, if 
<C>v</C> is an element of such a module, then <C>ExtRepOfObj( v )</C> 
is a <C>WeightRepElement</C>.
<P/>
Note that for the following examples of this chapter we increase the line
length limit from its default value 80 to 81 in order to make some long
output expressions fit into the lines.
<P/>
<Example><![CDATA[
gap> K1:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> K2:= SimpleLieAlgebra( "B", 2, Rationals );;
gap> L:= DirectSumOfAlgebras( K1, K2 );
<Lie algebra of dimension 24 over Rationals>
gap> V:= HighestWeightModule( L, [ 0, 1, 1, 1 ] );
<224-dimensional left-module over <Lie algebra of dimension 
24 over Rationals>>
gap> vv:= GeneratorsOfLeftModule( V );;
gap> vv[100];
y5*y7*y10*v0
gap> e:= ExtRepOfObj( vv[100] );
y5*y7*y10*v0
gap> ExtRepOfObj( e );
[ [ 100, y5*y7*y10, [ -3, 2, -1, 1 ] ], 1 ]
gap> Basis(L)[17]^vv[100];
-1*y5*y7*y8*v0-1*y5*y9*v0
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Tensor Products and Exterior and Symmetric Powers">
<Heading>Tensor Products and Exterior and Symmetric Powers</Heading>

<ManSection>
<Oper Name="TensorProductOfAlgebraModules" Arg='list'
 Label="for a list of algebra modules"/>
<Oper Name="TensorProductOfAlgebraModules" Arg='V, W'
 Label="for two algebra modules"/>

<Description>
Here the elements of <A>list</A> must be algebra modules. 
The tensor product is returned as an algebra module. 
The two-argument version works in the same way and 
returns the tensor product of its arguments.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= TensorProductOfAlgebraModules( [ V, V, V ] );
<343-dimensional left-module over <Lie algebra of dimension 
14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0<x>1*v0<x>1*v0)
gap> Basis(L)[1]^w;
<0-tensor>
gap> Basis(L)[7]^w;
1*(1*v0<x>1*v0<x>y1*v0)+1*(1*v0<x>y1*v0<x>1*v0)+1*(y
1*v0<x>1*v0<x>1*v0)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ExteriorPowerOfAlgebraModule" Arg='V, k'/>

<Description>
Here <A>V</A> must be an algebra module, defined over a Lie algebra. 
This function returns the <A>k</A>-th exterior power of <A>V</A> as an 
algebra module.
<Example><![CDATA[
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= ExteriorPowerOfAlgebraModule( V, 3 );
<35-dimensional left-module over <Lie algebra of dimension 
14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0/\y1*v0/\y3*v0)
gap> Basis(L)[10]^w;
1*(1*v0/\y1*v0/\y6*v0)+1*(1*v0/\y3*v0/\y5*v0)+1*(y1*v0/\y3*v0/\y4*v0)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SymmetricPowerOfAlgebraModule" Arg='V, k'/>

<Description>
Here <A>V</A> must be an algebra module. This function returns the 
<A>k</A>-th symmetric power of <A>V</A> (as an algebra module).
<Example><![CDATA[
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= SymmetricPowerOfAlgebraModule( V, 3 );
<84-dimensional left-module over <Lie algebra of dimension 
14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0.1*v0.1*v0)
gap> Basis(L)[2]^w;
<0-symmetric element>
gap> Basis(L)[7]^w;
3*(1*v0.1*v0.y1*v0)
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  mgmring.msk                  GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: mgmring.msk,v 1.6 2002/04/15 10:02:30 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->

<Chapter Label="Magma Rings">
<Heading>Magma Rings</Heading>

<Index>group algebra</Index>
<Index>group ring</Index>
Given a magma <M>M</M> then the <E>free magma ring</E>
(or <E>magma ring</E> for short) <M>RM</M> of <M>M</M>
over a ring-with-one <M>R</M> is the set of finite sums
<M>\sum_{{i \in I}} r_i m_i</M> with <M>r_i \in R</M>,
and <M>m_i \in M</M>.
With the obvious addition and <M>R</M>-action from the left,
<M>RM</M> is a free <M>R</M>-module with <M>R</M>-basis <M>M</M>,
and with the usual convolution product, <M>RM</M> is a ring.
<P/>
Typical examples of free magma rings are
<P/>
<List>
<Item>
    (multivariate) polynomial rings
    (see&nbsp;<Ref Chap="Polynomial Rings and Function Fields"/>),
    where the magma is a free abelian monoid generated by the
    indeterminates,
</Item>
<Item>
    group rings (see&nbsp;<Ref Func="IsGroupRing"/>),
    where the magma is a group,
</Item>
<Item>
    Laurent polynomial rings, which are group rings of the free abelian
    <!-- #T (see~???) -->
    groups generated by the indeterminates,
</Item>
<Item>
    free algebras and free associative algebras, with or without one,
    where the magma is a free magma or a free semigroup,
    or a free magma-with-one or a free monoid, respectively.
</Item>
</List>
Note that formally, polynomial rings in &GAP; are not constructed 
as free magma rings.
<P/>
Furthermore, a free Lie algebra is <E>not</E> a magma ring,
because of the additional relations given by the Jacobi identity;
see&nbsp;<Ref Sect="Magma Rings modulo Relations"/> for a generalization
of magma rings that covers such structures.
<P/>
The coefficient ring <M>R</M> and the magma <M>M</M> cannot be regarded
as subsets of <M>RM</M>,
hence the natural <E>embeddings</E> of <M>R</M> and <M>M</M> into
<M>RM</M> must be handled via explicit embedding maps
(see&nbsp;<Ref Sect="Natural Embeddings related to Magma Rings"/>).
Note that in a magma ring, the addition of elements is in general
different from an addition that may be defined already for the elements
of the magma;
for example, the addition in the group ring of a matrix group does in
general <E>not</E> coincide with the addition of matrices.
<P/>
<Example><![CDATA[
gap> a:= Algebra( GF(2), [ [ [ Z(2) ] ] ] );;  Size( a );
2
gap> rm:= FreeMagmaRing( GF(2), a );;
gap> emb:= Embedding( a, rm );;
gap> z:= Zero( a );;  o:= One( a );;
gap> imz:= z ^ emb;  IsZero( imz );
(Z(2)^0)*[ [ 0*Z(2) ] ]
false
gap> im1:= ( z + o ) ^ emb;
(Z(2)^0)*[ [ Z(2)^0 ] ]
gap> im2:= z ^ emb + o ^ emb;
(Z(2)^0)*[ [ 0*Z(2) ] ]+(Z(2)^0)*[ [ Z(2)^0 ] ]
gap> im1 = im2;
false
]]></Example>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Free Magma Rings">
<Heading>Free Magma Rings</Heading>

<ManSection>
<Func Name="FreeMagmaRing" Arg='R, M'/>

<Description>
is a free magma ring over the ring <A>R</A>, free on the magma <A>M</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="GroupRing" Arg='R, G'/>

<Description>
is the group ring of the group <A>G</A>, over the ring <A>R</A>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFreeMagmaRing" Arg='D' Type='Category'/>

<Description>
A domain lies in the category <Ref Func="IsFreeMagmaRing"/>
if it has been constructed as a free magma ring.
In particular, if <A>D</A> lies in this category then the operations
<Ref Func="LeftActingDomain"/> and
<Ref Func="UnderlyingMagma"/> are applicable to <A>D</A>,
and yield the ring <M>R</M> and the magma <M>M</M>
such that <A>D</A> is the magma ring <M>RM</M>.
<P/>
So being a magma ring in &GAP; includes the knowledge of the ring and
the magma.
Note that a magma ring <M>RM</M> may abstractly be generated as a
magma ring by a magma different from the underlying magma <M>M</M>.
For example, the group ring of the dihedral group of order <M>8</M>
over the field with <M>3</M> elements is also spanned by a quaternion
group of order <M>8</M> over the same field.
<P/>
<Example><![CDATA[
gap> d8:= DihedralGroup( 8 );
<pc group of size 8 with 3 generators>
gap> rm:= FreeMagmaRing( GF(3), d8 );
<algebra-with-one over GF(3), with 3 generators>
gap> emb:= Embedding( d8, rm );;
gap> gens:= List( GeneratorsOfGroup( d8 ), x -> x^emb );;
gap> x1:= gens[1] + gens[2];;
gap> x2:= ( gens[1] - gens[2] ) * gens[3];;
gap> x3:= gens[1] * gens[2] * ( One( rm ) - gens[3] );;
gap> g1:= x1 - x2 + x3;;
gap> g2:= x1 + x2;;
gap> q8:= Group( g1, g2 );;
gap> Size( q8 );
8
gap> ForAny( [ d8, q8 ], IsAbelian );
false
gap> List( [ d8, q8 ], g -> Number( AsList( g ), x -> Order( x ) = 2 ) );
[ 5, 1 ]
gap> Dimension( Subspace( rm, q8 ) );
8
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFreeMagmaRingWithOne" Arg='obj' Type='Category'/>

<Description>
<Ref Filt="IsFreeMagmaRingWithOne"/> is just a synonym for the meet of
<Ref Filt="IsFreeMagmaRing"/> and
<Ref Filt="IsMagmaWithOne"/>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsGroupRing" Arg='obj'/>

<Description>
A <E>group ring</E> is a magma ring where the underlying magma is a group.
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingMagma" Arg='RM'/>

<Description>
stores the underlying magma of a free magma ring.
</Description>
</ManSection>

<ManSection>
<Attr Name="AugmentationIdeal" Arg='RG'/>

<Description>
is the augmentation ideal of the group ring <A>RG</A>,
i.e., the kernel of the trivial representation of <A>RG</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elements of Free Magma Rings">
<Heading>Elements of Free Magma Rings</Heading>

In order to treat elements of free magma rings uniformly,
also without an external representation, the attributes
<Ref Attr="CoefficientsAndMagmaElements"/>
and <Ref Attr="ZeroCoefficient"/>
were introduced that allow one to <Q>take an element of an arbitrary
magma ring into pieces</Q>.
<P/>
Conversely, for constructing magma ring elements from coefficients
and magma elements, <Ref Func="ElementOfMagmaRing"/> can be used.
(Of course one can also embed each magma element into the magma ring,
see&nbsp;<Ref Sect="Natural Embeddings related to Magma Rings"/>,
and then form the linear combination,
but many unnecessary intermediate elements are created this way.)

<ManSection>
<Filt Name="IsMagmaRingObjDefaultRep" Arg='obj' Type='Representation'/>

<Description>
The default representation of a magma ring element is a list of length 2,
at first position the zero coefficient, at second position a list with
the coefficients at the even positions, and the magma elements at the
odd positions, with the ordering as defined for the magma elements.
<P/>
It is assumed that arithmetic operations on magma rings produce only
normalized elements.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsElementOfFreeMagmaRing" Arg='obj' Type='Category'/>
<Filt Name="IsElementOfFreeMagmaRingCollection" Arg='obj'
 Type='Category'/>

<Description>
The category of elements of a free magma ring
(See <Ref Func="IsFreeMagmaRing"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsElementOfFreeMagmaRingFamily" Arg='Fam' Type='Category'/>

<Description>
Elements of families in this category have trivial normalisation, i.e.,
efficient methods for <C>\=</C> and <C>\&lt;</C>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CoefficientsAndMagmaElements" Arg='elm'/>

<Description>
is a list that contains at the odd positions the magma elements,
and at the even positions their coefficients in the element <A>elm</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ZeroCoefficient" Arg='elm'/>

<Description>
For an element <A>elm</A> of a magma ring (modulo relations) <M>RM</M>,
<Ref Attr="ZeroCoefficient"/> returns the zero element
of the coefficient ring <M>R</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ElementOfMagmaRing" Arg='Fam, zerocoeff, coeffs, mgmelms'/>

<Description>
<Ref Func="ElementOfMagmaRing"/> returns the element
<M>\sum_{{i = 1}}^n c_i m_i'</M>,
where <M><A>coeffs</A> = [ c_1, c_2, \ldots, c_n ]</M> is a list of
coefficients, <M><A>mgmelms</A> = [ m_1, m_2, \ldots, m_n ]</M> is a list
of magma elements,
and <M>m_i'</M> is the image of <M>m_i</M> under an embedding
of a magma containing <M>m_i</M> into a magma ring
whose elements lie in the family <A>Fam</A>.
<A>zerocoeff</A> must be the zero of the coefficient ring
containing the <M>c_i</M>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Natural Embeddings related to Magma Rings">
<Heading>Natural Embeddings related to Magma Rings</Heading>

<Index Key="Embedding" Subkey="for magma rings"><C>Embedding</C></Index>
Neither the coefficient ring <M>R</M> nor the magma <M>M</M>
are regarded as subsets of the magma ring <M>RM</M>,
so one has to use <E>embeddings</E>
(see&nbsp;<Ref Func="Embedding" Label="for two domains"/>)
explicitly whenever one needs for example the magma ring element
corresponding to a given magma element.
<P/>
<Example><![CDATA[
gap> f:= Rationals;;  g:= SymmetricGroup( 3 );;
gap> fg:= FreeMagmaRing( f, g );
<algebra-with-one over Rationals, with 2 generators>
gap> Dimension( fg );
6
gap> gens:= GeneratorsOfAlgebraWithOne( fg );
[ (1)*(1,2,3), (1)*(1,2) ]
gap> ( 3*gens[1] - 2*gens[2] ) * ( gens[1] + gens[2] );
(-2)*()+(3)*(2,3)+(3)*(1,3,2)+(-2)*(1,3)
gap> One( fg );
(1)*()
gap> emb:= Embedding( g, fg );;
gap> elm:= (1,2,3)^emb;  elm in fg;
(1)*(1,2,3)
true
gap> new:= elm + One( fg );
(1)*()+(1)*(1,2,3)
gap> new^2;
(1)*()+(2)*(1,2,3)+(1)*(1,3,2)
gap> emb2:= Embedding( f, fg );;
gap> elm:= One( f )^emb2;  elm in fg;
(1)*()
true
]]></Example>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Magma Rings modulo Relations">
<Heading>Magma Rings modulo Relations</Heading>

A more general construction than that of free magma rings allows one
to create rings that are not free <M>R</M>-modules on a given magma
<M>M</M> but arise from the magma ring <M>RM</M> by factoring out certain
identities.
Examples for such structures are finitely presented (associative)
algebras and free Lie algebras
(see&nbsp;<Ref Func="FreeLieAlgebra" Label="for ring, rank (and name)"/>).
<!-- #T see ... ? -->
<P/>
In &GAP;, the use of magma rings modulo relations is limited to
situations where a normal form of the elements is known and where
one wants to guarantee that all elements actually constructed are
in normal form.
(In particular, the computation of the normal form must be cheap.)
This is because the methods for comparing elements in magma rings
modulo relations via <C>\=</C> and <C>\&lt;</C>
just compare the involved coefficients and magma elements,
and also the vector space functions regard those monomials as
linearly independent over the coefficients ring that actually occur
in the representation of an element of a magma ring modulo relations.
<P/>
Thus only very special finitely presented algebras will be represented
as magma rings modulo relations,
in general finitely presented algebras are dealt with via the
mechanism described in
Chapter&nbsp;<Ref Chap="Finitely Presented Algebras"/>.

<ManSection>
<Filt Name="IsElementOfMagmaRingModuloRelations" Arg='obj'
 Type='Category'/>
<Filt Name="IsElementOfMagmaRingModuloRelationsCollection" Arg='obj'
 Type='Category'/>

<Description>
This category is used, e.&nbsp;g., for elements of free Lie algebras.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsElementOfMagmaRingModuloRelationsFamily" Arg='Fam'
 Type='Category'/>

<Description>
The family category for the category 
<Ref Filt="IsElementOfMagmaRingModuloRelations" />.
</Description>
</ManSection>

<ManSection>
<Oper Name="NormalizedElementOfMagmaRingModuloRelations" Arg='F, descr'/>

<Description>
Let <A>F</A> be a family of magma ring elements modulo relations,
and <A>descr</A> the description of an element in a magma ring modulo
relations.
<Ref Func="NormalizedElementOfMagmaRingModuloRelations"/> returns
a description of the same element,
but normalized w.r.t.&nbsp;the relations.
So two elements are equal if and only if the result of
<Ref Func="NormalizedElementOfMagmaRingModuloRelations"/> is equal for
their internal data, that is,
<Ref Func="CoefficientsAndMagmaElements"/> will return the same
for the corresponding two elements.
<P/>
<Ref Func="NormalizedElementOfMagmaRingModuloRelations"/> is allowed
to return <A>descr</A> itself, it need not make a copy.
This is the case for example in the case of free magma rings.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMagmaRingModuloRelations" Arg='obj' Type='Category'/>

<Description>
A &GAP; object lies in the category
<Ref Func="IsMagmaRingModuloRelations"/>
if it has been constructed as a magma ring modulo relations.
Each element of such a ring has a unique normal form,
so <Ref Func="CoefficientsAndMagmaElements"/> is well-defined for it.
<P/>
This category is not inherited to factor structures,
which are in general best described as finitely presented algebras,
see Chapter&nbsp;<Ref Chap="Finitely Presented Algebras"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Magma Rings modulo the Span of a Zero Element">
<Heading>Magma Rings modulo the Span of a Zero Element</Heading>

<ManSection>
<Filt Name="IsElementOfMagmaRingModuloSpanOfZeroFamily" Arg='Fam'
 Type='Category'/>

<Description>
We need this for the normalization method, which takes a family as first
argument.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsMagmaRingModuloSpanOfZero" Arg='RM' Type='Category'/>

<Description>
The category of magma rings modulo the span of a zero element.
</Description>
</ManSection>

<ManSection>
<Func Name="MagmaRingModuloSpanOfZero" Arg='R, M, z'/>

<Description>
Let <A>R</A> be a ring, <A>M</A> a magma, and <A>z</A> an element of
<A>M</A> with the property that <M><A>z</A> * m = <A>z</A></M> holds
for all <M>m \in M</M>.
The element <A>z</A> could be called a <Q>zero element</Q> of <A>M</A>,
but note that in general <A>z</A> cannot be obtained as
<C>Zero( </C><M>m</M><C> )</C> for each <M>m \in M</M>,
so this situation does not match the definition of <Ref Func="Zero"/>.
<P/>
<Ref Func="MagmaRingModuloSpanOfZero"/> returns the magma ring
<M><A>R</A><A>M</A></M> modulo the relation given by the identification
of <A>z</A> with zero.
This is an example of a magma ring modulo relations,
see&nbsp;<Ref Sect="Magma Rings modulo Relations"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Technical Details about the Implementation of Magma Rings">
<Heading>Technical Details about the Implementation of Magma Rings</Heading>

The <E>family</E> containing elements in the magma ring <M>RM</M>
in fact contains all elements with coefficients in the family of elements
of <M>R</M> and magma elements in the family of elements of <M>M</M>.
So arithmetic operations with coefficients outside <M>R</M> or with
magma elements outside <M>M</M> might create elements outside <M>RM</M>.
<P/>
It should be mentioned that each call of <Ref Func="FreeMagmaRing"/>
creates a new family of elements,
so for example the elements of two group rings of permutation groups
over the same ring lie in different families and therefore are regarded
as different.
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 3 );;
gap> h:= AlternatingGroup( 3 );;
gap> IsSubset( g, h );
true
gap> f:= GF(2);;
gap> fg:= GroupRing( f, g );
<algebra-with-one over GF(2), with 2 generators>
gap> fh:= GroupRing( f, h );
<algebra-with-one over GF(2), with 1 generators>
gap> IsSubset( fg, fh );
false
gap> o1:= One( fh );  o2:= One( fg );  o1 = o2;
(Z(2)^0)*()
(Z(2)^0)*()
false
gap> emb:= Embedding( g, fg );;
gap> im:= Image( emb, h );
<group of size 3 with 1 generators>
gap> IsSubset( fg, im );
true
]]></Example>
<P/>
There is <E>no</E> generic <E>external representation</E> for elements
in an arbitrary free magma ring.
For example, polynomials are elements of a free magma ring,
and they have an external representation relying on the special form
of the underlying monomials.
On the other hand, elements in a group ring of a permutation group
do not admit such an external representation.
<P/>
For convenience, magma rings constructed with
<Ref Func="FreeAlgebra" Label="for ring, rank (and name)"/>,
<Ref Func="FreeAssociativeAlgebra" Label="for ring, rank (and name)"/>,
<Ref Func="FreeAlgebraWithOne" Label="for ring, rank (and name)"/>, and
<Ref Func="FreeAssociativeAlgebraWithOne"
Label="for ring, rank (and name)"/>
support an external representation of their elements,
which is defined as a list of length 2,
the first entry being the zero coefficient, the second being a list with
the external representations of the magma elements at the odd positions
and the corresponding coefficients at the even positions.
<P/>
As the above examples show, there are several possible representations
of magma ring elements, the representations used for polynomials
(see Chapter &nbsp;<Ref Sect="Polynomials and Rational Functions"/>)
as well as the default representation <Ref Filt="IsMagmaRingObjDefaultRep"/>
of magma ring elements.
The latter simply stores the zero coefficient and a list containing
the coefficients of the element at the even positions
and the corresponding magma elements at the odd positions,
where the succession is compatible with the ordering of magma elements
via <C>\&lt;</C>.


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  ratfun.msk                  GAP documentation            Alexander Hulpke -->
<!-- %A                                                           Frank Celler -->
<!-- %% -->
<!-- %A  @(#)<M>Id: ratfun.msk,v 1.69 2006/03/23 19:40:39 stefan Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Polynomials and Rational Functions">
<Heading>Polynomials and Rational Functions</Heading>

Let <M>R</M> be a commutative ring-with-one. We call a free associative
algebra <M>A</M> over <M>R</M> a <E>polynomial ring</E> over <M>R</M>. The free generators of
<M>A</M> are called <E>indeterminates</E>
(to avoid naming conflicts with the word <E>variables</E> which will be used
to denote &GAP; variables only)
, they are usually denoted by
<M>x_1, x_2, \ldots</M>.
The number of indeterminates is called the <E>rank</E> of <M>A</M>.
The elements of <M>A</M> are called <E>polynomials</E>. Products of
indeterminates are called <E>monomials</E>, every
polynomial can be expressed as a finite sum of products of monomials with
ring elements in a form like
<M>r_{{1,0}} x_1 + r_{{1,1}} x_1 x_2 + r_{{0,1}} x_2 + \cdots</M>
with <M>r_{{i,j}} \in R</M>.
<P/>
A polynomial ring of rank 1 is called an <E>univariate</E> polynomial ring, its
elements are <E>univariate polynomials</E>.
<P/>
Polynomial rings of smaller rank naturally embed in rings of higher rank; if
<M>S</M> is a subring of <M>R</M> then a polynomial ring over <M>S</M> naturally embeds in
a polynomial ring over <M>R</M> of the same rank. Note however that &GAP; does
not consider <M>R</M> as a subset of a polynomial ring over <M>R</M>; for example the
zero of <M>R</M> (<M>0</M>) and the zero of the polynomial ring (<M>0x^0</M>) are different
objects.
<P/>
Internally, indeterminates are represented by positive integers, but it is
possible to give names to them to have them printed in a nicer way. Beware,
however that there is not necessarily any relation between the way an
indeterminate is called and the way it is printed. See section
<Ref Sect="Indeterminates"/> for details.
<P/>
If <M>R</M> is an integral domain, the polynomial ring <M>A</M> over <M>R</M> is an integral domain as well and one can
therefore form its quotient field <M>Q</M>. This field is called a <E>field of
rational functions</E>. Again <M>A</M> embeds naturally into <M>Q</M> and &GAP; will
perform this embedding implicitly. (In fact it implements the ring of rational
functions over <M>R</M>.) To avoid problems with leading
coefficients, however, <M>R</M> must be a unique factorization domain.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Indeterminates">
<Heading>Indeterminates</Heading>

Internally, indeterminates are created for a <E>family</E> of objects
(for example all elements of finite fields in characteristic <M>3</M> are in
one family). Thus a variable <Q>x</Q> over the
rationals is also an <Q>x</Q> over the integers,
while an <Q>x</Q> over <C>GF(3)</C> is different.
<P/>
Within one family, every indeterminate has a number <A>nr</A> and as
long as  no other names have been assigned, this indeterminate will be
displayed as
<Q><C>x_<A>nr</A></C></Q>. Indeterminate numbers can be arbitrary
nonnegative integers.
<P/>
It is possible to assign names to indeterminates; these names are
strings and only provide a means for printing the indeterminates in a
nice way. Indeterminates that have not been assigned a name will be
printed as <Q><C>x_<A>nr</A></C></Q>.
<P/>
(Because of this printing convention, the name <C>x_<A>nr</A></C> is interpreted
specially to always denote the variable with internal number <A>nr</A>.)
<P/>
The indeterminate names have not necessarily any relations to variable
names: this means that an indeterminate whose name is, say,  <Q><C>x</C></Q>
cannot be accessed using the variable <C>x</C>, unless <C>x</C> was defined to
be that indeterminate.

<P/>
When asking for indeterminates with certain
names, &GAP; usually will take the first (with respect to the internal
numbering) indeterminates that are not
yet named, name these accordingly and return them. Thus when asking for
named indeterminates, no relation between names and indeterminate
numbers can be guaranteed. The attribute
<C>IndeterminateNumberOfLaurentPolynomial(<A>indet</A>)</C> will return
the number of the indeterminate <A>indet</A>.
<P/>
When asked to create an indeterminate with a name that exists already for
the family, &GAP; will by default return this existing indeterminate. If
you explicitly want a <E>new</E> indeterminate, distinct from the already
existing one with the <E>same</E> name, you can add the <C>new</C> option
to the function call. (This is in most cases not a good idea.)
<P/>
<Log><![CDATA[
gap> R:=PolynomialRing(GF(3),["x","y","z"]);
GF(3)[x,y,z]
gap> List(IndeterminatesOfPolynomialRing(R),
>   IndeterminateNumberOfLaurentPolynomial);
[ 1, 2, 3 ]
gap> R:=PolynomialRing(GF(3),["z"]);
GF(3)[z]
gap> List(IndeterminatesOfPolynomialRing(R),
>   IndeterminateNumberOfLaurentPolynomial);
[ 3 ]
gap> R:=PolynomialRing(GF(3),["x","y","z"]:new);
GF(3)[x,y,z]
gap> List(IndeterminatesOfPolynomialRing(R),
>   IndeterminateNumberOfLaurentPolynomial);
[ 4, 5, 6 ]
gap> R:=PolynomialRing(GF(3),["z"]);
GF(3)[z]
gap> List(IndeterminatesOfPolynomialRing(R),
>   IndeterminateNumberOfLaurentPolynomial);
[ 3 ]
]]></Log>

<ManSection>
<Heading>Indeterminate</Heading>
<Oper Name="Indeterminate" Arg='R[, nr]'
 Label="for a ring (and a number)"/>
<Oper Name="Indeterminate" Arg='R[, name][, avoid]'
 Label="for a ring (and a name, and an exclusion list)"/>
<Oper Name="Indeterminate" Arg='fam, nr'
 Label="for a family and a number"/>
<Oper Name="X" Arg='R[, nr]'
 Label="for a ring (and a number)"/>
<Oper Name="X" Arg='R[, name][, avoid]'
 Label="for a ring (and a name, and an exclusion list)"/>
<Oper Name="X" Arg='fam, nr'
 Label="for a family and a number"/>

<Description>
returns the indeterminate number <A>nr</A> over the ring <A>R</A>.
If <A>nr</A> is not given it defaults to 1.
If the number is not specified a list <A>avoid</A> of indeterminates
may be given.
The function will return an indeterminate that is guaranteed to be
different from all the indeterminates in the list <A>avoid</A>.
The third usage returns an indeterminate called <A>name</A>
(also avoiding the indeterminates in <A>avoid</A> if given).
<P/>
<Ref Oper="X" Label="for a ring (and a number)"/> is simply a synonym for
<Ref Oper="Indeterminate" Label="for a ring (and a number)"/>. However, 
we do not recommend to use this synonym which is supported only for the
backwards compatibility.
<P/>
<Example><![CDATA[
gap> x:=Indeterminate(GF(3),"x");
x
gap> y:=X(GF(3),"y");z:=X(GF(3),"X");
y
X
gap> X(GF(3),2);
y
gap> X(GF(3),"x_3");
X
gap> X(GF(3),[y,z]);
x
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IndeterminateNumberOfUnivariateRationalFunction" Arg='rfun'/>

<Description>
returns the number of the indeterminate in which the univariate rational
function <A>rfun</A> is expressed. (This also provides a way to obtain the
number of a given indeterminate.)
<P/>
A constant rational function might not possess an indeterminate number. In
this case <Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/>
will default to a value of 1.
Therefore two univariate polynomials may be considered to be in the same
univariate polynomial ring if their indeterminates have the same number
or one if of them is constant.  (see also&nbsp;<Ref Func="CIUnivPols"/>
and&nbsp;<Ref Func="IsLaurentPolynomialDefaultRep"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="IndeterminateOfUnivariateRationalFunction" Arg='rfun'/>

<Description>
returns the indeterminate in which the univariate rational
function <A>rfun</A> is expressed. (cf.
<Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/>.)
<Example><![CDATA[
gap> IndeterminateNumberOfUnivariateRationalFunction(z);
3
gap> IndeterminateOfUnivariateRationalFunction(z^5+z);
X
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IndeterminateName" Arg='fam,nr'/>
<Oper Name="HasIndeterminateName" Arg='fam,nr'/>
<Oper Name="SetIndeterminateName" Arg='fam,nr,name'/>

<Description>
<Ref Func="SetIndeterminateName"/> assigns the name <A>name</A> to
indeterminate <A>nr</A> in the rational functions family <A>fam</A>.
It issues an error if the indeterminate was already named.
<P/>
<Ref Func="IndeterminateName"/> returns the name of the <A>nr</A>-th
indeterminate (and returns <K>fail</K> if no name has been assigned).
<P/>
<Ref Func="HasIndeterminateName"/> tests whether indeterminate <A>nr</A>
has already been assigned a name.
<P/>
<Example><![CDATA[
gap> IndeterminateName(FamilyObj(x),2);
"y"
gap> HasIndeterminateName(FamilyObj(x),4);
false
gap> SetIndeterminateName(FamilyObj(x),10,"bla");
gap> Indeterminate(GF(3),10);
bla
]]></Example>
<P/>
As a convenience there is a special method installed for <C>SetName</C>
that will assign a name to an indeterminate.
<P/>
<Example><![CDATA[
gap> a:=Indeterminate(GF(3),5);
x_5
gap> SetName(a,"ah");
gap> a^5+a;
ah^5+ah
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CIUnivPols" Arg='upol1, upol2'/>

<Description>
This function (whose name stands for
<Q>common indeterminate of univariate polynomials</Q>) takes two
univariate polynomials as arguments.
If both polynomials are given in the same indeterminate number
<A>indnum</A> (in this case they are <Q>compatible</Q> as
univariate polynomials) it returns <A>indnum</A>.
In all other cases it returns <K>fail</K>.
<Ref Func="CIUnivPols"/> also accepts if either polynomial is constant
but formally expressed in another indeterminate, in this situation the
indeterminate of the other polynomial is selected.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Rational Functions">
<Heading>Operations for Rational Functions</Heading>

The rational functions form a field,
therefore all arithmetic operations are applicable to rational functions.
<P/>
<Index Subkey="rational functions">addition</Index>
<Index Subkey="rational functions">subtraction</Index>
<Index Subkey="rational functions">product</Index>
<Index Subkey="rational functions">quotient</Index>
<C><A>f</A> + <A>g</A></C>
<P/>
<C><A>f</A> - <A>g</A></C>
<P/>
<C><A>f</A> * <A>g</A></C>
<P/>
<C><A>f</A> / <A>g</A></C>
<P/>
<Example><![CDATA[
gap> x:=Indeterminate(Rationals,1);;y:=Indeterminate(Rationals,2);;
gap> f:=3+x*y+x^5;;g:=5+x^2*y+x*y^2;;
gap> a:=g/f;
(x_1^2*x_2+x_1*x_2^2+5)/(x_1^5+x_1*x_2+3)
]]></Example>
<P/>
Note that the quotient <C><A>f</A>/<A>g</A></C> of two polynomials might be represented as
a rational function again. If <A>g</A> is known to divide <A>f</A> the call
<C>Quotient(<A>f</A>,<A>g</A>)</C> (see&nbsp;<Ref Func="Quotient"/>) should be used instead.
<P/>
<Index Subkey="Laurent polynomials">mod</Index>
<C><A>f</A> mod <A>g</A></C>
<!-- %\><C><A>f</A> mod <A>int</A></C>{mod!integer polynomial} -->
<P/>
For two Laurent polynomials <A>f</A> and <A>g</A>, <C><A>f</A> mod <A>g</A></C> is the Euclidean
remainder (see&nbsp;<Ref Func="EuclideanRemainder"/>) of <A>f</A> modulo <A>g</A>.
<!-- % For a polynomial <A>f</A> over the integers and an integer <A>int</A>, <C><A>f</A> mod <A>int</A></C> -->
<!-- % is the polynomial over the integers obtained by reducing the coefficients -->
<!-- % of <A>f</A> modulo <A>int</A>. -->
<!-- % Just a remark: -->
<!-- % These two methods would not be compatible if integers would be regarded -->
<!-- % as constant polynomials. -->
<!-- % Therefore, I leave the second method undocumented. -->
<P/>
As calculating a multivariate Gcd can be expensive,
it is not guaranteed that rational functions will always be
represented as a quotient of coprime polynomials. In certain unfortunate
situations this might lead to a degree explosion.
To ensure cancellation you can use
<Ref Func="Gcd" Label="for (a ring and) several elements"/> on the
<Ref Func="NumeratorOfRationalFunction"/> and
<Ref Func="DenominatorOfRationalFunction"/> values
of a given rational function.
<P/>
All polynomials as well as all the univariate polynomials in the same
indeterminate form subrings of this field. If two rational functions are
known to be in the same subring, the result will be expressed as element in
this subring.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Rational Functions">
<Heading>Comparison of Rational Functions</Heading>

<Index Subkey="rational functions">comparison</Index>
<C><A>f</A> = <A>g</A></C>
<P/>
Two rational functions <A>f</A> and <A>g</A> are equal if the product
<C>Numerator(<A>f</A>) * Denominator(<A>g</A>)</C> equals
<C>Numerator(<A>g</A>) * Denominator(<A>f</A>)</C>.
<P/>
<Example><![CDATA[
gap> x:=Indeterminate(Rationals,"x");;y:=Indeterminate(Rationals,"y");;
gap> f:=3+x*y+x^5;;g:=5+x^2*y+x*y^2;;
gap> a:=g/f;
(x^2*y+x*y^2+5)/(x^5+x*y+3)
gap> b:=(g*f)/(f^2);
(x^7*y+x^6*y^2+5*x^5+x^3*y^2+x^2*y^3+3*x^2*y+3*x*y^2+5*x*y+15)/(x^10+2\
*x^6*y+6*x^5+x^2*y^2+6*x*y+9)
gap> a=b;
true
]]></Example>
<P/>
<Index Subkey="rational functions">smaller</Index>
<C><A>f</A> &lt; <A>g</A></C>
<P/>
The ordering of rational functions is defined in several steps. Monomials
(products of indeterminates) are sorted first by degree, then
lexicographically (with <M>x_1>x_2</M>)
(see&nbsp;<Ref Func="MonomialGrlexOrdering"/>). Products of monomials
with ring elements (<Q>terms</Q>) are compared first by their monomials and
then by their coefficients.
<P/>
<Example><![CDATA[
gap> x>y;
true
gap> x^2*y<x*y^2;
false
gap> x*y<x^2*y;
true
gap> x^2*y < 5* y*x^2;
true
]]></Example>
Polynomials are compared by comparing the largest terms in turn until they
differ.
<Example><![CDATA[
gap> x+y<y;
false
gap> x<x+1;
true
]]></Example>
Rational functions are compared by comparing the polynomial
<C>Numerator(<A>f</A>) * Denominator(<A>g</A>)</C> with the polynomial
<C>Numerator(<A>g</A>) * Denominator(<A>f</A>)</C>. (As the ordering of monomials used by
&GAP; is invariant under multiplication this is independent of common
factors in numerator and denominator.)
<Example><![CDATA[
gap> f/g<g/f;
false
gap> f/g<(g*g)/(f*g);
false
]]></Example>
<P/>
For univariate polynomials this reduces to an ordering first by total degree
and then lexicographically on the coefficients.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties and Attributes of Rational Functions">
<Heading>Properties and Attributes of Rational Functions</Heading>

All these tests are applicable to <E>every</E> rational function.
Depending on the internal representation of the rational function,
however some of these tests (in particular, univariateness)
might be expensive in some cases.
<P/>
For reasons of performance within algorithms it can be useful to use other
attributes, which give a slightly more technical representation.
See section&nbsp;<Ref Sect="The Representations of Rational Functions"/>
for details.

<ManSection>
<Filt Name="IsPolynomialFunction" Arg='obj' Type='Category'/>
<Filt Name="IsRationalFunction" Arg='obj' Type='Category'/>

<Description>
A rational function is an element of the quotient field of a polynomial
ring over an UFD. It is represented as a quotient of two polynomials,
its numerator (see&nbsp;<Ref Func="NumeratorOfRationalFunction"/>) and
its denominator (see&nbsp;<Ref Func="DenominatorOfRationalFunction"/>)
<P/>
A polynomial function is an element of a polynomial ring (not
necessarily an UFD), or a rational function.
<P/>
&GAP; considers <Ref Func="IsRationalFunction"/> as a subcategory of
<Ref Func="IsPolynomialFunction"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="NumeratorOfRationalFunction" Arg='ratfun'/>

<Description>
returns the numerator of the rational function <A>ratfun</A>.
<P/>
As no proper multivariate gcd has been implemented yet, numerators and
denominators are not guaranteed to be reduced!
</Description>
</ManSection>

<ManSection>
<Attr Name="DenominatorOfRationalFunction" Arg='ratfun'/>

<Description>
returns the denominator of the rational function <A>ratfun</A>.
<P/>
As no proper multivariate gcd has been implemented yet, numerators and
denominators are not guaranteed to be reduced!
<Example><![CDATA[
gap> x:=Indeterminate(Rationals,1);;y:=Indeterminate(Rationals,2);;
gap> DenominatorOfRationalFunction((x*y+x^2)/y);
y
gap> NumeratorOfRationalFunction((x*y+x^2)/y);
x^2+x*y
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPolynomial" Arg='ratfun'/>

<Description>
A polynomial is a rational function whose denominator is one. (If the
coefficients family forms a field this is equivalent to the denominator
being constant.)
<P/>
If the base family is not a field, it may be impossible to represent the
quotient of a polynomial by a ring element as a polynomial again, but it
will have to be represented as a rational function.
<Example><![CDATA[
gap> IsPolynomial((x*y+x^2*y^3)/y);
true
gap> IsPolynomial((x*y+x^2)/y);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AsPolynomial" Arg='poly'/>

<Description>
If <A>poly</A> is a rational function that is a polynomial this attribute
returns an equal rational function <M>p</M> such that <M>p</M> is equal
to its numerator and the denominator of <M>p</M> is one.
<Example><![CDATA[
gap> AsPolynomial((x*y+x^2*y^3)/y);
x^2*y^2+x
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsUnivariateRationalFunction" Arg='ratfun'/>

<Description>
A rational function is univariate if its numerator and its denominator
are both polynomials in the same one indeterminate. The attribute
<Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/> can be used to obtain
the number of this common indeterminate.
</Description>
</ManSection>

<ManSection>
<Attr Name="CoefficientsOfUnivariateRationalFunction" Arg='rfun'/>

<Description>
if <A>rfun</A> is a univariate rational function, this attribute
returns a list <C>[ <A>ncof</A>, <A>dcof</A>, <A>val</A> ]</C>
where <A>ncof</A> and <A>dcof</A> are coefficient lists of univariate
polynomials <A>n</A> and <A>d</A> and a valuation <A>val</A> such that
<M><A>rfun</A> = x^{<A>val</A>} \cdot <A>n</A> / <A>d</A></M>
where <M>x</M> is the variable with the number given by
<Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/>.
Numerator and denominator are guaranteed to be cancelled.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsUnivariatePolynomial" Arg='ratfun'/>

<Description>
A univariate polynomial is a polynomial in only one indeterminate.
</Description>
</ManSection>

<ManSection>
<Attr Name="CoefficientsOfUnivariatePolynomial" Arg='pol'/>

<Description>
<Ref Func="CoefficientsOfUnivariatePolynomial"/> returns the coefficient
list of the polynomial <A>pol</A>, sorted in ascending order.
(It returns the empty list if <A>pol</A> is 0.)
</Description>
</ManSection>

<ManSection>
<Prop Name="IsLaurentPolynomial" Arg='ratfun'/>

<Description>
A Laurent polynomial is a univariate rational function whose denominator
is a monomial. Therefore every univariate polynomial is a
Laurent polynomial.
<P/>
The attribute <Ref Func="CoefficientsOfLaurentPolynomial"/> gives a
compact representation as Laurent polynomial.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsConstantRationalFunction" Arg='ratfun'/>

<Description>
A  constant  rational   function is  a    function  whose  numerator  and
denominator are polynomials of degree 0.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsPrimitivePolynomial" Arg='F, pol'/>

<Description>
For a univariate polynomial <A>pol</A> of degree <M>d</M> in the
indeterminate <M>X</M>,
with coefficients in a finite field <A>F</A> with <M>q</M> elements, say,
<Ref Func="IsPrimitivePolynomial"/> returns <K>true</K> if
<Enum>
<Item>
    <A>pol</A> divides <M>X^{{q^d-1}} - 1</M>, and
</Item>
<Item>
    for each prime divisor <M>p</M> of <M>q^d - 1</M>,
    <A>pol</A> does not divide <M>X^{{(q^d-1)/p}} - 1</M>,
</Item>
</Enum>
and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="SplittingField" Arg='f'/>

<Description>
returns the smallest field which contains the coefficients of <A>f</A> and
the roots of <A>f</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Univariate Polynomials">
<Heading>Univariate Polynomials</Heading>

Some of the operations are actually defined on the larger domain of Laurent
polynomials (see <Ref Sect="Laurent Polynomials"/>). For this section you can simply
ignore the word <Q>Laurent</Q> if it occurs in a description.
<P/>

<ManSection>
<Oper Name="UnivariatePolynomial" Arg='ring, cofs[, ind]'/>

<Description>
constructs an univariate polynomial over the ring <A>ring</A> in the
indeterminate <A>ind</A> with the coefficients given by <A>coefs</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="UnivariatePolynomialByCoefficients" Arg='fam, cofs, ind'/>

<Description>
constructs an univariate polynomial over the coefficients family
<A>fam</A> and in the indeterminate <A>ind</A> with the coefficients given by
<A>coefs</A>. This function should be used in algorithms to create
polynomials as it avoids overhead associated with
<Ref Func="UnivariatePolynomial"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="DegreeOfLaurentPolynomial" Arg='pol'/>

<Description>
The degree of a univariate (Laurent) polynomial <A>pol</A> is the largest
exponent <M>n</M> of a monomial <M>x^n</M> of <A>pol</A>. The degree of
a zero polynomial is defined to be <C>-infinity</C>.
<Example><![CDATA[
gap> p:=UnivariatePolynomial(Rationals,[1,2,3,4],1);
4*x^3+3*x^2+2*x+1
gap> UnivariatePolynomialByCoefficients(FamilyObj(1),[9,2,3,4],73);
4*x_73^3+3*x_73^2+2*x_73+9
gap> CoefficientsOfUnivariatePolynomial(p);
[ 1, 2, 3, 4 ]
gap> DegreeOfLaurentPolynomial(p);
3
gap> DegreeOfLaurentPolynomial(Zero(p));
-infinity
gap> IndeterminateNumberOfLaurentPolynomial(p);
1
gap> IndeterminateOfLaurentPolynomial(p);
x
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootsOfPolynomial" Arg='[R,],p'/>

<Description>
For a univariate polynomial <A>p</A>, this function returns all roots of
<A>p</A> over the ring <A>R</A>. If the ring is not specified, it defaults
to the ring specified by the coefficients of <A>p</A> via
<Ref Func="DefaultRing" Label="for ring elements"/>).
<Example><![CDATA[
gap> x:=X(Rationals,"x");;p:=x^4-1;    
x^4-1
gap> RootsOfPolynomial(p);
[ 1, -1 ]
gap> RootsOfPolynomial(CF(4),p);
[ 1, -1, E(4), -E(4) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootsOfUPol" Arg='[field, ]upol'/>

<Description>
This function returns a list of all roots of the univariate polynomial
<A>upol</A> in its default domain.
If the optional argument <A>field</A> is a field then the roots in this
field are computed.
If <A>field</A> is the string <C>"split"</C> then the splitting field of
the polynomial is taken.
<Example><![CDATA[
gap> RootsOfUPol(50-45*x-6*x^2+x^3);
[ 10, 1, -5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="QuotRemLaurpols" Arg='left,right,mode'/>

<Description>
This internal function for euclidean division of polynomials
takes two polynomials <A>left</A> and <A>right</A>
and computes their quotient. No test is performed whether the arguments
indeed  are polynomials.
Depending on the integer variable <A>mode</A>, which may take values in 
a range from 1 to 4, it returns respectively:
<Enum>
<Item>
  the quotient (there might be some remainder),
</Item>
<Item>
  the remainder,
</Item>
<Item>
  a list <C>[<A>q</A>,<A>r</A>]</C> of quotient and remainder,
</Item>
<Item>
  the quotient if there is no remainder and <K>fail</K> otherwise.
</Item>
</Enum>
</Description>
</ManSection>

<ManSection>
<Func Name="UnivariatenessTestRationalFunction" Arg='f'/>

<Description>
takes a rational function <A>f</A> and tests whether it is univariate 
rational function (or even a Laurent polynomial). It returns a list
<C>[isunivariate, indet, islaurent, cofs]</C>. 
<P/>
If <A>f</A> is a univariate rational function then <C>isunivariate</C> 
is <K>true</K> and <C>indet</C> is the number of the appropriate 
indeterminate.
<P/>
Furthermore, if <A>f</A> is a Laurent polynomial, then <C>islaurent</C>
is also <K>true</K>. In this case the fourth entry, <C>cofs</C>, is 
the value of the attribute <Ref Attr="CoefficientsOfLaurentPolynomial"/> 
for <A>f</A>.
<P/>
If <C>isunivariate</C> is <K>true</K> but <C>islaurent</C> is 
<K>false</K>, then <C>cofs</C> is the value of the attribute 
<Ref Attr="CoefficientsOfUnivariateRationalFunction"/> for <A>f</A>.
<P/>
Otherwise, each entry of the returned list is equal to <K>fail</K>.
As there is no proper multivariate gcd, this may also happen for the
rational function which may be reduced to univariate (see example).
<Example><![CDATA[
gap> UnivariatenessTestRationalFunction( 50-45*x-6*x^2+x^3 );
[ true, 1, true, [ [ 50, -45, -6, 1 ], 0 ] ]
gap> UnivariatenessTestRationalFunction( (-6*y^2+y^3) / (y+1) );
[ true, 2, false, [ [ -6, 1 ], [ 1, 1 ], 2 ] ]
gap> UnivariatenessTestRationalFunction( (-6*y^2+y^3) / (x+1));
[ fail, fail, fail, fail ]
gap> UnivariatenessTestRationalFunction( ((y+2)*(x+1)) / ((y-1)*(x+1)) );
[ fail, fail, fail, fail ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoPoly"/>

<Description>
is the info class for univariate polynomials.
</Description>
</ManSection>


We remark that some functions for multivariate polynomials (which will be
defined in the following sections) permit a different syntax for univariate
polynomials which drops the requirement to specify the indeterminate.
Examples are
<Ref Func="Value" Label="for rat. function, a list of indeterminates, a value (and a one)"/>,
<Ref Func="Discriminant"/>, <Ref Func="Derivative"/>,
<Ref Func="LeadingCoefficient"/> and <Ref Func="LeadingMonomial"/>:
<Example><![CDATA[
gap> p:=UnivariatePolynomial(Rationals,[1,2,3,4],1);
4*x^3+3*x^2+2*x+1
gap> Value(p,Z(5));
Z(5)^2
gap> LeadingCoefficient(p);
4
gap> Derivative(p);
12*x^2+6*x+2
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Polynomials as Univariate Polynomials in one Indeterminate">
<Heading>Polynomials as Univariate Polynomials in one Indeterminate</Heading>

<ManSection>
<Oper Name="DegreeIndeterminate" Arg='pol, ind'/>

<Description>
returns the degree of the polynomial <A>pol</A> in the indeterminate
(or indeterminate number) <A>ind</A>.
<Example><![CDATA[
gap> f:=x^5+3*x*y+9*y^7+4*y^5*x+3*y+2;
9*y^7+4*x*y^5+x^5+3*x*y+3*y+2
gap> DegreeIndeterminate(f,1);
5
gap> DegreeIndeterminate(f,y);
7
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PolynomialCoefficientsOfPolynomial" Arg='pol, ind'/>

<Description>
<Ref Func="PolynomialCoefficientsOfPolynomial"/> returns the
coefficient list (whose entries are polynomials not involving the
indeterminate <A>ind</A>) describing the polynomial <A>pol</A> viewed as
a polynomial in <A>ind</A>. 
Instead of the indeterminate,
<A>ind</A> can also be an indeterminate number.
<Example><![CDATA[
gap> PolynomialCoefficientsOfPolynomial(f,2);
[ x^5+2, 3*x+3, 0, 0, 0, 4*x, 0, 9 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LeadingCoefficient" Arg='pol'/>

<Description>
returns the leading coefficient (that is the coefficient of the leading
monomial, see&nbsp;<Ref Func="LeadingMonomial"/>) of the polynomial <A>pol</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="LeadingMonomial" Arg='pol'/>

<Description>
returns the leading monomial (with respect to the ordering given by
<Ref Func="MonomialExtGrlexLess"/>) of the polynomial <A>pol</A> as a list
containing indeterminate numbers and exponents.
<Example><![CDATA[
gap> LeadingCoefficient(f,1);
1
gap> LeadingCoefficient(f,2);
9
gap> LeadingMonomial(f);
[ 2, 7 ]
gap> LeadingCoefficient(f);
9
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Derivative" Arg='ratfun[, ind]'/>

<Description>
If <A>ratfun</A> is a univariate rational function then
<Ref Func="Derivative"/> returns the <E>derivative</E> of <A>ufun</A> by
its indeterminate.
For a rational function <A>ratfun</A>,
the derivative by the indeterminate <A>ind</A> is returned,
regarding <A>ratfun</A> as univariate in <A>ind</A>.
Instead of the desired indeterminate, also the number of this
indeterminate can be given as <A>ind</A>.
<Example><![CDATA[
gap> Derivative(f,2);
63*y^6+20*x*y^4+3*x+3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Discriminant" Arg='pol[, ind]'/>

<Description>
If <A>pol</A> is a univariate polynomial then
<Ref Func="Discriminant"/> returns the <E>discriminant</E> of <A>pol</A>
by its indeterminate.
The two-argument form returns the discriminant of a polynomial <A>pol</A>
by the indeterminate number <A>ind</A>, regarding <A>pol</A> as univariate
in this indeterminate. Instead of the indeterminate number, the
indeterminate itself can also be given as <A>ind</A>.
<Example><![CDATA[
gap> Discriminant(f,1);
20503125*y^28+262144*y^25+27337500*y^22+19208040*y^21+1474560*y^17+136\
68750*y^16+18225000*y^15+6075000*y^14+1105920*y^13+3037500*y^10+648972\
0*y^9+4050000*y^8+900000*y^7+62208*y^5+253125*y^4+675000*y^3+675000*y^\
2+300000*y+50000
gap> Discriminant(f,1) = Discriminant(f,x);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Resultant" Arg='pol1, pol2, ind'/>

<Description>
computes the resultant of the polynomials <A>pol1</A> and <A>pol2</A>
with respect to the indeterminate <A>ind</A>,
or indeterminate number <A>ind</A>.
The resultant considers <A>pol1</A> and <A>pol2</A> as univariate in
<A>ind</A> and returns an element of the corresponding base ring
(which might be a polynomial ring).
<Example><![CDATA[
gap> Resultant(x^4+y,y^4+x,1);
y^16+y
gap> Resultant(x^4+y,y^4+x,2);
x^16+x
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Multivariate Polynomials">
<Heading>Multivariate Polynomials</Heading>

<ManSection>
<Heading>Value</Heading>
<Oper Name="Value" Arg='ratfun, indets, vals[, one]'
 Label="for rat. function, a list of indeterminates, a value (and a one)"/>
<Oper Name="Value" Arg='upol, value[, one]'
 Label="for a univariate rat. function, a value (and a one)"/>

<Description>
The first variant takes a rational function <A>ratfun</A> and specializes
the indeterminates given in <A>indets</A> to the values given in
<A>vals</A>,
replacing the <M>i</M>-th entry in <A>indets</A> by the <M>i</M>-th entry
in <A>vals</A>.
If this specialization results in a constant polynomial,
an element of the coefficient ring is returned.
If the specialization would specialize the denominator of <A>ratfun</A>
to zero, an error is raised.
<P/>
A variation is the evaluation at elements of another ring <M>R</M>,
for which a multiplication with elements of the coefficient ring of
<A>ratfun</A> are defined.
In this situation the identity element of <M>R</M> may be given by a
further argument <A>one</A> which will be used for <M>x^0</M> for any
specialized indeterminate <M>x</M>.
<P/>
The second version takes an univariate rational function and specializes
the value of its indeterminate to <A>val</A>.
Again, an optional argument <A>one</A> may be given.
<P/>
<Example><![CDATA[
gap> Value(x*y+y+x^7,[x,y],[5,7]);
78167
]]></Example>
<P/>
Note that the default values for <A>one</A> can lead to different results
than one would expect:
For example for a matrix <M>M</M>, the values <M>M+M^0</M> and <M>M+1</M>
are <E>different</E>.
As <Ref Func="Value" Label="for rat. function, a list of indeterminates, a value (and a one)"/>
defaults to the one of the coefficient ring,
when evaluating matrices in polynomials always the correct <A>one</A>
should be given!
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Minimal Polynomials">
<Heading>Minimal Polynomials</Heading>

<Index Key="MinimalPolynomial" Subkey="over a ring"><C>MinimalPolynomial</C></Index>
<ManSection>
<Oper Name="MinimalPolynomial" Arg='R, elm[, ind]'/>

<Description>
returns the <E>minimal polynomial</E> of <A>elm</A> over the ring <A>R</A>,
expressed in the indeterminate number <A>ind</A>.
If <A>ind</A> is not given, it defaults to 1.
<P/>
The minimal polynomial is the monic polynomial of smallest degree with
coefficients in <A>R</A> that has value zero at <A>elm</A>.
<Example><![CDATA[
gap> MinimalPolynomial(Rationals,[[2,0],[0,2]]);
x-2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Cyclotomic Polynomials">
<Heading>Cyclotomic Polynomials</Heading>

<ManSection>
<Func Name="CyclotomicPolynomial" Arg='F, n'/>

<Description>
is the <A>n</A>-th cyclotomic polynomial over the ring <A>F</A>.
<Example><![CDATA[
gap> CyclotomicPolynomial(Rationals,5);
x^4+x^3+x^2+x+1
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Polynomial Factorization">
<Heading>Polynomial Factorization</Heading>

At the moment &GAP; provides only methods to factorize 
polynomials over finite fields (see Chapter&nbsp;<Ref Chap="Finite Fields"/>),
over subfields of cyclotomic fields (see Chapter&nbsp;<Ref Chap="Abelian Number Fields"/>),
and over algebraic extensions of these
(see Chapter&nbsp;<Ref Chap="Algebraic extensions of fields"/>).
<P/>

<ManSection>
<Meth Name="Factors" Arg='[R, ]poly[, opt]' Label="of polynomial"/>

<Description>
returns a list of the irreducible factors of the polynomial
<A>poly</A> in the polynomial ring <A>R</A>. (That is factors over the
<Ref Func="CoefficientsRing"/> value of <A>R</A>.)
<P/>
For univariate factorizations, it is possible to pass a record <A>opt</A>
as a third argument. This record can contain the following components:
<List>
<Mark><C>onlydegs</C></Mark>
<Item>
is a set of positive integers. The factorization assumes
that all irreducible factors have a degree in this set.
</Item>
<Mark><C>stopdegs</C></Mark>
<Item>
is a set of positive integers. The factorization will stop once a
factor of degree in <C>stopdegs</C> has been found and will return the
factorization found so far.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> f:= CyclotomicPolynomial( GF(2), 7 );
x_1^6+x_1^5+x_1^4+x_1^3+x_1^2+x_1+Z(2)^0
gap> Factors( f );
[ x_1^3+x_1+Z(2)^0, x_1^3+x_1^2+Z(2)^0 ]
gap> Factors( PolynomialRing( GF(8) ), f );
[ x_1+Z(2^3), x_1+Z(2^3)^2, x_1+Z(2^3)^3, x_1+Z(2^3)^4, x_1+Z(2^3)^5, 
  x_1+Z(2^3)^6 ]
gap> f:= MinimalPolynomial( Rationals, E(4) );
x^2+1
gap> Factors( f );
[ x^2+1 ]
gap> Factors( PolynomialRing( Rationals ), f );
[ x^2+1 ]
gap> Factors( PolynomialRing( CF(4) ), f );
[ x+(-E(4)), x+E(4) ]
]]></Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="FactorsSquarefree" Arg='pring, upol, opt'/>

<Description>
returns a factorization of the squarefree, monic, univariate polynomial
<A>upol</A> in the polynomial ring <A>pring</A>;
<A>opt</A> must be a (possibly empty) record of options.
<A>upol</A> must not have zero as a root.
This function is used by the factoring algorithms.
<P/>
The current method for multivariate factorization reduces to univariate
factorization by use of a reduction homomorphism of the form
<M>f(x_1,x_2,x_3) \mapsto f(x,x^p,x^{{p^2}})</M>.
It can be very time intensive for larger degrees.
<P/>
<Example><![CDATA[
gap> Factors(x^10-y^10);
[ x-y, x+y, x^4-x^3*y+x^2*y^2-x*y^3+y^4, x^4+x^3*y+x^2*y^2+x*y^3+y^4 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Polynomials over the Rationals">
<Heading>Polynomials over the Rationals</Heading>

The following functions are only available to polynomials with rational
coefficients:

<ManSection>
<Func Name="PrimitivePolynomial" Arg='f'/>

<Description>
takes a polynomial <A>f</A> with rational coefficients and computes a new
polynomial with integral coefficients, obtained by multiplying with the
Lcm of the denominators of the coefficients and casting out the content
(the Gcd of the coefficients). The operation returns a list
[<A>newpol</A>,<A>coeff</A>] with rational <A>coeff</A> such that
<C><A>coeff</A>*<A>newpol</A>=<A>f</A></C>.
</Description>
</ManSection>

<ManSection>
<Func Name="PolynomialModP" Arg='pol,p'/>

<Description>
for a rational polynomial <A>pol</A> this function returns a polynomial over
the field with <A>p</A> elements, obtained by reducing the coefficients modulo
<A>p</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="GaloisType" Arg='f[,cand]'/>

<Description>
Let <A>f</A> be an irreducible polynomial with rational coefficients. This
function returns the type of Gal(<A>f</A>) 
(considered as a transitive permutation group of the roots of <A>f</A>). It
returns a number <A>i</A> if Gal(<A>f</A>) is permutation isomorphic to
<C>TransitiveGroup(<A>n</A>,<A>i</A>)</C> where <A>n</A> is the degree of <A>f</A>.
<P/>
Identification is performed by factoring
appropriate Galois resolvents as proposed in <Cite Key="MS85"/>.  This function
is provided for rational polynomials of degree up to 15.  However, in some
cases the required calculations become unfeasibly large.
<P/>
For a few polynomials of degree 14, a complete discrimination is not yet
possible, as it would require computations, that are not feasible with
current factoring methods.
<P/>
This function requires the transitive groups library to be installed (see
<Ref Sect="Transitive Permutation Groups"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="ProbabilityShapes" Arg='f'/>

<Description>
Let <A>f</A> be an irreducible polynomial with rational coefficients. This
function returns a list of the most likely type(s) of Gal(<A>f</A>)
(see <Ref Func="GaloisType"/>), based
on factorization modulo a set of primes.
It is very fast, but the result is only probabilistic.
<P/>
This function requires the transitive groups library to be installed (see
<Ref Sect="Transitive Permutation Groups"/>).
<Example><![CDATA[
gap> f:=x^9-9*x^7+27*x^5-39*x^3+36*x-8;;
gap> GaloisType(f);
25
gap> TransitiveGroup(9,25);
[1/2.S(3)^3]3
gap> ProbabilityShapes(f);
[ 25 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Factorization of Polynomials over the Rationals">
<Heading>Factorization of Polynomials over the Rationals</Heading>

The following operations are used by &GAP; inside the factorization algorithm
but might be of interest also in other contexts.
<ManSection>
<Func Name="BombieriNorm" Arg='pol'/>

<Description>
computes weighted Norm [<A>pol</A>]<M>_2</M> of <A>pol</A> which is a
good measure for factor coefficients (see <Cite Key="BTW93"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="MinimizedBombieriNorm" Arg='f'/>

<Description>
This function applies linear Tschirnhaus transformations 
(<M>x \mapsto x + i</M>) to the
polynomial <A>f</A>, trying to get the Bombieri norm of <A>f</A> small. It returns a
list <C>[<A>new_polynomial</A>, <A>i_of_transformation</A>]</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="HenselBound" Arg='pol,[minpol,den]'/>

<Description>
returns the Hensel bound of the polynomial <A>pol</A>.
If the computation takes place over an algebraic extension, then
the minimal polynomial <A>minpol</A> and denominator <A>den</A> must be given.
</Description>
</ManSection>

<ManSection>
<Func Name="OneFactorBound" Arg='pol'/>

<Description>
returns the coefficient bound for a single factor of the rational 
polynomial <A>pol</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Laurent Polynomials">
<Heading>Laurent Polynomials</Heading>

A univariate polynomial can be written in the form
<M>r_0 + r_1 x + \cdots + r_n x^n</M>, with <M>r_i \in R</M>.
Formally, there is no reason to start with 0, if <M>m</M> is an
integer, we can consider objects of the form
<M>r_m x^m + r_{{m+1}} x^{{m+1}} + \cdots + r_n x^n</M>.
We call these <E>Laurent polynomials</E>.
Laurent polynomials also can be considered as quotients of a univariate
polynomial by a power of the indeterminate.  The addition and multiplication
of univariate polynomials extends to Laurent polynomials (though it might be
impossible to interpret a Laurent polynomial as a function) and many
functions for univariate polynomials extend to Laurent polynomials (or
extended versions for Laurent polynomials exist).

<ManSection>
<Oper Name="LaurentPolynomialByCoefficients" Arg='fam, cofs, val [,ind]'/>

<Description>
constructs a Laurent polynomial over the coefficients
family <A>fam</A> and in the indeterminate <A>ind</A> (defaulting to 1)
with the coefficients given by <A>coefs</A> and valuation <A>val</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CoefficientsOfLaurentPolynomial" Arg='laurent'/>

<Description>
For a Laurent polynomial <A>laurent</A>, this function returns a pair
<C>[<A>cof</A>, <A>val</A>]</C>,
consisting of the coefficient list (in ascending order) <A>cof</A> and the
valuation <A>val</A> of <A>laurent</A>.
<Example><![CDATA[
gap> p:=LaurentPolynomialByCoefficients(FamilyObj(1),
> [1,2,3,4,5],-2);
5*x^2+4*x+3+2*x^-1+x^-2
gap> NumeratorOfRationalFunction(p);DenominatorOfRationalFunction(p);
5*x^4+4*x^3+3*x^2+2*x+1
x^2
gap> CoefficientsOfLaurentPolynomial(p*p);
[ [ 1, 4, 10, 20, 35, 44, 46, 40, 25 ], -4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IndeterminateNumberOfLaurentPolynomial" Arg='pol'/>

<Description>
Is a synonym for
<Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Univariate Rational Functions">
<Heading>Univariate Rational Functions</Heading>

<ManSection>
<Oper Name="UnivariateRationalFunctionByCoefficients"
 Arg='fam, ncof, dcof, val[, ind]'/>

<Description>
constructs a univariate rational function over the coefficients
family <A>fam</A> and in the indeterminate <A>ind</A> (defaulting to 1) with
numerator and denominator coefficients given by <A>ncof</A> and <A>dcof</A> and
valuation <A>val</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Polynomial Rings and Function Fields">
<Heading>Polynomial Rings and Function Fields</Heading>

While polynomials depend only on the family of the coefficients, polynomial
rings <M>A</M> are defined over a base ring <M>R</M>.
A polynomial is an element of <M>A</M> if and only if all its coefficients
are contained in <M>R</M>.
Besides providing domains and an easy way to create polynomials,
polynomial rings can affect the behavior of operations like
factorization into irreducibles.
<P/>
If you need to work with a polynomial ring and its indeterminates the
following two approaches will produce a ring that contains given variables
(see section&nbsp;<Ref Sect="Indeterminates"/> for details about the internal numbering):
Either, first create the ring and then get the indeterminates with
<Ref Func="IndeterminatesOfPolynomialRing"/>. 
<P/>
<Example><![CDATA[
gap> r := PolynomialRing(Rationals,["a","b"]);;
gap> indets := IndeterminatesOfPolynomialRing(r);;
gap> a := indets[1]; a := indets[2];
a
b
]]></Example>
<P/>
Alternatively, first create the
indeterminates and then create the ring including these indeterminates.
<P/>
<Example><![CDATA[
gap> a:=Indeterminate(Rationals,"a":old);;
gap> b:=Indeterminate(Rationals,"b":old);;
gap> PolynomialRing(Rationals,[a,b]);;
]]></Example>
<P/>
As a convenient shortcut, intended mainly for interactive working, the
<M>i</M>-th indeterminate of a polynomial ring <M>R</M> can be accessed as
<M>R.i</M>,
which corresponds exactly to
<C>IndeterminatesOfPolynomialRing</C><M>( R )[i]</M>
or, if it has the name <C>nam</C>, as <M>R</M><C>.nam</C>.
<E>Note</E> that the number <M>i</M> is in general
<E>not</E> the indeterminate number,
but simply an index into the indeterminates list of <M>R</M>.
<P/>
<Example><![CDATA[
gap> r := PolynomialRing(Rationals, ["a", "b"]:old );;
gap> r.1; r.2; r.a; r.b;
a
b
a
b
gap> IndeterminateNumberOfLaurentPolynomial(r.1);
3
]]></Example>
<P/>
Polynomials as &GAP; objects can exist without a polynomial ring being
defined and polynomials cannot be associated to a particular polynomial
ring. (For example dividing a polynomial which is in a polynomial ring over
the integers by another integer will result in a polynomial over the
rationals, not in a rational function over the integers.)
<P/>
<ManSection>
<Heading>PolynomialRing</Heading>
<Oper Name="PolynomialRing" Arg='R, rank[, avoid]'
 Label="for a ring and a rank (and an exclusion list)"/>
<Oper Name="PolynomialRing" Arg='R, names[, avoid]'
 Label="for a ring and a list of names (and an exclusion list)"/>
<Oper Name="PolynomialRing" Arg='R, indets'
 Label="for a ring and a list of indeterminates"/>
<Oper Name="PolynomialRing" Arg='R, indetnums'
 Label="for a ring and a list of indeterminate numbers"/>

<Description>
creates a polynomial ring over the ring <A>R</A>.
If a positive integer <A>rank</A> is given,
this creates the polynomial ring in <A>rank</A> indeterminates.
These indeterminates will have the internal index numbers 1 to
<A>rank</A>.
The second usage takes a list <A>names</A> of strings and returns a
polynomial ring in indeterminates labelled by <A>names</A>.
These indeterminates have <Q>new</Q> internal index numbers as if they
had been created by calls to
<Ref Func="Indeterminate" Label="for a ring (and a number)"/>.
(If the argument <A>avoid</A> is given it contains indeterminates that
should be avoided, in this case internal index numbers are incremented
to skip these variables.)
In the third version, a list of indeterminates <A>indets</A> is given.
This creates the polynomial ring in the indeterminates <A>indets</A>.
Finally, the fourth version specifies indeterminates by their index
numbers.
<P/>
To get the indeterminates of a polynomial ring use
<Ref Func="IndeterminatesOfPolynomialRing"/>.
(Indeterminates created independently with
<Ref Func="Indeterminate" Label="for a ring (and a number)"/>
will usually differ, though they might be given the same name and display
identically, see Section&nbsp;<Ref Sect="Indeterminates"/>.)
</Description>
</ManSection>

<ManSection>
<Attr Name="IndeterminatesOfPolynomialRing" Arg='pring'/>
<Attr Name="IndeterminatesOfFunctionField" Arg='ffield'/>

<Description>
returns a list of the indeterminates of the polynomial ring <A>pring</A>,
respectively the function field <A>ffield</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="CoefficientsRing" Arg='pring'/>

<Description>
returns the ring of coefficients of the polynomial ring <A>pring</A>,
that is the ring over which <A>pring</A> was defined.
<Example><![CDATA[
gap> r:=PolynomialRing(GF(7));
GF(7)[x_1]
gap> r:=PolynomialRing(GF(7),3);
GF(7)[x_1,x_2,x_3]
gap> IndeterminatesOfPolynomialRing(r);
[ x_1, x_2, x_3 ]
gap> r2:=PolynomialRing(GF(7),[5,7,12]);
GF(7)[x_5,x_7,x_12]
gap> CoefficientsRing(r);
GF(7)
gap> r:=PolynomialRing(GF(7),3);
GF(7)[x_1,x_2,x_3]
gap> r2:=PolynomialRing(GF(7),3,IndeterminatesOfPolynomialRing(r));
GF(7)[x_4,x_5,x_6]
gap> r:=PolynomialRing(GF(7),["x","y","z","z2"]);
GF(7)[x,y,z,z2]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPolynomialRing" Arg='pring' Type='Category'/>

<Description>
is the category of polynomial rings
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFiniteFieldPolynomialRing" Arg='pring' Type='Category'/>

<Description>
is the category of polynomial rings over a finite field
(see Chapter&nbsp;<Ref Chap="Finite Fields"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAbelianNumberFieldPolynomialRing" Arg='pring' Type='Category'/>

<Description>
is the category of polynomial rings over a field of cyclotomics
(see the chapters&nbsp;<Ref Chap="Cyclotomic Numbers"/> and <Ref Chap="Abelian Number Fields"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsRationalsPolynomialRing" Arg='pring' Type='Category'/>

<Description>
is the category of polynomial rings over the rationals
(see Chapter&nbsp;<Ref Chap="Rational Numbers"/>).
<Example><![CDATA[
gap> r := PolynomialRing(Rationals, ["a", "b"] );;
gap> IsPolynomialRing(r);
true
gap> IsFiniteFieldPolynomialRing(r);
false
gap> IsRationalsPolynomialRing(r);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>FunctionField</Heading>
<Oper Name="FunctionField" Arg='R, rank[, avoid]'
 Label="for an integral ring and a rank (and an exclusion list)"/>
<Oper Name="FunctionField" Arg='R, names[, avoid]'
 Label="for an integral ring and a list of names (and an exclusion list)"/>
<Oper Name="FunctionField" Arg='R, indets'
 Label="for an integral ring and a list of indeterminates"/>
<Oper Name="FunctionField" Arg='R, indetnums'
 Label="for an integral ring and a list of indeterminate numbers"/>

<Description>
creates a function field over the integral ring <A>R</A>.
If a positive integer <A>rank</A> is given,
this creates the function field in <A>rank</A> indeterminates.
These indeterminates will have the internal index numbers 1 to
<A>rank</A>.
The second usage takes a list <A>names</A> of strings and returns a
function field in indeterminates labelled by <A>names</A>.
These indeterminates have <Q>new</Q> internal index numbers as if they
had been created by calls to
<Ref Func="Indeterminate" Label="for a ring (and a number)"/>.
(If the argument <A>avoid</A> is given it contains indeterminates that
should be avoided, in this case internal index numbers are incremented
to skip these variables.)
In the third version, a list of indeterminates <A>indets</A> is given.
This creates the function field in the indeterminates <A>indets</A>.
Finally, the fourth version specifies indeterminates by their index
number.
<P/>
To get the indeterminates of a function field use
<Ref Func="IndeterminatesOfFunctionField"/>.
(Indeterminates created independently with
<Ref Func="Indeterminate" Label="for a ring (and a number)"/>
will usually differ, though they might be given the same name and display
identically, see Section&nbsp;<Ref Sect="Indeterminates"/>.)
</Description>
</ManSection>

<ManSection>
<Filt Name="IsFunctionField" Arg='ffield' Type='Category'/>

<Description>
is the category of function fields
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Univariate Polynomial Rings">
<Heading>Univariate Polynomial Rings</Heading>

<ManSection>
<Heading>UnivariatePolynomialRing</Heading>
<Oper Name="UnivariatePolynomialRing" Arg='R[, nr]'
 Label="for a ring (and an indeterminate number)"/>
<Oper Name="UnivariatePolynomialRing" Arg='R[, name][, avoid]'
 Label="for a ring (and a name and an exclusion list)"/>

<Description>
returns a univariate polynomial ring in the indeterminate <A>nr</A> over
the base ring <A>R</A>.
If <A>nr</A> is not given it defaults to 1.
<P/>
If the number is not specified a list <A>avoid</A> of indeterminates may
be given.
Then the function will return a ring in an indeterminate that is
guaranteed to be different from all the indeterminates in <A>avoid</A>.
<P/>
Also a string <A>name</A> can be prescribed as the name of the
indeterminate chosen
(also avoiding the indeterminates in the list <A>avoid</A> if given).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsUnivariatePolynomialRing" Arg='pring' Type='Category'/>

<Description>
is the category of polynomial rings with one indeterminate.
<Example><![CDATA[
gap> r:=UnivariatePolynomialRing(Rationals,"p");
Rationals[p]
gap> r2:=PolynomialRing(Rationals,["q"]);
Rationals[q]
gap> IsUnivariatePolynomialRing(r);
true
gap> IsUnivariatePolynomialRing(r2);
true
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Monomial Orderings">
<Heading>Monomial Orderings</Heading>

It is often desirable to consider the monomials within a polynomial to be
arranged with respect to a certain ordering. Such an ordering is called a
<E>monomial ordering</E> if it is total, invariant under multiplication with
other monomials and admits no infinite descending chains. For details on
monomial orderings see <Cite Key="coxlittleoshea"/>.
<P/>
In &GAP;, monomial orderings are represented by objects that provide a way
to compare monomials (as polynomials as well as &ndash;for efficiency purposes
within algorithms&ndash; in the internal representation as lists). 
<P/>
Normally the ordering chosen should be <E>admissible</E>, i.e. it
must be compatible with products:
If <M>a &lt; b</M> then <M>ca &lt; cb</M> for all monomials
<M>a, b</M> and <M>c</M>.
<P/>
Each monomial ordering provides the two functions
<Ref Func="MonomialComparisonFunction"/> and
<Ref Func="MonomialExtrepComparisonFun"/> to compare monomials.
These functions work as <Q>is less than</Q>,
i.e. they return <K>true</K> if and only if the left argument is smaller.
<P/>
<ManSection>
<Filt Name="IsMonomialOrdering" Arg='obj' Type='Category'/>

<Description>
A monomial ordering is an object representing a monomial ordering.
Its  attributes <Ref Func="MonomialComparisonFunction"/> and
<Ref Func="MonomialExtrepComparisonFun"/> are actual comparison functions.
</Description>
</ManSection>

<ManSection>
<Func Name="LeadingMonomialOfPolynomial" Arg='pol,ord'/>

<Description>
returns the leading monomial (with respect to the ordering <A>ord</A>)
of the polynomial <A>pol</A>.
<Example><![CDATA[
gap> x:=Indeterminate(Rationals,"x");;
gap> y:=Indeterminate(Rationals,"y");;
gap> z:=Indeterminate(Rationals,"z");;
gap> lexord:=MonomialLexOrdering();grlexord:=MonomialGrlexOrdering();
MonomialLexOrdering()
MonomialGrlexOrdering()
gap> f:=2*x+3*y+4*z+5*x^2-6*z^2+7*y^3;          
7*y^3+5*x^2-6*z^2+2*x+3*y+4*z
gap> LeadingMonomialOfPolynomial(f,lexord);
x^2
gap> LeadingMonomialOfPolynomial(f,grlexord);
y^3
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LeadingTermOfPolynomial" Arg='pol,ord'/>

<Description>
returns the leading term (with respect to the ordering <A>ord</A>)
of the polynomial <A>pol</A>, i.e. the product of leading coefficient and
leading monomial.
</Description>
</ManSection>

<ManSection>
<Oper Name="LeadingCoefficientOfPolynomial" Arg='pol,ord'/>

<Description>
returns the leading coefficient (that is the coefficient of the leading
monomial, see&nbsp;<Ref Func="LeadingMonomialOfPolynomial"/>) of the polynomial <A>pol</A>.
<Example><![CDATA[
gap> LeadingTermOfPolynomial(f,lexord);
5*x^2
gap> LeadingTermOfPolynomial(f,grlexord);
7*y^3
gap> LeadingCoefficientOfPolynomial(f,lexord);
5
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MonomialComparisonFunction" Arg='O'/>

<Description>
If <A>O</A> is an object representing a monomial ordering, this attribute
returns a <E>function</E> that can be used to compare or sort monomials (and
polynomials which will be compared by their monomials in decreasing
order) in this order.
<Example><![CDATA[
gap> MonomialComparisonFunction(lexord);
function( a, b ) ... end
gap> l:=[f,Derivative(f,x),Derivative(f,y),Derivative(f,z)];;
gap> Sort(l,MonomialComparisonFunction(lexord));l;
[ -12*z+4, 21*y^2+3, 10*x+2, 7*y^3+5*x^2-6*z^2+2*x+3*y+4*z ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MonomialExtrepComparisonFun" Arg='O'/>

<Description>
If <A>O</A> is an object representing a monomial ordering, this attribute
returns a <E>function</E> that can be used to compare or sort monomials <E>in
their external representation</E> (as lists). This comparison variant is
used inside algorithms that manipulate the external representation.
</Description>
</ManSection>

<ManSection>
<Func Name="MonomialLexOrdering" Arg='[vari]'/>

<Description>
This function creates a lexicographic ordering for monomials.
Monomials are compared first by the exponents of the largest variable,
then the exponents of the second largest variable and so on.
<P/>
The variables are ordered according to their (internal) index, i.e.,
<M>x_1</M> is larger than <M>x_2</M> and so on.
If <A>vari</A> is given, and is a list of variables or variable indices,
instead this arrangement of variables (in descending order; i.e. the
first variable is larger than the second) is 
used as the underlying order of variables.
<Example><![CDATA[
gap> l:=List(Tuples([1..3],3),i->x^(i[1]-1)*y^(i[2]-1)*z^(i[3]-1));
[ 1, z, z^2, y, y*z, y*z^2, y^2, y^2*z, y^2*z^2, x, x*z, x*z^2, x*y, 
  x*y*z, x*y*z^2, x*y^2, x*y^2*z, x*y^2*z^2, x^2, x^2*z, x^2*z^2, 
  x^2*y, x^2*y*z, x^2*y*z^2, x^2*y^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialLexOrdering()));l;
[ 1, z, z^2, y, y*z, y*z^2, y^2, y^2*z, y^2*z^2, x, x*z, x*z^2, x*y, 
  x*y*z, x*y*z^2, x*y^2, x*y^2*z, x*y^2*z^2, x^2, x^2*z, x^2*z^2, 
  x^2*y, x^2*y*z, x^2*y*z^2, x^2*y^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialLexOrdering([y,z,x])));l;
[ 1, x, x^2, z, x*z, x^2*z, z^2, x*z^2, x^2*z^2, y, x*y, x^2*y, y*z, 
  x*y*z, x^2*y*z, y*z^2, x*y*z^2, x^2*y*z^2, y^2, x*y^2, x^2*y^2, 
  y^2*z, x*y^2*z, x^2*y^2*z, y^2*z^2, x*y^2*z^2, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialLexOrdering([z,x,y])));l;
[ 1, y, y^2, x, x*y, x*y^2, x^2, x^2*y, x^2*y^2, z, y*z, y^2*z, x*z, 
  x*y*z, x*y^2*z, x^2*z, x^2*y*z, x^2*y^2*z, z^2, y*z^2, y^2*z^2, 
  x*z^2, x*y*z^2, x*y^2*z^2, x^2*z^2, x^2*y*z^2, x^2*y^2*z^2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MonomialGrlexOrdering" Arg='[vari]'/>

<Description>
This function creates a degree/lexicographic ordering.
In this ordering monomials are compared first by their total degree,
then lexicographically (see <Ref Func="MonomialLexOrdering"/>).
<P/>
The variables are ordered according to their (internal) index, i.e.,
<M>x_1</M> is larger than <M>x_2</M> and so on.
If <A>vari</A> is given, and is a list of variables or variable indices,
instead this arrangement of variables (in descending order; i.e. the
first variable is larger than the second) is 
used as the underlying order of variables.
</Description>
</ManSection>

<ManSection>
<Func Name="MonomialGrevlexOrdering" Arg='[vari]'/>

<Description>
This function creates a <Q>grevlex</Q> ordering.
In this ordering monomials are compared first by total degree and then
backwards lexicographically.
(This is different than <Q>grlex</Q> ordering with variables reversed.) 
<P/>
The variables are ordered according to their (internal) index, i.e.,
<M>x_1</M> is larger than <M>x_2</M> and so on.
If <A>vari</A> is given, and is a list of variables or variable indices,
instead this arrangement of variables (in descending order; i.e. the
first variable is larger than the second) is 
used as the underlying order of variables.
<Example><![CDATA[
gap> Sort(l,MonomialComparisonFunction(MonomialGrlexOrdering()));l;
[ 1, z, y, x, z^2, y*z, y^2, x*z, x*y, x^2, y*z^2, y^2*z, x*z^2, 
  x*y*z, x*y^2, x^2*z, x^2*y, y^2*z^2, x*y*z^2, x*y^2*z, x^2*z^2, 
  x^2*y*z, x^2*y^2, x*y^2*z^2, x^2*y*z^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialGrevlexOrdering()));l;
[ 1, z, y, x, z^2, y*z, x*z, y^2, x*y, x^2, y*z^2, x*z^2, y^2*z, 
  x*y*z, x^2*z, x*y^2, x^2*y, y^2*z^2, x*y*z^2, x^2*z^2, x*y^2*z, 
  x^2*y*z, x^2*y^2, x*y^2*z^2, x^2*y*z^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialGrlexOrdering([z,y,x])));l;
[ 1, x, y, z, x^2, x*y, y^2, x*z, y*z, z^2, x^2*y, x*y^2, x^2*z, 
  x*y*z, y^2*z, x*z^2, y*z^2, x^2*y^2, x^2*y*z, x*y^2*z, x^2*z^2, 
  x*y*z^2, y^2*z^2, x^2*y^2*z, x^2*y*z^2, x*y^2*z^2, x^2*y^2*z^2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="EliminationOrdering" Arg='elim[, rest]'/>

<Description>
This function creates an elimination ordering for eliminating the
variables in <A>elim</A>.
Two monomials are compared first by the exponent vectors for the
variables listed in <A>elim</A> (a lexicographic comparison with respect
to the ordering indicated in <A>elim</A>).
If these submonomial are equal, the submonomials given by the other
variables are compared by a graded lexicographic ordering
(with respect to the variable order given in <A>rest</A>,
if called with two parameters).
<P/>
Both <A>elim</A> and <A>rest</A> may be a list of variables or a list of
variable indices.
</Description>
</ManSection>

<ManSection>
<Func Name="PolynomialReduction" Arg='poly,gens,order'/>

<Description>
reduces the polynomial <A>poly</A> by the ideal generated by the polynomials
in <A>gens</A>, using the order <A>order</A> of monomials.  Unless <A>gens</A> is a
Gröbner basis the result is not guaranteed to be unique.
<P/>
The operation returns a list of length two, the first entry is the
remainder after the reduction. The second entry is a list of quotients
corresponding to <A>gens</A>.
<P/>
Note that the strategy used by <Ref Func="PolynomialReduction"/> differs from the 
standard textbook reduction algorithm, which is provided by
<Ref Func="PolynomialDivisionAlgorithm"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="PolynomialReducedRemainder" Arg='poly,gens,order'/>

<Description>
this operation does the same way as
<Ref Func="PolynomialReduction"/> but does not keep track of the actual quotients
and returns only the remainder (it is therefore slightly faster).
</Description>
</ManSection>

<ManSection>
<Func Name="PolynomialDivisionAlgorithm" Arg='poly,gens,order'/>

<Description>
This function implements the division algorithm for multivariate
polynomials as given in
<Cite Key="coxlittleoshea" Where="Theorem 3 in Chapter 2"/>.
(It might be slower than <Ref Func="PolynomialReduction"/> but the
remainders are guaranteed to agree with the textbook.)
<P/>
The operation returns a list of length two, the first entry is the
remainder after the reduction. The second entry is a list of quotients
corresponding to <A>gens</A>.
<Example><![CDATA[
gap> bas:=[x^3*y*z,x*y^2*z,z*y*z^3+x];;
gap> pol:=x^7*z*bas[1]+y^5*bas[3]+x*z;;
gap> PolynomialReduction(pol,bas,MonomialLexOrdering()); 
[ -y*z^5, [ x^7*z, 0, y^5+z ] ]
gap> PolynomialReducedRemainder(pol,bas,MonomialLexOrdering());
-y*z^5
gap> PolynomialDivisionAlgorithm(pol,bas,MonomialLexOrdering());
[ -y*z^5, [ x^7*z, 0, y^5+z ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MonomialExtGrlexLess" Arg='a,b'/>

<Description>
implements comparison of monomial in their external representation by a 
<Q>grlex</Q> order with <M>x_1>x_2</M>
(This is exactly the same as the ordering by
<Ref Func="MonomialGrlexOrdering"/>,
see&nbsp; <Ref Sect="Monomial Orderings"/>).
The function takes two
monomials <A>a</A> and <A>b</A> in expanded form and returns whether the first is
smaller than the second. (This ordering is also used by &GAP;
internally for representing polynomials as a linear combination of
monomials.)
<P/>
See section&nbsp;<Ref Sect="The Defining Attributes of Rational Functions"/> for details
on the expanded form of monomials.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Groebner Bases">
<Heading>Groebner Bases</Heading>

A <E>Groebner Basis</E> of an ideal <M>I</M>i, in a polynomial ring <M>R</M>, with
respect to a monomial ordering, is a set of ideal generators <A>G</A> such that
the ideal generated by the leading monomials of all polynomials in <A>G</A> is
equal to the ideal generated by the leading monomials of all polynomials
in <A>I</A>.
<P/>
For more details on Groebner bases see <Cite Key="coxlittleoshea"/>.

<ManSection>
<Heading>GroebnerBasis</Heading>
<Oper Name="GroebnerBasis" Arg='L, O'
 Label="for a list and a monomial ordering"/>
<Oper Name="GroebnerBasis" Arg='I, O'
 Label="for an ideal and a monomial ordering"/>
<Oper Name="GroebnerBasisNC" Arg='L, O'/>

<Description>
Let <A>O</A> be a monomial ordering and <A>L</A> be a list of polynomials
that generate an ideal <A>I</A>.
This operation returns a Groebner basis of <A>I</A> with respect to the
ordering <A>O</A>.
<P/>
<Ref Oper="GroebnerBasisNC"/> works like
<Ref Oper="GroebnerBasis" Label="for a list and a monomial ordering"/>
with the only distinction that the first argument has to be a list of
polynomials and that no test is performed to check whether the ordering
is defined for all occuring variables.
<P/>
Note that &GAP; at the moment only includes
a naïve implementation of Buchberger's algorithm (which is mainly
intended as a teaching tool).
It might not be sufficient for serious problems.
<Example><![CDATA[
gap> l:=[x^2+y^2+z^2-1,x^2+z^2-y,x-y];;
gap> GroebnerBasis(l,MonomialLexOrdering());
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1, -z^2+2*y-1, 
  1/2*z^4+2*z^2-1/2 ]
gap> GroebnerBasis(l,MonomialLexOrdering([z,x,y]));
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1 ]
gap> GroebnerBasis(l,MonomialGrlexOrdering());
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1, -z^2+2*y-1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>ReducedGroebnerBasis</Heading>
<Oper Name="ReducedGroebnerBasis" Arg='L, O'
 Label="for a list and a monomial ordering"/>
<Oper Name="ReducedGroebnerBasis" Arg='I, O'
 Label="for an ideal and a monomial ordering"/>

<Description>
a Groebner basis <M>B</M>
(see&nbsp;<Ref Func="GroebnerBasis" Label="for a list and a monomial ordering"/>)
is <E>reduced</E> if no monomial in a polynomial in <A>B</A> is divisible
by the leading monomial of another polynomial in <M>B</M>.
This operation computes a Groebner basis with respect
to the monomial ordering <A>O</A> and then reduces it.
<P/>
<Example><![CDATA[
gap> ReducedGroebnerBasis(l,MonomialGrlexOrdering());
[ x-y, z^2-2*y+1, y^2+y-1 ]
gap> ReducedGroebnerBasis(l,MonomialLexOrdering());    
[ z^4+4*z^2-1, -1/2*z^2+y-1/2, -1/2*z^2+x-1/2 ]
gap> ReducedGroebnerBasis(l,MonomialLexOrdering([y,z,x]));
[ x^2+x-1, z^2-2*x+1, -x+y ]
]]></Example>
<P/>
For performance reasons it can be advantageous to define
monomial orderings once and then to reuse them:
<P/>
<Example><![CDATA[
gap> ord:=MonomialGrlexOrdering();;
gap> GroebnerBasis(l,ord);
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1, -z^2+2*y-1 ]
gap> ReducedGroebnerBasis(l,ord);
[ x-y, z^2-2*y+1, y^2+y-1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="StoredGroebnerBasis" Arg='I'/>

<Description>
For an ideal <A>I</A> in a polynomial ring, this attribute holds a list
<M>[ B, O ]</M> where <M>B</M> is a Groebner basis for the monomial
ordering <M>O</M>.
this can be used to test membership or canonical coset representatives.
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoGroebner"/>

<Description>
This info class gives information about Groebner basis calculations.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Rational Function Families">
<Heading>Rational Function Families</Heading>

All rational functions defined over a ring lie in the same family, the
rational functions family over this ring.
<P/>
In &GAP; therefore the family of a polynomial depends only on the family of
the coefficients, all polynomials whose coefficients lie in the same family
are <Q>compatible</Q>.

<ManSection>
<Attr Name="RationalFunctionsFamily" Arg='fam'/>

<Description>
creates a   family  containing rational functions  with   coefficients
in <A>fam</A>. 
All elements of the <Ref Func="RationalFunctionsFamily"/> are
rational functions (see&nbsp;<Ref Func="IsRationalFunction"/>).
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPolynomialFunctionsFamily" Arg='obj' Type='Category'/>
<Filt Name="IsRationalFunctionsFamily" Arg='obj' Type='Category'/>

<Description>
<Ref Func="IsPolynomialFunctionsFamily"/> is the category of a family of
polynomials.
For families over an UFD, the category becomes
<Ref Func="IsRationalFunctionsFamily"/> (as rational functions and
quotients are only provided for families over an UFD.)
<!--  1996/10/14 fceller can this be done with <C>CategoryFamily</C>?-->
<P/>
<Log><![CDATA[
gap> fam:=RationalFunctionsFamily(FamilyObj(1));
NewFamily( "RationalFunctionsFamily(...)", [ 618, 620 ],
[ 82, 85, 89, 93, 97, 100, 103, 107, 111, 618, 620 ] )
]]></Log>
</Description>
</ManSection>

<ManSection>
<Attr Name="CoefficientsFamily" Arg='rffam'/>

<Description>
If <A>rffam</A> has been created as
<C>RationalFunctionsFamily(<A>cfam</A>)</C> this attribute holds the
coefficients family <A>cfam</A>.
<P/>
&GAP; does <E>not</E> embed the base ring in the polynomial ring. While
multiplication and addition of base ring elements to rational functions
return the expected results, polynomials and rational functions are not
equal.
<Example><![CDATA[
gap> 1=Indeterminate(Rationals)^0;
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Representations of Rational Functions">
<Heading>The Representations of Rational Functions</Heading>

&GAP; uses four representations of rational functions: Rational
functions given by numerator and denominator, polynomials, univariate
rational functions (given by coefficient lists for numerator and denominator
and valuation) and
Laurent polynomials (given by coefficient list and valuation).
<P/>
These representations do not necessarily reflect mathematical properties:
While an object in the Laurent polynomials representation must be a
Laurent polynomial it might turn out that a rational function given by
numerator and denominator is actually a Laurent polynomial and the property
tests in section&nbsp;<Ref Sect="Properties and Attributes of Rational Functions"/> will find
this out.
<P/>
Each representation is associated one or several <Q>defining attributes</Q>
that give an <Q>external</Q> representation
(see&nbsp;<Ref Sect="The Defining Attributes of Rational Functions"/>)
of the representation in the form of lists and are the defining information
that tells a rational function what it is.
<P/>
&GAP; also implements methods to compute these attributes for rational
functions in <E>other</E> representations, provided it would be possible to
express an <E>mathematically equal</E> rational function in the representation
associated with the attribute. (That is one can always get a
numerator/denominator representation of a polynomial while an arbitrary
function of course can compute a polynomial representation only if it is a
polynomial.)
<P/>
Therefore these attributes can be thought of as <Q>conceptual</Q>
representations that allow us &ndash;as far as possible&ndash;
to consider an object as a rational function, a polynomial or a Laurent
polynomial, regardless of the way it is represented in the computer.
<P/>
Functions thus usually do not need to care about the representation of
a rational function. Depending on its (known in the context or determined)
properties, they can access the attribute representing the rational function
in the desired way.
<P/>
Consequentially, methods for rational functions are installed for properties
and not for representations.
<P/>
When <E>creating</E> new rational functions however they must be created in one
of the three representations. In most cases this will be the representation
for which the <Q>conceptual</Q> representation in which the calculation was done
is the defining attribute.
<P/>
Iterated operations (like forming the product over a list) therefore will
tend to stay in the most suitable representation and the calculation of
another conceptual representation (which may be comparatively expensive in
certain circumstances) is not necessary.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Defining Attributes of Rational Functions">
<Heading>The Defining Attributes of Rational Functions</Heading>

In general, rational functions are given in terms of monomials.
They are represented by lists, using numbers
(see&nbsp;<Ref Sect="Indeterminates"/>) for the indeterminates.
<P/>
<Index>Expanded form of monomials</Index>
A monomial is a product of powers of indeterminates. A monomial is
stored as a list (we call this the <E>expanded form</E> of the monomial)
of the form <C>[<A>inum</A>,<A>exp</A>,<A>inum</A>,<A>exp</A>,...]</C> where each <A>inum</A>
is the number of an indeterminate and <A>exp</A> the corresponding exponent.
The list must be sorted according to the numbers of the indeterminates.
Thus for example, if <M>x</M>, <M>y</M> and <M>z</M> are the first three indeterminates,
the expanded form of the monomial <M>x^5 z^8 = z^8 x^5</M> is
<C>[ 1, 5, 3, 8 ]</C>.

<Index>External representation of polynomials</Index>
The representation of a polynomials is a list of the form
<C>[<A>mon</A>,<A>coeff</A>,<A>mon</A>,<A>coeff</A>,...]</C> where <A>mon</A> is a monomial in
expanded form (that is given as list) and <A>coeff</A> its coefficient. The
monomials must be sorted according to the total degree/lexicographic
order (This is the same as given by the <Q>grlex</Q> monomial ordering,
see&nbsp;<Ref Func="MonomialGrlexOrdering"/>). We call
this the <E>external representation</E> of a polynomial. (The
reason for ordering is that addition of polynomials becomes linear in
the number of monomials instead of quadratic; the reason for the
particular ordering chose is that it is compatible with multiplication
and thus gives acceptable performance for quotient calculations.)

<P/>
The attributes that give a representation of a a rational function as a Laurent polynomial are
<Ref Func="CoefficientsOfLaurentPolynomial"/>
and <Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/>.
<P/>
Algorithms should use only the attributes
<Ref Func="ExtRepNumeratorRatFun"/>,
<Ref Func="ExtRepDenominatorRatFun"/>,
<Ref Func="ExtRepPolynomialRatFun"/>,
<Ref Func="CoefficientsOfLaurentPolynomial"/> and
&ndash;if the univariate function is not constant&ndash;
<Ref Func="IndeterminateNumberOfUnivariateRationalFunction"/> as the
low-level interface to work with a polynomial.
They should not refer to the actual representation used.

<ManSection>
<Filt Name="IsRationalFunctionDefaultRep" Arg='obj' Type='Representation'/>

<Description>
is the default representation of rational functions. A rational function
in this representation is defined by the attributes
<Ref Func="ExtRepNumeratorRatFun"/> and
<Ref Func="ExtRepDenominatorRatFun"/>,
the values of which are external representations of polynomials.
</Description>
</ManSection>

<ManSection>
<Attr Name="ExtRepNumeratorRatFun" Arg='ratfun'/>

<Description>
returns the external representation of the numerator polynomial of the
rational function <A>ratfun</A>. Numerator and denominator are not guaranteed
to be cancelled against each other.
</Description>
</ManSection>

<ManSection>
<Attr Name="ExtRepDenominatorRatFun" Arg='ratfun'/>

<Description>
returns the external representation of the denominator polynomial of the
rational function <A>ratfun</A>. Numerator and denominator are not guaranteed
to be cancelled against each other.
</Description>
</ManSection>

<ManSection>
<Oper Name="ZeroCoefficientRatFun" Arg='ratfun'/>

<Description>
returns the zero of the coefficient ring. This might be needed to
represent the zero polynomial for which the external representation of
the numerator is the empty list.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPolynomialDefaultRep" Arg='obj' Type='Representation'/>

<Description>
is the default representation of polynomials. A polynomial
in this representation is defined by the components
and <Ref Func="ExtRepNumeratorRatFun"/> where
<Ref Func="ExtRepNumeratorRatFun"/> is the
external representation of the polynomial.
</Description>
</ManSection>

<ManSection>
<Attr Name="ExtRepPolynomialRatFun" Arg='polynomial'/>

<Description>
returns the external representation of a polynomial. The difference to
<Ref Func="ExtRepNumeratorRatFun"/> is that rational functions might know
to be a polynomial but can still have a non-vanishing denominator.
In this case
<Ref Func="ExtRepPolynomialRatFun"/> has to call a quotient routine.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsLaurentPolynomialDefaultRep" Arg='obj' Type='Representation'/>

<Description>
This representation is used for Laurent polynomials and univariate
polynomials. It represents a Laurent polynomial via the attributes
<Ref Func="CoefficientsOfLaurentPolynomial"/> and
<Ref Func="IndeterminateNumberOfLaurentPolynomial"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creation of Rational Functions">
<Heading>Creation of Rational Functions</Heading>

The operations <Ref Oper="LaurentPolynomialByCoefficients"/>,
<Ref Func="PolynomialByExtRep"/> and
<Ref Func="RationalFunctionByExtRep"/> are used to
construct objects in the three basic representations for rational
functions.

<ManSection>
<Func Name="RationalFunctionByExtRep" Arg='rfam, num, den'/>
<Func Name="RationalFunctionByExtRepNC" Arg='rfam, num, den'/>

<Description>
constructs a rational function (in the representation
<Ref Func="IsRationalFunctionDefaultRep"/>) in the rational function
family <A>rfam</A>,
the rational function itself is given by the external representations
<A>num</A> and <A>den</A> for numerator and denominator.
No cancellation takes place.
<P/>
The variant <Ref Func="RationalFunctionByExtRepNC"/> does not perform any
test of the arguments and thus potentially can create illegal objects.
It only should be used if speed is required and the arguments are known
to be in correct form.
</Description>
</ManSection>

<ManSection>
<Func Name="PolynomialByExtRep" Arg='rfam, extrep'/>
<Func Name="PolynomialByExtRepNC" Arg='rfam, extrep'/>

<Description>
constructs a polynomial
(in the representation <Ref Func="IsPolynomialDefaultRep"/>)
in the rational function family <A>rfam</A>, the polynomial itself is given
by the external representation <A>extrep</A>.
<P/>
The variant <Ref Func="PolynomialByExtRepNC"/> does not perform any test
of the arguments and thus potentially can create invalid objects. It only
should be used if speed is required and the arguments are known to be
in correct form.
<Example><![CDATA[
gap> fam:=RationalFunctionsFamily(FamilyObj(1));;
gap> p:=PolynomialByExtRep(fam,[[1,2],1,[2,1,15,7],3]);
3*y*x_15^7+x^2
gap> q:=p/(p+1);
(3*y*x_15^7+x^2)/(3*y*x_15^7+x^2+1)
gap> ExtRepNumeratorRatFun(q);
[ [ 1, 2 ], 1, [ 2, 1, 15, 7 ], 3 ]
gap> ExtRepDenominatorRatFun(q);
[ [  ], 1, [ 1, 2 ], 1, [ 2, 1, 15, 7 ], 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LaurentPolynomialByExtRep" Arg='fam, cofs,val ,ind'/>
<Func Name="LaurentPolynomialByExtRepNC" Arg='fam, cofs,val ,ind'/>

<Description>
creates a Laurent polynomial in the family <A>fam</A> with [<A>cofs</A>,<A>val</A>] as
value of <Ref Func="CoefficientsOfLaurentPolynomial"/>. No coefficient shifting is
performed.  This is the lowest level function to create a Laurent
polynomial but will rely on the coefficients being shifted properly and
will not perform any tests. Unless this is guaranteed for the
parameters,
<Ref Func="LaurentPolynomialByCoefficients"/> should be used.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic for External Representations of Polynomials">
<Heading>Arithmetic for External Representations of Polynomials</Heading>

The following operations are used internally to perform the arithmetic for
polynomials in their <Q>external</Q> representation
(see&nbsp;<Ref Sect="The Defining Attributes of Rational Functions"/>)
as lists.
<P/>
Functions to perform arithmetic with the coefficient lists of Laurent
polynomials are described in
Section&nbsp;<Ref Sect="Coefficient List Arithmetic"/>.

<ManSection>
<Oper Name="ZippedSum" Arg='z1, z2, czero, funcs'/>

<Description>
computes the sum of two external representations of polynomials
<A>z1</A> and <A>z2</A>.
<A>czero</A> is the appropriate coefficient zero and <A>funcs</A> a list
[ <A>monomial_less</A>, <A>coefficient_sum</A> ] containing a monomial
comparison and a coefficient addition function.
This list can be found in the component <A>fam</A><C>!.zippedSum</C>
of the rational functions family.
<P/>
Note that <A>coefficient_sum</A> must be a proper <Q>summation</Q>
function, not a function computing differences.
</Description>
</ManSection>

<ManSection>
<Oper Name="ZippedProduct" Arg='z1, z2, czero, funcs'/>

<Description>
computes the product of two external representations of polynomials
<A>z1</A> and <A>z2</A>.
<A>czero</A> is the appropriate coefficient zero and <A>funcs</A> a list
[ <A>monomial_prod</A>, <A>monomial_less</A>, <A>coefficient_sum</A>,
<A>coefficient_prod</A>] containing functions to multiply and compare
monomials, to add and to multiply coefficients.
This list can be found in the component <C><A>fam</A>!.zippedProduct</C>
of the rational functions family.
</Description>
</ManSection>

<ManSection>
<Func Name="QuotientPolynomialsExtRep" Arg='fam,a,b'/>

<Description>
Let <A>a</A> and <A>b</A> the external representations of two polynomials
in the rational functions family <A>fam</A>.
This function computes the external representation of the quotient of
both polynomials,
it returns <K>fail</K> if the polynomial described by <A>b</A> does not
divide the polynomial described by <A>a</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Cancellation Tests for Rational Functions">
<Heading>Cancellation Tests for Rational Functions</Heading>

The operation <Ref Func="Gcd" Label="for (a ring and) several elements"/>
can be used to test for common factors of two polynomials.
This however would be too expensive to be done in the arithmetic,
thus uses the following
operations internally to try to keep the denominators as small as
possible

<ManSection>
<Func Name="RationalFunctionByExtRepWithCancellation" Arg='rfam, num, den'/>

<Description>
constructs a rational function as <Ref Func="RationalFunctionByExtRep"/>
does but tries to cancel out common factors of numerator and denominator,
calling <Ref Func="TryGcdCancelExtRepPolynomials"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="TryGcdCancelExtRepPolynomials" Arg='fam,a,b'/>

<Description>
Let <A>a</A> and <A>b</A> be the external representations of two
polynomials.
This function tries to cancel common factors between the corresponding
polynomials and returns a list <M>[ a', b' ]</M> of
external representations of cancelled polynomials.
As there is no proper multivariate GCD
cancellation is not guaranteed to be optimal.
</Description>
</ManSection>

<ManSection>
<Oper Name="HeuristicCancelPolynomials" Arg='fam,ext1,ext2'/>

<Description>
is called by <Ref Func="TryGcdCancelExtRepPolynomials"/> to perform the
actual work.
It will return either <K>fail</K> or a new list of of external
representations of cancelled polynomials.
The cancellation performed is not necessarily optimal.
</Description>
</ManSection>


</Section>
</Chapter>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  algfld.msk                 GAP documentation             Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: algfld.msk,v 1.6 2006/10/19 10:32:09 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Algebraic extensions of fields">
<Heading>Algebraic extensions of fields</Heading>

If we adjoin a root <M>\alpha</M> of an irreducible polynomial <M>f \in K[x]</M> to
the field <M>K</M> we get an <E>algebraic extension</E> <M>K(\alpha)</M>, which is again
a field. We call <M>K</M> the <E>base field</E> of <M>K(\alpha)</M>.
<P/>
By Kronecker's construction, we may identify <M>K(\alpha)</M> with
the factor ring <M>K[x]/(f)</M>, an identification that also provides a method
for computing in these extension fields.
<P/>
It is important to note that different extensions of the same field are
entirely different (and its elements lie in different families), even if
mathematically one could be embedded in the other one.
<P/>
Currently &GAP; only allows extension fields of fields <M>K</M>, when <M>K</M>
itself is not an extension field.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creation of Algebraic Extensions">
<Heading>Creation of Algebraic Extensions</Heading>

<ManSection>
<Oper Name="AlgebraicExtension" Arg='K,f'/>

<Description>
constructs an extension <A>L</A> of the field <A>K</A> by one root of the
irreducible polynomial <A>f</A>, using Kronecker's construction.
<A>L</A> is a field whose <Ref Attr="LeftActingDomain"/> value is
<A>K</A>.
The  polynomial <A>f</A> is the <Ref Attr="DefiningPolynomial"/> value
of <A>L</A> and the attribute
<Ref Func="RootOfDefiningPolynomial"/>
of <A>L</A> holds a root of <A>f</A> in <A>L</A>.
<Example><![CDATA[
gap> x:=Indeterminate(Rationals,"x");;
gap> p:=x^4+3*x^2+1;;
gap> e:=AlgebraicExtension(Rationals,p);
<algebraic extension over the Rationals of degree 4>
gap> IsField(e);
true
gap> a:=RootOfDefiningPolynomial(e);
a
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsAlgebraicExtension" Arg='obj' Type='Category'/>

<Description>
is the category of algebraic extensions of fields.
<Example><![CDATA[
gap> IsAlgebraicExtension(e);
true
gap> IsAlgebraicExtension(Rationals);
false
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elements in Algebraic Extensions">
<Heading>Elements in Algebraic Extensions</Heading>

<Index>Operations for algebraic elements</Index>
According to Kronecker's construction, the elements of an algebraic
extension are considered to be polynomials in the primitive element.
The elements of the base field are represented as polynomials of degree zero.
&GAP; therefore displays elements of an algebraic extension as polynomials
in an indeterminate <Q>a</Q>, which is a root of the defining polynomial of the
extension.
Polynomials of degree zero are displayed with a leading exclamation mark to
indicate that they are different from elements of the base field.
<P/>
The usual field operations are applicable to algebraic elements.
<P/>
<Example><![CDATA[
gap> a^3/(a^2+a+1);
-1/2*a^3+1/2*a^2-1/2*a
gap> a*(1/a);
!1
]]></Example>
<P/>
The external representation of algebraic extension elements are the
polynomial coefficients in the primitive element <C>a</C>,
the operations <Ref Func="ExtRepOfObj"/> and <Ref Func="ObjByExtRep"/>
can be used for conversion.
<P/>
<Example><![CDATA[
gap> ExtRepOfObj(One(a));
[ 1, 0, 0, 0 ]
gap> ExtRepOfObj(a^3+2*a-9);
[ -9, 2, 0, 1 ]
gap> ObjByExtRep(FamilyObj(a),[3,19,-27,433]);
433*a^3-27*a^2+19*a+3
]]></Example>
<P/>
&GAP; does <E>not</E> embed the base field in its algebraic extensions and
therefore lists which contain elements of the base field and of the
extension are not homogeneous and thus cannot be used as polynomial
coefficients or to form matrices. The remedy is to multiply the
list(s) with the value of the attribute <Ref Attr="One"/> of the extension
which will embed all entries in the extension.
<P/>
<Example><![CDATA[
gap> m:=[[1,a],[0,1]];
[ [ 1, a ], [ 0, 1 ] ]
gap> IsMatrix(m);
false
gap> m:=m*One(e);
[ [ !1, a ], [ !0, !1 ] ]
gap> IsMatrix(m);
true
gap> m^2;
[ [ !1, 2*a ], [ !0, !1 ] ]
]]></Example>

<ManSection>
<Filt Name="IsAlgebraicElement" Arg='obj' Type='Category'/>

<Description>
is the category for elements of an algebraic extension.
</Description>
</ManSection>


</Section>
</Chapter>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  padics.msk                  GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: padics.msk,v 1.6 2002/04/15 10:02:31 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="p-adic Numbers">
<Heading>p-adic Numbers (preliminary)</Heading>

In this chapter <M>p</M> is always a (fixed) prime integer.
<P/>
The <M>p</M>-adic numbers <M>Q_p</M> are the completion of the rational
numbers with respect to the valuation <M>\nu_p( p^v \cdot a / b) = v</M>
if <M>p</M> divides neither <M>a</M> nor <M>b</M>.
They form a field of characteristic 0 which nevertheless shows
some behaviour of the finite field with <M>p</M> elements.
<P/>
A <M>p</M>-adic numbers can be represented by a
<Q><M>p</M>-adic expansion</Q> which is similar to the decimal expansion
used for the reals (but written from left to right).
So for example if <M>p = 2</M>, the numbers <M>1</M>, <M>2</M>, <M>3</M>,
<M>4</M>, <M>1/2</M>, and <M>4/5</M>
are represented as <M>1(2)</M>, <M>0.1(2)</M>, <M>1.1(2)</M>, <M>0.01(2)</M>,
<M>10(2)</M>, and the infinite periodic
expansion <M>0.010110011001100...(2)</M>.

<M>p</M>-adic numbers can be approximated by ignoring higher powers of <M>p</M>,
so for example with only 2 digits accuracy <M>4/5</M> would be approximated
as <M>0.01(2)</M>.
This is different from the decimal approximation of real numbers in that
<M>p</M>-adic approximation is a ring homomorphism on the subrings of
<M>p</M>-adic numbers whose valuation is bounded from below so that
rounding errors do not increase with repeated calculations.
<P/>

In &GAP;, <M>p</M>-adic numbers are always represented by such approximations.
A family of approximated <M>p</M>-adic numbers consists of
<M>p</M>-adic numbers with a fixed prime <M>p</M> and a certain precision,
and arithmetic with these numbers is done with this precision.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Pure p-adic Numbers">
<Heading>Pure p-adic Numbers</Heading>

Pure <M>p</M>-adic numbers are the <M>p</M>-adic numbers described so far.

<ManSection>
<Oper Name="PurePadicNumberFamily" Arg='p, precision'/>

<Description>
returns the family of pure <M>p</M>-adic numbers over the
prime <A>p</A> with <A>precision</A> <Q>digits</Q>. That is to say, the approximate value
will differ from the correct value by a multiple of <M>p^{digits}</M>.
</Description>
</ManSection>


<ManSection>
<Func Name="PadicNumber" Arg='fam, rat' Label="for pure padics"/>

<Description>
returns the element of the <M>p</M>-adic number family <A>fam</A>
that approximates the rational number <A>rat</A>.
<P/>
<M>p</M>-adic numbers allow the usual operations for fields.
<P/>
<Example><![CDATA[
gap> fam:=PurePadicNumberFamily(2,20);;
gap> a:=PadicNumber(fam,4/5);
0.010110011001100110011(2)
gap> fam:=PurePadicNumberFamily(2,3);;
gap> a:=PadicNumber(fam,4/5);
0.0101(2)
gap> 3*a;
0.0111(2)
gap> a/2;
0.101(2)
gap> a*10;
0.001(2)
]]></Example>
See 
<Ref Oper="PadicNumber" Label="for a p-adic extension family and a rational"/>
for other methods for <Ref Oper="PadicNumber" Label="for pure padics"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Valuation" Arg='obj'/>

<Description>
The valuation is the <M>p</M>-part of the <M>p</M>-adic number.
</Description>
</ManSection>

<ManSection>
<Oper Name="ShiftedPadicNumber" Arg='padic, int'/>

<Description>
<Ref Func="ShiftedPadicNumber"/> takes a <M>p</M>-adic number
<A>padic</A> and an integer <A>shift</A>
and returns the <M>p</M>-adic number <M>c</M>,
that is <A>padic</A> <C>*</C> <M>p</M><C>^</C><A>shift</A>.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPurePadicNumber" Arg='obj' Type='Category'/>

<Description>
The category of pure <M>p</M>-adic numbers.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPurePadicNumberFamily" Arg='fam' Type='Category'/>

<Description>
The family of pure <M>p</M>-adic numbers.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Extensions of the p-adic Numbers">
<Heading>Extensions of the p-adic Numbers</Heading>

The usual Kronecker construction with an irreducible polynomial can be used
to construct extensions of the <M>p</M>-adic numbers. 
Let <M>L</M> be such an extension.
Then there is a subfield <M>K &lt; L</M> such that <M>K</M> is an unramified
extension of the <M>p</M>-adic numbers and <M>L/K</M> is purely ramified.
<P/>
(For an explanation of <Q>ramification</Q> see for example
<Cite Key="neukirch" Where="Section II.7"/>,
or another book on algebraic number theory.
Essentially, an extension <M>L</M> of the <M>p</M>-adic numbers generated
by a rational polynomial <M>f</M> is unramified if <M>f</M> remains
squarefree modulo <M>p</M> and is completely ramified if modulo <M>p</M> the
polynomial <M>f</M> is a power of a linear factor while remaining irreducible
over the <M>p</M>-adic numbers.)
<P/>
The representation of extensions of <M>p</M>-adic numbers in &GAP; uses the
subfield <M>K</M>.

<ManSection>
<Func Name="PadicExtensionNumberFamily" Arg='p, precision, unram, ram'/>

<Description>
An extended <M>p</M>-adic field <M>L</M> is given by two polynomials
<M>h</M> and <M>g</M> with coefficient lists <A>unram</A> (for the
unramified part) and <A>ram</A> (for the ramified part).
Then <M>L</M> is isomorphic to <M>Q_p[x,y]/(h(x),g(y))</M>.
<P/>
This function takes the prime number <A>p</A> and the two coefficient
lists <A>unram</A> and <A>ram</A> for the two polynomials.
The polynomial given by the coefficients in <A>unram</A> must be a
cyclotomic polynomial and the polynomial given by <A>ram</A> must be
either an Eisenstein polynomial or <M>1+x</M>.
<E>This is not checked by &GAP;.</E>
<P/>
Every number in <M>L</M> is represented as a coefficient list w. r. t.
the basis <M>\{ 1, x, x^2, \ldots, y, xy, x^2 y, \ldots \}</M>
of <M>L</M>.
The integer <A>precision</A> is the number of <Q>digits</Q> that all the
coefficients have.
<P/>
<E>A general comment:</E>
<P/>
The polynomials with which <Ref Func="PadicExtensionNumberFamily"/> is
called define an extension of <M>Q_p</M>.
It must be ensured that both polynomials are really irreducible over
<M>Q_p</M>!
For example <M>x^2+x+1</M> is <E>not</E> irreducible over <M>Q_p</M>.
Therefore the <Q>extension</Q>
<C>PadicExtensionNumberFamily(3, 4, [1,1,1], [1,1])</C> contains
non-invertible <Q>pseudo-p-adic numbers</Q>.
Conversely, if an <Q>extension</Q> contains noninvertible elements
then one of the defining polynomials was not irreducible.
</Description>
</ManSection>

<ManSection>
<Oper Name="PadicNumber" Arg='fam, rat'
 Label="for a p-adic extension family and a rational"/>
<Oper Name="PadicNumber" Arg='purefam, list'
 Label="for a pure p-adic numbers family and a list"/>
<Oper Name="PadicNumber" Arg='extfam, list'
 Label="for a p-adic extension family and a list"/>

<Description>
(see also <Ref Oper="PadicNumber" Label="for pure padics"/>).
<P/>
<Ref Func="PadicNumber"
 Label="for a p-adic extension family and a rational"/>
creates a <M>p</M>-adic number in the
<M>p</M>-adic numbers family <A>fam</A>.
The first form returns the <M>p</M>-adic number corresponding to the
rational <A>rat</A>.
<P/>
The second form takes a pure <M>p</M>-adic numbers family <A>purefam</A>
and a list <A>list</A> of length two, and returns the number
<M>p</M><C>^</C><A>list</A><C>[1] * </C><A>list</A><C>[2]</C>.
It must be guaranteed that no entry of <A>list</A><C>[2]</C> is 
divisible by the prime <M>p</M>.
(Otherwise precision will get lost.)
<P/>
The third form creates a number in the family <A>extfam</A> of a
<M>p</M>-adic extension.
The second argument must be a list <A>list</A> of length two such that
<A>list</A><C>[2]</C> is the list of coefficients w.r.t. the basis
<M>\{ 1, \ldots, x^{{f-1}} \cdot y^{{e-1}} \}</M> of the extended
<M>p</M>-adic field and <A>list</A><C>[1]</C> is a common <M>p</M>-part
of all these coefficients.
<P/>
<M>p</M>-adic numbers admit the usual field operations.
<Example><![CDATA[
gap> efam:=PadicExtensionNumberFamily(3, 5, [1,1,1], [1,1]);;
gap> PadicNumber(efam,7/9);
padic(120(3),0(3))
]]></Example>
<P/>
<E>A word of warning:</E>
<P/>
Depending on the actual representation of quotients, precision may seem
to <Q>vanish</Q>.
For example in <C>PadicExtensionNumberFamily(3, 5, [1,1,1], [1,1])</C>
the number <C>(1.2000, 0.1210)(3)</C> can be represented as
<C>[ 0, [ 1.2000, 0.1210 ] ]</C>  or as <C>[ -1, [ 12.000, 1.2100 ] ]</C>
(here the coefficients have to be multiplied by <M>p^{{-1}}</M>).
<P/>
So there may be a number <C>(1.2, 2.2)(3)</C> which seems to have
only two digits of precision instead of the declared 5.
But internally the number is stored as <C>[ -3, [ 0.0012, 0.0022 ] ]</C>
and so has in fact maximum precision.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPadicExtensionNumber" Arg='obj' Type='Category'/>

<Description>
The category of elements of the extended <M>p</M>-adic field.
<Example><![CDATA[
gap>  efam:=PadicExtensionNumberFamily(3, 5, [1,1,1], [1,1]);;
gap> IsPadicExtensionNumber(PadicNumber(efam,7/9));
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsPadicExtensionNumberFamily" Arg='fam' Type='Category'/>

<Description>
Family of elements of the extended <M>p</M>-adic field.
<Example><![CDATA[
gap> efam:=PadicExtensionNumberFamily(3, 5, [1,1,1], [1,1]);;
gap> IsPadicExtensionNumberFamily(efam);
true
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  meataxe.tex                 GAP documentation        Alexander Hulpke -->
<!-- %% -->
<!-- %H  @(#)<M>Id: meataxe.tex,v 4.17 2004/06/23 19:22:40 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<!-- %%  This file contains a description of the MeatAxe functions. -->
<!-- %% -->
<Chapter Label="The MeatAxe">
<Heading>The MeatAxe</Heading>

The MeatAxe <Cite Key="Par84"/> is a tool for the examination of submodules of a
group algebra. It is a basic tool for the examination of group actions on
finite-dimensional modules. 
<P/>
&GAP; uses the improved MeatAxe of Derek Holt and Sarah Rees, and
also incorporates further improvements of Ivanyos and Lux.
<P/>
Please note that, consistently with the convention for group actions, the action of the &GAP; MeatAxe is always that of matrices
on row vectors by multiplication on the right. If you want to investigate
left modules you will have to transpose the matrices.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="MeatAxe Modules">
<Heading>MeatAxe Modules</Heading>

<ManSection>
<Heading>GModuleByMats</Heading>
<Func Name="GModuleByMats" Arg='gens, field'
 Label="for generators and a field"/>
<Func Name="GModuleByMats" Arg='emptygens, dim, field'
 Label="for empty list, the dimension, and a field"/>

<Description>
creates a MeatAxe module over <A>field</A> from a list of invertible matrices 
<A>gens</A> which reflect a group's action. If the list of generators is empty,
the dimension must be given as second argument.
<P/>
MeatAxe routines are on a level with Gaussian elimination. Therefore they do
not deal with &GAP; modules but essentially with lists of matrices. For the
MeatAxe, a module is a record with components
<P/>
<List>
<Mark><C>generators</C></Mark>
<Item>
   A list of matrices which represent a group operation on a
   finite dimensional row vector space.
</Item>
<Mark><C>dimension</C></Mark>
<Item>
   The dimension of the vector space (this is the common length of
   the row vectors (see&nbsp;<Ref Func="DimensionOfVectors"/>)).
</Item>
<Mark><C>field</C></Mark>
<Item>
   The field over which the vector space is defined.
</Item>
</List>
<P/>
Once a module has been created its entries may not be changed. A MeatAxe may
create a new component <A>NameOfMeatAxe</A> in which it can store private
information. By a MeatAxe <Q>submodule</Q> or <Q>factor module</Q> we denote
actually the <E>induced action</E> on the submodule, respectively factor module.
Therefore the submodules or factor modules are again MeatAxe modules. The
arrangement of <C>generators</C> is guaranteed to be the same for the induced
modules, but to obtain the complete relation to the original module, the
bases used are needed as well.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Module Constructions">
<Heading>Module Constructions</Heading>

<ManSection>
<Func Name="PermutationGModule" Arg='G, F'/>

<Description>
Called with a permutation group <A>G</A> and a finite field <A>F</A>,
<Ref Func="PermutationGModule"/> returns the natural permutation module
<M>M</M> over <A>F</A>
for the group of permutation matrices that acts on the canonical basis of
<M>M</M> in the same way as <A>G</A> acts on the points up to its largest
moved point (see&nbsp;<Ref Func="LargestMovedPoint" Label="for a list or collection of permutations"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="TensorProductGModule" Arg='m1, m2'/>

<Description>
<Ref Func="TensorProductGModule"/> calculates the tensor product
of the modules <A>m1</A> and <A>m2</A>. 
They are assumed to be modules over the same algebra so, in particular,
they  should have the same number of generators.
</Description>
</ManSection>

<ManSection>
<Func Name="WedgeGModule" Arg='module'/>

<Description>
<Ref Func="WedgeGModule"/> calculates the wedge product of a <A>G</A>-module.
That is the action on antisymmetric tensors.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Selecting a Different MeatAxe">
<Heading>Selecting a Different MeatAxe</Heading>

<ManSection>
<Var Name="MTX"/>

<Description>
All MeatAxe routines are accessed via the global variable <Ref Var="MTX"/>,
which is a record whose components hold the various functions.
It is possible to have several implementations of a MeatAxe available.
Each MeatAxe represents its routines in an own global variable and assigning
<Ref Var="MTX"/> to this variable selects the corresponding MeatAxe.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Accessing a Module">
<Heading>Accessing a Module</Heading>

Even though a MeatAxe module is a record, its components should never be
accessed outside of MeatAxe functions. Instead the following operations
should be used:

<ManSection>
<Func Name="MTX.Generators" Arg='module'/>

<Description>
returns a list of matrix generators of <A>module</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.Dimension" Arg='module'/>

<Description>
returns the dimension in which the matrices act.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.Field" Arg='module'/>

<Description>
returns the field over which <A>module</A> is defined.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Irreducibility Tests">
<Heading>Irreducibility Tests</Heading>

<ManSection>
<Func Name="MTX.IsIrreducible" Arg='module'/>

<Description>
tests whether the module <A>module</A> is irreducible (i.e. contains no proper
submodules.)
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.IsAbsolutelyIrreducible" Arg='module'/>

<Description>
A module is absolutely irreducible if it remains irreducible over the
algebraic closure of the field.
(Formally: If the tensor product <M>L \otimes_K M</M> is irreducible
where <M>M</M> is the module defined over <M>K</M> and <M>L</M> is the
algebraic closure of <M>K</M>.)
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.DegreeSplittingField" Arg='module'/>

<Description>
returns the degree of the splitting field as extension of the prime field.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Decomposition of modules">
<Heading>Decomposition of modules</Heading>

A module is <E>decomposable</E> if it can be written as the direct sum of two
proper submodules (and <E>indecomposable</E> if not). Obviously every finite
dimensional module is a direct sum of its indecomposable parts.
The <E>homogeneous components</E> of a module are the direct sums of isomorphic
indecomposable components. They are uniquely determined.
<P/>
<ManSection>
<Func Name="MTX.IsIndecomposable" Arg='module'/>

<Description>
returns whether <A>module</A> is indecomposable.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="MTX.Indecomposition" Arg='module'/>

<Description>
returns a decomposition of <A>module</A> as a direct sum of indecomposable
modules. It returns a list, each entry is a list of form [<A>B</A>,<A>ind</A>] where
<A>B</A> is a list of basis vectors for the indecomposable component and <A>ind</A>
the induced module action on this component. (Such a decomposition is not
unique.)
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="MTX.HomogeneousComponents" Arg='module'/>

<Description>
computes the homogeneous components of <A>module</A> given as sums of
indecomposable components. The function returns a list, each entry of which
is a record corresponding to one isomorphism type of indecomposable
components.
The record has the following components.
<P/>
<List>
<Mark><C>indices</C></Mark>
<Item>
  the index numbers of the indecomposable components,
  as given by <Ref Func="MTX.Indecomposition"/>,
  that are in the homogeneous component,
</Item>
<Mark><C>component</C></Mark>
<Item>
  one of the indecomposable components,
</Item>
<Mark><C>images</C></Mark>
<Item>
  a list of the remaining indecomposable components,
  each given as a record with the components
  <C>component</C> (the component itself) and
  <C>isomorphism</C> (an isomorphism from the defining component to this one).
</Item>
</List>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finding Submodules">
<Heading>Finding Submodules</Heading>

<ManSection>
<Func Name="MTX.SubmoduleGModule" Arg='module, subspace'/>
<Func Name="MTX.SubGModule" Arg='module, subspace'/>

<Description>
<A>subspace</A> should be a subspace of (or a vector in) the underlying vector
space of <A>module</A> i.e. the full row space of the same dimension and over
the same field as <A>module</A>. A normalized basis of the submodule of
<A>module</A> generated by <A>subspace</A> is returned.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.ProperSubmoduleBasis" Arg='module'/>

<Description>
returns the basis of a proper submodule of <A>module</A> and <K>fail</K> if no proper
submodule exists.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasesSubmodules" Arg='module'/>

<Description>
returns a list containing a basis for every submodule.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasesMinimalSubmodules" Arg='module'/>

<Description>
returns a list of bases of all minimal submodules.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasesMaximalSubmodules" Arg='module'/>

<Description>
returns a list of bases of all maximal submodules.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasisRadical" Arg='module'/>

<Description>
returns a basis of the radical of <A>module</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasisSocle" Arg='module'/>

<Description>
returns a basis of the socle of <A>module</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasesMinimalSupermodules" Arg='module, sub'/>

<Description>
returns a list of bases of all minimal supermodules of the submodule given by
the basis <A>sub</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasesCompositionSeries" Arg='module'/>

<Description>
returns a list of bases of submodules in a composition series in ascending
order.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.CompositionFactors" Arg='module'/>

<Description>
returns a list of composition factors of <A>module</A> in ascending order.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.CollectedFactors" Arg='module'/>

<Description>
returns a list giving all irreducible composition factors with their
frequencies.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Induced Actions">
<Heading>Induced Actions</Heading>

<ManSection>
<Func Name="MTX.NormedBasisAndBaseChange" Arg='sub'/>

<Description>
returns a list <C>[<A>bas</A>, <A>change</A> ]</C> where <A>bas</A> is a
normed basis (i.e. in echelon form with pivots normed to 1) for <A>sub</A>
and <A>change</A> is the base change from <A>bas</A> to <A>sub</A>
(the basis vectors of <A>bas</A> expressed in coefficients for <A>sub</A>).
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.InducedActionSubmodule" Arg='module, sub'/>
<Func Name="MTX.InducedActionSubmoduleNB" Arg='module, sub'/>

<Description>
creates a new module corresponding to the action of <A>module</A> on
<A>sub</A>.
In the <C>NB</C> version the basis <A>sub</A> must be normed.
(That is it must be in echelon form with pivots normed to 1,
see&nbsp;<Ref Func="MTX.NormedBasisAndBaseChange"/>.)
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.InducedActionFactorModule" Arg='module, sub[, compl]'/>

<Description>
creates a new module corresponding to the action of <A>module</A> on the
factor of <A>sub</A>. If <A>compl</A> is given, it has to be a basis of a
(vector space-)complement of <A>sub</A>. The action then will correspond to
<A>compl</A>.
<P/>
The basis <A>sub</A> has to be given in normed form. (That is it must be in
echelon form with pivots normed to 1,
see&nbsp;<Ref Func="MTX.NormedBasisAndBaseChange"/>)
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.InducedActionMatrix" Arg='mat, sub'/>
<Func Name="MTX.InducedActionMatrixNB" Arg='mat, sub'/>
<Func Name="MTX.InducedActionFactorMatrix" Arg='mat, sub[, compl]'/>

<Description>
work the same way as the above functions for modules, but take as input only
a single matrix.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.InducedAction" Arg='module, sub[, type]'/>

<Description>
Computes induced actions on submodules or factor modules and also returns the
corresponding bases. The action taken is binary encoded in <A>type</A>:
<C>1</C> stands for subspace action,
<C>2</C> for factor action,
and <C>4</C> for action of the full module on a subspace adapted basis.
The routine returns the computed results in a list in sequence
(<A>sub</A>,<A>quot</A>,<A>both</A>,<A>basis</A>)
where <A>basis</A> is a basis for the whole space,
extending <A>sub</A>. (Actions which are not computed are omitted, so the
returned list may be shorter.)
If no <A>type</A> is given, it is assumed to be <C>7</C>.
The basis given in <A>sub</A> must be normed!
<P/>
All these routines return <K>fail</K> if <A>sub</A> is not a proper subspace.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Module Homomorphisms">
<Heading>Module Homomorphisms</Heading>

<ManSection>
<Func Name="MTX.BasisModuleHomomorphisms" Arg='module1, module2'/>

<Description>
returns a basis of all module homomorphisms from <A>module1</A> to
<A>module2</A>.
Homomorphisms are by matrices, whose rows give the images of the
standard basis vectors of <A>module1</A> in the standard basis of
<A>module2</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.BasisModuleEndomorphisms" Arg='module'/>

<Description>
returns a basis of all module homomorphisms from <A>module</A> to <A>module</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.IsomorphismModules" Arg='module1, module2'/>

<Description>
If <A>module1</A> and <A>module2</A> are isomorphic modules,
this function returns an isomorphism from <A>module1</A> to <A>module2</A>
in form of a matrix.
It returns <K>fail</K> if the modules are not isomorphic.
</Description>
</ManSection>

<ManSection>
<Func Name="MTX.ModuleAutomorphisms" Arg='module'/>

<Description>
returns the module automorphisms of <A>module</A> (the set of all isomorphisms
from <A>module</A> to itself) as a matrix group.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Module Homomorphisms for irreducible modules">
<Heading>Module Homomorphisms for irreducible modules</Heading>

The following are lower-level functions that provide homomorphism
functionality for irreducible modules. Generic code should use the functions
in Section <Ref Sect="Module Homomorphisms"/> instead.

<ManSection>
<Func Name="MTX.IsEquivalent" Arg='module1, module2'/>

<Description>
tests two irreducible modules for equivalence.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.IsomorphismIrred" Arg='module1, module2'/>

<Description>
returns an isomorphism from <A>module1</A> to <A>module2</A> (if one exists),
and <K>fail</K> otherwise. It requires that one of the modules is known to be
irreducible. It implicitly assumes that the same group is acting, otherwise
the results are unpredictable.
The isomorphism is given by a matrix <M>M</M>, whose rows give the images of
the standard basis vectors of <A>module1</A> in the standard basis of
<A>module2</A>.
That is, conjugation of the generators of <A>module2</A> with <M>M</M> yields
the generators of <A>module1</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.Homomorphism" Arg='module1, module2, mat'/>

<Description>
<A>mat</A> should be a <A>dim1</A> <M>\times</M> <A>dim2</A> matrix
defining a homomorphism from <A>module1</A> to <A>module2</A>.
This function verifies that <A>mat</A>
really does define a module homomorphism, and then returns the
corresponding homomorphism between the underlying row spaces of the
modules. This can be used for computing kernels, images and pre-images.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.Homomorphisms" Arg='module1, module2'/>

<Description>
returns a basis of the space of all homomorphisms from the irreducible module 
<A>module1</A> to <A>module2</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.Distinguish" Arg='cf, nr'/>

<Description>
Let <A>cf</A> be the output of <Ref Func="MTX.CollectedFactors"/>.
This routine tries to find a group algebra element that has nullity zero
on all composition factors except number <A>nr</A>.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="meataxe:Invariant Forms">
<Heading>MeatAxe Functionality for Invariant Forms</Heading>

The functions in this section can only be applied to an absolutely irreducible
MeatAxe module.

<ManSection>
<Func Name="MTX.InvariantBilinearForm" Arg='module'/>

<Description>
returns an invariant bilinear form, which may be symmetric or anti-symmetric,
of <A>module</A>, or <K>fail</K> if no such form exists.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.InvariantSesquilinearForm" Arg='module'/>

<Description>
returns an invariant hermitian (= self-adjoint) sesquilinear form of
<A>module</A>,
which must be defined over a finite field whose order is a square,
or <K>fail</K> if no such form exists.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.InvariantQuadraticForm" Arg='module'/>

<Description>
returns an invariant quadratic form of <A>module</A>,
or <K>fail</K> if no such form exists. If the characteristic of the field over
which <A>module</A> is defined is not 2, then the invariant bilinear form (if
any) divided by two will be returned. In characteristic 2, the form
returned will be lower triangular.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.BasisInOrbit" Arg='module'/>

<Description>
returns a basis of the underlying vector space of <A>module</A> which is contained
in an orbit of the action of the generators of module on that space.
This is used by <Ref Func="MTX.InvariantQuadraticForm"/> in characteristic 2.
</Description>
</ManSection>


<ManSection>
<Func Name="MTX.OrthogonalSign" Arg='module'/>

<Description>
for an even dimensional module, returns 1 or -1, according as
<C>MTX.InvariantQuadraticForm(<A>module</A>)</C> is of + or - type. For an odd
dimensional module, returns 0. For a module with no invariant
quadratic form, returns <K>fail</K>. This calculation uses an algorithm due
to Jon Thackray.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Smash MeatAxe">
<Heading>The Smash MeatAxe</Heading>

The standard MeatAxe provided in the &GAP; library is
based on the MeatAxe in the &GAP;&nbsp;3 package <Package>Smash</Package>,
originally written by Derek Holt and Sarah Rees <Cite Key="HR94"/>.
It is accessible via the variable <C>SMTX</C> to which <Ref Var="MTX"/>
is assigned by default. 
For the sake of completeness the remaining sections document more technical
functions of this MeatAxe.

<ManSection>
<Func Name="SMTX.RandomIrreducibleSubGModule" Arg='module'/>

<Description>
returns the module action on a random irreducible submodule.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.GoodElementGModule" Arg='module'/>

<Description>
finds an element with minimal possible nullspace dimension if <A>module</A>
is known to be irreducible.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.SortHomGModule" Arg='module1, module2, homs'/>

<Description>
Function to sort the output of <C>Homomorphisms</C>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.MinimalSubGModules" Arg='module1, module2[, max]'/>

<Description>
returns (at most <A>max</A>) bases of submodules of <A>module2</A> which are
isomorphic to the irreducible module  <A>module1</A>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.Setter" Arg='string'/>

<Description>
returns a setter function for the component <C>smashMeataxe.(string)</C>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.Getter" Arg='string'/>

<Description>
returns a getter function for the component <C>smashMeataxe.(string)</C>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.IrreducibilityTest" Arg='module'/>

<Description>
Tests for irreducibility and sets a subbasis if reducible. It neither sets
an irreducibility flag, nor tests it. Thus the routine also can simply be
called to obtain a random submodule.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AbsoluteIrreducibilityTest" Arg='module'/>

<Description>
Tests for absolute irreducibility and sets splitting field degree. It
neither sets an absolute irreducibility flag, nor tests it.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.MinimalSubGModule" Arg='module, cf, nr'/>

<Description>
returns the basis of a minimal submodule of <A>module</A> containing the
indicated composition factor. It assumes <C>Distinguish</C> has been called
already.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.MatrixSum" Arg='matrices1, matrices2'/>

<Description>
creates the direct sum of two matrix lists.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.CompleteBasis" Arg='module, pbasis'/>

<Description>
extends the partial basis <A>pbasis</A> to a basis of the full space
by action of <A>module</A>. It returns whether it succeeded.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Smash MeatAxe Flags">
<Heading>Smash MeatAxe Flags</Heading>

The following getter routines access internal flags. For each routine, the
appropriate setter's name is prefixed with <C>Set</C>.

<ManSection>
<Func Name="SMTX.Subbasis" Arg='module'/>

<Description>
Basis of a submodule.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AlgEl" Arg='module'/>

<Description>
list <C>[newgens,coefflist]</C> giving an algebra element used for chopping.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AlgElMat" Arg='module'/>

<Description>
matrix of <Ref Func="SMTX.AlgEl"/>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AlgElCharPol" Arg='module'/>

<Description>
minimal polynomial of <Ref Func="SMTX.AlgEl"/>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AlgElCharPolFac" Arg='module'/>

<Description>
uses factor of <Ref Func="SMTX.AlgEl"/>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AlgElNullspaceVec" Arg='module'/>

<Description>
nullspace of the matrix evaluated under this factor.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.AlgElNullspaceDimension" Arg='module'/>

<Description>
dimension of the nullspace.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.CentMat" Arg='module'/>

<Description>
matrix centralising all generators which is computed as
a byproduct of <Ref Func="SMTX.AbsoluteIrreducibilityTest"/>.
</Description>
</ManSection>


<ManSection>
<Func Name="SMTX.CentMatMinPoly" Arg='module'/>

<Description>
minimal polynomial of <Ref Func="SMTX.CentMat"/>.
</Description>
</ManSection>

</Section>
</Chapter>




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  tom.msk                     GAP documentation              Götz Pfeiffer -->
<!-- %W                                                            Thomas Merkwitz -->
<!-- %% -->
<!-- %H  @(#)<M>Id: tom.msk,v 1.25 2004/03/30 09:27:45 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<!-- %%  This file describes the functions dealing with tables of marks. -->
<!-- %%  The corresponding &GAP; code is contained in the files <C>lib/tom.g[di]</C>. -->
<!-- %% -->
<Chapter Label="Tables of Marks">
<Heading>Tables of Marks</Heading>

The concept of a <E>table of marks</E> was introduced by W.&nbsp;Burnside
in his book <Q>Theory of Groups of Finite Order</Q>,
see&nbsp;<Cite Key="Bur55"/>.
Therefore a table of marks is sometimes called a <E>Burnside matrix</E>.
<P/>
The table of marks of a finite group <M>G</M> is a matrix whose rows and
columns are labelled by the conjugacy classes of subgroups of <M>G</M>
and where for two subgroups <M>A</M> and <M>B</M> the <M>(A, B)</M>-entry
is the number of fixed points of <M>B</M> in the transitive action of
<M>G</M> on the cosets of <M>A</M> in <M>G</M>.
So the table of marks characterizes the set of all permutation
representations of <M>G</M>.
<P/>
Moreover, the table of marks gives a compact description of the subgroup
lattice of <M>G</M>, since from the numbers of fixed points the numbers
of conjugates of a subgroup <M>B</M> contained in a subgroup <M>A</M>
can be derived.
<P/>
A table of marks of a given group <M>G</M> can be constructed from the
subgroup lattice of <M>G</M>
(see&nbsp;<Ref Sect="Constructing Tables of Marks"/>).
For several groups, the table of marks can be restored from the &GAP;
library of tables of marks
(see&nbsp;<Ref Sect="The Library of Tables of Marks"/>).
<P/>
Given the table of marks of <M>G</M>, one can display it
(see&nbsp;<Ref Sect="Printing Tables of Marks"/>)
and derive information about <M>G</M> and its Burnside ring from it
(see&nbsp;<Ref Sect="Attributes of Tables of Marks"/>,
<Ref Sect="Properties of Tables of Marks"/>,
<Ref Sect="Other Operations for Tables of Marks"/>).
Moreover, tables of marks in &GAP; provide an easy access to the classes
of subgroups of their underlying groups
(see&nbsp;<Ref Sect="Accessing Subgroups via Tables of Marks"/>).


<!-- %%  The code for tables of marks has been designed and implemented by G{\"o}tz -->
<!-- %%  Pfeiffer and Thomas Merkwitz. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="More about Tables of Marks">
<Heading>More about Tables of Marks</Heading>

Let <M>G</M> be a finite group with <M>n</M> conjugacy classes of
subgroups <M>C_1, C_2, \ldots, C_n</M> and representatives
<M>H_i \in C_i</M>, <M>1 \leq i \leq n</M>.
The <E>table of marks</E> of <M>G</M> is defined to be the
<M>n \times n</M> matrix <M>M = (m_{ij})</M> where the
<E>mark</E> <M>m_{ij}</M> is the number of fixed points of the subgroup
<M>H_j</M> in the action of <M>G</M> on the right cosets of <M>H_i</M>
in <M>G</M>.
<P/>
Since <M>H_j</M> can only have fixed points if it is contained in a point
stabilizer the matrix <M>M</M> is lower triangular if the classes
<M>C_i</M> are sorted according to the condition that if <M>H_i</M>
is contained in a conjugate of <M>H_j</M> then <M>i \leq j</M>.
<P/>
Moreover, the diagonal entries <M>m_{ii}</M> are nonzero
since <M>m_{ii}</M> equals the index of <M>H_i</M> in its normalizer
in <M>G</M>.  Hence <M>M</M> is invertible.
Since any transitive action of <M>G</M> is equivalent to an action on the
cosets of a subgroup of <M>G</M>, one sees that the table of marks
completely characterizes the set of all permutation representations of
<M>G</M>.
<P/>
The marks <M>m_{ij}</M> have further meanings.
If <M>H_1</M> is the trivial subgroup of <M>G</M> then each mark
<M>m_{i1}</M> in the first column of <M>M</M> is equal to the index of
<M>H_i</M> in <M>G</M> since the trivial subgroup fixes all cosets of
<M>H_i</M>.
If <M>H_n = G</M> then each <M>m_{nj}</M> in the last row of <M>M</M> is
equal to <M>1</M> since there is only one coset of <M>G</M> in <M>G</M>.
In general, <M>m_{ij}</M> equals the number of conjugates of <M>H_i</M>
containing <M>H_j</M>, multiplied by the index of <M>H_i</M> in its
normalizer in <M>G</M>.
Moreover, the number <M>c_{ij}</M> of conjugates of <M>H_j</M> which are
contained in <M>H_i</M> can be derived from the marks <M>m_{ij}</M> via
the formula
<Display Mode="M">
c_{ij} = ( m_{ij} m_{j1} ) / ( m_{i1} m_{jj} )
</Display>.
<P/>
Both the marks <M>m_{ij}</M>  and the numbers of subgroups <M>c_{ij}</M>
are needed for the functions described in this chapter.
<P/>
A brief survey of properties of tables of marks and a description of
algorithms for the interactive construction of tables of marks using
&GAP; can be found in&nbsp;<Cite Key="Pfe97"/>.


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Table of Marks Objects in GAP">
<Heading>Table of Marks Objects in GAP</Heading>

A table of marks of a group <M>G</M> in &GAP; is represented by an
immutable (see&nbsp;<Ref Sect="Mutability and Copyability"/>) object
<A>tom</A> in the category <Ref Func="IsTableOfMarks"/>,
with defining attributes <Ref Func="SubsTom"/> and
<Ref Func="MarksTom"/>.
These two attributes encode the matrix of marks in a compressed form.
The <Ref Func="SubsTom"/> value of <A>tom</A> is a list where for each
conjugacy class of subgroups the class numbers of its subgroups are
stored.
These are exactly the positions in the corresponding row of the matrix of
marks which have nonzero entries.
The marks themselves are stored via the <Ref Func="MarksTom"/> value of
<A>tom</A>, which is a list that contains for each entry in
<C>SubsTom( <A>tom</A> )</C> the corresponding nonzero value of the
table of marks.
<P/>
It is possible to create table of marks objects that do not store a
group, moreover one can create a table of marks object from a matrix of
marks (see&nbsp;<Ref Func="TableOfMarks" Label="for a matrix"/>).
So it may happen that a table of marks object in &GAP; is in fact
<E>not</E> the table of marks of a group.
To some extent, the consistency of a table of marks object can be checked
(see&nbsp;<Ref Sect="Other Operations for Tables of Marks"/>),
but &GAP; knows no general way to prove or disprove that a given matrix
of nonnegative integers is the matrix of marks for a group.
Many functions for tables of marks work well without access to the group
&ndash;this is one of the arguments why tables of marks are so
useful&ndash;,
but for example normalizers (see&nbsp;<Ref Func="NormalizerTom"/>)
and derived subgroups (see&nbsp;<Ref Func="DerivedSubgroupTom"/>) of
subgroups are in general not uniquely determined by the matrix of marks.
<P/>
&GAP; tables of marks are assumed to be in lower triangular form,
that is, if a subgroup from the conjugacy class corresponding to the
<M>i</M>-th row is contained in a subgroup from the class corresponding
to the <M>j</M>-th row j then <M>i \leq j</M>.
<P/>
The <Ref Func="MarksTom"/> information can be computed from the values of
the attributes <Ref Func="NrSubsTom"/>, <Ref Func="LengthsTom"/>,
<Ref Func="OrdersTom"/>, and <Ref Func="SubsTom"/>.
<Ref Func="NrSubsTom"/> stores a list containing for each entry in the
<Ref Func="SubsTom"/> value the corresponding number of conjugates that
are contained in a subgroup,
<Ref Func="LengthsTom"/> a list containing for each conjugacy class
of subgroups its length,
and <Ref Func="OrdersTom"/> a list containing for each class of subgroups
their order.
So the <Ref Func="MarksTom"/> value of <A>tom</A> may be missing
provided that the values of <Ref Func="NrSubsTom"/>,
<Ref Func="LengthsTom"/>, and <Ref Func="OrdersTom"/> are stored in
<A>tom</A>.
<P/>
Additional information about a table of marks is needed by some
functions.
The class numbers of normalizers in <M>G</M> and the number of the
derived subgroup of <M>G</M> can be stored via appropriate attributes
(see&nbsp;<Ref Func="NormalizersTom"/>,
<Ref Func="DerivedSubgroupTom"/>).
<P/>
If <A>tom</A> stores its group <M>G</M> and a bijection from the rows and
columns of the matrix of marks of <A>tom</A> to the classes of subgroups
of <M>G</M> then clearly normalizers, derived subgroup etc.&nbsp;can be
computed from this information.
But in general a table of marks need not have access to <M>G</M>,
for example <A>tom</A> might have been constructed from a generic table
of marks
(see&nbsp;<Ref Sect="Generic Construction of Tables of Marks"/>),
or as table of marks of a factor group from a given table of marks
(see&nbsp;<Ref Func="FactorGroupTom"/>).
Access to the group <M>G</M> is provided by the attribute
<Ref Attr="UnderlyingGroup" Label="for tables of marks"/>
if this value is set.
Access to the relevant information about conjugacy classes of subgroups
of <M>G</M>
&ndash;compatible with the ordering of rows and columns of the marks in
<A>tom</A>&ndash; is signalled by the filter
<Ref Func="IsTableOfMarksWithGens"/>.

<P/>
Several examples in this chapter require
the &GAP; package <Package>TomLib</Package>
(the &GAP; Library of Tables of Marks) to be available.
If it is not yet loaded then we load it now.
<P/>
<Example><![CDATA[
gap> LoadPackage( "tomlib" );
true
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Tables of Marks">
<Heading>Constructing Tables of Marks</Heading>

<ManSection>
<Attr Name="TableOfMarks" Arg='G' Label="for a group"/>
<Attr Name="TableOfMarks" Arg='string' Label="for a string"/>
<Attr Name="TableOfMarks" Arg='matrix' Label="for a matrix"/>

<Description>
In the first form, <A>G</A> must be a finite group,
and <Ref Func="TableOfMarks" Label="for a group"/>
constructs the table of marks of <A>G</A>.
This computation requires the knowledge of the complete subgroup lattice
of <A>G</A> (see&nbsp;<Ref Func="LatticeSubgroups"/>).
If the lattice is not yet stored then it will be constructed.
This may take a while if <A>G</A> is large.
The result has the <Ref Func="IsTableOfMarksWithGens"/> value
<K>true</K>.
<P/>
In the second form, <A>string</A> must be a string,
and <Ref Func="TableOfMarks" Label="for a string"/> gets
the table of marks with name <A>string</A> from the &GAP; library
(see <Ref Sect="The Library of Tables of Marks"/>).
If no table of marks with this name is contained in the library then
<K>fail</K> is returned.
<P/>
In the third form, <A>matrix</A> must be a matrix or a list of rows
describing a lower triangular matrix where the part above the diagonal is
omitted.
For such an argument <A>matrix</A>,
<Ref Func="TableOfMarks" Label="for a matrix"/> returns
a table of marks object
(see&nbsp;<Ref Sect="Table of Marks Objects in GAP"/>)
for which <A>matrix</A> is the matrix of marks.
Note that not every matrix
(containing only nonnegative integers and having lower triangular shape)
describes a table of marks of a group.
Necessary conditions are checked with
<Ref Func="IsInternallyConsistent" Label="for tables of marks"/>
(see&nbsp;<Ref Sect="Other Operations for Tables of Marks"/>),
and <K>fail</K> is returned if <A>matrix</A> is proved not to describe a
matrix of marks;
but if <Ref Func="TableOfMarks" Label="for a matrix"/> returns a table of
marks object created from a matrix then it may still happen that this
object does not describe the table of marks of a group.
<P/>
For an overview of operations for table of marks objects,
see the introduction to Chapter&nbsp;<Ref Chap="Tables of Marks"/>.
<P/>
<Example><![CDATA[
gap> tom:= TableOfMarks( AlternatingGroup( 5 ) );
TableOfMarks( Alt( [ 1 .. 5 ] ) )
gap> TableOfMarks( "J5" );
fail
gap> a5:= TableOfMarks( "A5" );
TableOfMarks( "A5" )
gap> mat:=
> [ [ 60, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 30, 2, 0, 0, 0, 0, 0, 0, 0 ], 
>   [ 20, 0, 2, 0, 0, 0, 0, 0, 0 ], [ 15, 3, 0, 3, 0, 0, 0, 0, 0 ], 
>   [ 12, 0, 0, 0, 2, 0, 0, 0, 0 ], [ 10, 2, 1, 0, 0, 1, 0, 0, 0 ], 
>   [ 6, 2, 0, 0, 1, 0, 1, 0, 0 ], [ 5, 1, 2, 1, 0, 0, 0, 1, 0 ], 
>   [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ];;
gap> TableOfMarks( mat );
TableOfMarks( <9 classes> )
]]></Example>
<P/>
The following <Ref Func="TableOfMarks" Label="for a group"/> methods
for a group are installed.
<List>
<Item>
  If the group is known to be cyclic then
  <Ref Func="TableOfMarks" Label="for a group"/> constructs the
  table of marks essentially without the group, instead the knowledge
  about the structure of cyclic groups is used.
</Item>
<Item>
  If the lattice of subgroups is already stored in the group then
  <Ref Func="TableOfMarks" Label="for a group"/> computes the
  table of marks from the lattice
  (see&nbsp;<Ref Func="TableOfMarksByLattice"/>).
</Item>
<Item>
  If the group is known to be solvable then
  <Ref Func="TableOfMarks" Label="for a group"/> takes the
  lattice of subgroups (see&nbsp;<Ref Func="LatticeSubgroups"/>) of the
  group &ndash;which means that the lattice is computed if it is not yet
  stored&ndash;
  and then computes the table of marks from it.
  This method is also accessible via the global function
  <Ref Func="TableOfMarksByLattice"/>.
</Item>
<Item>
  If the group doesn't know its lattice of subgroups or its conjugacy
  classes of subgroups then the table of marks and the conjugacy
  classes of subgroups are computed at the same time by the cyclic
  extension method.
  Only the table of marks is stored because the conjugacy classes of
  subgroups or the lattice of subgroups can be easily read off
  (see&nbsp;<Ref Func="LatticeSubgroupsByTom"/>).
</Item>
</List>
<P/>
Conversely, the lattice of subgroups of a group with known table of marks
can be computed using the table of marks, via the function
<Ref Func="LatticeSubgroupsByTom"/>.
This is also installed as a method for <Ref Func="LatticeSubgroups"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="TableOfMarksByLattice" Arg='G'/>

<Description>
<Ref Func="TableOfMarksByLattice"/> computes the table of marks of the
group <A>G</A> from the lattice of subgroups of <A>G</A>.
This lattice is computed via <Ref Func="LatticeSubgroups"/>
if it is not yet stored in <A>G</A>.
The function <Ref Func="TableOfMarksByLattice"/> is installed as a method
for <Ref Func="TableOfMarks" Label="for a group"/> for solvable groups
and groups with stored subgroup lattice,
and is available as a global variable only in order to provide
explicit access to this method.
</Description>
</ManSection>

<ManSection>
<Func Name="LatticeSubgroupsByTom" Arg='G'/>

<Description>
<Ref Func="LatticeSubgroupsByTom"/> computes the lattice of subgroups of
<A>G</A> from the table of marks of <A>G</A>,
using <Ref Func="RepresentativeTom"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Printing Tables of Marks">
<Heading>Printing Tables of Marks</Heading>

<ManSection>
<Meth Name="ViewObj" Arg='tom' Label="for a table of marks"/>

<Description>
The default <Ref Func="ViewObj"/> method for tables of marks prints
the string <C>"TableOfMarks"</C>,
followed by &ndash;if known&ndash; the identifier
(see&nbsp;<Ref Attr="Identifier" Label="for tables of marks"/>)
or the group of the table of marks enclosed in brackets;
if neither group nor identifier are known then just
the number of conjugacy classes of subgroups is printed instead.
</Description>
</ManSection>

<ManSection>
<Meth Name="PrintObj" Arg='tom' Label="for a table of marks"/>

<Description>
The default <Ref Func="PrintObj"/> method for tables of marks
does the same as <Ref Func="ViewObj"/>,
except that <Ref Func="PrintObj"/> is used for the group instead of
<Ref Func="ViewObj"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg='tom[, arec]' Label="for a table of marks"/>

<Description>
The default <Ref Func="Display"/> method for a table of marks <A>tom</A>
produces a formatted output of the marks in <A>tom</A>.
Each line of output begins with the number of the corresponding class of
subgroups.
This number is repeated if the output spreads over several pages.
The number of columns printed at one time depends on the actual
line length, which can be accessed and changed by the function
<Ref Func="SizeScreen"/>.
<P/>
An interactive variant of <Ref Oper="Display"/> is the
<Ref Oper="Browse" BookName="browse"/> method for tables of marks
that is provided by the &GAP; package <Package>Browse</Package>,
see <Ref Meth="Browse" Label="for tables of marks"
BookName="browse"/>.
<P/>
The optional second argument <A>arec</A> of <Ref Func="Display"/> can be
used to change the default style for displaying a table of marks.
<A>arec</A> must be a record, its relevant components are the following.
<P/>
<List>
<Mark><C>classes</C></Mark>
<Item>
  a list of class numbers to select only the rows and columns of the
  matrix that correspond to this list for printing,
</Item>
<Mark><C>form</C></Mark>
<Item>
  one of the strings <C>"subgroups"</C>, <C>"supergroups"</C>;
  in the former case, at position <M>(i,j)</M> of the matrix the number
  of conjugates of <M>H_j</M> contained in <M>H_i</M> is printed,
  and in the latter case, at position <M>(i,j)</M> the number of
  conjugates of <M>H_i</M> which contain <M>H_j</M> is printed.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> tom:= TableOfMarks( "A5" );;
gap> Display( tom );
1:  60
2:  30 2
3:  20 . 2
4:  15 3 . 3
5:  12 . . . 2
6:  10 2 1 . . 1
7:   6 2 . . 1 . 1
8:   5 1 2 1 . . . 1
9:   1 1 1 1 1 1 1 1 1

gap> Display( tom, rec( classes:= [ 1, 2, 3, 4, 8 ] ) );
1:  60
2:  30 2
3:  20 . 2
4:  15 3 . 3
8:   5 1 2 1 1

gap> Display( tom, rec( form:= "subgroups" ) );
1:  1
2:  1  1
3:  1  .  1
4:  1  3  . 1
5:  1  .  . . 1
6:  1  3  1 . .  1
7:  1  5  . . 1  . 1
8:  1  3  4 1 .  . . 1
9:  1 15 10 5 6 10 6 5 1

gap> Display( tom, rec( form:= "supergroups" ) );
1:   1
2:  15 1
3:  10 . 1
4:   5 1 . 1
5:   6 . . . 1
6:  10 2 1 . . 1
7:   6 2 . . 1 . 1
8:   5 1 2 1 . . . 1
9:   1 1 1 1 1 1 1 1 1

]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sorting Tables of Marks">
<Heading>Sorting Tables of Marks</Heading>

<ManSection>
<Oper Name="SortedTom" Arg='tom, perm'/>

<Description>
<Ref Func="SortedTom"/> returns a table of marks where the rows and
columns of the table of marks <A>tom</A> are reordered according to the
permutation <A>perm</A>.
<P/>
<E>Note</E> that in each table of marks in &GAP;,
the matrix of marks is assumed to have lower triangular shape
(see&nbsp;<Ref Sect="Table of Marks Objects in GAP"/>).
If the permutation <A>perm</A> does <E>not</E> have this property then
the functions for tables of marks might return wrong results when applied
to the output of <Ref Func="SortedTom"/>.
<P/>
The returned table of marks has only those attribute values stored that
are known for <A>tom</A> and listed in
<Ref Var="TableOfMarksComponents"/>.
<P/>
<Example><![CDATA[
gap> tom:= TableOfMarksCyclic( 6 );;  Display( tom );
1:  6
2:  3 3
3:  2 . 2
4:  1 1 1 1

gap> sorted:= SortedTom( tom, (2,3) );;  Display( sorted );
1:  6
2:  2 2
3:  3 . 3
4:  1 1 1 1

gap> wrong:= SortedTom( tom, (1,2) );;  Display( wrong );
1:  3
2:  . 6
3:  . 2 2
4:  1 1 1 1

]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="PermutationTom" Arg='tom'/>

<Description>
For the table of marks <A>tom</A> of the group <M>G</M> stored as
<Ref Attr="UnderlyingGroup" Label="for tables of marks"/>
value of <A>tom</A>,
<Ref Func="PermutationTom"/> is a permutation <M>\pi</M> such that the
<M>i</M>-th conjugacy class of subgroups of <M>G</M> belongs to the
<M>i^\pi</M>-th column and row of marks in <A>tom</A>.
<P/>
This attribute value is bound only if <A>tom</A> was obtained from
another table of marks by permuting with <Ref Func="SortedTom"/>,
and there is no default method to compute its value.
<P/>
The attribute is necessary because the original and the sorted table of
marks have the same identifier and the same group,
and information computed from the group may depend on the ordering of
marks, for example the fusion from the ordinary character table of
<M>G</M> into <A>tom</A>.
<P/>
<Example><![CDATA[
gap> MarksTom( tom )[2];
[ 3, 3 ]
gap> MarksTom( sorted )[2];
[ 2, 2 ]
gap> HasPermutationTom( sorted );
true
gap> PermutationTom( sorted );
(2,3)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Technical Details about Tables of Marks">
<Heading>Technical Details about Tables of Marks</Heading>

<ManSection>
<InfoClass Name="InfoTom"/>

<Description>
is the info class for computations concerning tables of marks.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsTableOfMarks" Arg='obj' Type='Category'/>

<Description>
Each table of marks belongs to this category.
</Description>
</ManSection>

<ManSection>
<Var Name="TableOfMarksFamily"/>

<Description>
Each table of marks belongs to this family.
</Description>
</ManSection>

<ManSection>
<Var Name="TableOfMarksComponents"/>

<Description>
The list <Ref Var="TableOfMarksComponents"/> is used when a
table of marks object is created from a record via
<Ref Func="ConvertToTableOfMarks"/>.
<Ref Var="TableOfMarksComponents"/> contains at position <M>2i-1</M>
a name of an attribute and at position <M>2i</M> the corresponding
attribute getter function.
</Description>
</ManSection>

<ManSection>
<Func Name="ConvertToTableOfMarks" Arg='record'/>

<Description>
<Ref Func="ConvertToTableOfMarks"/> converts a record with components
from <Ref Var="TableOfMarksComponents"/> into a table of marks object
with the corresponding attributes.
<P/>
<Example><![CDATA[
gap> record:= rec( MarksTom:= [ [ 4 ], [ 2, 2 ], [ 1, 1, 1 ] ],
>  SubsTom:= [ [ 1 ], [ 1, 2 ], [ 1, 2, 3 ] ] );;
gap> ConvertToTableOfMarks( record );;
gap> record;
TableOfMarks( <3 classes> )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes of Tables of Marks">
<Heading>Attributes of Tables of Marks</Heading>

<ManSection>
<Attr Name="MarksTom" Arg='tom'/>
<Attr Name="SubsTom" Arg='tom'/>

<Description>
The matrix of marks (see&nbsp;<Ref Sect="More about Tables of Marks"/>)
of the table of marks <A>tom</A> is stored in a compressed form
where zeros are omitted,
using the attributes <Ref Func="MarksTom"/> and <Ref Func="SubsTom"/>.
If <M>M</M> is the square matrix of marks of <A>tom</A>
(see&nbsp;<Ref Func="MatTom"/>) then the <Ref Func="SubsTom"/> value of
<A>tom</A> is a list that contains at position <M>i</M> the list
of all positions of nonzero entries of the <M>i</M>-th row of <M>M</M>,
and the <Ref Func="MarksTom"/> value of <A>tom</A> is a list
that contains at position <M>i</M> the list of the corresponding marks.
<P/>
<Ref Func="MarksTom"/> and <Ref Func="SubsTom"/> are defining attributes
of tables of marks (see&nbsp;<Ref Sect="Table of Marks Objects in GAP"/>).
There is no default method for computing the <Ref Func="SubsTom"/> value,
and the default <Ref Func="MarksTom"/> method needs the values of
<Ref Func="NrSubsTom"/> and <Ref Func="OrdersTom"/>.
<P/>
<Example><![CDATA[
gap> a5:= TableOfMarks( "A5" );
TableOfMarks( "A5" )
gap> MarksTom( a5 );
[ [ 60 ], [ 30, 2 ], [ 20, 2 ], [ 15, 3, 3 ], [ 12, 2 ], 
  [ 10, 2, 1, 1 ], [ 6, 2, 1, 1 ], [ 5, 1, 2, 1, 1 ], 
  [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
gap> SubsTom( a5 );
[ [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 5 ], [ 1, 2, 3, 6 ], 
  [ 1, 2, 5, 7 ], [ 1, 2, 3, 4, 8 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NrSubsTom" Arg='tom'/>
<Attr Name="OrdersTom" Arg='tom'/>

<Description>
Instead of storing the marks (see&nbsp;<Ref Func="MarksTom"/>) of the
table of marks <A>tom</A> one can use a matrix which contains at position
<M>(i,j)</M> the number of subgroups of conjugacy class <M>j</M>
that are contained in one member of the conjugacy class <M>i</M>.
These values are stored in the <Ref Func="NrSubsTom"/> value in the same
way as the marks in the <Ref Func="MarksTom"/> value.
<P/>
<Ref Func="OrdersTom"/> returns a list that contains at position <M>i</M>
the order of a representative of the <M>i</M>-th conjugacy class of
subgroups of <A>tom</A>.
<P/>
One can compute the <Ref Func="NrSubsTom"/> and <Ref Func="OrdersTom"/>
values from the <Ref Func="MarksTom"/> value of <A>tom</A>
and vice versa.
<P/>
<Example><![CDATA[
gap> NrSubsTom( a5 );
[ [ 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 3, 1 ], [ 1, 1 ], [ 1, 3, 1, 1 ], 
  [ 1, 5, 1, 1 ], [ 1, 3, 4, 1, 1 ], [ 1, 15, 10, 5, 6, 10, 6, 5, 1 ] 
 ]
gap> OrdersTom( a5 );
[ 1, 2, 3, 4, 5, 6, 10, 12, 60 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="LengthsTom" Arg='tom'/>

<Description>
For a table of marks <A>tom</A>,
<Ref Func="LengthsTom"/> returns a list of the lengths of
the conjugacy classes of subgroups.
<P/>
<Example><![CDATA[
gap> LengthsTom( a5 );
[ 1, 15, 10, 5, 6, 10, 6, 5, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassTypesTom" Arg='tom'/>

<Description>
<Ref Attr="ClassTypesTom"/> distinguishes isomorphism types of the
classes of subgroups of the table of marks <A>tom</A>
as far as this is possible from the <Ref Func="SubsTom"/> and
<Ref Func="MarksTom"/> values of <A>tom</A>.
<P/>
Two subgroups are clearly not isomorphic if they have different orders.
Moreover, isomorphic subgroups must contain the same number of subgroups
of each type.
<P/>
Each type is represented by a positive integer.
<Ref Attr="ClassTypesTom"/> returns the list which contains for each
class of subgroups its corresponding type.
<P/>
<Example><![CDATA[
gap> a6:= TableOfMarks( "A6" );;
gap> ClassTypesTom( a6 );
[ 1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 9, 10, 11, 11, 12, 13, 13, 14, 15, 
  15, 16 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassNamesTom" Arg='tom'/>

<Description>
<Ref Func="ClassNamesTom"/> constructs generic names for the conjugacy
classes of subgroups of the table of marks <A>tom</A>.
In general, the generic name of a class of non-cyclic subgroups consists
of three parts and has the form
<C>"(</C><A>o</A><C>)_{</C><A>t</A><C>}</C><A>l</A><C>"</C>,
where <A>o</A> indicates the order of the subgroup,
<A>t</A> is a number that distinguishes different types of subgroups of
the same order, and <A>l</A> is a letter that distinguishes classes of
subgroups of the same type and order.
The type of a subgroup is determined by the numbers of its subgroups of
other types (see&nbsp;<Ref Func="ClassTypesTom"/>).
This is slightly weaker than isomorphism.
<P/>
The letter is omitted if there is only one class of subgroups of that
order and type,
and the type is omitted if there is only one class of that order.
Moreover, the braces <C>{}</C>  around the type are omitted
if the type number has only one digit.
<P/>
For classes of cyclic subgroups, the parentheses round the order and the
type are omitted.
Hence the most general form of their generic names is
<C>"<A>o</A>,<A>l</A>"</C>.
Again, the letter is omitted if there is only one class of cyclic
subgroups of that order.
<P/>
<Example><![CDATA[
gap> ClassNamesTom( a6 );
[ "1", "2", "3a", "3b", "5", "4", "(4)_2a", "(4)_2b", "(6)a", "(6)b", 
  "(8)", "(9)", "(10)", "(12)a", "(12)b", "(18)", "(24)a", "(24)b", 
  "(36)", "(60)a", "(60)b", "(360)" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="FusionsTom" Arg='tom'/>

<Description>
For a table of marks <A>tom</A>,
<Ref Func="FusionsTom"/> is a list of fusions into other tables of marks.
Each fusion is a list of length  two, the  first  entry being the
<Ref Attr="Identifier" Label="for tables of marks"/>) value
of the image table, the second entry being the list of images of
the class positions of <A>tom</A> in the image table.
<P/>
This attribute is mainly used for tables of marks in the &GAP; library
(see&nbsp;<Ref Sect="The Library of Tables of Marks"/>).
<P/>
<Example><![CDATA[
gap> fus:= FusionsTom( a6 );;
gap> fus[1];
[ "L3(4)", 
  [ 1, 2, 3, 3, 14, 5, 9, 7, 15, 15, 24, 26, 27, 32, 33, 50, 57, 55, 
      63, 73, 77, 90 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="UnderlyingGroup" Arg='tom' Label="for tables of marks"/>

<Description>
<Ref Func="UnderlyingGroup" Label="for tables of marks"/> is used
to access an underlying group that is stored on the table of marks
<A>tom</A>.
There is no default method to compute an underlying group if it is not
stored.
<P/>
<Example><![CDATA[
gap> UnderlyingGroup( a6 );
Group([ (1,2)(3,4), (1,2,4,5)(3,6) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IdempotentsTom" Arg='tom'/>
<Attr Name="IdempotentsTomInfo" Arg='tom'/>

<Description>
<Ref Func="IdempotentsTom"/> encodes the idempotents of the integral
Burnside ring described by the table of marks <A>tom</A>.
The return value is a list <M>l</M> of positive integers such that each
row vector describing a primitive idempotent has value <M>1</M> at all
positions with the same entry in <M>l</M>, and <M>0</M> at all other
positions.
<P/>
According to A.&nbsp;Dress&nbsp;<Cite Key="Dre69"/>
(see also&nbsp;<Cite Key="Pfe97"/>),
these idempotents correspond to the classes of perfect subgroups,
and each such idempotent is the characteristic function of all those
subgroups that arise by cyclic extension from the corresponding perfect
subgroup
(see&nbsp;<Ref Func="CyclicExtensionsTom" Label="for a prime"/>).
<P/>
<Ref Func="IdempotentsTomInfo"/> returns a record with components
<C>fixpointvectors</C> and <C>primidems</C>, both bound to lists.
The <M>i</M>-th entry of the <C>fixpointvectors</C> list is the
<M>0-1</M>-vector describing the <M>i</M>-th primitive idempotent,
and the <M>i</M>-th entry of <C>primidems</C> is the decomposition of this
idempotent in the rows of <A>tom</A>.
<P/>
<Example><![CDATA[
gap> IdempotentsTom( a5 );
[ 1, 1, 1, 1, 1, 1, 1, 1, 9 ]
gap> IdempotentsTomInfo( a5 );
rec( 
  fixpointvectors := [ [ 1, 1, 1, 1, 1, 1, 1, 1, 0 ], 
      [ 0, 0, 0, 0, 0, 0, 0, 0, 1 ] ], 
  primidems := [ [ 1, -2, -1, 0, 0, 1, 1, 1 ], 
      [ -1, 2, 1, 0, 0, -1, -1, -1, 1 ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="Identifier" Arg='tom' Label="for tables of marks"/>

<Description>
The identifier of a table of marks <A>tom</A> is a string.
It is used for printing the table of marks
(see&nbsp;<Ref Sect="Printing Tables of Marks"/>)
and in fusions between tables of marks
(see&nbsp;<Ref Func="FusionsTom"/>).
<P/>
If <A>tom</A> is a table of marks from the &GAP; library of tables of
marks (see&nbsp;<Ref Sect="The Library of Tables of Marks"/>)
then it has an identifier,
and if <A>tom</A> was constructed from a group with <Ref Func="Name"/>
then this name is chosen as
<Ref Func="Identifier" Label="for tables of marks"/> value.
There is no default method to compute an identifier in all other cases.
<P/>
<Example><![CDATA[
gap> Identifier( a5 );
"A5"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MatTom" Arg='tom'/>

<Description>
<Ref Func="MatTom"/> returns the square matrix of marks
(see&nbsp;<Ref Sect="More about Tables of Marks"/>) of the table of marks
<A>tom</A> which is stored in a compressed form using the attributes
<Ref Func="MarksTom"/> and <Ref Func="SubsTom"/>
This may need substantially more space than the values of
<Ref Func="MarksTom"/> and <Ref Func="SubsTom"/>.
<P/>
<Example><![CDATA[
gap> MatTom( a5 );
[ [ 60, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 30, 2, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 20, 0, 2, 0, 0, 0, 0, 0, 0 ], [ 15, 3, 0, 3, 0, 0, 0, 0, 0 ], 
  [ 12, 0, 0, 0, 2, 0, 0, 0, 0 ], [ 10, 2, 1, 0, 0, 1, 0, 0, 0 ], 
  [ 6, 2, 0, 0, 1, 0, 1, 0, 0 ], [ 5, 1, 2, 1, 0, 0, 0, 1, 0 ], 
  [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MoebiusTom" Arg='tom'/>

<Description>
<Ref Func="MoebiusTom"/> computes the Möbius values both of the subgroup
lattice of the group <M>G</M> with table of marks <A>tom</A>
and of the poset of conjugacy classes of subgroups of <M>G</M>.
It returns a record where the component
<C>mu</C> contains the Möbius values of the subgroup lattice,
and the component <C>nu</C> contains the Möbius values of the poset.
<P/>
Moreover, according to an observation of Isaacs et al.
(see&nbsp;<Cite Key="HIO89"/>, <Cite Key="Pah93"/>),
the values on the subgroup lattice often can be derived
from those of the poset of conjugacy classes.
These <Q>expected values</Q> are returned in the component <C>ex</C>,
and the list of numbers of those subgroups where the expected value does
not coincide with the actual value are returned in the component
<C>hyp</C>.
For the computation of these values, the position of the derived subgroup
of <M>G</M> is needed (see&nbsp;<Ref Func="DerivedSubgroupTom"/>).
If it is not uniquely determined then the result does not have the
components <C>ex</C> and <C>hyp</C>.
<P/>
<Example><![CDATA[
gap> MoebiusTom( a5 );
rec( ex := [ -60, 4, 2,,, -1, -1, -1, 1 ], hyp := [  ], 
  mu := [ -60, 4, 2,,, -1, -1, -1, 1 ], 
  nu := [ -1, 2, 1,,, -1, -1, -1, 1 ] )
gap> tom:= TableOfMarks( "M12" );;
gap> moebius:= MoebiusTom( tom );;
gap> moebius.hyp;
[ 1, 2, 4, 16, 39, 45, 105 ]
gap> moebius.mu[1];  moebius.ex[1];
95040
190080
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="WeightsTom" Arg='tom'/>

<Description>
<Ref Attr="WeightsTom"/> extracts the <E>weights</E> from the table of
marks <A>tom</A>, i.e., the diagonal entries of the matrix of marks
(see&nbsp;<Ref Func="MarksTom"/>),
indicating the index of a subgroup in its normalizer.
<P/>
<Example><![CDATA[
gap> wt:= WeightsTom( a5 );
[ 60, 2, 2, 3, 2, 1, 1, 1, 1 ]
]]></Example>
<P/>
This information may be used to obtain the numbers of conjugate
supergroups from the marks.
<Example><![CDATA[
gap> marks:= MarksTom( a5 );;
gap> List( [ 1 .. 9 ], x -> marks[x] / wt[x] );
[ [ 1 ], [ 15, 1 ], [ 10, 1 ], [ 5, 1, 1 ], [ 6, 1 ], [ 10, 2, 1, 1 ],
  [ 6, 2, 1, 1 ], [ 5, 1, 2, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Properties of Tables of Marks">
<Heading>Properties of Tables of Marks</Heading>

For a table of marks <A>tom</A> of a group <M>G</M>,
the following properties have the same meaning as the corresponding
properties for <M>G</M>.
Additionally, if a positive integer <A>sub</A> is given
as the second argument
then the value of the corresponding property for the <A>sub</A>-th class
of subgroups of <A>tom</A> is returned.
<P/>
<ManSection>
<Prop Name="IsAbelianTom" Arg='tom[, sub]'/>
<Prop Name="IsCyclicTom" Arg='tom[, sub]'/>
<Prop Name="IsNilpotentTom" Arg='tom[, sub]'/>
<Prop Name="IsPerfectTom" Arg='tom[, sub]'/>
<Prop Name="IsSolvableTom" Arg='tom[, sub]'/>

<Description>
<Example><![CDATA[
gap> tom:= TableOfMarks( "A5" );;
gap> IsAbelianTom( tom );  IsPerfectTom( tom );
false
true
gap> IsAbelianTom( tom, 3 );  IsNilpotentTom( tom, 7 );
true
false
gap> IsPerfectTom( tom, 7 );  IsSolvableTom( tom, 7 );
false
true
gap> for i in [ 1 .. 6 ] do
> Print( i, ": ", IsCyclicTom(a5, i), "  " );
> od;  Print( "\n" );
1: true  2: true  3: true  4: false  5: true  6: false  
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Other Operations for Tables of Marks">
<Heading>Other Operations for Tables of Marks</Heading>

<ManSection>
<Meth Name="IsInternallyConsistent"
 Arg='tom' Label="for tables of marks"/>

<Description>
For a table of marks <A>tom</A>,
<Ref Func="IsInternallyConsistent" Label="for tables of marks"/>
decomposes all tensor products of rows of <A>tom</A>.
It returns <K>true</K> if all decomposition numbers are nonnegative
integers, and <K>false</K> otherwise.
This provides a strong consistency check for a table of marks.
</Description>
</ManSection>

<ManSection>
<Oper Name="DerivedSubgroupTom" Arg='tom, sub'/>
<Func Name="DerivedSubgroupsTom" Arg='tom'/>

<Description>
For a table of marks <A>tom</A> and a positive integer <A>sub</A>,
<Ref Oper="DerivedSubgroupTom"/> returns either a positive integer
<M>i</M> or a list <M>l</M> of positive integers.
In the former case, the result means that the derived subgroups of the
subgroups in the <A>sub</A>-th class of <A>tom</A> lie in the
<M>i</M>-th class.
In the latter case, the class of the derived subgroups could not be
uniquely determined, and the position of the class of derived subgroups
is an entry of <M>l</M>.
<P/>
Values computed with <Ref Oper="DerivedSubgroupTom"/> are stored
using the attribute <Ref Func="DerivedSubgroupsTomPossible"/>.
<P/>
<Ref Func="DerivedSubgroupsTom"/> is just the list of
<Ref Oper="DerivedSubgroupTom"/> values for all values of <A>sub</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="DerivedSubgroupsTomPossible" Arg='tom'/>
<Attr Name="DerivedSubgroupsTomUnique" Arg='tom'/>

<Description>
Let <A>tom</A> be a table of marks.
The value of the attribute <Ref Func="DerivedSubgroupsTomPossible"/> is
a list in which the value at position <M>i</M> &ndash;if bound&ndash;
is a positive integer or a list; the meaning of the entry is the same as
in <Ref Func="DerivedSubgroupTom"/>.
<P/>
If the value of the attribute <Ref Func="DerivedSubgroupsTomUnique"/> is
known for <A>tom</A> then it is a list of positive integers,
the value at position <M>i</M> being the position of the class of derived
subgroups of the <M>i</M>-th class of subgroups in <A>tom</A>.
<P/>
The derived subgroups are in general not uniquely determined by the table
of marks if no <Ref Attr="UnderlyingGroup" Label="for tables of marks"/>
value is stored, so there is no default method for
<Ref Func="DerivedSubgroupsTomUnique"/>.
But in some cases the derived subgroups are explicitly set when the table
of marks is constructed.
In this case, <Ref Func="DerivedSubgroupTom"/> does not set values in
the <Ref Func="DerivedSubgroupsTomPossible"/> list.
<P/>
The <Ref Func="DerivedSubgroupsTomUnique"/> value is automatically set
when the last missing unique value is entered in the
<Ref Func="DerivedSubgroupsTomPossible"/> list by
<Ref Func="DerivedSubgroupTom"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="NormalizerTom" Arg='tom, sub'/>
<Attr Name="NormalizersTom" Arg='tom'/>

<Description>
Let <A>tom</A> be the table of marks of a group <M>G</M>, say.
<Ref Oper="NormalizerTom"/> tries to find the conjugacy class of the
normalizer <M>N</M> in <M>G</M> of a subgroup <M>U</M> in the
<A>sub</A>-th class of <A>tom</A>.
The return value is either the list of class numbers of those subgroups
that have the right size and contain the subgroup and all subgroups that
clearly contain it as a normal subgroup, or the class number of the
normalizer if it is uniquely determined by these conditions.
If <A>tom</A> knows the subgroup lattice of <M>G</M>
(see&nbsp;<Ref Func="IsTableOfMarksWithGens"/>)
then all normalizers are uniquely determined.
<Ref Oper="NormalizerTom"/> should never return an empty list.
<P/>
<Ref Attr="NormalizersTom"/> returns the list of positions of the classes
of normalizers of subgroups in <A>tom</A>.
In addition to the criteria for a single class of subgroup used by
<Ref Oper="NormalizerTom"/>,
the approximations of normalizers for several classes are used and thus
<Ref Attr="NormalizersTom"/> may return better approximations than
<Ref Oper="NormalizerTom"/>.
<P/>
<Example><![CDATA[
gap> NormalizerTom( a5, 4 );
8
gap> NormalizersTom( a5 );
[ 9, 4, 6, 8, 7, 6, 7, 8, 9 ]
]]></Example>
<P/>
The example shows that a subgroup with class number 4 in <M>A_5</M>
(which is a Kleinian four group)
is normalized by a subgroup in class 8.
This class contains the subgroups of <M>A_5</M> which are isomorphic to
<M>A_4</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="ContainedTom" Arg='tom, sub1, sub2'/>

<Description>
<Ref Func="ContainedTom"/> returns the number of subgroups in class
<A>sub1</A> of the table of marks <A>tom</A> that are contained in one
fixed member of the class <A>sub2</A>.
<P/>
<Example><![CDATA[
gap> ContainedTom( a5, 3, 5 );  ContainedTom( a5, 3, 8 );
0
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ContainingTom" Arg='tom, sub1, sub2'/>

<Description>
<Ref Func="ContainingTom"/> returns the number of subgroups in class
<A>sub2</A> of the table of marks <A>tom</A> that contain one fixed
member of the class <A>sub1</A>.
<P/>
<Example><![CDATA[
gap> ContainingTom( a5, 3, 5 );  ContainingTom( a5, 3, 8 );
0
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CyclicExtensionsTom" Arg='tom, p' Label="for a prime"/>
<Attr Name="CyclicExtensionsTom" Arg='tom[, list]'
 Label="for a list of primes"/>

<Description>
According to A.&nbsp;Dress&nbsp;<Cite Key="Dre69"/>,
two columns of the table of marks <A>tom</A> are equal modulo the prime
<A>p</A> if and only if the corresponding subgroups are connected by a
chain of normal extensions of order <A>p</A>.
<P/>
Called with <A>tom</A> and <A>p</A>,
<Ref Func="CyclicExtensionsTom" Label="for a prime"/>
returns the classes of this equivalence relation.
<P/>
In the second form, <A>list</A> must be a list of primes,
and the return value is the list of classes of the relation obtained by
considering chains of normal extensions of prime order where all primes
are in <A>list</A>.
The default value for <A>list</A> is the set of prime divisors of the
order of the group of <A>tom</A>.
<P/>
(This information is <E>not</E> used by <Ref Func="NormalizerTom"/>
although it might give additional restrictions in the search of
normalizers.)
<P/>
<Example><![CDATA[
gap> CyclicExtensionsTom( a5, 2 );
[ [ 1, 2, 4 ], [ 3, 6 ], [ 5, 7 ], [ 8 ], [ 9 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DecomposedFixedPointVector" Arg='tom, fix'/>

<Description>
Let <A>tom</A> be the table of marks of the group <M>G</M>, say,
and let <A>fix</A> be a vector of fixed point numbers w.r.t.&nbsp;an
action of <M>G</M>, i.e., a vector which contains for each class of
subgroups the number of fixed points under the given action.
<Ref Func="DecomposedFixedPointVector"/> returns the decomposition of
<A>fix</A> into rows of the table of marks.
This decomposition  corresponds to a decomposition of the action into
transitive constituents.
Trailing zeros in <A>fix</A> may be omitted.
<P/>
<Example><![CDATA[
gap> DecomposedFixedPointVector( a5, [ 16, 4, 1, 0, 1, 1, 1 ] );
[ 0, 0, 0, 0, 0, 1, 1 ]
]]></Example>
<P/>
The vector <A>fix</A> may be any vector of integers.
The resulting decomposition, however, will not be integral, in general.
<Example><![CDATA[
gap> DecomposedFixedPointVector( a5, [ 0, 0, 0, 0, 1, 1 ] );
[ 2/5, -1, -1/2, 0, 1/2, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EulerianFunctionByTom" Arg='tom, n[, sub]'/>

<Description>
Called with two arguments, <Ref Func="EulerianFunctionByTom"/> computes
the Eulerian function (see&nbsp;<Ref Func="EulerianFunction"/>) of the
underlying group <M>G</M> of the table of marks <A>tom</A>,
that is, the number of <A>n</A>-tuples of elements in <M>G</M> that
generate <M>G</M>.
If the optional argument <A>sub</A> is given then
<Ref Func="EulerianFunctionByTom"/> computes the Eulerian function
of each subgroup in the <A>sub</A>-th class of subgroups of <A>tom</A>.
<P/>
For a group <M>G</M> whose table of marks is known,
<Ref Func="EulerianFunctionByTom"/>
is installed as a method for <Ref Func="EulerianFunction"/>.
<P/>
<Example><![CDATA[
gap> EulerianFunctionByTom( a5, 2 );
2280
gap> EulerianFunctionByTom( a5, 3 );
200160
gap> EulerianFunctionByTom( a5, 2, 3 );
8
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="IntersectionsTom" Arg='tom, sub1, sub2'/>

<Description>
The intersections of the groups in the <A>sub1</A>-th conjugacy class of
subgroups of the table of marks <A>tom</A> with the groups in the
<A>sub2</A>-th conjugacy classes of subgroups of <A>tom</A>
are determined up to conjugacy by the decomposition of the tensor product
of their rows of marks.
<Ref Func="IntersectionsTom"/> returns a list <M>l</M> that describes
this decomposition.
The <M>i</M>-th entry in <M>l</M> is the multiplicity of groups in the
<M>i</M>-th conjugacy class as an intersection.
<P/>
<Example><![CDATA[
gap> IntersectionsTom( a5, 8, 8 );
[ 0, 0, 1, 0, 0, 0, 0, 1 ]
]]></Example>
Any two subgroups of class number 8 (<M>A_4</M>) of <M>A_5</M> are either
equal and their intersection has again class number 8,
or their intersection has class number <M>3</M>,
and is a cyclic subgroup of order 3.
</Description>
</ManSection>

<ManSection>
<Oper Name="FactorGroupTom" Arg='tom, n'/>

<Description>
For a table of marks <A>tom</A> of the group <M>G</M>, say,
and the normal subgroup <M>N</M> of <M>G</M> corresponding to the
<A>n</A>-th class of subgroups of <A>tom</A>,
<Ref Func="FactorGroupTom"/> returns the table of marks of the factor
group <M>G / N</M>.
<P/>
<Example><![CDATA[
gap> s4:= TableOfMarks( SymmetricGroup( 4 ) );
TableOfMarks( Sym( [ 1 .. 4 ] ) )
gap> LengthsTom( s4 );
[ 1, 3, 6, 4, 1, 3, 3, 4, 3, 1, 1 ]
gap> OrdersTom( s4 );
[ 1, 2, 2, 3, 4, 4, 4, 6, 8, 12, 24 ]
gap> s3:= FactorGroupTom( s4, 5 );
TableOfMarks( Group([ f1, f2 ]) )
gap> Display( s3 );
1:  6
2:  3 1
3:  2 . 2
4:  1 1 1 1

]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MaximalSubgroupsTom" Arg='tom[, sub]'/>

<Description>
Called with a table of marks <A>tom</A>,
<Ref Func="MaximalSubgroupsTom"/> returns a list of length two,
the first entry being the list of positions of the classes of maximal
subgroups of the whole group of <A>tom</A>,
the second entry being the list of class lengths of these groups.
<P/>
Called with a table of marks <A>tom</A> and a position <A>sub</A>,
the same information for the <A>sub</A>-th class of subgroups is
returned.
<P/>
<Example><![CDATA[
gap> MaximalSubgroupsTom( s4 );
[ [ 10, 9, 8 ], [ 1, 3, 4 ] ]
gap> MaximalSubgroupsTom( s4, 10 );
[ [ 5, 4 ], [ 1, 4 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="MinimalSupergroupsTom" Arg='tom, sub'/>

<Description>
For a table of marks <A>tom</A>,
<Ref Func="MinimalSupergroupsTom"/> returns a list of length two,
the first entry being the list of positions of the classes
containing the minimal supergroups of the groups in the <A>sub</A>-th
class of subgroups of <A>tom</A>,
the second entry being the list of class lengths of these groups.
<P/>
<Example><![CDATA[
gap> MinimalSupergroupsTom( s4, 5 );
[ [ 9, 10 ], [ 3, 1 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Accessing Subgroups via Tables of Marks">
<Heading>Accessing Subgroups via Tables of Marks</Heading>

Let <A>tom</A> be the table of marks of the group <M>G</M>,
and assume that <A>tom</A> has access to <M>G</M> via the
<Ref Attr="UnderlyingGroup" Label="for tables of marks"/> value.
Then it makes sense to use <A>tom</A> and its ordering of conjugacy
classes of subgroups of <M>G</M> for storing information for constructing
representatives of these classes.
The group <M>G</M> is in general not sufficient for this,
<A>tom</A> needs more information;
this is available if and only if the <Ref Func="IsTableOfMarksWithGens"/>
value of <A>tom</A> is <K>true</K>.
In this case, <Ref Func="RepresentativeTom"/> can be used
to get a subgroup of the <M>i</M>-th class, for all <M>i</M>.
<P/>
&GAP; provides two different possibilities to store generators of the
representatives of classes of subgroups.
The first is implemented by the attribute
<Ref Func="GeneratorsSubgroupsTom"/>, which uses explicit generators
of the subgroups.
The second, more general, possibility is implemented by the attribute
<Ref Func="StraightLineProgramsTom"/>, which encodes the generators as
straight line programs (see&nbsp;<Ref Sect="Straight Line Programs"/>)
that evaluate to the generators in question when applied to
<E>standard generators</E> of <M>G</M>.
<!--, see <Ref Sect="Standard Generators of Groups" BookName="tomlib"/>. -->
This means that on the one hand, standard generators of <M>G</M> must be
known in order to use <Ref Func="StraightLineProgramsTom"/>.
On the other hand, the straight line programs allow one to compute easily
generators not only of a subgroup <M>U</M> of <M>G</M> but also
generators of the image of <M>U</M> in any representation of <M>G</M>,
provided that one knows standard generators of the image of <M>G</M>
under this representation.
See the manual of the package <Package>TomLib</Package> for details
and an example.

<ManSection>
<Attr Name="GeneratorsSubgroupsTom" Arg='tom'/>

<Description>
Let <A>tom</A> be a table of marks with
<Ref Func="IsTableOfMarksWithGens"/> value <K>true</K>.
Then <Ref Func="GeneratorsSubgroupsTom"/> returns a list of length two,
the first entry being a list <M>l</M> of elements of the group stored as
<Ref Attr="UnderlyingGroup" Label="for tables of marks"/> value of
<A>tom</A>,
the second entry being a list that contains at position <M>i</M> a list
of positions in <M>l</M> of generators of a representative of a subgroup
in class <M>i</M>.
<P/>
The <Ref Func="GeneratorsSubgroupsTom"/> value is known for all tables of
marks that have been computed with
<Ref Func="TableOfMarks" Label="for a group"/> from a group,
and there is a method to compute the value for a table of marks that
admits <Ref Func="RepresentativeTom"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="StraightLineProgramsTom" Arg='tom'/>

<Description>
For a table of marks <A>tom</A> with <Ref Func="IsTableOfMarksWithGens"/>
value <K>true</K>,
<Ref Func="StraightLineProgramsTom"/> returns a list that contains at
position <M>i</M> either a list of straight line programs or a
straight line program (see&nbsp;<Ref Sect="Straight Line Programs"/>),
encoding the generators of a representative of the <M>i</M>-th conjugacy
class of subgroups of <C>UnderlyingGroup( <A>tom</A> )</C>;
in the former case, each straight line program returns a generator,
in the latter case, the program returns the list of generators.
<P/>
There is no default method to compute the
<Ref Func="StraightLineProgramsTom"/> value
of a table of marks if they are not yet stored.
The value is known for all tables of marks that belong to the
&GAP; library of tables of marks
(see&nbsp;<Ref Sect="The Library of Tables of Marks"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="IsTableOfMarksWithGens" Arg='tom'/>

<Description>
This filter shall express the union of the filters
<C>IsTableOfMarks and HasStraightLineProgramsTom</C> and
<C>IsTableOfMarks and HasGeneratorsSubgroupsTom</C>.
If a table of marks <A>tom</A> has this filter set then <A>tom</A> can be
asked to compute information that is in general not uniquely determined
by a table of marks,
for example the positions of derived subgroups or normalizers of
subgroups
(see&nbsp;<Ref Func="DerivedSubgroupTom"/>, <Ref Func="NormalizerTom"/>).
<P/>
<Example><![CDATA[
gap> a5:= TableOfMarks( "A5" );;  IsTableOfMarksWithGens( a5 );
true
gap> HasGeneratorsSubgroupsTom( a5 );  HasStraightLineProgramsTom( a5 );
false
true
gap> alt5:= TableOfMarks( AlternatingGroup( 5 ) );;
gap> IsTableOfMarksWithGens( alt5 );
true
gap> HasGeneratorsSubgroupsTom(alt5); HasStraightLineProgramsTom(alt5);
true
false
gap> progs:= StraightLineProgramsTom( a5 );;
gap> OrdersTom( a5 );
[ 1, 2, 3, 4, 5, 6, 10, 12, 60 ]
gap> IsCyclicTom( a5, 4 );
false
gap> Length( progs[4] );
2
gap> progs[4][1];
<straight line program>
gap> # first generator of an el. ab group of order 4:
gap> Display( progs[4][1] );
# input:
r:= [ g1, g2 ];
# program:
r[3]:= r[2]*r[1];
r[4]:= r[3]*r[2]^-1*r[1]*r[3]*r[2]^-1*r[1]*r[2];
# return value:
r[4]
gap> x:= [ [ Z(2)^0, 0*Z(2) ], [ Z(2^2), Z(2)^0 ] ];;
gap> y:= [ [ Z(2^2), Z(2)^0 ], [ 0*Z(2), Z(2^2)^2 ] ];;
gap> res1:= ResultOfStraightLineProgram( progs[4][1], [ x, y ] );
[ [ Z(2)^0, 0*Z(2) ], [ Z(2^2)^2, Z(2)^0 ] ]
gap> res2:= ResultOfStraightLineProgram( progs[4][2], [ x, y ] );
[ [ Z(2)^0, 0*Z(2) ], [ Z(2^2), Z(2)^0 ] ]
gap> w:= y*x;;
gap> res1 = w*y^-1*x*w*y^-1*x*y;
true
gap> subgrp:= Group( res1, res2 );;  Size( subgrp );  IsCyclic( subgrp );
4
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="RepresentativeTom" Arg='tom, sub'/>
<Oper Name="RepresentativeTomByGenerators" Arg='tom, sub, gens'/>
<Oper Name="RepresentativeTomByGeneratorsNC" Arg='tom, sub, gens'/>

<Description>
Let <A>tom</A> be a table of marks with
<Ref Func="IsTableOfMarksWithGens"/> value <K>true</K>,
and <A>sub</A> a positive integer.
<Ref Func="RepresentativeTom"/> returns a representative of the
<A>sub</A>-th conjugacy class of subgroups of <A>tom</A>.
<P/>
If the attribute <Ref Attr="StraightLineProgramsTom"/> is set in
<A>tom</A> then methods for the operations
<Ref Func="RepresentativeTomByGenerators"/> and
<Ref Func="RepresentativeTomByGeneratorsNC"/> are available, which
return a representative of the <A>sub</A>-th conjugacy class of subgroups
of <A>tom</A>, as a subgroup of the group generated by <A>gens</A>.
This means that the standard generators of <A>tom</A> are replaced by
<A>gens</A>.
<P/>
<Ref Func="RepresentativeTomByGenerators"/> checks whether mapping the
standard generators of <A>tom</A> to <A>gens</A> extends to a group
isomorphism, and returns <K>fail</K> if not.
<Ref Func="RepresentativeTomByGeneratorsNC"/> omits all checks.
So <Ref Func="RepresentativeTomByGenerators"/> is thought mainly for
debugging purposes;
note that when several representatives are constructed, it is cheaper to
construct (and check) the isomorphism once, and to map the groups
returned by <Ref Func="RepresentativeTom"/> under this isomorphism.
The idea behind <Ref Func="RepresentativeTomByGeneratorsNC"/>, however,
is to avoid the overhead of using isomorphisms when <A>gens</A> are known
to be standard generators.
In order to proceed like this, the attribute
<Ref Attr="StraightLineProgramsTom"/> is needed.
<P/>
<Example><![CDATA[
gap> RepresentativeTom( a5, 4 );
Group([ (2,3)(4,5), (2,4)(3,5) ])
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Interface between Tables of Marks and Character Tables">
<Heading>The Interface between Tables of Marks and Character Tables</Heading>

The following examples require the &GAP; Character Table Library
to be available.
If it is not yet loaded then we load it now.
<P/>
<Example><![CDATA[
gap> LoadPackage( "ctbllib" );
true
]]></Example>
<P/>
<ManSection>
<Oper Name="FusionCharTableTom" Arg='tbl, tom'/>
<Oper Name="PossibleFusionsCharTableTom" Arg='tbl, tom[, options]'/>

<Description>
Let <A>tbl</A> be the ordinary character table of the group <M>G</M>,
say, and <A>tom</A> the table of marks of <M>G</M>.
<Ref Func="FusionCharTableTom"/> determines the fusion of the classes of
elements from <A>tbl</A> to the classes of cyclic subgroups on
<A>tom</A>, that is, a list that contains at position <M>i</M> the
position of the class of cyclic subgroups in <A>tom</A> that are
generated by elements in the <M>i</M>-th conjugacy class of elements in
<A>tbl</A>.
<P/>
Three cases are handled differently.
<Enum>
<Item>
  The fusion is explicitly stored on <A>tbl</A>.
  Then nothing has to be done.
  This happens only if both <A>tbl</A> and <A>tom</A> are tables from the
  &GAP; library (see&nbsp;<Ref Sect="The Library of Tables of Marks"/>
  and the manual of the &GAP; Character Table Library).
</Item>
<Item>
  The <Ref Attr="UnderlyingGroup" Label="for tables of marks"/> values of
  <A>tbl</A> and <A>tom</A> are known and equal.
  Then the group is used to compute the fusion.
</Item>
<Item>
  There is neither fusion nor group information available.
  In this case only necessary conditions can be checked,
  and if they are not sufficient to determine the fusion uniquely then
  <K>fail</K> is returned by <Ref Oper="FusionCharTableTom"/>.
</Item>
</Enum>
<P/>
<Ref Oper="PossibleFusionsCharTableTom"/> computes the list of possible
fusions from <A>tbl</A> to <A>tom</A>,
according to the criteria that have been checked.
So if <Ref Oper="FusionCharTableTom"/> returns a unique fusion then the
list returned by <Ref Oper="PossibleFusionsCharTableTom"/> for the same
arguments contains exactly this fusion,
and if <Ref Oper="FusionCharTableTom"/> returns <K>fail</K> then the
length of this list is different from <M>1</M>.
<!-- this is fishy!-->
<P/>
The optional argument <A>options</A> must be a record that may have the
following components.
<List>
<Mark><C>fusionmap</C></Mark>
<Item>
  a parametrized map which is an approximation of the desired map,
</Item>
<Mark><C>quick</C></Mark>
<Item>
  a Boolean;
  if <K>true</K> then as soon as only one possibility remains
  this possibility is returned immediately;
  the default value is <K>false</K>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> a5c:= CharacterTable( "A5" );;
gap> fus:= FusionCharTableTom( a5c, a5 );
[ 1, 2, 3, 5, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PermCharsTom" Arg='fus, tom' Label="via fusion map"/>
<Oper Name="PermCharsTom" Arg='tbl, tom' Label="from a character table"/>

<Description>
<Ref Func="PermCharsTom" Label="via fusion map"/> returns the list of
transitive permutation characters from the table of marks <A>tom</A>.
In the first form, <A>fus</A> must be the fusion map from the ordinary
character table of the group of <A>tom</A> to <A>tom</A>
(see&nbsp;<Ref Func="FusionCharTableTom"/>).
In the second form, <A>tbl</A> must be the character table of the group
of which <A>tom</A> is the table of marks.
If the fusion map is not uniquely determined
(see&nbsp;<Ref Func="FusionCharTableTom"/>) then <K>fail</K> is returned.
<P/>
If the fusion map <A>fus</A> is given as first argument then each
transitive permutation character is represented by its values list.
If the character table <A>tbl</A> is given then the permutation
characters are class function objects
(see Chapter&nbsp;<Ref Chap="Class Functions"/>).
<P/>
<Example><![CDATA[
gap> PermCharsTom( a5c, a5 );
[ Character( CharacterTable( "A5" ), [ 60, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 15, 3, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 12, 0, 0, 2, 2 ] ), 
  Character( CharacterTable( "A5" ), [ 10, 2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 6, 2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ) ]
gap> PermCharsTom( fus, a5 )[1];
[ 60, 0, 0, 0, 0 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Generic Construction of Tables of Marks">
<Heading>Generic Construction of Tables of Marks</Heading>

The following three operations construct a table of marks only from the
data given, i.e., without underlying group.

<ManSection>
<Oper Name="TableOfMarksCyclic" Arg='n'/>

<Description>
<Ref Func="TableOfMarksCyclic"/> returns the table of marks of the cyclic
group of order <A>n</A>.
<P/>
A cyclic group of order <A>n</A> has as its subgroups for each divisor
<M>d</M> of <A>n</A> a cyclic subgroup of order <M>d</M>.
<P/>
<Example><![CDATA[
gap> Display( TableOfMarksCyclic( 6 ) );
1:  6
2:  3 3
3:  2 . 2
4:  1 1 1 1

]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TableOfMarksDihedral" Arg='n'/>

<Description>
<Ref Func="TableOfMarksDihedral"/> returns the table of marks of the
dihedral group of order <A>m</A>.
<P/>
For each divisor <M>d</M> of <A>m</A>, a dihedral group of order
<M>m = 2n</M> contains subgroups of order <M>d</M> according to the
following rule.
If <M>d</M> is odd and divides <M>n</M> then there is only one cyclic
subgroup of order <M>d</M>.
If <M>d</M> is even and divides <M>n</M> then there are a cyclic subgroup
of order <M>d</M> and two classes of dihedral subgroups of order <M>d</M>
(which are cyclic, too, in the case <M>d = 2</M>, see the example below).
Otherwise (i.e., if <M>d</M> does not divide <M>n</M>) there is just one
class of dihedral subgroups of order <M>d</M>.
<P/>
<Example><![CDATA[
gap> Display( TableOfMarksDihedral( 12 ) );
 1:  12
 2:   6 6
 3:   6 . 2
 4:   6 . . 2
 5:   4 . . . 4
 6:   3 3 1 1 . 1
 7:   2 2 . . 2 . 2
 8:   2 . 2 . 2 . . 2
 9:   2 . . 2 2 . . . 2
10:   1 1 1 1 1 1 1 1 1 1

]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TableOfMarksFrobenius" Arg='p, q'/>

<Description>
<Ref Func="TableOfMarksFrobenius"/> computes the table of marks of a
Frobenius group of order <M>p q</M>, where <M>p</M> is a prime and
<M>q</M> divides <M>p-1</M>.
<P/>
<Example><![CDATA[
gap> Display( TableOfMarksFrobenius( 5, 4 ) );
1:  20
2:  10 2
3:   5 1 1
4:   4 . . 4
5:   2 2 . 2 2
6:   1 1 1 1 1 1

]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Library of Tables of Marks">
<Heading>The Library of Tables of Marks</Heading>

The &GAP; package <Package>TomLib</Package> provides access to several
hundred tables of marks of almost simple groups and their maximal subgroups.
If this package is installed then the tables from this database can be
accessed via <Ref Func="TableOfMarks" Label="for a string"/> with argument
a string.
If also the &GAP; Character Table Library is installed and contains the
ordinary character table of the group for which one wants to fetch the table
of marks then one can also call
<Ref Func="TableOfMarks" Label="for a string"/>
<!-- This reference is not correct.
     The Character Table Library or the ``Interface'' section above
     should document this method,
     and then an external reference should be created. -->
with argument the character table.
<P/>
A list of all names of tables of marks that are provided by the
<Package>TomLib</Package> package can be obtained via
<Ref Func="AllLibTomNames" BookName="tomlib"/>.
<P/>
<Example><![CDATA[
gap> names:= AllLibTomNames();;
gap> "A5" in names;
true
]]></Example>

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!--
%W  ctbl.xml                   GAP documentation               Thomas Breuer
%W                                                          Alexander Hulpke
%Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group

The documentation in this chapter corresponds to the declarations in the
library files ctbl.gd, ctblauto.gd, ctblgrp.gd, ctblothe.gd, ctblsolv.gd.
-->
<Chapter Label="Character Tables">
<Heading>Character Tables</Heading>

<Index>tables</Index>
This chapter describes operations for <E>character tables of finite groups</E>.
<P/>
Operations for <E>characters</E> (or, more general, <E>class functions</E>) are
described in Chapter&nbsp;<Ref Chap="Class Functions"/>.
<P/>
For a description of the &GAP; Library of Character Tables,
see the separate manual for the &GAP; package <Package>CTblLib</Package>.
<P/>
Several examples in this chapter require the &GAP; Character Table Library
to be available.
If it is not yet loaded then we load it now.
<P/>
<Example><![CDATA[
gap> LoadPackage( "ctbllib" );
true
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Some Remarks about Character Theory in GAP">
<Heading>Some Remarks about Character Theory in &GAP;</Heading>

It seems to be necessary to state some basic facts
&ndash;and maybe warnings&ndash;
at the beginning of the character theory package.
This holds for people who are familiar with character theory because
there is no global reference on computational character theory,
although there are many papers on this topic,
such as&nbsp;<Cite Key="NPP84"/> or&nbsp;<Cite Key="LP91"/>.
It holds, however, also for people who are familiar with &GAP; because
the general concept of domains (see Chapter&nbsp;<Ref Sect="Domains"/>)
plays no important role here
&ndash;we will justify this later in this section.
<P/>
Intuitively, <E>characters</E> (or more generally,
<E>class functions</E>) of a finite group <M>G</M> can be thought of as
certain mappings defined on <M>G</M>,
with values in the complex number field;
the set of all characters of <M>G</M> forms a semiring, with both
addition and multiplication defined pointwise, which is naturally
embedded into the ring of <E>generalized</E> (or <E>virtual</E>)
<E>characters</E> in the natural way.
A <M>&ZZ;</M>-basis of this ring, and also a vector space basis of the
complex vector space of class functions of <M>G</M>,
is given by the irreducible characters of <M>G</M>.
<P/>
At this stage one could ask where there is a problem, since all these
algebraic structures are supported by &GAP;.
But in practice, these structures are of minor importance,
compared to individual characters and the <E>character tables</E>
themselves (which are not domains in the sense of &GAP;).
<P/>
For computations with characters of a finite group <M>G</M> with <M>n</M>
conjugacy classes, say, we fix an ordering of the classes, and then
identify each class with its position according to this ordering.
Each character of <M>G</M> can be represented by a list of length
<M>n</M> in which the character value for elements of the <M>i</M>-th
class is stored at the <M>i</M>-th position.
Note that we need not know the conjugacy classes of <M>G</M> physically,
even our knowledge of <M>G</M> may be implicit in the sense that, e.g.,
we know how many classes of involutions <M>G</M> has, and which length
these classes have, but we never have seen an element of <M>G</M>,
or a presentation or representation of <M>G</M>.
This allows us to work with the character tables of very large groups,
e.g., of the so-called monster, where &GAP; has (currently) no chance
to deal with the group.
<P/>
As a consequence, also other information involving characters is given
implicitly.  For example, we can talk about the kernel of a character not
as a group but as a list of classes (more exactly: a list of their
positions according to the chosen ordering of classes) forming this
kernel; we can deduce the group order, the contained cyclic subgroups
and so on, but we do not get the group itself.
<P/>
So typical calculations with characters involve loops over lists of
character values.
For  example, the scalar product of two characters <M>\chi</M>,
<M>\psi</M> of <M>G</M> given by
<Display Mode="M">
[ \chi, \psi ] =
\left( \sum_{{g \in G}} \chi(g) \psi(g^{{-1}}) \right) / |G|
</Display>
can be written as
<Listing><![CDATA[
Sum( [ 1 .. n ], i -> SizesConjugacyClasses( t )[i] * chi[i]
                          * ComplexConjugate( psi[i] ) ) / Size( t );
]]></Listing>
where <C>t</C> is the character table of <M>G</M>, and <C>chi</C>,
<C>psi</C> are the lists of values of <M>\chi</M>, <M>\psi</M>,
respectively.
<P/>
It is one of the advantages of character theory that after one has
translated a problem concerning groups into a problem concerning
only characters, the necessary calculations are mostly simple.
For example, one can often prove that a group is a Galois group over the
rationals using calculations with structure constants that can be
computed from the character table,
and information about (the character tables of) maximal subgroups.
When one deals with such questions,
the translation back to groups is just an interpretation by the user,
it does not take place in &GAP;.
<P/>
&GAP; uses character <E>tables</E> to store information such as class
lengths, element orders, the irreducible characters of <M>G</M>
etc.&nbsp;in a consistent way;
in the example above, we have seen that
<Ref Attr="SizesConjugacyClasses"/> returns
the list of class lengths of its argument.
Note that the values of these attributes rely on the chosen ordering
of conjugacy classes,
a character table is not determined by something similar to generators
of groups or rings in &GAP; where knowledge could in principle be
recovered from the generators but is stored mainly for the sake of
efficiency.
<P/>
Note that the character table of a group <M>G</M> in &GAP; must
<E>not</E> be mixed up with the list of complex irreducible characters
of <M>G</M>.
The irreducible characters are stored in a character table via the
attribute <Ref Attr="Irr" Label="for a group"/>.
<P/>
Two further important instances of information that depends on the
ordering of conjugacy classes are <E>power maps</E> and
<E>fusion maps</E>.
Both are represented as lists of integers in &GAP;.
The <M>k</M>-th power map maps each class to the class of <M>k</M>-th
powers of its elements, the corresponding list contains at each position
the position of the image.
A class fusion map between the classes of a subgroup <M>H</M> of <M>G</M>
and the classes of <M>G</M> maps each class <M>c</M> of <M>H</M> to that
class of <M>G</M> that contains <M>c</M>, the corresponding list contains
again the positions of image classes;
if we know only the character tables of <M>H</M> and <M>G</M> but not the
groups themselves,
this means with respect to a fixed embedding of <M>H</M> into <M>G</M>.
More about power maps and fusion maps can be found in
Chapter&nbsp;<Ref Chap="Maps Concerning Character Tables"/>.
<P/>
So class functions, power maps, and fusion maps are represented by lists
in &GAP;.
If they are plain lists then they are regarded as class functions
etc.&nbsp;of an appropriate character table when they are passed to &GAP;
functions that expect class functions etc.
For example, a list with all entries equal to 1 is regarded as the
trivial character if it is passed to a function that expects a character.
Note that this approach requires the character table as an argument for
such a function.
<P/>
One can construct class function objects that store their underlying
character table and other attribute values
(see Chapter&nbsp;<Ref Chap="Class Functions"/>).
This allows one to omit the character table argument in many functions,
and it allows one to use infix operations for tensoring or inducing
class functions.


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="History of Character Theory Stuff in GAP">
<Heading>History of Character Theory Stuff in GAP</Heading>

&GAP; provides functions for dealing with group characters since the version
&GAP;&nbsp;3.1, which was released in March 1992.
The reason for adding this branch of mathematics to the topics of &GAP; was
(apart from the usefulness of character theoretic computations in general)
the insight that &GAP; provides an ideal environment for developing the
algorithms needed.
In particular, it had been decided at Lehrstuhl D für Mathematik
that the <Package>CAS</Package> system (a standalone Fortran program
together with a database of character tables, see&nbsp;<Cite Key="NPP84"/>)
should not be developed further and the functionality
of <Package>CAS</Package> should be made available in &GAP;.
The background was that extending <Package>CAS</Package>
(by new Fortran code) had turned out to be much less flexible
than writing analogous &GAP; library code.
<P/>
For integrating the existing character theory algorithms,
&GAP;'s memory management and long integer arithmetic were useful
as well as the list handling
&ndash;it is an important feature of character theoretic methods
that questions about groups are translated into manipulations of lists;
on the other hand, the datatype of cyclotomics
(see Chapter&nbsp;<Ref Func="Cyclotomics"/>)
was added to the &GAP; kernel because of the character theory algorithms.
For developing further code, also other areas of &GAP;'s library became
interesting, such as permutation groups, finite fields, and polynomials.
<P/>
The development of character theory code for &GAP; has been supported
by several DFG grants,
in particular the project
<Q>Representation Theory of Finite Groups and Finite Dimensional Algebras</Q>
(until 1991),
and the Schwerpunkt <Q>Algorithmische Zahlentheorie und Algebra</Q>
(from 1991 until 1997).
Besides that, several Diploma theses at Lehrstuhl D were concerned with
the development and/or implementation of algorithms dealing with characters
in &GAP;.
<P/>
The major contributions can be listed as follows.
<List>
<Item>
    The arithmetic for the cyclotomics data type,
    following&nbsp;<Cite Key="Zum89"/>,
    was first implemented by Marco van Meegen; an alternative approach was
    studied in the diploma thesis of Michael Scherner
    (see&nbsp;<Cite Key="Scherner92"/>)
    but was not efficient enough;
    later Martin Schönert replaced the implementation by a better one.
<!-- and since then, there have been more than 30 local improvements ... -->
</Item>
<Item>
    The basic routines for characters and character tables were written
    by Thomas Breuer and Götz Pfeiffer.
</Item>
<Item>
    The lattice related functions, such as <Ref Func="LLL"/>,
    <Ref Func="OrthogonalEmbeddings"/>,
    and <Ref Func="DnLattice"/>, were implemented by Ansgar Kaup
    (see&nbsp;<Cite Key="Kaup92"/>).
</Item>
<Item>
    Functions for computing possible class fusions, possible power maps,
    and table automorphisms were written by Thomas Breuer
    (see&nbsp;<Cite Key="Bre91"/>).
</Item>
<Item>
    Functions for computing possible permutation characters were written by
    Thomas Breuer (see&nbsp;<Cite Key="Bre91"/>)
    and Götz Pfeiffer (see&nbsp;<Cite Key="Pfe91"/>).
</Item>
<Item>
    Functions for computing character tables from groups were written by
    Alexander Hulpke (Dixon-Schneider algorithm,
    see&nbsp;<Cite Key="Hulpke93"/>)
    and Hans Ulrich Besche (Baum algorithm and Conlon algorithm,
    see&nbsp;<Cite Key="Besche92"/>).
</Item>
<Item>
    Functions for dealing with Clifford matrices were written by
    Ute Schiffer (see&nbsp;<Cite Key="Schiffer94"/>).
</Item>
<Item>
    Functions for monomiality questions were written by Thomas Breuer and
    Erzsébet Horváth.
</Item>
</List>
<P/>
Since then, the code has been maintained and extended further by
Alexander Hulpke (code related to his implementation of the Dixon-Schneider
algorithm) and Thomas Breuer.
<P/>
<!-- % D. Bauten? -->
Currently &GAP; does not provide special functionality for computing
Brauer character tables,
but there is an interface to the <Package>MOC</Package> system
(see&nbsp;<Cite Key="HJLP92"/>),
and the &GAP; Character Table Library contains many
known Brauer character tables.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Character Tables">
<Heading>Creating Character Tables</Heading>

<Index>tables</Index>
<Index>character tables</Index>
<Index>library tables</Index>
<Index Subkey="access to">character tables</Index>
<Index Subkey="calculate">character tables</Index>
<Index Subkey="of groups">character tables</Index>
There are in general five different ways to get a character table in
&GAP;.
You can
<P/>
<Enum>
<Item>
  compute the table from a group,
</Item>
<Item>
  read a file that contains the table data,
</Item>
<Item>
  construct the table using generic formulae,
</Item>
<Item>
  derive it from known character tables, or
</Item>
<Item>
  combine partial information about conjugacy classes, power maps
  of the group in question, and about (character tables of) some
  subgroups and supergroups.
</Item>
</Enum>
<P/>
In 1., the computation of the irreducible characters is the hardest part;
the different algorithms available for this are described
in&nbsp;<Ref Sect="Computing the Irreducible Characters of a Group"/>.
Possibility 2.&nbsp;is used for the character tables in the
&GAP; Character  Table Library, see the manual of this library.
Generic character tables &ndash;as addressed by 3.&ndash; are described
in&nbsp;<Ref Chap="Generic Character Tables" BookName="ctbllib"/>.
Several occurrences of 4.&nbsp;are described
in&nbsp;<Ref Sect="Constructing Character Tables from Others"/>.
The last of the above possibilities
<E>is currently not supported and will be described in a chapter of its
own when it becomes available</E>.
<P/>
The operation <Ref Func="CharacterTable" Label="for a group"/>
can be used for the cases 1. to 3.

<ManSection>
<Heading>CharacterTable</Heading>
<Oper Name="CharacterTable" Arg='G[, p]' Label="for a group"/>
<Oper Name="CharacterTable" Arg='ordtbl, p'
      Label="for an ordinary character table"/>
<Oper Name="CharacterTable" Arg='name[, param]' Label="for a string"/>

<Description>
Called with a group <A>G</A>,
<Ref Oper="CharacterTable" Label="for a group"/> calls the
attribute <Ref Attr="OrdinaryCharacterTable" Label="for a group"/>.
Called with first argument a group <A>G</A> or an ordinary character
table <A>ordtbl</A>, and second argument a prime <A>p</A>,
<Ref Oper="CharacterTable" Label="for a group"/> calls the operation
<Ref Oper="BrauerTable" Label="for a group, and a prime integer"/>.
<P/>
Called with a string <A>name</A> and perhaps optional parameters
<A>param</A>, <Ref Oper="CharacterTable" Label="for a string"/>
tries to access a character table from the &GAP; Character Table Library.
See the manual of the &GAP; package <Package>CTblLib</Package> for an
overview of admissible arguments.
An error is signalled if this &GAP; package is not loaded in this case.
<P/>
Probably the most interesting information about the character table is
its list of irreducibles, which can be accessed as the value of the
attribute <Ref Attr="Irr" Label="for a character table"/>.
If the argument of <Ref Oper="CharacterTable" Label="for a string"/> is a
string <A>name</A> then the irreducibles are just read from the library
file, therefore the returned table stores them already.
However, if <Ref Oper="CharacterTable" Label="for a group"/> is called
with a group <A>G</A> or with an ordinary character table <A>ordtbl</A>,
the irreducible characters are <E>not</E> computed by
<Ref Oper="CharacterTable" Label="for a group"/>.
They are only computed when the
<Ref Attr="Irr" Label="for a character table"/> value is accessed for
the first time, for example when <Ref Oper="Display"/> is called for the
table (see&nbsp;<Ref Sect="Printing Character Tables"/>).
This means for example that
<Ref Oper="CharacterTable" Label="for a group"/> returns its
result very quickly, and the first call of <Ref Oper="Display"/> for this
table may take some time because the irreducible characters must be
computed at that time before they can be displayed together with other
information stored on the character table.
The value of the filter <C>HasIrr</C> indicates whether the irreducible
characters have been computed already.
<P/>
The reason why <Ref Oper="CharacterTable" Label="for a group"/> does not
compute the irreducible characters is that there are situations where one
only needs the <Q>table head</Q>, that is, the information about
class lengths, power maps etc., but not the irreducibles.
For example, if one wants to inspect permutation characters of a group
then all one has to do is to induce the trivial characters of subgroups
one is interested in; for that, only class lengths and the class fusion
are needed.
Or if one wants to compute the Molien series
(see&nbsp;<Ref Func="MolienSeries"/>) for a given complex matrix group,
the irreducible characters of this group are in general of no interest.
<P/>
For details about different algorithms to compute the irreducible
characters,
see&nbsp;<Ref Sect="Computing the Irreducible Characters of a Group"/>.
<P/>
If the group <A>G</A> is given as an argument,
<Ref Oper="CharacterTable" Label="for a group"/> accesses the conjugacy
classes of <A>G</A> and therefore causes that these classes are
computed if they were not yet stored
(see <Ref Sect="The Interface between Character Tables and Groups"/>).
</Description>
</ManSection>

<ManSection>
<Heading>BrauerTable</Heading>
<Oper Name="BrauerTable" Arg='ordtbl, p'
      Label="for a character table, and a prime integer"/>
<Oper Name="BrauerTable" Arg='G, p'
      Label="for a group, and a prime integer"/>
<Oper Name="BrauerTableOp" Arg='ordtbl, p'/>
<Attr Name="ComputedBrauerTables" Arg='ordtbl'/>

<Description>
Called with an ordinary character table <A>ordtbl</A> or a
group <A>G</A>,
<Ref Oper="BrauerTable" Label="for a group, and a prime integer"/>
returns its <A>p</A>-modular
character table if &GAP; can compute this table, and <K>fail</K>
otherwise.
The <A>p</A>-modular table can be computed for <A>p</A>-solvable groups
(using the Fong-Swan Theorem) and in the case that <A>ordtbl</A> is a
table from the &GAP; character table library for which also the
<A>p</A>-modular table is contained in the table library.
<P/>
The default method for a group and a prime delegates to
<Ref Oper="BrauerTable" Label="for a group, and a prime integer"/>
for the ordinary character table of this group.
The default method for <A>ordtbl</A> uses the attribute
<Ref Attr="ComputedBrauerTables"/> for storing the computed Brauer table
at position <A>p</A>, and calls the operation <Ref Oper="BrauerTableOp"/>
for computing values that are not yet known.
<P/>
So if one wants to install a new method for computing Brauer tables
then it is sufficient to install it for <Ref Oper="BrauerTableOp"/>.
<P/>
The <K>mod</K> operator for a character table and a prime
(see&nbsp;<Ref Sect="Operators for Character Tables"/>) delegates to
<Ref Oper="BrauerTable" Label="for a group, and a prime integer"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="CharacterTableRegular" Arg='tbl, p'/>

<Description>
For an ordinary character table <A>tbl</A> and a prime integer <A>p</A>,
<Ref Func="CharacterTableRegular"/> returns the <Q>table head</Q> of the
<A>p</A>-modular Brauer character table of <A>tbl</A>.
This is the restriction of <A>tbl</A> to its <A>p</A>-regular classes,
like the return value of <Ref Oper="BrauerTable" 
Label="for a character table, and a prime integer"/>,
but without the irreducible Brauer characters.
(In general, these characters are hard to compute,
and <Ref Oper="BrauerTable"
Label="for a character table, and a prime integer"/>
may return <K>fail</K> for the given arguments,
for example if <A>tbl</A> is a table from the &GAP; character table
library.)
<P/>
The returned table head can be used to create <A>p</A>-modular Brauer
characters, by restricting ordinary characters, for example when one
is interested in approximations of the (unknown) irreducible Brauer
characters.
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> tbl:= CharacterTable( g );;  HasIrr( tbl );
false
gap> tblmod2:= CharacterTable( tbl, 2 );
BrauerTable( Sym( [ 1 .. 4 ] ), 2 )
gap> tblmod2 = CharacterTable( tbl, 2 );
true
gap> tblmod2 = BrauerTable( tbl, 2 );
true
gap> tblmod2 = BrauerTable( g, 2 );
true
gap> libtbl:= CharacterTable( "M" );
CharacterTable( "M" )
gap> CharacterTableRegular( libtbl, 2 );
BrauerTable( "M", 2 )
gap> BrauerTable( libtbl, 2 );
fail
gap> CharacterTable( "Symmetric", 4 );
CharacterTable( "Sym(4)" )
gap> ComputedBrauerTables( tbl );
[ , BrauerTable( Sym( [ 1 .. 4 ] ), 2 ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="SupportedCharacterTableInfo"/>

<Description>
<Ref Var="SupportedCharacterTableInfo"/> is a list that contains
at position <M>3i-2</M> an attribute getter function,
at position <M>3i-1</M> the name of this attribute,
and at position <M>3i</M> a list containing one or two of the
strings <C>"class"</C>, <C>"character"</C>,
depending on whether the attribute value relies on the ordering of
classes or characters.
This allows one to set exactly the components with these names in the
record that is later converted to the new table,
in order to use the values as attribute values.
So the record components that shall <E>not</E> be regarded as attribute
values can be ignored.
Also other attributes of the old table are ignored.
<P/>
<Ref Var="SupportedCharacterTableInfo"/> is used when (ordinary or
Brauer) character table objects are created from records, using
<Ref Func="ConvertToCharacterTable"/>.
<P/>
New attributes and properties can be notified to
<Ref Var="SupportedCharacterTableInfo"/> by creating them with
<C>DeclareAttributeSuppCT</C> and <C>DeclarePropertySuppCT</C> instead of
<Ref Func="DeclareAttribute"/> and
<Ref Func="DeclareProperty"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ConvertToCharacterTable" Arg='record'/>
<Func Name="ConvertToCharacterTableNC" Arg='record'/>

<Description>
Let <A>record</A> be a record.
<Ref Func="ConvertToCharacterTable"/> converts <A>record</A> into a
component object
(see&nbsp;<Ref Sect="Component Objects"/>)
representing a character table.
The values of those components of <A>record</A> whose names occur in
<Ref Var="SupportedCharacterTableInfo"/>
correspond to attribute values of the returned character table.
All other components of the record simply become components of the
character table object.
<P/>
If inconsistencies in <A>record</A> are detected,
<K>fail</K> is returned.
<A>record</A> must have the component <C>UnderlyingCharacteristic</C>
bound
(cf.&nbsp;<Ref Attr="UnderlyingCharacteristic" Label="for a character table"/>),
since this decides about whether the returned character table lies in
<Ref Filt="IsOrdinaryTable"/> or in <Ref Filt="IsBrauerTable"/>.
<P/>
<Ref Func="ConvertToCharacterTableNC"/> does the same except that all
checks of <A>record</A> are omitted.
<P/>
An example of a conversion from a record to a character table object
can be found in Section&nbsp;<Ref Func="PrintCharacterTable"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Character Table Categories">
<Heading>Character Table Categories</Heading>

<ManSection>
<Filt Name="IsNearlyCharacterTable" Arg='obj' Type='Category'/>
<Filt Name="IsCharacterTable" Arg='obj' Type='Category'/>
<Filt Name="IsOrdinaryTable" Arg='obj' Type='Category'/>
<Filt Name="IsBrauerTable" Arg='obj' Type='Category'/>
<Filt Name="IsCharacterTableInProgress" Arg='obj' Type='Category'/>

<Description>
Every <Q>character table like object</Q> in &GAP; lies in the category
<Ref Filt="IsNearlyCharacterTable"/>.
There are four important subcategories,
namely the <E>ordinary</E> tables in <Ref Filt="IsOrdinaryTable"/>,
the <E>Brauer</E> tables in <Ref Filt="IsBrauerTable"/>,
the union of these two in <Ref Filt="IsCharacterTable"/>,
and the <E>incomplete ordinary</E> tables in
<Ref Filt="IsCharacterTableInProgress"/>.
<P/>
We want to distinguish ordinary and Brauer tables because a Brauer table
may delegate tasks to the ordinary table of the same group,
for example the computation of power maps.
A Brauer table is constructed from an ordinary table and stores this
table upon construction
(see&nbsp;<Ref Attr="OrdinaryCharacterTable" Label="for a group"/>).
<P/>
Furthermore, <Ref Filt="IsOrdinaryTable"/> and
<Ref Filt="IsBrauerTable"/> denote character tables that provide enough
information to compute all power maps and irreducible characters (and in
the case of Brauer tables to get the ordinary table), for example because
the underlying group
(see&nbsp;<Ref Attr="UnderlyingGroup" Label="for character tables"/>) is
known or because the table is a library table
(see the manual of the &GAP; Character Table Library).
We want to distinguish these tables from partially known ordinary tables
that cannot be asked for all power maps or all irreducible characters.
<P/>
The character table objects in <Ref Filt="IsCharacterTable"/> are always
immutable (see&nbsp;<Ref Sect="Mutability and Copyability"/>).
This means mainly that the ordering of conjugacy classes used for the
various attributes of the character table cannot be changed;
see&nbsp;<Ref Sect="Sorted Character Tables"/> for how to compute a
character table with a different ordering of classes.
<P/>
The &GAP; objects in <Ref Filt="IsCharacterTableInProgress"/> represent
incomplete ordinary character tables.
This means that not all irreducible characters, not all power maps are
known, and perhaps even the number of classes and the centralizer orders
are known.
Such tables occur when the character table of a group <M>G</M> is
constructed using character tables of related groups and information
about <M>G</M> but for example without explicitly computing the conjugacy
classes of <M>G</M>.
An object in <Ref Filt="IsCharacterTableInProgress"/> is first of all
<E>mutable</E>,
so <E>nothing is stored automatically</E> on such a table,
since otherwise one has no control of side-effects when
a hypothesis is changed.
Operations for such tables may return more general values than for
other tables, for example class functions may contain unknowns
(see Chapter&nbsp;<Ref Chap="Unknowns"/>) or lists of possible values in
certain positions,
the same may happen also for power maps and class fusions
(see&nbsp;<Ref Sect="Parametrized Maps"/>).
<E>Incomplete tables in this sense are currently not supported and will be
described in a chapter of their own when they become available.</E>
Note that the term <Q>incomplete table</Q> shall express that &GAP; cannot
compute certain values such as irreducible characters or power maps.
A table with access to its group is therefore always complete,
also if its irreducible characters are not yet stored.
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 4 );;
gap> tbl:= CharacterTable( g );  modtbl:= tbl mod 2;
CharacterTable( Sym( [ 1 .. 4 ] ) )
BrauerTable( Sym( [ 1 .. 4 ] ), 2 )
gap> IsCharacterTable( tbl );  IsCharacterTable( modtbl );
true
true
gap> IsBrauerTable( modtbl );  IsBrauerTable( tbl );
true
false
gap> IsOrdinaryTable( tbl );  IsOrdinaryTable( modtbl );
true
false
gap> IsCharacterTable( g );  IsCharacterTable( Irr( g ) );
false
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<InfoClass Name="InfoCharacterTable"/>

<Description>
is the info class (see&nbsp;<Ref Sect="Info Functions"/>) for
computations with character tables.
</Description>
</ManSection>

<ManSection>
<Var Name="NearlyCharacterTablesFamily"/>

<Description>
Every character table like object lies in this family
(see&nbsp;<Ref Sect="Families"/>).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Conventions for Character Tables">
<Heading>Conventions for Character Tables</Heading>

The following few conventions should be noted.
<List>
<Item>
  The class of the <E>identity element</E> is expected to be the first one;
  thus the degree of a character is the character value at position <M>1</M>.
</Item>
<Item>
  The <E>trivial character</E> of a character table need not be the first in
  the list of irreducibles.
</Item>
<Item>
  Most functions that take a character table as an argument and work with
  characters expect these characters as an argument, too.
  For some functions, the list of irreducible characters serves as the
  default, i.e, the value of the attribute
  <Ref Attr="Irr" Label="for a character table"/>;
  in these cases,
  the <Ref Attr="Irr" Label="for a character table"/> value is
  automatically computed if it was not yet known.
</Item>
<Item>
  For a stored class fusion, the image table is denoted by its
  <Ref Attr="Identifier" Label="for character tables"/> value;
  each library table has a unique identifier by which it can be accessed
  (see&nbsp;<Ref Sect="Accessing a Character Table from the Library"
  BookName="ctbllib"/> in the manual for the
  &GAP; Character Table Library),
  tables constructed from groups get an identifier that is unique in the
  current &GAP; session.
</Item>
</List>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Interface between Character Tables and Groups">
<Heading>The Interface between Character Tables and Groups</Heading>

For a character table with underlying group
(see&nbsp;<Ref Attr="UnderlyingGroup" Label="for character tables"/>),
the interface between table and group consists of three attribute values,
namely the <E>group</E>, the <E>conjugacy classes</E> stored in the table
(see <Ref Attr="ConjugacyClasses" Label="for character tables"/> below)
and the <E>identification</E> of the conjugacy classes of table and group
(see&nbsp;<Ref Func="IdentificationOfConjugacyClasses"/> below).
<P/>
Character tables constructed from groups know these values upon
construction,
and for character tables constructed without groups, these values are
usually not known and cannot be computed from the table.
<P/>
However, given a group <M>G</M> and a character table of a group
isomorphic to <M>G</M> (for example a character table from the
&GAP; table library),
one can tell &GAP; to compute a new instance of the given table and to
use it as the character table of <M>G</M>
(see&nbsp;<Ref Func="CharacterTableWithStoredGroup"/>).
<P/>
Tasks may be delegated from a group to its character table or vice versa
only if these three attribute values are stored in the character table.

<ManSection>
<Attr Name="UnderlyingGroup" Arg='ordtbl' Label="for character tables"/>

<Description>
For an ordinary character table <A>ordtbl</A> of a finite group,
the group can be stored as value of
<Ref Attr="UnderlyingGroup" Label="for character tables"/>.
<P/>
Brauer tables do not store the underlying group,
they access it via the ordinary table
(see&nbsp;<Ref Attr="OrdinaryCharacterTable" Label="for a character table"/>).
</Description>
</ManSection>

<ManSection>
<Attr Name="ConjugacyClasses" Arg='tbl' Label="for character tables"/>

<Description>
For a character table <A>tbl</A> with known underlying group <M>G</M>,
the <Ref Func="ConjugacyClasses" Label="for character tables"/> value of
<A>tbl</A> is a list of conjugacy classes of <M>G</M>.
All those lists stored in the table that are related to the ordering
of conjugacy classes (such as sizes of centralizers and conjugacy
classes, orders of representatives, power maps, and all class functions)
refer to the ordering of this list.
<P/>
This ordering need <E>not</E> coincide with the ordering of conjugacy
classes as stored in the underlying group of the table
(see&nbsp;<Ref Sect="Sorted Character Tables"/>).
One reason for this is that otherwise we would not be allowed to
use a library table as the character table of a group for which the
conjugacy classes are stored already.
(Another, less important reason is that we can use the same group as
underlying group of character tables that differ only w.r.t.&nbsp;the
ordering of classes.)
<P/>
The class of the identity element must be the first class
(see&nbsp;<Ref Sect="Conventions for Character Tables"/>).
<P/>
If <A>tbl</A> was constructed from <M>G</M> then the conjugacy classes
have been stored at the same time when <M>G</M> was stored.
If <M>G</M> and <A>tbl</A> have been connected later than in the
construction of <A>tbl</A>, the recommended way to do this is via
<Ref Func="CharacterTableWithStoredGroup"/>.
So there is no method for
<Ref Attr="ConjugacyClasses" Label="for character tables"/> that computes
the value for <A>tbl</A> if it is not yet stored.
<P/>
Brauer tables do not store the (<M>p</M>-regular) conjugacy classes,
they access them via the ordinary table
(see&nbsp;<Ref Attr="OrdinaryCharacterTable" Label="for a character table"/>)
if necessary.
</Description>
</ManSection>

<ManSection>
<Attr Name="IdentificationOfConjugacyClasses" Arg='tbl'/>

<Description>
For an ordinary character table <A>tbl</A> with known underlying group
<M>G</M>, <Ref Attr="IdentificationOfConjugacyClasses"/> returns a list
of positive integers that contains at position <M>i</M> the position of
the <M>i</M>-th conjugacy class of <A>tbl</A> in the
<Ref Attr="ConjugacyClasses" Label="for character tables"/> value of
<M>G</M>.
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 4 );;
gap> repres:= [ (1,2), (1,2,3), (1,2,3,4), (1,2)(3,4), () ];;
gap> ccl:= List( repres, x -> ConjugacyClass( g, x ) );;
gap> SetConjugacyClasses( g, ccl );
gap> tbl:= CharacterTable( g );;   # the table stores already the values
gap> HasConjugacyClasses( tbl );  HasUnderlyingGroup( tbl );
true
true
gap> UnderlyingGroup( tbl ) = g;
true
gap> HasIdentificationOfConjugacyClasses( tbl );
true
gap> IdentificationOfConjugacyClasses( tbl );
[ 5, 1, 2, 3, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CharacterTableWithStoredGroup" Arg='G, tbl[, info]'/>

<Description>
Let <A>G</A> be a group and <A>tbl</A> a character table of (a group
isomorphic to) <A>G</A>, such that <A>G</A> does not store its
<Ref Attr="OrdinaryCharacterTable" Label="for a group"/> value.
<Ref Func="CharacterTableWithStoredGroup"/> calls
<Ref Func="CompatibleConjugacyClasses"/>,
trying to identify the classes of <A>G</A> with the columns of
<A>tbl</A>.
<P/>
If this identification is unique up to automorphisms of <A>tbl</A>
(see&nbsp;<Ref Func="AutomorphismsOfTable"/>) then <A>tbl</A> is stored
as <Ref Attr="CharacterTable" Label="for a group"/> value of <A>G</A>,
and a new character table is returned that is equivalent to <A>tbl</A>,
is sorted in the same way as <A>tbl</A>, and has the values of
<Ref Attr="UnderlyingGroup" Label="for character tables"/>,
<Ref Attr="ConjugacyClasses" Label="for character tables"/>, and
<Ref Attr="IdentificationOfConjugacyClasses"/> set.
<P/>
Otherwise, i.e., if &GAP; cannot identify the classes of <A>G</A> up to
automorphisms of <A>tbl</A>, <K>fail</K> is returned.
<P/>
If a record is present as the third argument <A>info</A>,
its meaning is the same as the optional argument <A>arec</A> for
<Ref Func="CompatibleConjugacyClasses"/>.
<P/>
If a list is entered as third argument <A>info</A>
it is used as value of <Ref Func="IdentificationOfConjugacyClasses"/>,
relative to the
<Ref Attr="ConjugacyClasses" Label="for character tables"/>
value of <A>G</A>, without further checking,
and the corresponding character table is returned.
</Description>
</ManSection>

<ManSection>
<Oper Name="CompatibleConjugacyClasses" Arg='[G, ccl, ]tbl[, arec]'/>

<Description>
If the arguments <A>G</A> and <A>ccl</A> are present then <A>ccl</A> must
be a list of the conjugacy classes of the group <A>G</A>,
and <A>tbl</A> the ordinary character table of <A>G</A>.
Then <Ref Oper="CompatibleConjugacyClasses"/> returns a list <M>l</M> of
positive integers that describes an identification of the columns of
<A>tbl</A> with the conjugacy classes <A>ccl</A> in the sense that
<M>l[i]</M> is the position in <A>ccl</A> of the class corresponding to
the <M>i</M>-th column of <A>tbl</A>, if this identification is unique up
to automorphisms of <A>tbl</A>
(see&nbsp;<Ref Func="AutomorphismsOfTable"/>);
if &GAP; cannot identify the classes, <K>fail</K> is returned.
<P/>
If <A>tbl</A> is the first argument then it must be an ordinary character
table, and <Ref Oper="CompatibleConjugacyClasses"/> checks whether the
columns of <A>tbl</A> can be identified with the conjugacy classes of
a group isomorphic to that for which <A>tbl</A> is the character table;
the return value is a list of all those sets of class positions for which
the columns of <A>tbl</A> cannot be distinguished with the invariants
used, up to automorphisms of <A>tbl</A>.
So the identification is unique if and only if the returned list is
empty.
<P/>
The usual approach is that one first calls
<Ref Oper="CompatibleConjugacyClasses"/>
in the second form for checking quickly whether the first form will be
successful, and only if this is the case the more time consuming
calculations with both group and character table are done.
<P/>
The following invariants are used.
<Enum>
<Item>
 element orders (see&nbsp;<Ref Attr="OrdersClassRepresentatives"/>),
</Item>
<Item>
 class lengths (see&nbsp;<Ref Attr="SizesConjugacyClasses"/>),
</Item>
<Item>
 power maps (see&nbsp;<Ref Func="PowerMap"/>,
 <Ref Attr="ComputedPowerMaps"/>),
</Item>
<Item>
 symmetries of the table (see&nbsp;<Ref Attr="AutomorphismsOfTable"/>).
</Item>
</Enum>
<P/>
If the optional argument <A>arec</A> is present then it must be a record
whose components describe additional information for the class
identification.
The following components are supported.
<List>
<Mark><C>natchar</C> </Mark>
<Item>
  if <M>G</M> is a permutation group or matrix group then the value of
  this component is regarded as the list of values of the natural
  character (see&nbsp;<Ref Func="NaturalCharacter" Label="for a group"/>)
  of <A>G</A>, w.r.t.&nbsp;the ordering of classes in <A>tbl</A>,
</Item>
<Mark><C>bijection</C> </Mark>
<Item>
  a list describing a partial bijection; the <M>i</M>-th entry, if bound,
  is the position of the <M>i</M>-th conjugacy class of <A>tbl</A> in the
  list <A>ccl</A>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> g:= AlternatingGroup( 5 );
Alt( [ 1 .. 5 ] )
gap> tbl:= CharacterTable( "A5" );
CharacterTable( "A5" )
gap> HasUnderlyingGroup( tbl );  HasOrdinaryCharacterTable( g );
false
false
gap> CompatibleConjugacyClasses( tbl );   # unique identification
[  ]
gap> new:= CharacterTableWithStoredGroup( g, tbl );
CharacterTable( Alt( [ 1 .. 5 ] ) )
gap> Irr( new ) = Irr( tbl );
true
gap> HasConjugacyClasses( new );  HasUnderlyingGroup( new );
true
true
gap> IdentificationOfConjugacyClasses( new );
[ 1, 2, 3, 4, 5 ]
gap> # Here is an example where the identification is not unique.
gap> CompatibleConjugacyClasses( CharacterTable( "J2" ) );
[ [ 17, 18 ], [ 9, 10 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operators for Character Tables">
<Heading>Operators for Character Tables</Heading>

<Index Key="*" Subkey="for character tables"><C>*</C></Index>
<Index Key="/" Subkey="for character tables"><C>/</C></Index>
<Index Key="mod" Subkey="for character tables"><K>mod</K></Index>
<Index Subkey="infix operators">character tables</Index>
The following infix operators are defined for character tables.
<List>
<Mark><C><A>tbl1</A> * <A>tbl2</A></C></Mark>
<Item>
    the direct product of two character tables
    (see&nbsp;<Ref Func="CharacterTableDirectProduct"/>),
</Item>
<Mark><C><A>tbl</A> / <A>list</A></C></Mark>
<Item>
    the table of the factor group modulo the normal subgroup spanned by
    the classes in the list <A>list</A>
    (see&nbsp;<Ref Func="CharacterTableFactorGroup"/>),
</Item>
<Mark><C><A>tbl</A> mod <A>p</A></C></Mark>
<Item>
    the <A>p</A>-modular Brauer character table corresponding to
    the ordinary character table <A>tbl</A>
    (see&nbsp;<Ref Attr="BrauerTable"
Label="for a character table, and a prime integer"/>),
</Item>
<Mark><C><A>tbl</A>.<A>name</A></C></Mark>
<Item>
    the position of the class with name <A>name</A> in <A>tbl</A>
    (see&nbsp;<Ref Attr="ClassNames"/>).
</Item>
</List>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties of Character Tables">
<Heading>Attributes and Properties for Groups and Character Tables</Heading>

Several <E>attributes for groups</E> are valid also for character tables.
<P/>
These are first those that have the same meaning for both
the group and its character table,
and whose values can be read off or computed, respectively,
from the character table,
such as <Ref Attr="Size" Label="for a character table"/>,
<Ref Prop="IsAbelian" Label="for a character table"/>,
or <Ref Prop="IsSolvable" Label="for a character table"/>.
<P/>
Second, there are attributes whose meaning for character
tables is different from the meaning for groups, such as
<Ref Attr="ConjugacyClasses" Label="for character tables"/>.

<ManSection>
<Heading>CharacterDegrees</Heading>
<Attr Name="CharacterDegrees" Arg='G[, p]' Label="for a group"/>
<Attr Name="CharacterDegrees" Arg='tbl' Label="for a character table"/>

<Description>
In the first form, <Ref Attr="CharacterDegrees" Label="for a group"/>
returns a collected list of the degrees of the absolutely irreducible
characters of the group <A>G</A>;
the optional second argument <A>p</A> must be either zero or a prime
integer denoting the characteristic, the default value is zero.
In the second form, <A>tbl</A> must be an (ordinary or Brauer) character
table, and <Ref Attr="CharacterDegrees" Label="for a character table"/>
returns a collected list of the degrees of the absolutely irreducible
characters of <A>tbl</A>.
<P/>
(The default method for the call with only argument a group is to call
the operation with second argument <C>0</C>.)
<P/>
For solvable groups,
the default method is based on&nbsp;<Cite Key="Con90b"/>.
<P/>
<Example><![CDATA[
gap> CharacterDegrees( SymmetricGroup( 4 ) );
[ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ] ]
gap> CharacterDegrees( SymmetricGroup( 4 ), 2 );
[ [ 1, 1 ], [ 2, 1 ] ]
gap> CharacterDegrees( CharacterTable( "A5" ) );
[ [ 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5, 1 ] ]
gap> CharacterDegrees( CharacterTable( "A5" ) mod 2 );
[ [ 1, 1 ], [ 2, 2 ], [ 4, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Irr</Heading>
<Attr Name="Irr" Arg='G[, p]' Label="for a group"/>
<Attr Name="Irr" Arg='tbl' Label="for a character table"/>

<Description>
Called with a group <A>G</A>, <Ref Attr="Irr" Label="for a group"/>
returns the irreducible characters of the ordinary character table of
<A>G</A>.
Called with a group <A>G</A> and a prime integer <A>p</A>,
<Ref Attr="Irr" Label="for a group"/> returns the irreducible characters
of the <A>p</A>-modular Brauer table of <A>G</A>.
Called with an (ordinary or Brauer) character table <A>tbl</A>,
<Ref Attr="Irr" Label="for a group"/> returns the list of all
complex absolutely irreducible characters of <A>tbl</A>.
<P/>
For a character table <A>tbl</A> with underlying group,
<Ref Attr="Irr" Label="for a character table"/> may delegate to the group.
For a group <A>G</A>, <Ref Attr="Irr" Label="for a group"/> may delegate
to its character table only if the irreducibles are already stored there.
<P/>
(If <A>G</A> is <A>p</A>-solvable (see&nbsp;<Ref Attr="IsPSolvable"/>)
then the <A>p</A>-modular irreducible characters can be computed by the
Fong-Swan Theorem; in all other cases, there may be no method.)
<P/>
Note that the ordering of columns in the
<Ref Attr="Irr" Label="for a group"/> matrix of the
group <A>G</A> refers to the ordering of conjugacy classes in the
<Ref Attr="CharacterTable" Label="for a group"/> value of <A>G</A>,
which may differ from the ordering of conjugacy classes in <A>G</A>
(see <Ref Sect="The Interface between Character Tables and Groups"/>).
As an extreme example, for a character table obtained from sorting the
classes of the <Ref Attr="CharacterTable" Label="for a group"/>
value of <A>G</A>,
the ordering of columns in the <Ref Attr="Irr" Label="for a group"/>
matrix respects the
sorting of classes (see&nbsp;<Ref Sect="Sorted Character Tables"/>),
so the irreducibles of such a table will in general not coincide with
the irreducibles stored as the <Ref Attr="Irr" Label="for a group"/>
value of <A>G</A> although also the sorted table stores the group
<A>G</A>.
<P/>
The ordering of the entries in the attribute
<Ref Attr="Irr" Label="for a group"/> of a group
need <E>not</E> coincide with the ordering of its
<Ref Func="IrreducibleRepresentations"/> value.
<P/>
<Example><![CDATA[
gap> Irr( SymmetricGroup( 4 ) );
[ Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, -1, 1, 1, -1 
     ] ), Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), 
    [ 3, -1, -1, 0, 1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 2, 0, 2, -1, 0 ] )
    , Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), 
    [ 3, 1, -1, 0, -1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] ) 
 ]
gap> Irr( SymmetricGroup( 4 ), 2 );
[ Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 1, 1 ] ), 
  Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 2, -1 ] ) ]
gap> Irr( CharacterTable( "A5" ) );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
gap> Irr( CharacterTable( "A5" ) mod 2 );
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>LinearCharacters</Heading>
<Attr Name="LinearCharacters" Arg='G[, p]' Label="for a group"/>
<Attr Name="LinearCharacters" Arg='tbl' Label="for a character table"/>

<Description>
<Ref Attr="LinearCharacters" Label="for a group"/> returns the linear
(i.e., degree <M>1</M>) characters in the
<Ref Attr="Irr" Label="for a group"/> list of the group
<A>G</A> or the character table <A>tbl</A>, respectively.
In the second form,
<Ref Attr="LinearCharacters" Label="for a character table"/> returns the
<A>p</A>-modular linear characters of the group <A>G</A>.
<P/>
For a character table <A>tbl</A> with underlying group,
<Ref Attr="LinearCharacters" Label="for a character table"/> may delegate
to the group.
For a group <A>G</A>, <Ref Attr="LinearCharacters" Label="for a group"/>
may delegate to its character table only if the irreducibles
are already stored there.
<P/>
The ordering of linear characters in <A>tbl</A> need not coincide with the
ordering of linear characters in the irreducibles of <A>tbl</A>
(see&nbsp;<Ref Attr="Irr" Label="for a character table"/>).
<P/>
<Example><![CDATA[
gap> LinearCharacters( SymmetricGroup( 4 ) );
[ Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] ),
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, -1, 1, 1, -1 
     ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>OrdinaryCharacterTable</Heading>
<Attr Name="OrdinaryCharacterTable" Arg='G' Label="for a group"/>
<Attr Name="OrdinaryCharacterTable" Arg='modtbl'
      Label="for a character table"/>

<Description>
<Ref Attr="OrdinaryCharacterTable" Label="for a group"/> returns the
ordinary character table of the group <A>G</A>
or the Brauer character table <A>modtbl</A>, respectively.
<P/>
Since Brauer character tables are constructed from ordinary tables,
the attribute value for <A>modtbl</A> is already stored
(cf.&nbsp;<Ref Sect="Character Table Categories"/>).
<P/>
<Example><![CDATA[
gap> OrdinaryCharacterTable( SymmetricGroup( 4 ) );
CharacterTable( Sym( [ 1 .. 4 ] ) )
gap> tbl:= CharacterTable( "A5" );;  modtbl:= tbl mod 2;
BrauerTable( "A5", 2 )
gap> OrdinaryCharacterTable( modtbl ) = tbl;
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Group Operations Applicable to Character Tables</Heading>
<Attr Name="AbelianInvariants" Arg='tbl' Label="for a character table"/>
<Attr Name="CommutatorLength" Arg='tbl' Label="for a character table"/>
<Attr Name="Exponent" Arg='tbl' Label="for a character table"/>
<Prop Name="IsAbelian" Arg='tbl' Label="for a character table"/>
<Prop Name="IsAlmostSimple" Arg='tbl' Label="for a character table"/>
<Prop Name="IsCyclic" Arg='tbl' Label="for a character table"/>
<Prop Name="IsElementaryAbelian" Arg='tbl' Label="for a character table"/>
<Prop Name="IsFinite" Arg='tbl' Label="for a character table"/>
<Prop Name="IsMonomial" Arg='tbl' Label="for a character table"/>
<Prop Name="IsNilpotent" Arg='tbl' Label="for a character table"/>
<Prop Name="IsPerfect" Arg='tbl' Label="for a character table"/>
<Prop Name="IsSimple" Arg='tbl' Label="for a character table"/>
<Prop Name="IsSolvable" Arg='tbl' Label="for a character table"/>
<Prop Name="IsSporadicSimple" Arg='tbl' Label="for a character table"/>
<Prop Name="IsSupersolvable" Arg='tbl' Label="for a character table"/>
<Attr Name="IsomorphismTypeInfoFiniteSimpleGroup" Arg='tbl'
 Label="for a character table"/>
<Attr Name="NrConjugacyClasses" Arg='tbl' Label="for a character table"/>
<Attr Name="Size" Arg='tbl' Label="for a character table"/>

<Description>
These operations for groups are applicable to character tables
and mean the same for a character table as for its underlying group;
see Chapter <Ref Chap="Groups"/> for the definitions.
The operations are mainly useful for selecting character tables with
certain properties, also for character tables without access to a group.
<P/>
<Example><![CDATA[
gap> tables:= [ CharacterTable( CyclicGroup( 3 ) ),
>               CharacterTable( SymmetricGroup( 4 ) ),
>               CharacterTable( AlternatingGroup( 5 ) ) ];;
gap> List( tables, AbelianInvariants );
[ [ 3 ], [ 2 ], [  ] ]
gap> List( tables, CommutatorLength );
[ 1, 1, 1 ]
gap> List( tables, Exponent );
[ 3, 12, 30 ]
gap> List( tables, IsAbelian );
[ true, false, false ]
gap> List( tables, IsAlmostSimple );
[ false, false, true ]
gap> List( tables, IsCyclic );
[ true, false, false ]
gap> List( tables, IsFinite );
[ true, true, true ]
gap> List( tables, IsMonomial );
[ true, true, false ]
gap> List( tables, IsNilpotent );
[ true, false, false ]
gap> List( tables, IsPerfect );
[ false, false, true ]
gap> List( tables, IsSimple );
[ true, false, true ]
gap> List( tables, IsSolvable );
[ true, true, false ]
gap> List( tables, IsSupersolvable );
[ true, false, false ]
gap> List( tables, NrConjugacyClasses );
[ 3, 5, 5 ]
gap> List( tables, Size );
[ 3, 24, 60 ]
gap> IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "C5" ) );
rec( name := "Z(5)", parameter := 5, series := "Z" )
gap> IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "S3" ) );
fail
gap> IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "S6(3)" ) );
rec( name := "C(3,3) = S(6,3)", parameter := [ 3, 3 ], series := "C" )
gap> IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "O7(3)" ) );
rec( name := "B(3,3) = O(7,3)", parameter := [ 3, 3 ], series := "B" )
gap> IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "A8" ) );
rec( name := "A(8) ~ A(3,2) = L(4,2) ~ D(3,2) = O+(6,2)", 
  parameter := 8, series := "A" )
gap> IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "L3(4)" ) );
rec( name := "A(2,4) = L(3,4)", parameter := [ 3, 4 ], series := "L" )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties only for Character Tables">
<Heading>Attributes and Properties only for Character Tables</Heading>

The following three <E>attributes for character tables</E>
&ndash;<Ref Func="OrdersClassRepresentatives"/>,
<Ref Func="SizesCentralizers"/>, and
<Ref Func="SizesConjugacyClasses"/>&ndash; would make sense
also for groups but are in fact <E>not</E> used for groups.
This is because the values depend on the ordering of conjugacy classes
stored as the value of
<Ref Attr="ConjugacyClasses" Label="for character tables"/>,
and this value may differ for a group and its character table
(see <Ref Sect="The Interface between Character Tables and Groups"/>).
Note that for character tables, the consistency of attribute values must
be guaranteed,
whereas for groups, there is no need to impose such a consistency rule.
<P/>
The other attributes introduced in this section apply only to character
tables, not to groups.

<ManSection>
<Attr Name="OrdersClassRepresentatives" Arg='tbl'/>

<Description>
is a list of orders of representatives of conjugacy classes of the
character table <A>tbl</A>,
in the same ordering as the conjugacy classes of <A>tbl</A>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> OrdersClassRepresentatives( tbl );
[ 1, 2, 3, 5, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SizesCentralizers" Arg='tbl'/>
<Attr Name="SizesCentralisers" Arg='tbl'/>

<Description>
is a list that stores at position <M>i</M> the size of the centralizer of
any element in the <M>i</M>-th conjugacy class of the character table
<A>tbl</A>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> SizesCentralizers( tbl );
[ 60, 4, 3, 5, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="SizesConjugacyClasses" Arg='tbl'/>

<Description>
is a list that stores at position <M>i</M> the size of the <M>i</M>-th
conjugacy class of the character table <A>tbl</A>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> SizesConjugacyClasses( tbl );
[ 1, 15, 20, 12, 12 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="AutomorphismsOfTable" Arg='tbl'/>

<Description>
is the permutation group of all column permutations of the character
table <A>tbl</A> that leave the set of irreducibles and each power map of
<A>tbl</A> invariant (see also&nbsp;<Ref Func="TableAutomorphisms"/>).
<Example><![CDATA[
gap> tbl:= CharacterTable( "Dihedral", 8 );;
gap> AutomorphismsOfTable( tbl );
Group([ (4,5) ])
gap> OrdersClassRepresentatives( tbl );
[ 1, 4, 2, 2, 2 ]
gap> SizesConjugacyClasses( tbl );
[ 1, 2, 1, 2, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>UnderlyingCharacteristic</Heading>
<Attr Name="UnderlyingCharacteristic" Arg='tbl'
 Label="for a character table"/>
<Attr Name="UnderlyingCharacteristic" Arg='psi' Label="for a character"/>

<Description>
For an ordinary character table <A>tbl</A>, the result is <C>0</C>,
for a <M>p</M>-modular Brauer table <A>tbl</A>, it is <M>p</M>.
The underlying characteristic of a class function <A>psi</A> is equal to
that of its underlying character table.
<P/>
The underlying characteristic must be stored when the table is
constructed, there is no method to compute it.
<P/>
We cannot use the attribute <Ref Attr="Characteristic"/>
to denote this, since of course each Brauer character is an element
of characteristic zero in the sense of &GAP;
(see Chapter&nbsp;<Ref Chap="Class Functions"/>).
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> UnderlyingCharacteristic( tbl );
0
gap> UnderlyingCharacteristic( tbl mod 17 );
17
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Class Names and Character Names</Heading>
<Attr Name="ClassNames" Arg='tbl[, "ATLAS"]'/>
<Attr Name="CharacterNames" Arg='tbl'/>

<Description>
<Ref Attr="ClassNames"/> and <Ref Attr="CharacterNames"/> return lists of
strings, one for each conjugacy class or irreducible character,
respectively, of the character table <A>tbl</A>.
These names are used when <A>tbl</A> is displayed.
<P/>
The default method for <Ref Attr="ClassNames"/> computes class names
consisting of the order of an element in the class and at least one
distinguishing letter.
<P/>
The default method for <Ref Attr="CharacterNames"/> returns the list
<C>[ "X.1", "X.2", ... ]</C>, whose length is the number of
irreducible characters of <A>tbl</A>.
<P/>
The position of the class with name <A>name</A> in <A>tbl</A> can be
accessed as <C><A>tbl</A>.<A>name</A></C>.
<P/>
When <Ref Oper="ClassNames"/> is called with two arguments, the second
being the string <C>"ATLAS"</C>, the class names returned obey the
convention used in the &ATLAS; of Finite Groups
<Cite Key="CCN85" Where="Chapter 7, Section 5"/>.
If one is interested in <Q>relative</Q> class names of almost simple
&ATLAS; groups, one can use the function
<Ref Func="AtlasClassNames" BookName="atlasrep"/>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> ClassNames( tbl );
[ "1a", "2a", "3a", "5a", "5b" ]
gap> tbl.2a;
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>Class Parameters and Character Parameters</Heading>
<Attr Name="ClassParameters" Arg='tbl'/>
<Attr Name="CharacterParameters" Arg='tbl'/>

<Description>
The values of these attributes are lists containing a parameter for each
conjugacy class or irreducible character, respectively,
of the character table <A>tbl</A>.
<P/>
It depends on <A>tbl</A> what these parameters are,
so there is no default to compute class and character parameters.
<P/>
For example, the classes of symmetric groups can be parametrized by
partitions, corresponding to the cycle structures of permutations.
Character tables constructed from generic character tables
(see the manual of the &GAP; Character Table Library)
usually have class and character parameters stored.
<P/>
If <A>tbl</A> is a <M>p</M>-modular Brauer table such that class
parameters are stored in the underlying ordinary table
(see&nbsp;<Ref Attr="OrdinaryCharacterTable" Label="for a character table"/>)
of <A>tbl</A> then <Ref Attr="ClassParameters"/> returns the sublist of
class parameters of the ordinary table, for <M>p</M>-regular classes.
<!--
<P/>
A kind of partial character parameters for finite groups of Lie type
is given by the Deligne-Lusztig names of unipotent characters,
see&nbsp;<Ref Sect="sec:unipot" BookName="ctbllib"/>.
-->
</Description>
</ManSection>

<ManSection>
<Attr Name="Identifier" Arg='tbl' Label="for character tables"/>

<Description>
is a string that identifies the character table <A>tbl</A> in the current
&GAP; session.
It is used mainly for class fusions into <A>tbl</A> that are stored on
other character tables.
For character tables without group,
the identifier is also used to print the table;
this is the case for library tables,
but also for tables that are constructed as direct products, factors
etc.&nbsp;involving tables that may or may not store their groups.
<P/>
The default method for ordinary tables constructs strings of the form
<C>"CT<A>n</A>"</C>, where <A>n</A> is a positive integer.
<C>LARGEST_IDENTIFIER_NUMBER</C> is a list containing the largest integer
<A>n</A> used in the current &GAP; session.
<P/>
The default method for Brauer tables returns the concatenation of the
identifier of the ordinary table, the string <C>"mod"</C>,
and the (string of the) underlying characteristic.
<P/>
<Example><![CDATA[
gap> Identifier( CharacterTable( "A5" ) );
"A5"
gap> tbl:= CharacterTable( Group( () ) );;
gap> Identifier( tbl );  Identifier( tbl mod 2 );
"CT8"
"CT8mod2"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="InfoText" Arg='tbl' Label="for character tables"/>

<Description>
is a mutable string with information about the character table
<A>tbl</A>.
There is no default method to create an info text.
<P/>
This attribute is used mainly for library tables (see the manual of the
&GAP; Character Table Library).
Usual parts of the information are the origin of the table,
tests it has passed (<C>1.o.r.</C> for the test of orthogonality,
<C>pow[<A>p</A>]</C> for the construction of the <A>p</A>-th power map,
<C>DEC</C> for the decomposition of ordinary into Brauer characters,
<C>TENS</C> for the decomposition of tensor products of irreducibles),
and choices made without loss of generality.
<P/>
<Example><![CDATA[
gap> Print( InfoText( CharacterTable( "A5" ) ), "\n" );
origin: ATLAS of finite groups, tests: 1.o.r., pow[2,3,5]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="InverseClasses" Arg='tbl'/>

<Description>
For a character table <A>tbl</A>,
<Ref Attr="InverseClasses"/> returns the list mapping
each conjugacy class to its inverse class.
This list can be regarded as <M>(-1)</M>-st power map of <A>tbl</A>
(see&nbsp;<Ref Func="PowerMap"/>).
<P/>
<Example><![CDATA[
gap> InverseClasses( CharacterTable( "A5" ) );
[ 1, 2, 3, 4, 5 ]
gap> InverseClasses( CharacterTable( "Cyclic", 3 ) );
[ 1, 3, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="RealClasses" Arg='tbl'/>

<Description>
<Index Subkey="real">classes</Index>
For a character table <A>tbl</A>,
<Ref Attr="RealClasses"/> returns the strictly sorted
list of positions of classes in <A>tbl</A> that consist of real elements.
<P/>
An element <M>x</M> is <E>real</E> iff it is conjugate to its inverse
<M>x^{{-1}} = x^{{o(x)-1}}</M>.
<P/>
<Example><![CDATA[
gap> RealClasses( CharacterTable( "A5" ) );
[ 1, 2, 3, 4, 5 ]
gap> RealClasses( CharacterTable( "Cyclic", 3 ) );
[ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ClassOrbit" Arg='tbl, cc'/>

<Description>
is the list of positions of those conjugacy classes
of the character table <A>tbl</A> that are Galois conjugate to the
<A>cc</A>-th class.
That is, exactly the classes at positions given by the list returned by
<Ref Oper="ClassOrbit"/> contain generators of the cyclic group generated
by an element in the <A>cc</A>-th class.
<P/>
This information is computed from the power maps of <A>tbl</A>.
<P/>
<Example><![CDATA[
gap> ClassOrbit( CharacterTable( "A5" ), 4 );
[ 4, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassRoots" Arg='tbl'/>

<Description>
For a character table <A>tbl</A>,
<Ref Attr="ClassRoots"/> returns a list containing at position <M>i</M>
the list of positions of the classes of all nontrivial <M>p</M>-th roots,
where <M>p</M> runs over the prime divisors of the
<Ref Attr="Size" Label="for a character table"/> value of <A>tbl</A>.
<P/>
This information is computed from the power maps of <A>tbl</A>.
<P/>
<Example><![CDATA[
gap> ClassRoots( CharacterTable( "A5" ) );
[ [ 2, 3, 4, 5 ], [  ], [  ], [  ], [  ] ]
gap> ClassRoots( CharacterTable( "Cyclic", 6 ) );
[ [ 3, 4, 5 ], [  ], [ 2 ], [ 2, 6 ], [ 6 ], [  ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Normal Subgroups Represented by Lists of Class Positions">
<Heading>Normal Subgroups Represented by Lists of Class Positions</Heading>

The following attributes for a character table <A>tbl</A> correspond to
attributes for the group <M>G</M> of <A>tbl</A>.
But instead of a normal subgroup (or a list of normal subgroups) of
<M>G</M>, they return a strictly sorted list of positive integers (or a
list of such lists) which are the positions
&ndash;relative to the
<Ref Attr="ConjugacyClasses" Label="for character tables"/>
value of <A>tbl</A>&ndash;
of those classes forming the normal subgroup in question.

<ManSection>
<Attr Name="ClassPositionsOfNormalSubgroups" Arg='ordtbl'/>
<Attr Name="ClassPositionsOfMaximalNormalSubgroups" Arg='ordtbl'/>
<Attr Name="ClassPositionsOfMinimalNormalSubgroups" Arg='ordtbl'/>

<Description>
correspond to <Ref Func="NormalSubgroups"/>,
<Ref Func="MaximalNormalSubgroups"/>,
<Ref Func="MinimalNormalSubgroups"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
The entries of the result lists are sorted according to increasing
length.
(So this total order respects the partial order of normal subgroups
given by inclusion.)
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfNormalSubgroups( tbls4 );
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ClassPositionsOfAgemo" Arg='ordtbl, p'/>

<Description>
corresponds to <Ref Func="Agemo"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfAgemo( tbls4, 2 );
[ 1, 3, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfCentre" Arg='ordtbl'
Label="for a character table"/>
<Attr Name="ClassPositionsOfCenter" Arg='ordtbl'
Label="for a character table"/>

<Description>
corresponds to <Ref Attr="Centre"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> ClassPositionsOfCentre( tbld8 );
[ 1, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfDirectProductDecompositions"
      Arg='tbl[, nclasses]'/>

<Description>
Let <A>tbl</A> be the ordinary character table of the group <M>G</M>,
say.
Called with the only argument <A>tbl</A>,
<Ref Attr="ClassPositionsOfDirectProductDecompositions"/> returns
the list of all those pairs <M>[ l_1, l_2 ]</M> where <M>l_1</M> and
<M>l_2</M> are lists of class positions of normal subgroups <M>N_1</M>,
<M>N_2</M> of <M>G</M> such that <M>G</M> is their direct product and
<M>|N_1| \leq |N_2|</M> holds.
Called with second argument a list <A>nclasses</A> of class positions of
a normal subgroup <M>N</M> of <M>G</M>,
<Ref Attr="ClassPositionsOfDirectProductDecompositions"/> returns
the list of pairs describing the decomposition of <M>N</M> as a direct
product of two normal subgroups of <M>G</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfDerivedSubgroup" Arg='ordtbl'/>

<Description>
corresponds to <Ref Attr="DerivedSubgroup"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> ClassPositionsOfDerivedSubgroup( tbld8 );
[ 1, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfElementaryAbelianSeries" Arg='ordtbl'/>

<Description>
corresponds to <Ref Attr="ElementaryAbelianSeries" Label="for a group"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> tbla5:= CharacterTable( "A5" );;
gap> ClassPositionsOfElementaryAbelianSeries( tbls4 );
[ [ 1 .. 5 ], [ 1, 3, 4 ], [ 1, 3 ], [ 1 ] ]
gap> ClassPositionsOfElementaryAbelianSeries( tbla5 );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfFittingSubgroup" Arg='ordtbl'/>

<Description>
corresponds to <Ref Attr="FittingSubgroup"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfFittingSubgroup( tbls4 );
[ 1, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfLowerCentralSeries" Arg='tbl'/>

<Description>
corresponds to <Ref Func="LowerCentralSeriesOfGroup"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> ClassPositionsOfLowerCentralSeries( tbls4 );
[ [ 1 .. 5 ], [ 1, 3, 4 ] ]
gap> ClassPositionsOfLowerCentralSeries( tbld8 );
[ [ 1 .. 5 ], [ 1, 3 ], [ 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfUpperCentralSeries" Arg='ordtbl'/>

<Description>
corresponds to <Ref Func="UpperCentralSeriesOfGroup"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> ClassPositionsOfUpperCentralSeries( tbls4 );
[ [ 1 ] ]
gap> ClassPositionsOfUpperCentralSeries( tbld8 );
[ [ 1, 3 ], [ 1, 2, 3, 4, 5 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfSupersolvableResiduum" Arg='ordtbl'/>

<Description>
corresponds to <Ref Func="SupersolvableResiduum"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfSupersolvableResiduum( tbls4 );
[ 1, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ClassPositionsOfPCore" Arg='ordtbl, p'/>

<Description>
corresponds to <Ref Oper="PCore"/>
for the group of the ordinary character table <A>ordtbl</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfPCore( tbls4, 2 );
[ 1, 3 ]
gap> ClassPositionsOfPCore( tbls4, 3 );
[ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ClassPositionsOfNormalClosure" Arg='ordtbl, classes'/>

<Description>
is the sorted list of the positions of all conjugacy classes of the
ordinary character table <A>ordtbl</A> that form the normal closure
(see&nbsp;<Ref Func="NormalClosure"/>) of the conjugacy classes at
positions in the list <A>classes</A>.
<P/>
<Example><![CDATA[
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfNormalClosure( tbls4, [ 1, 4 ] );
[ 1, 3, 4 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations Concerning Blocks">
<Heading>Operations Concerning Blocks</Heading>

<ManSection>
<Oper Name="PrimeBlocks" Arg='ordtbl, p'/>
<Oper Name="PrimeBlocksOp" Arg='ordtbl, p'/>
<Attr Name="ComputedPrimeBlockss" Arg='tbl'/>

<Description>
For an ordinary character table <A>ordtbl</A> and a prime integer
<A>p</A>,
<Ref Oper="PrimeBlocks"/> returns a record with the following components.
<List>
<Mark><C>block</C></Mark>
<Item>
  a list, the value <M>j</M> at position <M>i</M> means that the
  <M>i</M>-th irreducible character of <A>ordtbl</A> lies in the
  <M>j</M>-th <A>p</A>-block of <A>ordtbl</A>,
</Item>
<Mark><C>defect</C></Mark>
<Item>
  a list containing at position <M>i</M> the defect of the <M>i</M>-th
  block,
</Item>
<Mark><C>height</C></Mark>
<Item>
  a list containing at position <M>i</M> the height of the <M>i</M>-th
  irreducible character of <A>ordtbl</A> in its block,
</Item>
<Mark><C>relevant</C></Mark>
<Item>
  a list of class positions such that only the restriction to these
  classes need be checked for deciding whether two characters lie
  in the same block, and
</Item>
<Mark><C>centralcharacter</C></Mark>
<Item>
  a list containing at position <M>i</M> a list whose values at the
  positions stored in the component <C>relevant</C> are the values of
  a central character in the <M>i</M>-th block.
</Item>
</List>
<P/>
The components <C>relevant</C> and <C>centralcharacters</C> are
used by <Ref Func="SameBlock"/>.
<P/>
If <Ref InfoClass="InfoCharacterTable"/> has level at least 2,
the defects of the blocks and the heights of the characters are printed.
<P/>
The default method uses the attribute
<Ref Attr="ComputedPrimeBlockss"/> for storing the computed value at
position <A>p</A>, and calls the operation <Ref Oper="PrimeBlocksOp"/>
for computing values that are not yet known.
<P/>
Two ordinary irreducible characters <M>\chi, \psi</M> of a group <M>G</M>
are said to lie in the same <M>p</M>-<E>block</E> if the images of their
central characters <M>\omega_{\chi}, \omega_{\psi}</M>
(see&nbsp;<Ref Func="CentralCharacter"/>) under the
natural ring epimorphism <M>R \rightarrow R / M</M> are equal,
where <M>R</M> denotes the ring of algebraic integers in the complex
number field, and <M>M</M> is a maximal ideal in <M>R</M> with
<M>pR \subseteq M</M>.
(The distribution to <M>p</M>-blocks is in fact independent of the choice
of <M>M</M>, see&nbsp;<Cite Key="Isa76"/>.)
<P/>
For <M>|G| = p^a m</M> where <M>p</M> does not divide <M>m</M>,
the <E>defect</E> of a block is the integer <M>d</M> such that
<M>p^{{a-d}}</M> is the largest power of <M>p</M> that divides the degrees
of all characters in the block.
<P/>
The <E>height</E> of a character <M>\chi</M> in the block is defined as
the largest exponent <M>h</M> for which <M>p^h</M> divides
<M>\chi(1) / p^{{a-d}}</M>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "L3(2)" );;
gap> pbl:= PrimeBlocks( tbl, 2 );
rec( block := [ 1, 1, 1, 1, 1, 2 ], 
  centralcharacter := [ [ ,, 56,, 24 ], [ ,, -7,, 3 ] ], 
  defect := [ 3, 0 ], height := [ 0, 0, 0, 1, 0, 0 ], 
  relevant := [ 3, 5 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SameBlock" Arg='p, omega1, omega2, relevant'/>

<Description>
Let <A>p</A> be a prime integer, <A>omega1</A> and <A>omega2</A> be two
central characters (or their values lists) of a character table,
and <A>relevant</A> be a list of positions as is stored in the component
<C>relevant</C> of a record returned by <Ref Func="PrimeBlocks"/>.
<P/>
<Ref Func="SameBlock"/> returns <K>true</K> if <A>omega1</A> and
<A>omega2</A> are equal modulo any maximal ideal in the ring of complex
algebraic integers containing the ideal spanned by <A>p</A>,
and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> omega:= List( Irr( tbl ), CentralCharacter );;
gap> SameBlock( 2, omega[1], omega[2], pbl.relevant );
true
gap> SameBlock( 2, omega[1], omega[6], pbl.relevant );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="BlocksInfo" Arg='modtbl'/>

<Description>
For a Brauer character table <A>modtbl</A>, the value of
<Ref Attr="BlocksInfo"/> is a list of (mutable) records,
the <M>i</M>-th entry containing information about the <M>i</M>-th block.
Each record has the following components.
<List>
<Mark><C>defect</C></Mark>
<Item>
  the defect of the block,
</Item>
<Mark><C>ordchars</C></Mark>
<Item>
  the list of positions of the ordinary characters that belong to the
  block, relative to
  <C>Irr( OrdinaryCharacterTable( <A>modtbl</A> ) )</C>,
</Item>
<Mark><C>modchars</C></Mark>
<Item>
  the list of positions of the Brauer characters that belong to the
  block, relative to <C>IBr( <A>modtbl</A> )</C>.
</Item>
</List>
Optional components are
<List>
<Mark><C>basicset</C></Mark>
<Item>
  a list of positions of ordinary characters in the block whose
  restriction to <A>modtbl</A> is maximally linearly independent,
  relative to <C>Irr( OrdinaryCharacterTable( <A>modtbl</A> ) )</C>,
</Item>
<Mark><C>decmat</C></Mark>
<Item>
  the decomposition matrix of the block,
  it is stored automatically when <Ref Func="DecompositionMatrix"/>
  is called for the block,
</Item>
<Mark><C>decinv</C></Mark>
<Item>
  inverse of the decomposition matrix of the block, restricted to the
  ordinary characters described by <C>basicset</C>,
</Item>
<Mark><C>brauertree</C></Mark>
<Item>
  a list that describes the Brauer tree of the block,
  in the case that the block is of defect <M>1</M>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> BlocksInfo( CharacterTable( "L3(2)" ) mod 2 );
[ rec( basicset := [ 1, 2, 3 ], 
      decinv := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
      defect := 3, modchars := [ 1, 2, 3 ], 
      ordchars := [ 1, 2, 3, 4, 5 ] ), 
  rec( basicset := [ 6 ], decinv := [ [ 1 ] ], defect := 0, 
      modchars := [ 4 ], ordchars := [ 6 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DecompositionMatrix" Arg='modtbl[, blocknr]'/>

<Description>
Let <A>modtbl</A> be a Brauer character table.
<P/>
Called with one argument, <Ref Oper="DecompositionMatrix"/> returns the
decomposition matrix of <A>modtbl</A>, where the rows and columns are
indexed by the irreducible characters of the ordinary character table of
<A>modtbl</A> and the irreducible characters of <A>modtbl</A>,
respectively,
<P/>
Called with two arguments, <Ref Oper="DecompositionMatrix"/> returns the
decomposition matrix of the block of <A>modtbl</A> with number
<A>blocknr</A>;
the matrix is stored as value of the <C>decmat</C> component of the
<A>blocknr</A>-th entry of the <Ref Func="BlocksInfo"/> list of
<A>modtbl</A>.
<P/>
An ordinary irreducible character is in block <M>i</M> if and only if all
characters before the first character of the same block lie in <M>i-1</M>
different blocks.
An irreducible Brauer character is in block <M>i</M> if it has nonzero
scalar product with an ordinary irreducible character in block <M>i</M>.
<P/>
<Ref Oper="DecompositionMatrix"/> is based on the more general function
<Ref Func="Decomposition"/>.
<P/>
<Example><![CDATA[
gap> modtbl:= CharacterTable( "L3(2)" ) mod 2;
BrauerTable( "L3(2)", 2 )
gap> DecompositionMatrix( modtbl );
[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 0 ], 
  [ 1, 1, 1, 0 ], [ 0, 0, 0, 1 ] ]
gap> DecompositionMatrix( modtbl, 1 );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ]
gap> DecompositionMatrix( modtbl, 2 );
[ [ 1 ] ]
]]></Example>
</Description>
</ManSection>

<Index Subkey="for a decomposition matrix">LaTeX</Index>
<ManSection>
<Func Name="LaTeXStringDecompositionMatrix"
 Arg='modtbl[, blocknr][, options]'/>

<Description>
is a string that contains La&TeX; code to print a decomposition matrix
(see&nbsp;<Ref Func="DecompositionMatrix"/>) nicely.
<P/>
The optional argument <A>options</A>, if present, must be a record with
components
<C>phi</C>, <C>chi</C> (strings used in each label for columns and rows),
<C>collabels</C>, <C>rowlabels</C> (subscripts for the labels).
The defaults for <C>phi</C> and <C>chi</C> are
<C>"{\\tt Y}"</C> and <C>"{\\tt X}"</C>,
the defaults for <C>collabels</C> and <C>rowlabels</C> are the lists of
positions of the Brauer characters and ordinary characters in the
respective lists of irreducibles in the character tables.
<P/>
The optional components <C>nrows</C> and <C>ncols</C> denote the maximal
number of rows and columns per array;
if they are present then each portion of <C>nrows</C> rows and
<C>ncols</C> columns forms an array of its own which is enclosed in
<C>\[</C>, <C>\]</C>.
<P/>
If the component <C>decmat</C> is bound in <A>options</A> then it must be
the decomposition matrix in question, in this case the matrix is not
computed from the information in <A>modtbl</A>.
<P/>
For those character tables from the &GAP; table library that belong to
the &ATLAS; of Finite Groups&nbsp;<Cite Key="CCN85"/>,
<Ref Func="AtlasLabelsOfIrreducibles" BookName="ctbllib"/> constructs
character labels that are compatible with those used in the &ATLAS;
(see&nbsp;<Ref Sect="ATLAS Tables" BookName="ctbllib"/>
in the manual of the &GAP; Character Table Library).
<P/>
<Example><![CDATA[
gap> modtbl:= CharacterTable( "L3(2)" ) mod 2;;
gap> Print( LaTeXStringDecompositionMatrix( modtbl, 1 ) );
\[
\begin{array}{r|rrr} \hline
 & {\tt Y}_{1}
 & {\tt Y}_{2}
 & {\tt Y}_{3}
 \rule[-7pt]{0pt}{20pt} \\ \hline
{\tt X}_{1} & 1 & . & . \rule[0pt]{0pt}{13pt} \\
{\tt X}_{2} & . & 1 & . \\
{\tt X}_{3} & . & . & 1 \\
{\tt X}_{4} & . & 1 & 1 \\
{\tt X}_{5} & 1 & 1 & 1 \rule[-7pt]{0pt}{5pt} \\
\hline
\end{array}
\]
gap> options:= rec( phi:= "\\varphi", chi:= "\\chi" );;
gap> Print( LaTeXStringDecompositionMatrix( modtbl, 1, options ) );
\[
\begin{array}{r|rrr} \hline
 & \varphi_{1}
 & \varphi_{2}
 & \varphi_{3}
 \rule[-7pt]{0pt}{20pt} \\ \hline
\chi_{1} & 1 & . & . \rule[0pt]{0pt}{13pt} \\
\chi_{2} & . & 1 & . \\
\chi_{3} & . & . & 1 \\
\chi_{4} & . & 1 & 1 \\
\chi_{5} & 1 & 1 & 1 \rule[-7pt]{0pt}{5pt} \\
\hline
\end{array}
\]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Other Operations for Character Tables">
<Heading>Other Operations for Character Tables</Heading>

In the following, we list operations for character tables that are not
attributes.


<P/>

<ManSection>
<Oper Name="Index" Arg='tbl, subtbl' Label="for two character tables"/>

<Description>
For two character tables <A>tbl</A> and <A>subtbl</A>,
<Ref Func="Index" Label="for two character tables"/> returns the
quotient of the <Ref Attr="Size" Label="for a character table"/> values
of <A>tbl</A> and <A>subtbl</A>.
The containment of the underlying groups of <A>subtbl</A> and <A>tbl</A>
is <E>not</E> checked;
so the distinction between 
<Ref Func="Index" Label="for a group and its subgroup"/> 
and <Ref Func="IndexNC" Label="for a group and its subgroup"/>
is not made for character tables.
</Description>
</ManSection>

<ManSection>
<Meth Name="IsInternallyConsistent"
 Arg='tbl' Label="for character tables"/>

<Description>
For an <E>ordinary</E> character table <A>tbl</A>,
<Ref Oper="IsInternallyConsistent"/>
checks the consistency of the following attribute values (if stored).
<List>
<Item>
  <Ref Attr="Size"/>, <Ref Attr="SizesCentralizers"/>,
  and <Ref Attr="SizesConjugacyClasses"/>.
</Item>
<Item>
  <Ref Attr="SizesCentralizers"/> and
  <Ref Attr="OrdersClassRepresentatives"/>.
</Item>
<Item>
  <Ref Attr="ComputedPowerMaps"/> and
  <Ref Attr="OrdersClassRepresentatives"/>.
</Item>
<Item>
  <Ref Attr="SizesCentralizers"/>
  and <Ref Attr="Irr" Label="for a character table"/>.
</Item>
<Item>
  <Ref Attr="Irr" Label="for a character table"/>
  (first orthogonality relation).
</Item>
</List>
<P/>
For a <E>Brauer</E> table <A>tbl</A>,
<Ref Meth="IsInternallyConsistent" Label="for character tables"/>
checks the consistency of the following attribute values (if stored).
<List>
<Item>
  <Ref Attr="Size"/>, <Ref Attr="SizesCentralizers"/>,
  and <Ref Attr="SizesConjugacyClasses"/>.
</Item>
<Item>
  <Ref Attr="SizesCentralizers"/> and
  <Ref Attr="OrdersClassRepresentatives"/>.
</Item>
<Item>
  <Ref Attr="ComputedPowerMaps"/> and
  <Ref Attr="OrdersClassRepresentatives"/>.
</Item>
<Item>
  <Ref Attr="Irr" Label="for a character table"/>
  (closure under complex conjugation and Frobenius map).
</Item>
</List>
<P/>
If no inconsistency occurs, <K>true</K> is returned,
otherwise each inconsistency is printed to the screen if the level of
<Ref InfoClass="InfoWarning"/> is at least <M>1</M>
(see&nbsp;<Ref Sect="Info Functions"/>),
and <K>false</K> is returned at the end.
</Description>
</ManSection>

<ManSection>
<Oper Name="IsPSolvableCharacterTable" Arg='tbl, p'/>
<Oper Name="IsPSolubleCharacterTable" Arg='tbl, p'/>
<Oper Name="IsPSolvableCharacterTableOp" Arg='tbl, p'/>
<Oper Name="IsPSolubleCharacterTableOp" Arg='tbl, p'/>
<Attr Name="ComputedIsPSolvableCharacterTables" Arg='tbl'/>
<Attr Name="ComputedIsPSolubleCharacterTables" Arg='tbl'/>

<Description>
<Ref Oper="IsPSolvableCharacterTable"/> for the ordinary character table
<A>tbl</A> corresponds to <Ref Func="IsPSolvable"/> for the group of
<A>tbl</A>, <A>p</A> must be either a prime integer or <C>0</C>.
<P/>
The default method uses the attribute
<Ref Attr="ComputedIsPSolvableCharacterTables"/> for storing the computed
value at position <A>p</A>, and calls the operation
<Ref Oper="IsPSolvableCharacterTableOp"/>
for computing values that are not yet known.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "Sz(8)" );;
gap> IsPSolvableCharacterTable( tbl, 2 );
false
gap> IsPSolvableCharacterTable( tbl, 3 );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsClassFusionOfNormalSubgroup" Arg='subtbl, fus, tbl'/>

<Description>
For two ordinary character tables <A>tbl</A> and <A>subtbl</A> of a group
<M>G</M> and its subgroup <M>U</M>, say,
and a list <A>fus</A> of positive integers that describes the class
fusion of <M>U</M> into <M>G</M>,
<Ref Func="IsClassFusionOfNormalSubgroup"/> returns <K>true</K>
if <M>U</M> is a normal subgroup of <M>G</M>, and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> tblc2:= CharacterTable( "Cyclic", 2 );;
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> fus:= PossibleClassFusions( tblc2, tbld8 );
[ [ 1, 3 ], [ 1, 4 ], [ 1, 5 ] ]
gap> List(fus, map -> IsClassFusionOfNormalSubgroup(tblc2, map, tbld8));
[ true, false, false ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Indicator" Arg='tbl[, characters], n'/>
<Oper Name="IndicatorOp" Arg='tbl, characters, n'/>
<Attr Name="ComputedIndicators" Arg='tbl'/>

<Description>
If <A>tbl</A> is an ordinary character table then <Ref Oper="Indicator"/>
returns the list of <A>n</A>-th Frobenius-Schur indicators of the
characters in the list <A>characters</A>;
the default of <A>characters</A> is <C>Irr( <A>tbl</A> )</C>.
<P/>
The <M>n</M>-th Frobenius-Schur indicator <M>\nu_n(\chi)</M> of an
ordinary character <M>\chi</M> of the group <M>G</M> is given by
<M>\nu_n(\chi) = ( \sum_{{g \in G}} \chi(g^n) ) / |G|</M>.
<P/>
If <A>tbl</A> is a Brauer table in characteristic <M> \neq 2</M> and
<M><A>n</A> = 2</M> then <Ref Oper="Indicator"/> returns the second
indicator.
<P/>
The default method uses the attribute
<Ref Attr="ComputedIndicators"/> for storing the computed value at
position <A>n</A>, and calls the operation <Ref Oper="IndicatorOp"/> for
computing values that are not yet known.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "L3(2)" );;
gap> Indicator( tbl, 2 );
[ 1, 0, 0, 1, 1, 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NrPolyhedralSubgroups" Arg='tbl, c1, c2, c3'/>

<Description>
<Index Subkey="polyhedral">subgroups</Index>
returns the number and isomorphism type of polyhedral subgroups of the
group with ordinary character table <A>tbl</A> which are generated by an
element <M>g</M> of class <A>c1</A> and an element <M>h</M> of class
<A>c2</A> with the property that the product <M>gh</M> lies in class
<A>c3</A>.
<P/>
According to <Cite Key="NPP84" Where="p. 233"/>, the number of
polyhedral subgroups of isomorphism type <M>V_4</M>, <M>D_{2n}</M>,
<M>A_4</M>, <M>S_4</M>, and <M>A_5</M> can be derived from the class
multiplication coefficient
(see&nbsp;<Ref Func="ClassMultiplicationCoefficient"
Label="for character tables"/>)
and the number of Galois
conjugates of a class (see&nbsp;<Ref Oper="ClassOrbit"/>).
<P/>
The classes <A>c1</A>, <A>c2</A> and <A>c3</A> in the parameter list must
be ordered according to the order of the elements in these classes.
If elements in class <A>c1</A> and <A>c2</A> do not generate a
polyhedral group then <K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> NrPolyhedralSubgroups( tbl, 2, 2, 4 );
rec( number := 21, type := "D8" )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ClassMultiplicationCoefficient" Arg='tbl, i, j, k'
 Label="for character tables"/>

<Description>
<Index Subkey="for character tables" Key="ClassMultiplicationCoefficient">
<C>ClassMultiplicationCoefficient</C></Index>
<Index>class multiplication coefficient</Index>
<Index>structure constant</Index>
returns the class multiplication coefficient of the classes <A>i</A>,
<A>j</A>, and <A>k</A> of the group <M>G</M> with ordinary character
table <A>tbl</A>.
<P/>
The class multiplication coefficient <M>c_{{i,j,k}}</M> of the classes
<A>i</A>, <A>j</A>, <A>k</A> equals the number of pairs <M>(x,y)</M> of
elements <M>x, y \in G</M> such that <M>x</M> lies in class <A>i</A>,
<M>y</M> lies in class <A>j</A>,
and their product <M>xy</M> is a fixed element of class <A>k</A>.
<P/>
In the center of the group algebra of <M>G</M>, these numbers are found
as coefficients of the decomposition of the product of two class sums
<M>K_i</M> and <M>K_j</M> into class sums:
<Display Mode="M">
K_i K_j = \sum_k c_{ijk} K_k .
</Display>
Given the character table of a finite group <M>G</M>,
whose classes  are <M>C_1, \ldots, C_r</M> with representatives
<M>g_i \in C_i</M>,
the class multiplication coefficient <M>c_{ijk}</M> can be computed
with the following formula:
<Display Mode="M">
c_{ijk} = |C_i| \cdot |C_j| / |G| \cdot
\sum_{{\chi \in Irr(G)}}
\chi(g_i) \chi(g_j) \chi(g_k^{{-1}}) / \chi(1).
</Display>
<P/>
On the other hand the knowledge of the class multiplication coefficients
admits the computation of the irreducible characters of <M>G</M>,
see&nbsp;<Ref Func="IrrDixonSchneider"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ClassStructureCharTable" Arg='tbl, classes'/>

<Description>
<Index>class multiplication coefficient</Index>
<Index>structure constant</Index>
<P/>
returns the so-called class structure of the classes in the list
<A>classes</A>, for the character table <A>tbl</A> of the group <M>G</M>.
The length of <A>classes</A> must be at least 2.
<P/>
Let <M>C = (C_1, C_2, \ldots, C_n)</M> denote the <M>n</M>-tuple
of conjugacy classes of <M>G</M> that are indexed by <A>classes</A>.
The class structure <M>n(C)</M> equals
the number of <M>n</M>-tuples <M>(g_1, g_2, \ldots, g_n)</M> of elements
<M>g_i \in C_i</M> with <M>g_1 g_2 \cdots g_n = 1</M>.
Note the difference to the definition of the class multiplication
coefficients in 
<Ref Func="ClassMultiplicationCoefficient"
Label="for character tables"/>.
<P/>
<M>n(C_1, C_2, \ldots, C_n)</M> is computed using the formula
<Display Mode="M">
n(C_1, C_2, \ldots, C_n) =
|C_1| |C_2| \cdots |C_n| / |G| \cdot
\sum_{{\chi \in Irr(G)}}
\chi(g_1) \chi(g_2) \cdots \chi(g_n) / \chi(1)^{{n-2}} .
</Display>
</Description>
</ManSection>

<ManSection>
<Func Name="MatClassMultCoeffsCharTable" Arg='tbl, i'/>

<Description>
<Index>structure constant</Index>
<Index>class multiplication coefficient</Index>
<P/>
For an ordinary character table <A>tbl</A> and a class position <A>i</A>,
<C>MatClassMultCoeffsCharTable</C> returns the matrix
<M>[ a_{ijk} ]_{{j,k}}</M> of structure constants
(see&nbsp;<Ref Func="ClassMultiplicationCoefficient"
Label="for character tables"/>).
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "L3(2)" );;
gap> ClassMultiplicationCoefficient( tbl, 2, 2, 4 );
4
gap> ClassStructureCharTable( tbl, [ 2, 2, 4 ] );
168
gap> ClassStructureCharTable( tbl, [ 2, 2, 2, 4 ] );
1848
gap> MatClassMultCoeffsCharTable( tbl, 2 );
[ [ 0, 1, 0, 0, 0, 0 ], [ 21, 4, 3, 4, 0, 0 ], [ 0, 8, 6, 8, 7, 7 ], 
  [ 0, 8, 6, 1, 7, 7 ], [ 0, 0, 3, 4, 0, 7 ], [ 0, 0, 3, 4, 7, 0 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Printing Character Tables">
<Heading>Printing Character Tables</Heading>

<ManSection>
<Meth Name="ViewObj" Arg='tbl' Label="for a character table"/>

<Description>
The default <Ref Oper="ViewObj"/> method for ordinary character
tables prints the string <C>"CharacterTable"</C>,
followed by the identifier
(see&nbsp;<Ref Attr="Identifier" Label="for character tables"/>) or,
if known, the group of the character table enclosed in brackets.
<Ref Oper="ViewObj"/> for Brauer tables does the same, except that the
first string is replaced by <C>"BrauerTable"</C>,
and that the characteristic is also shown.
</Description>
</ManSection>

<ManSection>
<Meth Name="PrintObj" Arg='tbl' Label="for a character table"/>

<Description>
The default <Ref Oper="PrintObj"/> method for character tables
does the same as <Ref Oper="ViewObj"/>,
except that <Ref Func="PrintObj"/> is used for the group instead of
<Ref Func="ViewObj"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg='tbl' Label="for a character table"/>

<Description>
There are various ways to customize the <Ref Oper="Display"/> output
for character tables.
First we describe the default behaviour,
alternatives are then described below.
<P/>
The default <Ref Oper="Display"/> method prepares the data in <A>tbl</A>
for a columnwise output.
The number of columns printed at one time depends on the actual
line length, which can be accessed and changed by the function
<Ref Func="SizeScreen"/>.
<P/>
An interesting variant of <Ref Oper="Display"/> is the function
<Ref Func="PageDisplay" BookName="gapdoc"/>.
Convenient ways to print the <Ref Oper="Display"/> format to a file
are given by the function <Ref Func="PrintTo1" BookName="gapdoc"/>
or by using <Ref Func="PageDisplay" BookName="gapdoc"/> and the
facilities of the pager used, cf.&nbsp;<Ref Func="Pager"/>.
<P/>
An interactive variant of <Ref Oper="Display"/> is the
<Ref Oper="Browse" BookName="browse"/> method for character tables
that is provided by the &GAP; package <Package>Browse</Package>,
see <Ref Meth="Browse" Label="for character tables"
BookName="browse"/>.
<P/>
<Ref Oper="Display"/> shows certain characters (by default all
irreducible characters) of <A>tbl</A>, together with the orders of the
centralizers in factorized form and the available power maps
(see&nbsp;<Ref Attr="ComputedPowerMaps"/>).
The <A>n</A>-th displayed character is given the name <C>X.<A>n</A></C>.
<P/>
The first lines of the output describe the order of the centralizer
of an element of the class factorized into its prime divisors.
<P/>
The next line gives the name of each class.
If no class names are stored on <A>tbl</A>,
<Ref Func="ClassNames"/> is called.
<P/>
Preceded by a name <C>P<A>n</A></C>, the next lines show the <A>n</A>th
power maps of <A>tbl</A> in terms of the former shown class names.
<P/>
Every ambiguous or unknown (see Chapter&nbsp;<Ref Chap="Unknowns"/>)
value of the table is displayed as a question mark <C>?</C>.
<P/>
Irrational character values are not printed explicitly because the
lengths of their printed representation might disturb the layout.
Instead of that every irrational value is indicated by a name,
which is a string of at least one capital letter.
<P/>
Once a name for an irrational value is found, it is used all over the
printed table.
Moreover the complex conjugate (see&nbsp;<Ref Func="ComplexConjugate"/>,
<Ref Func="GaloisCyc" Label="for a cyclotomic"/>)
and the star of an irrationality (see&nbsp;<Ref Func="StarCyc"/>) are
represented by that very name preceded by a <C>/</C> and a <C>*</C>,
respectively.
<P/>
The printed character table is then followed by a legend,
a list identifying the occurring symbols with their actual values.
Occasionally this identification is supplemented by a quadratic
representation of the irrationality (see&nbsp;<Ref Func="Quadratic"/>)
together with the corresponding &ATLAS; notation
(see&nbsp;<Cite Key="CCN85"/>).
<P/>
This default style can be changed by prescribing a record <A>arec</A> of
options, which can be given
<P/>
<Enum>
<Item>
  as an optional argument in the call to <Ref Oper="Display"/>,
</Item>
<Item>
  as the value of the attribute <Ref Func="DisplayOptions"/>
  if this value is stored in the table,
</Item>
<Item>
  as the value of the global variable
  <C>CharacterTableDisplayDefaults.User</C>, or
</Item>
<Item>
  as the value of the global variable
  <C>CharacterTableDisplayDefaults.Global</C>
</Item>
</Enum>
<P/>
(in this order of precedence).
<P/>
The following components of <A>arec</A> are supported.
<P/>
<List>
<Mark><C>centralizers</C></Mark>
<Item>
  <K>false</K> to suppress the printing of the orders of the centralizers,
  or the string <C>"ATLAS"</C> to force the printing of non-factorized
  centralizer orders in a style similar to that used in the
  &ATLAS; of Finite Groups&nbsp;<Cite Key="CCN85"/>,
</Item>
<Mark><C>chars</C></Mark>
<Item>
  an integer or a list of integers to select a sublist of the
  irreducible characters of <A>tbl</A>,
  or a list of characters of <A>tbl</A>
  (in this case the letter <C>"X"</C> is replaced by <C>"Y"</C>),
</Item>
<Mark><C>classes</C></Mark>
<Item>
  an integer or a list of integers to select a sublist of the
  classes of <A>tbl</A>,
</Item>
<Mark><C>indicator</C></Mark>
<Item>
  <K>true</K> enables the printing of the second Frobenius Schur
  indicator, a list of integers enables the printing of the corresponding
  indicators (see&nbsp;<Ref Func="Indicator"/>),
</Item>
<Mark><C>letter</C></Mark>
<Item>
  a single capital letter (e.&nbsp;g.&nbsp;<C>"P"</C> for permutation
  characters) to replace the default <C>"X"</C> in character names,
</Item>
<Mark><C>powermap</C></Mark>
<Item>
  an integer or a list of integers to select a subset of the
  available power maps,
  <K>false</K> to suppress the printing of power maps,
  or the string <C>"ATLAS"</C> to force a printing of class names and
  power maps in a style similar to that used in the
  &ATLAS; of Finite Groups&nbsp;<Cite Key="CCN85"/>,
</Item>
<Mark><C>Display</C></Mark>
<Item>
  the function that is actually called in order to display the table;
  the arguments are the table and the optional record, whose components
  can be used inside the <C>Display</C> function,
</Item>
<Mark><C>StringEntry</C></Mark>
<Item>
  a function that takes either a character value or a character value
  and the return value of <C>StringEntryData</C> (see below),
  and returns the string that is actually displayed;
  it is called for all character values to be displayed,
  and also for the displayed indicator values (see above),
</Item>
<Mark><C>StringEntryData</C></Mark>
<Item>
  a unary function that is called once with argument <A>tbl</A> before
  the character values are displayed;
  it returns an object that is used as second argument of the function
  <C>StringEntry</C>,
</Item>
<Mark><C>Legend</C></Mark>
<Item>
  a function that takes the result of the <C>StringEntryData</C> call as
  its only argument, after the character table has been displayed;
  the return value is a string that describes the symbols used in the
  displayed table in a formatted way,
  it is printed below the displayed table.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Attr Name="DisplayOptions" Arg='tbl'/>

<Description>
<!-- is a more general attribute?-->
There is no default method to compute a value,
one can set a value with <C>SetDisplayOptions</C>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> Display( tbl );
A5

     2  2  2  .  .  .
     3  1  .  1  .  .
     5  1  .  .  1  1

       1a 2a 3a 5a 5b
    2P 1a 1a 3a 5b 5a
    3P 1a 2a 1a 5b 5a
    5P 1a 2a 3a 1a 1a

X.1     1  1  1  1  1
X.2     3 -1  .  A *A
X.3     3 -1  . *A  A
X.4     4  .  1 -1 -1
X.5     5  1 -1  .  .

A = -E(5)-E(5)^4
  = (1-Sqrt(5))/2 = -b5
gap> CharacterTableDisplayDefaults.User:= rec(
>        powermap:= "ATLAS", centralizers:= "ATLAS", chars:= false );;
gap> Display( CharacterTable( "A5" ) );
A5

    60  4  3  5  5

 p      A  A  A  A
 p'     A  A  A  A
    1A 2A 3A 5A B*

gap> options:= rec( chars:= 4, classes:= [ tbl.3a .. tbl.5a ],
>                   centralizers:= false, indicator:= true,
>                   powermap:= [ 2 ] );;
gap> Display( tbl, options );
A5

          3a 5a
       2P 3a 5b
       2
X.4    +   1 -1
gap> SetDisplayOptions( tbl, options );  Display( tbl );
A5

          3a 5a
       2P 3a 5b
       2
X.4    +   1 -1
gap> Unbind( CharacterTableDisplayDefaults.User );
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrintCharacterTable" Arg='tbl, varname'/>

<Description>
Let <A>tbl</A> be a nearly character table, and <A>varname</A> a string.
<Ref Func="PrintCharacterTable"/> prints those values of the supported
attributes (see&nbsp;<Ref Var="SupportedCharacterTableInfo"/>) that are
known for <A>tbl</A>.
<!--  If <A>tbl</A> is a library table then also the known values of
      supported components
      (see&nbsp;<Ref Var="SupportedLibraryTableComponents"/>)
      are printed.-->
<P/>
The output of <Ref Func="PrintCharacterTable"/> is &GAP; readable;
actually reading it into &GAP; will bind the variable with name
<A>varname</A> to a character table that coincides with <A>tbl</A> for
all printed components.
<P/>
This is used mainly for saving character tables to files.
A more human readable form is produced by <Ref Oper="Display"/>.
<!-- Note that a table with group can be read back only if the group
     elements can be read back;
     so this works for permutation groups but not for PC groups!
     (what about the efficiency?) -->
<!-- Is there a problem of consistency,
     if the group is stored but classes are not, and later the classes
     are automatically constructed? (This should be safe.) -->
<P/>
<Example><![CDATA[
gap> PrintCharacterTable( CharacterTable( "Cyclic", 2 ), "tbl" );
tbl:= function()
local tbl, i;
tbl:=rec();
tbl.Irr:=
[ [ 1, 1 ], [ 1, -1 ] ];
tbl.NrConjugacyClasses:=
2;
tbl.Size:=
2;
tbl.OrdersClassRepresentatives:=
[ 1, 2 ];
tbl.SizesCentralizers:=
[ 2, 2 ];
tbl.UnderlyingCharacteristic:=
0;
tbl.ClassParameters:=
[ [ 1, 0 ], [ 1, 1 ] ];
tbl.CharacterParameters:=
[ [ 1, 0 ], [ 1, 1 ] ];
tbl.Identifier:=
"C2";
tbl.InfoText:=
"computed using generic character table for cyclic groups";
tbl.ComputedPowerMaps:=
[ , [ 1, 1 ] ];
ConvertToLibraryCharacterTableNC(tbl);
return tbl;
end;
tbl:= tbl();
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Computing the Irreducible Characters of a Group">
<Heading>Computing the Irreducible Characters of a Group</Heading>

Several algorithms are available for computing the irreducible characters of
a finite group <M>G</M>.
The default method for arbitrary finite groups is to use the Dixon-Schneider
algorithm (see&nbsp;<Ref Func="IrrDixonSchneider"/>).
For supersolvable groups,
Conlon's algorithm can be used (see&nbsp;<Ref Func="IrrConlon"/>).
For abelian-by-supersolvable groups,
the Baum-Clausen algorithm for computing the irreducible representations
(see&nbsp;<Ref Func="IrreducibleRepresentations"/>) can be used to compute
the irreducible characters (see&nbsp;<Ref Func="IrrBaumClausen"/>).
<P/>
These functions are installed in methods for
<Ref Attr="Irr" Label="for a group"/>,
but explicitly calling one of them will <E>not</E> set the
<Ref Attr="Irr" Label="for a group"/> value of <M>G</M>.

<ManSection>
<Attr Name="IrrDixonSchneider" Arg='G'/>

<Description>
computes the irreducible characters of the finite group <A>G</A>,
using the Dixon-Schneider method
(see&nbsp;<Ref Sect="The Dixon-Schneider Algorithm"/>).
It calls <Ref Func="DixonInit"/> and <Ref Func="DixonSplit"/>,
<!--  and <C>OrbitSplit</C>, % is not documented! -->
and finally returns the list returned by <Ref Func="DixontinI"/>.
See also the sections
<Ref Sect="Components of a Dixon Record"/> and
<Ref Sect="An Example of Advanced Dixon-Schneider Calculations"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="IrrConlon" Arg='G'/>

<Description>
For a finite solvable group <A>G</A>,
<Ref Func="IrrConlon"/> returns a list of certain irreducible characters
of <A>G</A>, among those all irreducibles that have the
supersolvable residuum of <A>G</A> in their kernels;
so if <A>G</A> is supersolvable,
all irreducible characters of <A>G</A> are returned.
An error is signalled if <A>G</A> is not solvable.
<P/>
The characters are computed using Conlon's algorithm
(see&nbsp;<Cite Key="Con90a"/> and&nbsp;<Cite Key="Con90b"/>).
For each irreducible character in the returned list,
the monomiality information
(see&nbsp;<Ref Func="TestMonomial" Label="for a group"/>) is stored.
</Description>
</ManSection>

<ManSection>
<Attr Name="IrrBaumClausen" Arg='G'/>

<Description>
<Ref Func="IrrBaumClausen"/> returns the absolutely irreducible ordinary
characters of the factor group of the finite solvable group <A>G</A>
by the derived subgroup of its supersolvable residuum.
<P/>
The characters are computed using the algorithm by Baum and Clausen
(see&nbsp;<Cite Key="BC94"/>).
An error is signalled if <A>G</A> is not solvable.
<P/>
<Example><![CDATA[
gap> g:= SL(2,3);;
gap> irr1:= IrrDixonSchneider( g );
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 2, 1, 1, -2, -1, -1, 0 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 2, E(3)^2, E(3), -2, -E(3), -E(3)^2, 0 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 2, E(3), E(3)^2, -2, -E(3)^2, -E(3), 0 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
gap> irr2:= IrrConlon( g );
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
gap> irr3:= IrrBaumClausen( g );
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
gap> chi:= irr2[4];;  HasTestMonomial( chi );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IrreducibleRepresentations" Arg='G[, F]'/>

<Description>
Called with a finite group <A>G</A> and a field <A>F</A>,
<Ref Func="IrreducibleRepresentations"/> returns a list of
representatives of the irreducible matrix representations of <A>G</A>
over <A>F</A>, up to equivalence.
<P/>
If <A>G</A> is the only argument then
<Ref Func="IrreducibleRepresentations"/> returns a list of
representatives of the absolutely irreducible complex representations
of <A>G</A>, up to equivalence.
<P/>
At the moment, methods are available for the following cases:
If <A>G</A> is abelian by supersolvable the method
of&nbsp;<Cite Key="BC94"/> is used.
<P/>
Otherwise, if <A>F</A> and <A>G</A> are both finite,
the regular module of <A>G</A> is split by MeatAxe methods which can make
this an expensive operation.
<P/>
Finally, if <A>F</A> is not given (i.e. it defaults to the cyclotomic
numbers) and <A>G</A> is a finite group,
the method of <Cite Key="Dix93"/>
(see <Ref Func="IrreducibleRepresentationsDixon"/>) is used.
<P/>
For other cases no methods are implemented yet.
<P/>
The representations obtained are <E>not</E> guaranteed to be <Q>nice</Q>
(for example preserving a unitary form) in any way.
<P/>
See also <Ref Func="IrreducibleModules"/>,
which provides efficient methods for solvable groups.
<P/>
<Example><![CDATA[
gap> g:= AlternatingGroup( 4 );;
gap> repr:= IrreducibleRepresentations( g );
[ Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ 1 ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ E(3) ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ E(3)^2 ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ], 
      [ [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, -1 ] ], 
      [ [ 1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ] ] ]
gap> ForAll( repr, IsGroupHomomorphism );
true
gap> Length( repr );
4
gap> gens:= GeneratorsOfGroup( g );
[ (1,2,3), (2,3,4) ]
gap> List( gens, x -> x^repr[1] );
[ [ [ 1 ] ], [ [ 1 ] ] ]
gap>  List( gens, x -> x^repr[4] );
[ [ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, 0 ] ], 
  [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IrreducibleRepresentationsDixon" Arg='G[, chi]'/>

<Description>
Called with one argument, a group <A>G</A>,
<Ref Func="IrreducibleRepresentationsDixon"/>
computes (representatives of) all irreducible complex representations for
the finite group <A>G</A>, using the method of&nbsp;<Cite Key="Dix93"/>,
which computes the character table and computes the representation
as constituent of an induced monomial representation of a subgroup.
<P/>
This method can be quite expensive for larger groups, for example it
might involve calculation of the subgroup lattice of <A>G</A>.
<P/>
A character <A>chi</A> of <A>G</A> can be given as the second argument,
in this case only a representation affording <A>chi</A> is returned.
<P/>
The second argument can also be a list of characters of <A>G</A>,
in this case only representations for characters in this list are
computed.
<P/>
Note that this method might fail if for an irreducible representation
there is no subgroup in which its reduction has a linear constituent
with multiplicity one.
<P/>
If the option <A>unitary</A> is given, &GAP; tries, at extra cost, to find a
unitary representation (and will issue an error if it cannot do so).
<Example><![CDATA[
gap> a5:= AlternatingGroup( 5 );
Alt( [ 1 .. 5 ] )
gap> char:= First( Irr( a5 ), x -> x[1] = 4 );
Character( CharacterTable( Alt( [ 1 .. 5 ] ) ), [ 4, 0, 1, -1, -1 ] )
gap> hom:=IrreducibleRepresentationsDixon( a5, char: unitary );;
gap> Order( a5.1*a5.2 ) = Order( Image( hom, a5.1 )*Image( hom, a5.2 ) );
true
gap> reps:= List( ConjugacyClasses( a5 ), Representative );;
gap> List( reps, g -> TraceMat( Image( hom, g ) ) );
[ 4, 0, 1, -1, -1 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Representations given by modules">
<Heading>Representations Given by Modules</Heading>

This section describes functions that return certain modules of a given
group.
(Extensions by modules can be formed by the command <Ref Func="Extensions"/>.)

<ManSection>
<Oper Name="IrreducibleModules" Arg='G, F, dim'/>

<Description>
returns a list of length 2. The first entry is a generating system of
<A>G</A>. The second entry is a list of all irreducible modules of
<A>G</A> over the field <A>F</A> in dimension <A>dim</A>, given as MeatAxe modules
(see&nbsp;<Ref Func="GModuleByMats" Label="for generators and a field"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="AbsolutelyIrreducibleModules" Arg='G, F, dim'/>
<Oper Name="AbsoluteIrreducibleModules" Arg='G, F, dim'/>
<Oper Name="AbsolutIrreducibleModules" Arg='G, F, dim'/>

<Description>
returns a list of length 2. The first entry is a generating system of
<A>G</A>. The second entry is a list of all absolute irreducible modules of
<A>G</A> over the field <A>F</A> in dimension <A>dim</A>, given as MeatAxe modules
(see&nbsp;<Ref Func="GModuleByMats" Label="for generators and a field"/>).
The other two names are just synonyms.
</Description>
</ManSection>

<ManSection>
<Oper Name="RegularModule" Arg='G, F'/>

<Description>
returns a list of length 2. The first entry is a generating system of
<A>G</A>.
The second entry is the regular module of <A>G</A> over <A>F</A>,
given as a MeatAxe module
(see&nbsp;<Ref Func="GModuleByMats" Label="for generators and a field"/>).
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Dixon-Schneider Algorithm">
<Heading>The Dixon-Schneider Algorithm</Heading>

<Index>Dixon-Schneider algorithm</Index>
The &GAP; library implementation of the Dixon-Schneider algorithm
first computes the linear characters, using the commutator factor group.
If irreducible characters are missing afterwards,
they are computed using the techniques described in <Cite Key="Dix67"/>,
<Cite Key="Sch90"/> and <Cite Key="Hulpke93"/>.
<P/>
Called with a group <M>G</M>, the function
<Ref Func="CharacterTable" Label="for a group"/> returns a character
table object that stores already information such as class lengths,
but not the irreducible characters.
The routines that compute the irreducibles may use the information that
is already contained in this table object.
In particular the ordering of classes in the computed characters
coincides with the ordering of classes in the character table of <A>G</A>
(see&nbsp;<Ref Sect="The Interface between Character Tables and Groups"/>).
Thus it is possible to combine computations using the group
with character theoretic computations
(see&nbsp;<Ref Sect="Advanced Methods for Dixon-Schneider Calculations"/>
for details),
for example one can enter known characters.
Note that the user is responsible for the correctness of the characters.
(There is little use in providing the trivial character to the routine.)
<P/>
The computation of irreducible characters from the group needs to
identify the classes of group elements very often,
so it can be helpful to store a class list of all group elements.
Since this is obviously limited by the group order,
it is controlled by the global function <Ref Func="IsDxLargeGroup"/>.
<P/>
The routines compute in a prime field of size <M>p</M>,
such that the exponent of the group divides <M>(p-1)</M> and such that
<M>2 \sqrt{{|G|}} &lt; p</M>.
Currently prime fields of size smaller than <M>65\,536</M> are handled more
efficiently than larger prime fields,
so the runtime of the character calculation depends on how large the
chosen prime is.
<P/>
The routine stores a Dixon record (see&nbsp;<Ref Func="DixonRecord"/>)
in the group that helps routines that identify classes,
for example <Ref Func="FusionConjugacyClasses" Label="for two groups"/>,
to work much faster.
Note that interrupting Dixon-Schneider calculations will prevent &GAP;
from cleaning up the Dixon record;
when the computation by <Ref Func="IrrDixonSchneider"/> is complete,
the possibly large record is shrunk to an acceptable size.


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Advanced Methods for Dixon-Schneider Calculations">
<Heading>Advanced Methods for Dixon-Schneider Calculations</Heading>

<Index Subkey="computation">irreducible characters</Index>

The computation of irreducible characters of very large groups
may take quite some time.
On the other hand, for the expert only a few irreducible characters may be
needed,
since the other ones can be computed using character theoretic methods
such as tensoring, induction, and restriction.
Thus &GAP; provides also step-by-step routines for doing the calculations.
These routines allow one to compute some characters and to stop before all
are calculated.
Note that there is no <Q>safety net</Q>:
The routines (being somehow internal) do no error checking,
and assume the information given is correct.
<P/>
When the info level of <Ref Func="InfoCharacterTable"/> if positive,
information about the progress of splitting is printed.
(The default value is zero.)

<ManSection>
<Attr Name="DixonRecord" Arg='G'/>

<Description>
The <Ref Attr="DixonRecord"/> of a group contains information used by the
routines to compute the irreducible characters and related information
via the Dixon-Schneider algorithm such as class arrangement and character
spaces split obtained so far.
Usually this record is passed as argument to all subfunctions to avoid a
long argument list.
It has a component <C>conjugacyClasses</C> which contains the classes of
<A>G</A> <E>ordered as the algorithm needs them</E>.
</Description>
</ManSection>

<ManSection>
<Func Name="DixonInit" Arg='G'/>

<Description>
This function does all the initializations for the Dixon-Schneider
algorithm. This includes calculation of conjugacy classes, power maps,
linear characters and character morphisms.
It returns a record (see&nbsp;<Ref Func="DixonRecord"/> and
Section <Ref Sect="Components of a Dixon Record"/>)
that can be used when calculating the irreducible characters of <A>G</A>
interactively.
</Description>
</ManSection>

<ManSection>
<Func Name="DixontinI" Arg='D'/>

<Description>
This function ends a Dixon-Schneider calculation.
It sorts the characters according to the degree and
unbinds components in the Dixon record that are not of use any longer.
It returns a list of irreducible characters.
</Description>
</ManSection>

<ManSection>
<Func Name="DixonSplit" Arg='D'/>

<Description>
This function performs one splitting step in the Dixon-Schneider
algorithm. It selects a class, computes the (partial) class sum matrix,
uses it to split character spaces and stores all the irreducible
characters obtained that way.
<P/>
The class to use for splitting is chosen via
<Ref Func="BestSplittingMatrix"/> and the options described for this
function apply here.
<P/>
<Ref Func="DixonSplit"/> returns the number of the class that was 
used for splitting if a split was performed, and <K>fail</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Func Name="BestSplittingMatrix" Arg='D'/>

<Description>
returns the number of the class sum matrix that is assumed to yield the 
best (cost/earning ration) split. This matrix then will be the next one
computed and used.
<P/>
The global option <C>maxclasslen</C>
(defaulting to <Ref Var="infinity"/>) is recognized
by <Ref Func="BestSplittingMatrix"/>:
Only classes whose length is limited by the value of this option will be
considered for splitting. If no usable class remains,
<K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Func Name="DxIncludeIrreducibles" Arg='D, new[, newmod]'/>

<Description>
This function takes a list of irreducible characters <A>new</A>,
each given as a list of values (corresponding to the class arrangement in
<A>D</A>), and adds these to a partial computed list of irreducibles as
maintained by the Dixon record <A>D</A>.
This permits one to add characters in interactive use obtained from other
sources and to continue the Dixon-Schneider calculation afterwards.
If the optional argument <A>newmod</A> is given, it must be a
list of reduced characters, corresponding to <A>new</A>.
(Otherwise the function has to reduce the characters itself.)
<P/>
The function closes the new characters under the action of Galois
automorphisms and tensor products with linear characters.
</Description>
</ManSection>

<ManSection>
<Func Name="SplitCharacters" Arg='D, list'/>

<Description>
This routine decomposes the characters given in <A>list</A> according to
the character spaces found up to this point. By applying this routine to
tensor products etc., it may result in characters with smaller norm,
even irreducible ones. Since the recalculation of characters is only
possible if the degree is small enough, the splitting process is
applied only to characters of sufficiently small degree.
</Description>
</ManSection>

<ManSection>
<Func Name="IsDxLargeGroup" Arg='G'/>

<Description>
returns <K>true</K> if the order of the group <A>G</A> is smaller than
the current value of the global variable <C>DXLARGEGROUPORDER</C>,
and <K>false</K> otherwise.
In Dixon-Schneider calculations, for small groups in the above sense a
class map is stored, whereas for large groups,
each occurring element is identified individually.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Components of a Dixon Record">
<Heading>Components of a Dixon Record</Heading>

The <Q>Dixon record</Q> <A>D</A> returned by <Ref Func="DixonInit"/>
stores all the information that is used by the Dixon-Schneider routines
while computing the irreducible characters of a group.
Some entries, however, may be useful to know about when using the algorithm
interactively,
see <Ref Sect="An Example of Advanced Dixon-Schneider Calculations"/>.

<List>
<Mark><C>group</C></Mark>
<Item>
   the group <M>G</M> of which the character table is to be computed,
</Item>
<Mark><C>conjugacyClasses</C></Mark>
<Item>
   classes of <M>G</M> (all characters stored in the Dixon record
   correspond to this arrangement of classes),
</Item>
<Mark><C>irreducibles</C></Mark>
<Item>
   the already known irreducible characters
   (given as lists of their values on the conjugacy classes),
</Item>
<Mark><C>characterTable</C></Mark>
<Item>
   the <Ref Func="CharacterTable" Label="for a group"/> value of <M>G</M>
   (whose irreducible characters are not yet known),
</Item>
<Mark><C>ClassElement( <A>D</A>, <A>el</A> )</C></Mark>
<Item>
   a function that returns the number of the class of <M>G</M>
   that contains the element <A>el</A>.
</Item>
</List>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="An Example of Advanced Dixon-Schneider Calculations">
<Heading>An Example of Advanced Dixon-Schneider Calculations</Heading>

First, we set the appropriate info level higher.
<P/>
<Example><![CDATA[
gap> SetInfoLevel( InfoCharacterTable, 1 );
]]></Example>
<P/>
for printout of some internal results.
We now define our group, which is isomorphic to PSL<M>_4(3)</M>.
<P/>
<Example><![CDATA[
gap> g:= PrimitiveGroup(40,5);
PSL(4, 3)
gap> Size(g);
6065280
gap> d:= DixonInit( g );;
#I  29 classes
#I  choosing prime 65521
gap> c:= d.characterTable;;
]]></Example>
<P/>
After the initialisation, one structure matrix is evaluated,
yielding smaller spaces and several irreducible characters.
<P/>
<Example><![CDATA[
gap> DixonSplit( d );
#I  Matrix 2,Representative of Order 3,Centralizer: 5832
#I  Dimensions: [ 1, 2, 1, 4, 12, 1, 1, 2, 1, 2, 1 ]
#I  Two-dim space split
#I  Two-dim space split
#I  Two-dim space split
2
]]></Example>
<P/>
In this case spaces of the listed dimensions are a result of the
splitting process.
The three two dimensional spaces are split successfully by combinatoric
means.
<P/>
We obtain several irreducible characters by tensor products and notify them
to the Dixon record.
<P/>
<Example><![CDATA[
gap> asp:= AntiSymmetricParts( c, d.irreducibles, 2 );;
gap> ro:= ReducedCharacters( c, d.irreducibles, asp );;
gap> Length( ro.irreducibles );
3
gap> DxIncludeIrreducibles( d, ro.irreducibles );
]]></Example>
<P/>
The tensor products of the nonlinear characters among each other are reduced
with the irreducible characters.
The result is split according to the spaces found, which yields characters
of smaller norms, but no new irreducibles.
<P/>
<Example><![CDATA[
gap> nlc:= Filtered( d.irreducibles, i -> i[1] > 1 );;
gap> t:= Tensored( nlc, nlc );;
gap> ro:= ReducedCharacters( c, d.irreducibles, t );;  ro.irreducibles;
[  ]
gap> List( ro.remainders, i -> ScalarProduct( c, i, i) );
[ 2, 2, 4, 4, 4, 4, 13, 13, 18, 18, 19, 21, 21, 36, 36, 29, 34, 34, 
  42, 34, 48, 54, 62, 68, 68, 78, 84, 84, 88, 90, 159, 169, 169, 172, 
  172, 266, 271, 271, 268, 274, 274, 280, 328, 373, 373, 456, 532, 
  576, 679, 683, 683, 754, 768, 768, 890, 912, 962, 1453, 1453, 1601, 
  1601, 1728, 1739, 1739, 1802, 2058, 2379, 2414, 2543, 2744, 2744, 
  2920, 3078, 3078, 4275, 4275, 4494, 4760, 5112, 5115, 5115, 5414, 
  6080, 6318, 7100, 7369, 7369, 7798, 8644, 10392, 12373, 12922, 
  14122, 14122, 18948, 21886, 24641, 24641, 25056, 38942, 44950, 
  78778 ]
gap> t:= SplitCharacters( d, ro.remainders );;
gap> List( t, i -> ScalarProduct( c, i, i ) );
[ 2, 2, 4, 2, 2, 4, 4, 3, 6, 5, 5, 9, 9, 4, 12, 13, 18, 18, 20, 18, 
  20, 24, 26, 32, 32, 16, 42, 59, 69, 69, 72, 72, 36, 72, 78, 78, 84, 
  122, 117, 127, 117, 127, 64, 132, 100, 144, 196, 256, 456, 532, 
  576, 679, 683, 683, 754, 768, 768, 890, 912, 962, 1453, 1453, 1601, 
  1601, 1728, 1739, 1739, 1802, 2058, 2379, 2414, 2543, 2744, 2744, 
  2920, 3078, 3078, 4275, 4275, 4494, 4760, 5112, 5115, 5115, 5414, 
  6080, 6318, 7100, 7369, 7369, 7798, 8644, 10392, 12373, 12922, 
  14122, 14122, 18948, 21886, 24641, 24641, 25056, 38942, 44950, 
  78778 ]
]]></Example>
<P/>
Finally we calculate the characters induced from all cyclic subgroups and
obtain the missing irreducibles by applying the LLL-algorithm to them.
<P/>
<Example><![CDATA[
gap> ic:= InducedCyclic( c, "all" );;
gap> ro:= ReducedCharacters( c, d.irreducibles, ic );;
gap> Length( ro.irreducibles );
0
gap> l:= LLL( c, ro.remainders );;
gap> Length( l.irreducibles );
13
]]></Example>
<P/>
The LLL returns class function objects
(see Chapter&nbsp;<Ref Chap="Class Functions"/>),
and the Dixon record works with character values lists.
So we convert them to a list of values
before feeding them in the machinery of the Dixon-algorithm.
<P/>
<Example><![CDATA[
gap> l.irreducibles[1];
Character( CharacterTable( PSL(4, 3) ),
 [ 640, -8, -8, -8, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, E(13)^7+E(13)^8+E(13)^11, E(13)^4+E(13)^10+E(13)^12, 
  E(13)^2+E(13)^5+E(13)^6, E(13)+E(13)^3+E(13)^9, 0 ] )
gap> l:=List(l.irreducibles,ValuesOfClassFunction);;
gap> DxIncludeIrreducibles( d, l );
gap> Length( d.irreducibles );
29
gap> Length( d.classes );
29
]]></Example>
<P/>
It turns out we have found all irreducible characters.
As the last step, we obtain the irreducible characters and tell them to the
group.
This makes them available also to the character table.
<P/>
<Example><![CDATA[
gap> irrs:= DixontinI( d );;
#I  Total:1 matrices,[ 2 ]
gap> SetIrr(g,irrs);
gap> Length(Irr(c));
29
gap> SetInfoLevel( InfoCharacterTable, 0 );
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Character Tables from Others">
<Heading>Constructing Character Tables from Others</Heading>

The following operations take one or more character table arguments,
and return a character table.
This holds also for <Ref Oper="BrauerTable"
Label="for a character table, and a prime integer"/>.
note that the return value of <Ref Oper="BrauerTable"
Label="for a character table, and a prime integer"/>
will in general not know the irreducible Brauer characters,
and &GAP; might be unable to compute these characters.
<P/>
<E>Note</E> that whenever fusions between input and output tables occur
in these operations,
they are stored on the concerned tables,
and the <Ref Attr="NamesOfFusionSources"/> values are updated.
<P/>
(The interactive construction of character tables using character
theoretic methods and incomplete tables is not described here.)
<E>Currently it is not supported and will be described in a chapter of its
own when it becomes available</E>.

<ManSection>
<Oper Name="CharacterTableDirectProduct" Arg='tbl1, tbl2'/>

<Description>
is the table of the direct product of the character tables <A>tbl1</A>
and <A>tbl2</A>.
<P/>
The matrix of irreducibles of this table is the Kronecker product
(see&nbsp;<Ref Func="KroneckerProduct"/>) of the irreducibles of
<A>tbl1</A> and <A>tbl2</A>.
<P/>
Products of ordinary and Brauer character tables are supported.
<P/>
In general, the result will not know an underlying group,
so missing power maps (for prime divisors of the result)
and irreducibles of the input tables may be computed in order to
construct the table of the direct product.
<P/>
The embeddings of the input tables into the direct product are stored,
they can be fetched with <Ref Func="GetFusionMap"/>;
if <A>tbl1</A> is equal to <A>tbl2</A> then the two embeddings are
distinguished by their <C>specification</C> components <C>"1"</C> and
<C>"2"</C>, respectively.
<P/>
Analogously, the projections from the direct product onto the input
tables are stored, and can be distinguished by the <C>specification</C>
components.
<!-- generalize this to arbitrarily many arguments!-->
<P/>
The attribute <Ref Func="FactorsOfDirectProduct"/>
is set to the lists of arguments.
<P/>
The <C>*</C> operator for two character tables
(see&nbsp;<Ref Sect="Operators for Character Tables"/>) delegates to
<Ref Oper="CharacterTableDirectProduct"/>.
<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> s3:= CharacterTable( "Symmetric", 3 );;
gap> Display( CharacterTableDirectProduct( c2, s3 ) );
C2xSym(3)

     2  2  2  1  2  2  1
     3  1  .  1  1  .  1

       1a 2a 3a 2b 2c 6a
    2P 1a 1a 3a 1a 1a 3a
    3P 1a 2a 1a 2b 2c 2b

X.1     1 -1  1  1 -1  1
X.2     2  . -1  2  . -1
X.3     1  1  1  1  1  1
X.4     1 -1  1 -1  1 -1
X.5     2  . -1 -2  .  1
X.6     1  1  1 -1 -1 -1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="FactorsOfDirectProduct" Arg='tbl'/>

<Description>
For an ordinary character table that has been constructed via
<Ref Oper="CharacterTableDirectProduct"/>,
the value of <Ref Attr="FactorsOfDirectProduct"/> is the list of
arguments in the <Ref Oper="CharacterTableDirectProduct"/> call.
<P/>
Note that there is no default method for <E>computing</E> the value of
<Ref Attr="FactorsOfDirectProduct"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="CharacterTableFactorGroup" Arg='tbl, classes'/>

<Description>
is the character table of the factor group of the ordinary character
table <A>tbl</A> by the normal closure of the classes whose positions are
contained in the list <A>classes</A>.
<P/>
The <C>/</C> operator for a character table and a list of class positions
(see&nbsp;<Ref Sect="Operators for Character Tables"/>) delegates to
<Ref Oper="CharacterTableFactorGroup"/>.
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfNormalSubgroups( s4 );
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
gap> f:= CharacterTableFactorGroup( s4, [ 3 ] );
CharacterTable( "Sym(4)/[ 1, 3 ]" )
gap> Display( f );
Sym(4)/[ 1, 3 ]

     2  1  1  .
     3  1  .  1

       1a 2a 3a
    2P 1a 1a 3a
    3P 1a 2a 1a

X.1     1 -1  1
X.2     2  . -1
X.3     1  1  1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CharacterTableIsoclinic" Arg='tbl[, classes][, centre]'/>
<Attr Name="SourceOfIsoclinicTable" Arg='tbl'/>

<Description>
If <A>tbl</A> is the (ordinary or modular) character table of a group
with the structure <M>2.G.2</M> with a central subgroup <M>Z</M> of order
<M>2</M> or <M>4</M> and a normal subgroup <M>N</M> of index <M>2</M>
that contains <M>Z</M> then <Ref Oper="CharacterTableIsoclinic"/> returns
the table of the isoclinic group in the sense of the
&ATLAS; of Finite Groups
<Cite Key="CCN85" Where="Chapter 6, Section 7"/>.
If <M>N</M> is not uniquely determined then the positions of the classes
forming <M>N</M> must be entered as list <A>classes</A>.
If <M>Z</M> is not unique inside <M>N</M> then the positions of the
classes in <M>Z</M> must be entered as list <A>centre</A>;
If <M>Z</M> has order <M>2</M> then <A>centre</A> can be also the
position of the involution in <M>Z</M>.
<P/>
Note that also if <A>tbl</A> is a Brauer table then <A>classes</A> and
<A>centre</A> denote class numbers w.r.t.&nbsp;the <E>ordinary</E>
character table.
<P/>
For an ordinary character table that has been constructed via
<Ref Oper="CharacterTableIsoclinic"/>,
the value of <Ref Attr="SourceOfIsoclinicTable"/> is the list of three
arguments in the <Ref Oper="CharacterTableIsoclinic"/> call.
<P/>
Note that there is no default method for <E>computing</E> the value of
<Ref Attr="SourceOfIsoclinicTable"/>.
<P/>
<Example><![CDATA[
gap> d8:= CharacterTable( "Dihedral", 8 );
CharacterTable( "Dihedral(8)" )
gap> nsg:= ClassPositionsOfNormalSubgroups( d8 );
[ [ 1 ], [ 1, 3 ], [ 1 .. 3 ], [ 1, 3, 4 ], [ 1, 3 .. 5 ], [ 1 .. 5 ] 
 ]
gap> iso:= CharacterTableIsoclinic( d8, nsg[3] );;
gap> Display( iso );
Isoclinic(Dihedral(8))

     2  3  2  3  2  2

       1a 4a 2a 4b 4c
    2P 1a 2a 1a 2a 2a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     1 -1  1  1 -1
X.4     1 -1  1 -1  1
X.5     2  . -2  .  .
gap> SourceOfIsoclinicTable( iso );
[ CharacterTable( "Dihedral(8)" ), [ 1, 2, 3 ], [ 3 ], 3 ]
]]></Example>
</Description>
</ManSection>

<!-- %Declaration{CharacterTableOfNormalSubgroup} -->
<ManSection>
<Func Name="CharacterTableWreathSymmetric" Arg='tbl, n'/>

<Description>
returns the character table of the wreath product of a group <M>G</M>
with the full symmetric group on <A>n</A> points,
where <A>tbl</A> is the character table of <M>G</M>.
<P/>
The result has values for <Ref Attr="ClassParameters"/> and
<Ref Attr="CharacterParameters"/> stored,
the entries in these lists are sequences of partitions.
Note that this parametrization prevents the principal character from
being the first one in the list of irreducibles.
<P/>
<Example><![CDATA[
gap> c3:= CharacterTable( "Cyclic", 3 );;
gap> wr:= CharacterTableWreathSymmetric( c3, 2 );;
gap> Display( wr );
C3wrS2

     2  1   .   .   1  .   1  1   1   1
     3  2   2   2   2  2   2  1   1   1

       1a  3a  3b  3c 3d  3e 2a  6a  6b
    2P 1a  3b  3a  3e 3d  3c 1a  3c  3e
    3P 1a  1a  1a  1a 1a  1a 2a  2a  2a

X.1     1   1   1   1  1   1 -1  -1  -1
X.2     2   A  /A   B -1  /B  .   .   .
X.3     2  /A   A  /B -1   B  .   .   .
X.4     1 -/A  -A  -A  1 -/A -1  /A   A
X.5     2  -1  -1   2 -1   2  .   .   .
X.6     1  -A -/A -/A  1  -A -1   A  /A
X.7     1   1   1   1  1   1  1   1   1
X.8     1 -/A  -A  -A  1 -/A  1 -/A  -A
X.9     1  -A -/A -/A  1  -A  1  -A -/A

A = -E(3)^2
  = (1+Sqrt(-3))/2 = 1+b3
B = 2*E(3)
  = -1+Sqrt(-3) = 2b3
gap> CharacterParameters( wr )[1];
[ [ 1, 1 ], [  ], [  ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Sorted Character Tables">
<Heading>Sorted Character Tables</Heading>

<ManSection>
<Oper Name="CharacterTableWithSortedCharacters" Arg='tbl[, perm]'/>

<Description>
is a character table that differs from <A>tbl</A> only by the succession
of its irreducible characters.
This affects the values of the attributes
<Ref Attr="Irr" Label="for a character table"/> and
<Ref Attr="CharacterParameters"/>.
Namely, these lists are permuted by the permutation <A>perm</A>.
<P/>
If no second argument is given then a permutation is used that yields
irreducible characters of increasing degree for the result.
For the succession of characters in the result,
see&nbsp;<Ref Func="SortedCharacters"/>.
<P/>
The result has all those attributes and properties of <A>tbl</A> that are
stored in <Ref Var="SupportedCharacterTableInfo"/> and do not depend
on the ordering of characters.
</Description>
</ManSection>

<ManSection>
<Oper Name="SortedCharacters" Arg='tbl, chars[, flag]'/>

<Description>
is a list containing the characters <A>chars</A>, ordered as specified
by the other arguments.
<P/>
There are three possibilities to sort characters:
They can be sorted according to ascending norms
(<A>flag</A> is the string <C>"norm"</C>),
to ascending degree (<A>flag</A> is the string <C>"degree"</C>),
or both (no third argument is given),
i.e., characters with same norm are sorted according to ascending degree,
and characters with smaller norm precede those with bigger norm.
<P/>
Rational characters in the result precede other ones with same norm
and/or same degree.
<P/>
The trivial character, if contained in <A>chars</A>, will always be
sorted to the first position.
</Description>
</ManSection>

<ManSection>
<Oper Name="CharacterTableWithSortedClasses" Arg='tbl[, flag]'/>

<Description>
is a character table obtained by permutation of the classes of
<A>tbl</A>.
If the second argument <A>flag</A> is the string <C>"centralizers"</C>
then the classes of the result are sorted according to descending
centralizer orders.
If the second argument is the string <C>"representatives"</C> then the
classes of the result are sorted according to ascending representative
orders.
If no second argument is given then the classes of the result are sorted
according to ascending representative orders,
and classes with equal representative orders are sorted according to
descending centralizer orders.
<P/>
If the second argument is a permutation then the classes of the
result are sorted by application of this permutation.
<P/>
The result has all those attributes and properties of <A>tbl</A> that are
stored in <Ref Var="SupportedCharacterTableInfo"/> and do not depend
on the ordering of classes.
</Description>
</ManSection>

<ManSection>
<Func Name="SortedCharacterTable" Arg='tbl, kernel'
 Label="w.r.t. a normal subgroup"/>
<Func Name="SortedCharacterTable" Arg='tbl, normalseries'
 Label="w.r.t. a series of normal subgroups"/>
<Func Name="SortedCharacterTable" Arg='tbl, facttbl, kernel'
 Label="relative to the table of a factor group"/>

<Description>
is a character table obtained on permutation of the classes and the
irreducibles characters of <A>tbl</A>.
<P/>
The first form sorts the classes at positions contained in the list
<A>kernel</A> to the beginning, and sorts all characters in
<C>Irr( <A>tbl</A> )</C> such that the first characters are those that
contain <A>kernel</A> in their kernel.
<P/>
The second form does the same successively for all kernels <M>k_i</M> in
the list <M><A>normalseries</A> = [ k_1, k_2, \ldots, k_n ]</M> where
<M>k_i</M> must be a sublist of <M>k_{{i+1}}</M> for
<M>1 \leq i \leq n-1</M>.
<P/>
The third form computes the table <M>F</M> of the factor group of
<A>tbl</A> modulo the normal subgroup formed by the classes whose
positions are contained in the list <A>kernel</A>;
<M>F</M> must be permutation equivalent to the table <A>facttbl</A>,
in the sense of <Ref Func="TransformingPermutationsCharacterTables"/>,
otherwise <K>fail</K> is returned.
The classes of <A>tbl</A> are sorted such that the preimages
of a class of <M>F</M> are consecutive,
and that the succession of preimages is that of <A>facttbl</A>.
The <Ref Attr="Irr" Label="for a character table"/> value of <A>tbl</A>
is sorted as with <C>SortCharTable( <A>tbl</A>, <A>kernel</A> )</C>.
<P/>
(<E>Note</E> that the transformation is only unique up to table
automorphisms of <M>F</M>, and this need not be unique up to table
automorphisms of <A>tbl</A>.)
<P/>
All rearrangements of classes and characters are stable,
i.e., the relative positions of classes and characters that are not
distinguished by any relevant property is not changed.
<P/>
The result has all those attributes and properties of <A>tbl</A> that are
stored in <Ref Var="SupportedCharacterTableInfo"/> and do not depend on
the ordering of classes and characters.
<P/>
The <Ref Attr="ClassPermutation"/> value of <A>tbl</A> is changed if
necessary, see&nbsp;<Ref Sect="Conventions for Character Tables"/>.
<P/>
<Ref Func="SortedCharacterTable" Label="w.r.t. a normal subgroup"/>
uses <Ref Func="CharacterTableWithSortedClasses"/> and
<Ref Func="CharacterTableWithSortedCharacters"/>.
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPermutation" Arg='tbl'/>

<Description>
is a permutation <M>\pi</M> of classes of the character table <A>tbl</A>.
If it is stored then class fusions into <A>tbl</A> that are stored on
other tables must be followed by <M>\pi</M> in order to describe the
correct fusion.
<P/>
This attribute value is bound only if <A>tbl</A> was obtained from another
table by permuting the classes,
using <Ref Func="CharacterTableWithSortedClasses"/>
or <Ref Func="SortedCharacterTable" Label="w.r.t. a normal subgroup"/>.
<P/>
It is necessary because the original table and the sorted table have the
same identifier (and the same group if known),
and hence the same fusions are valid for the two tables.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "Symmetric", 4 );
CharacterTable( "Sym(4)" )
gap> Display( tbl );
Sym(4)

     2  3  2  3  .  2
     3  1  .  .  1  .

       1a 2a 2b 3a 4a
    2P 1a 1a 1a 3a 2b
    3P 1a 2a 2b 1a 4a

X.1     1 -1  1  1 -1
X.2     3 -1 -1  .  1
X.3     2  .  2 -1  .
X.4     3  1 -1  . -1
X.5     1  1  1  1  1
gap> srt1:= CharacterTableWithSortedCharacters( tbl );
CharacterTable( "Sym(4)" )
gap> List( Irr( srt1 ), Degree );
[ 1, 1, 2, 3, 3 ]
gap> srt2:= CharacterTableWithSortedClasses( tbl );
CharacterTable( "Sym(4)" )
gap> SizesCentralizers( tbl );
[ 24, 4, 8, 3, 4 ]
gap> SizesCentralizers( srt2 );
[ 24, 8, 4, 3, 4 ]
gap> nsg:= ClassPositionsOfNormalSubgroups( tbl );
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
gap> srt3:= SortedCharacterTable( tbl, nsg );
CharacterTable( "Sym(4)" )
gap> nsg:= ClassPositionsOfNormalSubgroups( srt3 );
[ [ 1 ], [ 1, 2 ], [ 1 .. 3 ], [ 1 .. 5 ] ]
gap> Display( srt3 );
Sym(4)

     2  3  3  .  2  2
     3  1  .  1  .  .

       1a 2a 3a 2b 4a
    2P 1a 1a 3a 1a 2a
    3P 1a 2a 1a 2b 4a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     2  2 -1  .  .
X.4     3 -1  . -1  1
X.5     3 -1  .  1 -1
gap> ClassPermutation( srt3 );
(2,4,3)
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Automorphisms and Equivalence of Character Tables">
<Heading>Automorphisms and Equivalence of Character Tables</Heading>

<ManSection>
<Oper Name="MatrixAutomorphisms" Arg='mat[, maps, subgroup]'/>

<Description>
For a matrix <A>mat</A>,
<Ref Oper="MatrixAutomorphisms"/> returns the group of those
permutations of the columns of <A>mat</A> that leave the set of rows of
<A>mat</A> invariant.
<P/>
If the arguments <A>maps</A> and <A>subgroup</A> are given,
only the group of those permutations is constructed that additionally
fix each list in the list <A>maps</A> under pointwise action
<Ref Func="OnTuples"/>,
and <A>subgroup</A> is a permutation group that is known to be a subgroup
of this group of automorphisms.
<P/>
Each entry in <A>maps</A> must be a list of same length as the rows of
<A>mat</A>.
For example, if <A>mat</A> is a list of irreducible characters of a group
then the list of element orders of the conjugacy classes
(see&nbsp;<Ref Func="OrdersClassRepresentatives"/>) may be an entry in
<A>maps</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="TableAutomorphisms" Arg='tbl, characters[, info]'/>

<Description>
<Ref Oper="TableAutomorphisms"/> returns the permutation group of those
matrix automorphisms (see&nbsp;<Ref Func="MatrixAutomorphisms"/>) of the
list <A>characters</A> that leave the element orders
(see&nbsp;<Ref Func="OrdersClassRepresentatives"/>)
and all stored power maps (see&nbsp;<Ref Func="ComputedPowerMaps"/>)
of the character table <A>tbl</A> invariant.
<P/>
If <A>characters</A> is closed under Galois conjugacy
&ndash;this is always fulfilled for the list of all irreducible
characters of ordinary character tables&ndash; the string <C>"closed"</C>
may be entered as the third argument <A>info</A>.
Alternatively, a known subgroup of the table automorphisms
can be entered as the third argument <A>info</A>.
<P/>
The attribute <Ref Attr="AutomorphismsOfTable"/>
can be used to compute and store the table automorphisms for the case
that <A>characters</A> equals the
<Ref Func="Irr" Label="for a character table"/> value of <A>tbl</A>.
<P/>
<Example><![CDATA[
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> irrd8:= Irr( tbld8 );
[ Character( CharacterTable( "Dihedral(8)" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, 1, 1, -1, -1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, -1, 1, -1, 1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 2, 0, -2, 0, 0 ] ) ]
gap> orders:= OrdersClassRepresentatives( tbld8 );
[ 1, 4, 2, 2, 2 ]
gap> MatrixAutomorphisms( irrd8 );
Group([ (4,5), (2,4) ])
gap> MatrixAutomorphisms( irrd8, [ orders ], Group( () ) );
Group([ (4,5) ])
gap> TableAutomorphisms( tbld8, irrd8 );
Group([ (4,5) ])
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TransformingPermutations" Arg='mat1, mat2'/>

<Description>
Let <A>mat1</A> and <A>mat2</A> be matrices.
<Ref Oper="TransformingPermutations"/> tries to construct
a permutation <M>\pi</M> that transforms the set of rows of the matrix
<A>mat1</A> to the set of rows of the matrix <A>mat2</A>
by permuting the columns.
<P/>
If such a permutation exists,
a record with the components <C>columns</C>, <C>rows</C>,
and <C>group</C> is returned, otherwise <K>fail</K>.
For <C>TransformingPermutations( <A>mat1</A>, <A>mat2</A> )
= <A>r</A></C> <M>\neq</M> <K>fail</K>,
we have <C><A>mat2</A> =
 Permuted( List( <A>mat1</A>, x -&gt; Permuted( x, <A>r</A>.columns ) ),
<A>r</A>.rows )</C>.
<P/>
<A>r</A><C>.group</C> is the group of matrix automorphisms of <A>mat2</A>
(see&nbsp;<Ref Oper="MatrixAutomorphisms"/>).
This group stabilizes the transformation in the sense that applying any
of its elements to the columns of <A>mat2</A>
preserves the set of rows of <A>mat2</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="TransformingPermutationsCharacterTables" Arg='tbl1, tbl2'/>

<Description>
Let <A>tbl1</A> and <A>tbl2</A> be character tables.
<Ref Oper="TransformingPermutationsCharacterTables"/> tries to construct
a permutation <M>\pi</M> that transforms the set of rows of the matrix
<C>Irr( <A>tbl1</A> )</C> to the set of rows of the matrix
<C>Irr( <A>tbl2</A> )</C> by permuting the columns
(see&nbsp;<Ref Oper="TransformingPermutations"/>), such that
<M>\pi</M> transforms also the power maps and the element orders.
<P/>
If such a permutation <M>\pi</M> exists then a record with the components
<C>columns</C> (<M>\pi</M>),
<C>rows</C> (the permutation of <C>Irr( <A>tbl1</A> )</C> corresponding
to <M>\pi</M>), and <C>group</C> (the permutation group of table
automorphisms of <A>tbl2</A>,
see&nbsp;<Ref Attr="AutomorphismsOfTable"/>) is returned.
If no such permutation exists, <K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> tblq8:= CharacterTable( "Quaternionic", 8 );;
gap> irrq8:= Irr( tblq8 );
[ Character( CharacterTable( "Q8" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, 1, 1, -1, -1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, -1, 1, -1, 1 ] ), 
  Character( CharacterTable( "Q8" ), [ 2, 0, -2, 0, 0 ] ) ]
gap> OrdersClassRepresentatives( tblq8 );
[ 1, 4, 2, 4, 4 ]
gap> TransformingPermutations( irrd8, irrq8 );
rec( columns := (), group := Group([ (4,5), (2,4) ]), rows := () )
gap> TransformingPermutationsCharacterTables( tbld8, tblq8 );
fail
gap> tbld6:= CharacterTable( "Dihedral", 6 );;
gap> tbls3:= CharacterTable( "Symmetric", 3 );;
gap> TransformingPermutationsCharacterTables( tbld6, tbls3 );
rec( columns := (2,3), group := Group(()), rows := (1,3,2) )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FamiliesOfRows" Arg='mat, maps'/>

<Description>
distributes the rows of the matrix <A>mat</A> into families, as follows.
Two rows of <A>mat</A> belong to the same family if there is
a permutation of columns that maps one row to the other row.
Each entry in the list <A>maps</A> is regarded to form a family
of length 1.
<P/>
<Ref Func="FamiliesOfRows"/> returns a record with the components
<List>
<Mark><C>famreps</C></Mark>
<Item>
   the list of representatives for each family,
</Item>
<Mark><C>permutations</C></Mark>
<Item>
   the list that contains at position <M>i</M> a list of permutations
   that map the members of the family with representative
   <C>famreps</C><M>[i]</M> to that representative,
</Item>
<Mark><C>families</C></Mark>
<Item>
   the list that contains at position <M>i</M> the list of positions
   of members of the family of representative <C>famreps</C><M>[i]</M>;
   (for the element <A>maps</A><M>[i]</M> the only member of the family
   will get the number <C>Length( <A>mat</A> ) + </C><M>i</M>).
</Item>
</List>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Storing Normal Subgroup Information">
<Heading>Storing Normal Subgroup Information</Heading>

<ManSection>
<Attr Name="NormalSubgroupClassesInfo" Arg='tbl'/>

<Description>
Let <A>tbl</A> be the ordinary character table of the group <M>G</M>.
Many computations for group characters of <M>G</M> involve computations
in normal subgroups or factor groups of <M>G</M>.
<P/>
In some cases the character table <A>tbl</A> is sufficient;
for example questions about a normal subgroup <M>N</M> of <M>G</M> can be
answered if one knows the conjugacy classes that form <M>N</M>,
e.g., the question whether a character of <M>G</M> restricts
irreducibly to <M>N</M>.
But other questions require the computation of <M>N</M> or
even more information, like the character table of <M>N</M>.
<P/>
In order to do these computations only once, one stores in the group a
record with components to store normal subgroups, the corresponding lists
of conjugacy classes, and (if necessary) the factor groups, namely
<P/>
<List>
<Mark><C>nsg</C></Mark>
<Item>
  list of normal subgroups of <M>G</M>, may be incomplete,
</Item>
<Mark><C>nsgclasses</C></Mark>
<Item>
  at position <M>i</M>, the list of positions of conjugacy
  classes of <A>tbl</A> forming the <M>i</M>-th entry of the <C>nsg</C>
  component,
</Item>
<Mark><C>nsgfactors</C></Mark>
<Item>
  at position <M>i</M>, if bound, the factor group
  modulo the <M>i</M>-th entry of the <C>nsg</C> component.
</Item>
</List>
<P/>
<Ref Func="NormalSubgroupClasses"/>,
<Ref Func="FactorGroupNormalSubgroupClasses"/>, and
<Ref Func="ClassPositionsOfNormalSubgroup"/>
each use these components, and they are the only functions to do so.
<P/>
So if you need information about a normal subgroup for that you know the
conjugacy classes, you should get it using
<Ref Func="NormalSubgroupClasses"/>.
If the normal subgroup was already used it is just returned, with all the
knowledge it contains.  Otherwise the normal subgroup is added to the
lists, and will be available for the next call.
<P/>
For example, if you are dealing with kernels of characters using the
<Ref Func="KernelOfCharacter"/> function you make use of this feature
because <Ref Func="KernelOfCharacter"/> calls
<Ref Func="NormalSubgroupClasses"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ClassPositionsOfNormalSubgroup" Arg='tbl, N'/>

<Description>
is the list of positions of conjugacy classes of the character table
<A>tbl</A> that are contained in the normal subgroup <A>N</A>
of the underlying group of <A>tbl</A>.
</Description>
</ManSection>

<ManSection>
<Func Name="NormalSubgroupClasses" Arg='tbl, classes'/>

<Description>
returns the normal subgroup of the underlying group <M>G</M> of the
ordinary character table <A>tbl</A>
that consists of those conjugacy classes of <A>tbl</A> whose positions
are in the list <A>classes</A>.
<P/>
If <C>NormalSubgroupClassesInfo( <A>tbl</A> ).nsg</C> does not yet
contain the required normal subgroup,
and if <C>NormalSubgroupClassesInfo( <A>tbl</A> ).normalSubgroups</C> is
bound then the result will be identical to the group in
<C>NormalSubgroupClassesInfo( <A>tbl</A> ).normalSubgroups</C>.
</Description>
</ManSection>

<ManSection>
<Func Name="FactorGroupNormalSubgroupClasses" Arg='tbl, classes'/>

<Description>
is the factor group of the underlying group <M>G</M> of the ordinary
character table <A>tbl</A> modulo the normal subgroup of <M>G</M> that
consists of those conjugacy classes of <A>tbl</A> whose positions are in
the list <A>classes</A>.
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> SetName( g, "S4" );
gap> tbl:= CharacterTable( g );
CharacterTable( S4 )
gap> irr:= Irr( g );
[ Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] ), 
  Character( CharacterTable( S4 ), [ 2, 0, 2, -1, 0 ] ), 
  Character( CharacterTable( S4 ), [ 3, 1, -1, 0, -1 ] ), 
  Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ) ]
gap> kernel:= KernelOfCharacter( irr[3] );
Group([ (1,2)(3,4), (1,3)(2,4) ])
gap> HasNormalSubgroupClassesInfo( tbl );
true
gap> NormalSubgroupClassesInfo( tbl );
rec( nsg := [ Group([ (1,2)(3,4), (1,3)(2,4) ]) ],
  nsgclasses := [ [ 1, 3 ] ], nsgfactors := [  ] )
gap> ClassPositionsOfNormalSubgroup( tbl, kernel );
[ 1, 3 ]
gap> FactorGroupNormalSubgroupClasses( tbl, [ 1, 3 ] );
Group([ f1, f2 ])
gap> NormalSubgroupClassesInfo( tbl );
rec( nsg := [ Group([ (1,2)(3,4), (1,3)(2,4) ]) ],
  nsgclasses := [ [ 1, 3 ] ], nsgfactors := [ Group([ f1, f2 ]) ] )
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>

<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  ctblfuns.msk                GAP documentation               Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: ctblfuns.msk,v 1.31 2006/03/08 14:46:24 jjm Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<!-- %%  The documentation in this chapter corresponds to the declarations in the -->
<!-- %%  library files ctblfuns.gd, ctbllatt.gd, ctblmoli.gd, ctblpope.gd. -->
<!-- %% -->
<Chapter Label="Class Functions">
<Heading>Class Functions</Heading>

<Index>characters</Index>
<Index>group characters</Index>
<Index>virtual characters</Index>
<Index>generalized characters</Index>

This chapter describes operations for <E>class functions of finite groups</E>.
For operations concerning <E>character tables</E>,
see Chapter&nbsp;<Ref Chap="Character Tables"/>.
<P/>
Several examples in this chapter require the &GAP; Character Table Library
to be available.
If it is not yet loaded then we load it now.
<P/>
<Example><![CDATA[
gap> LoadPackage( "ctbllib" );
true
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Why Class Functions?">
<Heading>Why Class Functions?</Heading>

In principle it is possible to represent group characters or more general
class functions by the plain lists of their values,
and in fact many operations for class functions work with plain lists of
class function values.
But this has two disadvantages.
<P/>
First, it is then necessary to regard a values list explicitly as a class
function of a particular character table, by supplying this character
table as an argument.
In practice this means that with this setup,
the user has the task to put the objects into the right context.
For example, forming the scalar product or the tensor product of two
class functions or forming an induced class function or a conjugate
class function then needs three arguments in this case;
this is particularly inconvenient in cases where infix operations cannot
be used because of the additional argument, as for tensor products and
induced class functions.
<P/>
Second, when one says that
<Q><M>\chi</M> is a character of a group <M>G</M></Q>
then this object <M>\chi</M> carries a lot of information.
<M>\chi</M> has certain properties such as being irreducible or not.
Several subgroups of <M>G</M> are related to <M>\chi</M>,
such as the kernel and the centre of <M>\chi</M>.
Other attributes of characters are the determinant and the central
character.
This knowledge cannot be stored in a plain list.
<P/>
For dealing with a group together with its characters, and maybe also
subgroups and their characters, it is desirable that &GAP; keeps track
of the interpretation of characters.
On the other hand, for using characters without accessing their groups,
such as characters of tables from the &GAP; table library,
dealing just with values lists is often sufficient.
In particular, if one deals with incomplete character tables then it is
often necessary to specify the arguments explicitly,
for example one has to choose a fusion map or power map from a set of
possibilities.
<P/>
The main idea behind class function objects is that a class function
object is equal to its values list in the sense of <Ref Func="\="/>,
so class function objects can be used wherever their values lists
can be used,
but there are operations for class function objects that do not work
just with values lists.
<!-- Note that a class function object lies in the same family as its list of-->
<!-- values.-->
<!-- As a consequence, there is no filter <C>IsClassFunctionCollection</C>,-->
<!-- so we have no special treatment of spaces and algebras without hacks.-->
&GAP; library functions prefer to return class function objects
rather than returning just values lists,
for example <Ref Attr="Irr" Label="for a group"/> lists
consist of class function objects,
and <Ref Func="TrivialCharacter" Label="for a group"/>
returns a class function object.
<P/>
Here is an <E>example</E> that shows both approaches.
First we define some groups.
<P/>
<Example><![CDATA[
gap> S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );
gap> D8:= SylowSubgroup( S4, 2 );; SetName( D8, "D8" );
]]></Example>
<P/>
We do some computations using the functions described later in this
Chapter, first with class function objects.
<P/>
<Example><![CDATA[
gap> irrS4:= Irr( S4 );;
gap> irrD8:= Irr( D8 );;
gap> chi:= irrD8[4];
Character( CharacterTable( D8 ), [ 1, -1, 1, -1, 1 ] )
gap> chi * chi;
Character( CharacterTable( D8 ), [ 1, 1, 1, 1, 1 ] )
gap> ind:= chi ^ S4;
Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] )
gap> List( irrS4, x -> ScalarProduct( x, ind ) );
[ 0, 1, 0, 0, 0 ]
gap> det:= Determinant( ind );
Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] )
gap> cent:= CentralCharacter( ind );
ClassFunction( CharacterTable( S4 ), [ 1, -2, -1, 0, 2 ] )
gap> rest:= Restricted( cent, D8 );
ClassFunction( CharacterTable( D8 ), [ 1, -2, -1, -1, 2 ] )
]]></Example>
<P/>
Now we repeat these calculations with plain lists of character values.
Here we need the character tables in some places.
<P/>
<Example><![CDATA[
gap> tS4:= CharacterTable( S4 );;
gap> tD8:= CharacterTable( D8 );;
gap> chi:= ValuesOfClassFunction( irrD8[4] );
[ 1, -1, 1, -1, 1 ]
gap> Tensored( [ chi ], [ chi ] )[1];
[ 1, 1, 1, 1, 1 ]
gap> ind:= InducedClassFunction( tD8, chi, tS4 );
ClassFunction( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] )
gap> List( Irr( tS4 ), x -> ScalarProduct( tS4, x, ind ) );
[ 0, 1, 0, 0, 0 ]
gap> det:= DeterminantOfCharacter( tS4, ind );
ClassFunction( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] )
gap> cent:= CentralCharacter( tS4, ind );
ClassFunction( CharacterTable( S4 ), [ 1, -2, -1, 0, 2 ] )
gap> rest:= Restricted( tS4, cent, tD8 );
ClassFunction( CharacterTable( D8 ), [ 1, -2, -1, -1, 2 ] )
]]></Example>
<P/>
If one deals with character tables from the &GAP; table library then
one has no access to their groups,
but often the tables provide enough information for computing induced or
restricted class functions, symmetrizations etc.,
because the relevant class fusions and power maps are often stored on
library tables.
In these cases it is possible to use the tables instead of the groups
as arguments.
(If necessary information is not uniquely determined by the tables then
an error is signalled.)
<P/>
<Example><![CDATA[
gap> s5 := CharacterTable( "A5.2" );; irrs5 := Irr( s5  );;
gap> m11:= CharacterTable( "M11"  );; irrm11:= Irr( m11 );;
gap> chi:= TrivialCharacter( s5 );
Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, 1, 1, 1 ] )
gap> chi ^ m11;
Character( CharacterTable( "M11" ), [ 66, 10, 3, 2, 1, 1, 0, 0, 0, 0 
 ] )
gap> Determinant( irrs5[4] );
Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, -1, -1, -1 ] )
]]></Example>
<P/>
Functions that compute <E>normal</E> subgroups related to characters
have counterparts that return the list of class positions corresponding
to these groups.
<P/>
<Example><![CDATA[
gap> ClassPositionsOfKernel( irrs5[2] );
[ 1, 2, 3, 4 ]
gap> ClassPositionsOfCentre( irrs5[2] );
[ 1, 2, 3, 4, 5, 6, 7 ]
]]></Example>
<P/>
Non-normal subgroups cannot be described this way,
so for example inertia subgroups (see&nbsp;<Ref Func="InertiaSubgroup"/>)
can in general not be computed from character tables without access to
their groups.

<ManSection>
<Filt Name="IsClassFunction" Arg='obj' Type='Category'/>

<Description>
<Index>class function</Index><Index>class function objects</Index>
A <E>class function</E> (in characteristic <M>p</M>) of a finite group
<M>G</M> is a map from the set of (<M>p</M>-regular) elements in <M>G</M>
to the field of cyclotomics
that is constant on conjugacy classes of <M>G</M>.
<P/>
Each class function in &GAP; is represented by an <E>immutable list</E>,
where at the <M>i</M>-th position the value on the <M>i</M>-th conjugacy
class of the character table of <M>G</M> is stored.
The ordering of the conjugacy classes is the one used in the underlying
character table.
Note that if the character table has access to its underlying group then
the ordering of conjugacy classes in the group and in the character table
may differ
(see <Ref Sect="The Interface between Character Tables and Groups"/>);
class functions always refer to the ordering of classes in the character
table.
<P/>
<E>Class function objects</E> in &GAP; are not just plain lists,
they store the character table of the group <M>G</M> as value of the
attribute <Ref Func="UnderlyingCharacterTable"/>.
The group <M>G</M> itself is accessible only via the character table
and thus only if the character table stores its group, as value of the
attribute <Ref Attr="UnderlyingGroup" Label="for character tables"/>.
The reason for this is that many computations with class functions are
possible without using their groups,
for example class functions of character tables in the &GAP;
character table library do in general not have access to their
underlying groups.
<P/>
There are (at least) two reasons why class functions in &GAP; are
<E>not</E> implemented as mappings.
First, we want to distinguish class functions in different
characteristics, for example to be able to define the Frobenius character
of a given Brauer character;
viewed as mappings, the trivial characters in all characteristics coprime
to the order of <M>G</M> are equal.
Second, the product of two class functions shall be again a class
function, whereas the product of general mappings is defined as
composition.
<P/>
A further argument is that the typical operations for mappings such as
<Ref Func="Image" Label="set of images of the source of a general mapping"/>
and
<Ref Func="PreImage" Label="set of preimages of the range of a general mapping"/>
play no important role for class functions.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Basic Operations for Class Functions">
<Heading>Basic Operations for Class Functions</Heading>

Basic operations for class functions are
<Ref Func="UnderlyingCharacterTable"/>,
<Ref Func="ValuesOfClassFunction"/>,
and the basic operations for lists
(see&nbsp;<Ref Sect="Basic Operations for Lists"/>).

<ManSection>
<Attr Name="UnderlyingCharacterTable" Arg='psi'/>

<Description>
For a class function <A>psi</A> of the group <M>G</M>, say,
the character table of <M>G</M> is stored as value of
<Ref Attr="UnderlyingCharacterTable"/>.
The ordering of entries in the list <A>psi</A>
(see&nbsp;<Ref Func="ValuesOfClassFunction"/>)
refers to the ordering of conjugacy classes in this character table.
<P/>
If <A>psi</A> is an ordinary class function then the underlying character
table is the ordinary character table of <M>G</M>
(see&nbsp;<Ref Func="OrdinaryCharacterTable" Label="for a group"/>),
if <A>psi</A> is a class function in characteristic <M>p \neq 0</M> then
the underlying character table is the <M>p</M>-modular Brauer table of
<M>G</M>
(see&nbsp;<Ref Func="BrauerTable"
Label="for a group, and a prime integer"/>).
So the underlying characteristic of <A>psi</A> can be read off from the
underlying character table.
</Description>
</ManSection>

<ManSection>
<Attr Name="ValuesOfClassFunction" Arg='psi'/>

<Description>
is the list of values of the class function <A>psi</A>,
the <M>i</M>-th entry being the value on the <M>i</M>-th conjugacy class
of the underlying character table
(see&nbsp;<Ref Func="UnderlyingCharacterTable"/>).
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> psi:= TrivialCharacter( g );
Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] )
gap> UnderlyingCharacterTable( psi );
CharacterTable( Sym( [ 1 .. 4 ] ) )
gap> ValuesOfClassFunction( psi );
[ 1, 1, 1, 1, 1 ]
gap> IsList( psi );
true
gap> psi[1];
1
gap> Length( psi );
5
gap> IsBound( psi[6] );
false
gap> Concatenation( psi, [ 2, 3 ] );
[ 1, 1, 1, 1, 1, 2, 3 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Class Functions">
<Heading>Comparison of Class Functions</Heading>

With respect to <Ref Func="\="/> and <Ref Func="\&lt;"/>,
class functions behave equally to their lists of values
(see&nbsp;<Ref Func="ValuesOfClassFunction"/>).
So two class functions are equal if and only if their lists of values are
equal, no matter whether they are class functions of the same character
table, of the same group but w.r.t.&nbsp;different class ordering,
or of different groups.
<P/>
<Example><![CDATA[
gap> grps:= Filtered( AllSmallGroups( 8 ), g -> not IsAbelian( g ) );
[ <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators> ]
gap> t1:= CharacterTable( grps[1] );  SetName( t1, "t1" );
CharacterTable( <pc group of size 8 with 3 generators> )
gap> t2:= CharacterTable( grps[2] );  SetName( t2, "t2" );
CharacterTable( <pc group of size 8 with 3 generators> )
gap> irr1:= Irr( grps[1] );
[ Character( t1, [ 1, 1, 1, 1, 1 ] ), 
  Character( t1, [ 1, -1, -1, 1, 1 ] ), 
  Character( t1, [ 1, -1, 1, 1, -1 ] ), 
  Character( t1, [ 1, 1, -1, 1, -1 ] ), 
  Character( t1, [ 2, 0, 0, -2, 0 ] ) ]
gap> irr2:= Irr( grps[2] );
[ Character( t2, [ 1, 1, 1, 1, 1 ] ), 
  Character( t2, [ 1, -1, -1, 1, 1 ] ), 
  Character( t2, [ 1, -1, 1, 1, -1 ] ), 
  Character( t2, [ 1, 1, -1, 1, -1 ] ), 
  Character( t2, [ 2, 0, 0, -2, 0 ] ) ]
gap> irr1 = irr2;
true
gap> IsSSortedList( irr1 );
false
gap> irr1[1] < irr1[2];
false
gap> irr1[2] < irr1[3];
true
]]></Example>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Operations for Class Functions">
<Heading>Arithmetic Operations for Class Functions</Heading>

Class functions are <E>row vectors</E> of cyclotomics.
The <E>additive</E> behaviour of class functions is defined such that
they are equal to the plain lists of class function values except that
the results are represented again as class functions whenever this makes
sense.
The <E>multiplicative</E> behaviour, however, is different.
This is motivated by the fact that the tensor product of class functions
is a more interesting operation than the vector product of plain lists.
(Another candidate for a multiplication of compatible class functions
would have been the inner product, which is implemented via the function
<Ref Func="ScalarProduct" Label="for characters"/>.
In terms of filters, the arithmetic of class functions is based on the
decision that they lie in <Ref Func="IsGeneralizedRowVector"/>,
with additive nesting depth <M>1</M>, but they do <E>not</E> lie in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>.
<P/>
More specifically, the scalar multiple of a class function with a
cyclotomic is a class function,
and the sum and the difference of two class functions
of the same underlying character table
(see&nbsp;<Ref Func="UnderlyingCharacterTable"/>)
are again class functions of this table.
The sum and the difference of a class function and a list that is
<E>not</E> a class function are plain lists,
as well as the sum and the difference of two class functions of different
character tables.
<P/>
<Example><![CDATA[
gap> g:= SymmetricGroup( 4 );;  tbl:= CharacterTable( g );;
gap> SetName( tbl, "S4" );  irr:= Irr( g );
[ Character( S4, [ 1, -1, 1, 1, -1 ] ), 
  Character( S4, [ 3, -1, -1, 0, 1 ] ), 
  Character( S4, [ 2, 0, 2, -1, 0 ] ), 
  Character( S4, [ 3, 1, -1, 0, -1 ] ), 
  Character( S4, [ 1, 1, 1, 1, 1 ] ) ]
gap> 2 * irr[5];
Character( S4, [ 2, 2, 2, 2, 2 ] )
gap> irr[1] / 7;
ClassFunction( S4, [ 1/7, -1/7, 1/7, 1/7, -1/7 ] )
gap> lincomb:= irr[3] + irr[1] - irr[5];
VirtualCharacter( S4, [ 2, -2, 2, -1, -2 ] )
gap> lincomb:= lincomb + 2 * irr[5];
VirtualCharacter( S4, [ 4, 0, 4, 1, 0 ] )
gap> IsCharacter( lincomb );
true
gap> lincomb;
Character( S4, [ 4, 0, 4, 1, 0 ] )
gap> irr[5] + 2;
[ 3, 3, 3, 3, 3 ]
gap> irr[5] + [ 1, 2, 3, 4, 5 ];
[ 2, 3, 4, 5, 6 ]
gap> zero:= 0 * irr[1];
VirtualCharacter( S4, [ 0, 0, 0, 0, 0 ] )
gap> zero + Z(3);
[ Z(3), Z(3), Z(3), Z(3), Z(3) ]
gap> irr[5] + TrivialCharacter( DihedralGroup( 8 ) );
[ 2, 2, 2, 2, 2 ]
]]></Example>
<P/>
<Index Subkey="as ring elements">class functions</Index>
The product of two class functions of the same character table is the
tensor product (pointwise product) of these class functions.
Thus the set of all class functions of a fixed group forms a ring,
and for any field <M>F</M> of cyclotomics, the <M>F</M>-span of a given
set of class functions forms an algebra.
<P/>
The product of two class functions of <E>different</E> tables and the
product of a class function and a list that is <E>not</E> a class
function are not defined, an error is signalled in these cases.
Note that in this respect, class functions behave differently from their
values lists, for which the product is defined as the standard scalar
product.
<P/>
<Example><![CDATA[
gap> tens:= irr[3] * irr[4];
Character( S4, [ 6, 0, -2, 0, 0 ] )
gap> ValuesOfClassFunction( irr[3] ) * ValuesOfClassFunction( irr[4] );
4
]]></Example>
<P/>
<Index Subkey="of class function">inverse</Index>
Class functions without zero values are invertible,
the <E>inverse</E> is defined pointwise.
As a consequence, for example groups of linear characters can be formed.
<P/>
<Example><![CDATA[
gap> tens / irr[1];
Character( S4, [ 6, 0, -2, 0, 0 ] )
]]></Example>
<P/>
Other (somewhat strange) implications of the definition of arithmetic
operations for class functions, together with the general rules of list
arithmetic (see&nbsp;<Ref Sect="Arithmetic for Lists"/>),
apply to the case of products involving <E>lists</E> of class functions.
No inverse of the list of irreducible characters as a matrix is defined;
if one is interested in the inverse matrix then one can compute it from
the matrix of class function values.
<P/>
<Example><![CDATA[
gap> Inverse( List( irr, ValuesOfClassFunction ) );
[ [ 1/24, 1/8, 1/12, 1/8, 1/24 ], [ -1/4, -1/4, 0, 1/4, 1/4 ], 
  [ 1/8, -1/8, 1/4, -1/8, 1/8 ], [ 1/3, 0, -1/3, 0, 1/3 ], 
  [ -1/4, 1/4, 0, -1/4, 1/4 ] ]
]]></Example>
<P/>
Also the product of a class function with a list of class functions is
<E>not</E> a vector-matrix product but the list of pointwise products.
<P/>
<Example><![CDATA[
gap> irr[1] * irr{ [ 1 .. 3 ] };
[ Character( S4, [ 1, 1, 1, 1, 1 ] ), 
  Character( S4, [ 3, 1, -1, 0, -1 ] ), 
  Character( S4, [ 2, 0, 2, -1, 0 ] ) ]
]]></Example>
<P/>
And the product of two lists of class functions is <E>not</E> the matrix
product but the sum of the pointwise products.
<P/>
<Example><![CDATA[
gap> irr * irr;
Character( S4, [ 24, 4, 8, 3, 4 ] )
]]></Example>
<P/>
<Index Subkey="of group element using powering operator">character value</Index>
<Index Subkey="meaning for class functions">power</Index>
<Index Subkey="for class functions"><C>^</C></Index>
The <E>powering</E> operator <Ref Func="\^"/> has several meanings
for class functions.
The power of a class function by a nonnegative integer is clearly the
tensor power.
The power of a class function by an element that normalizes the
underlying group or by a Galois automorphism is the conjugate class
function.
(As a consequence, the application of the permutation induced by such an
action cannot be denoted by <Ref Func="\^"/>; instead one can use
<Ref Func="Permuted"/>.)
The power of a class function by a group or a character table is the
induced class function (see&nbsp;<Ref Func="InducedClassFunction"
Label="for the character table of a supergroup"/>).
The power of a group element by a class function is the class function
value at (the conjugacy class containing) this element.
<P/>
<Example><![CDATA[
gap> irr[3] ^ 3;
Character( S4, [ 8, 0, 8, -1, 0 ] )
gap> lin:= LinearCharacters( DerivedSubgroup( g ) );
[ Character( CharacterTable( Alt( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1 ] ), 
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3), E(3)^2 ] ),
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3)^2, E(3) ] ) ]
gap> List( lin, chi -> chi ^ (1,2) );
[ Character( CharacterTable( Alt( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1 ] ), 
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3)^2, E(3) ] ),
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3), E(3)^2 ] ) ]
gap> Orbit( GaloisGroup( CF(3) ), lin[2] );
[ Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3), E(3)^2 ] ),
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3)^2, E(3) ] ) ]
gap> lin[1]^g;
Character( S4, [ 2, 0, 2, 2, 0 ] )
gap> (1,2,3)^lin[2];
E(3)
]]></Example>

<ManSection>
<Func Name="Characteristic" Arg='chi' Label="for a class function"/>

<Description>
The <E>characteristic</E> of class functions is zero,
as for all list of cyclotomics.
For class functions of a <M>p</M>-modular character table, such as Brauer
characters, the prime <M>p</M> is given by the
<Ref Attr="UnderlyingCharacteristic" Label="for a character table"/>
value of the character table.
<P/>
<Example><![CDATA[
gap> Characteristic( irr[1] );
0
gap> irrmod2:= Irr( g, 2 );
[ Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 1, 1 ] ), 
  Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 2, -1 ] ) ]
gap> Characteristic( irrmod2[1] );
0
gap> UnderlyingCharacteristic( UnderlyingCharacterTable( irrmod2[1] ) );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ComplexConjugate" Arg='chi' Label="for a class function"/>
<Func Name="GaloisCyc" Arg='chi, k' Label="for a class function"/>
<Func Name="Permuted" Arg='chi, pi' Label="for a class function"/>

<Description>
The operations
<Ref Func="ComplexConjugate" Label="for a class function"/>,
<Ref Func="GaloisCyc" Label="for a class function"/>,
and <Ref Func="Permuted" Label="for a class function"/> return
a class function when they are called with a class function;
The complex conjugate of a class function that is known to be a (virtual)
character is again known to be a (virtual) character, and applying an
arbitrary Galois automorphism to an ordinary (virtual) character yields
a (virtual) character.
<P/>
<Example><![CDATA[
gap> ComplexConjugate( lin[2] );
Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
 [ 1, 1, E(3)^2, E(3) ] )
gap> GaloisCyc( lin[2], 5 );
Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
 [ 1, 1, E(3)^2, E(3) ] )
gap> Permuted( lin[2], (2,3,4) );
ClassFunction( CharacterTable( Alt( [ 1 .. 4 ] ) ),
 [ 1, E(3)^2, 1, E(3) ] )
]]></Example>
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="Order" Arg='chi' Label="for a class function"/>

<Description>
By definition of <Ref Func="Order"/> for arbitrary monoid elements,
the return value of <Ref Func="Order"/> for a character must be its
multiplicative order.
The <E>determinantal order</E>
(see&nbsp;<Ref Func="DeterminantOfCharacter"/>) of a character <A>chi</A>
can be computed as <C>Order( Determinant( <A>chi</A> ) )</C>.
<P/>
<Example><![CDATA[
gap> det:= Determinant( irr[3] );
Character( S4, [ 1, -1, 1, 1, -1 ] )
gap> Order( det );
2
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Printing Class Functions">
<Heading>Printing Class Functions</Heading>

<ManSection>
<Meth Name="ViewObj" Arg='chi' Label="for class functions"/>

<Description>
The default <Ref Func="ViewObj"/> methods for class functions
print one of the strings <C>"ClassFunction"</C>,
<C>"VirtualCharacter"</C>, <C>"Character"</C> (depending on whether the
class function is known to be a character or virtual character,
see&nbsp;<Ref Func="IsCharacter"/>, <Ref Func="IsVirtualCharacter"/>),
followed by the <Ref Func="ViewObj"/> output for the underlying character
table (see&nbsp;<Ref Sect="Printing Character Tables"/>),
and the list of values.
The table is chosen (and not the group) in order to distinguish class
functions of different underlying characteristic
(see&nbsp;<Ref Attr="UnderlyingCharacteristic" Label="for a character"/>).
</Description>
</ManSection>

<ManSection>
<Meth Name="PrintObj" Arg='chi' Label="for class functions"/>

<Description>
The default <Ref Func="PrintObj"/> method for class functions
does the same as <Ref Func="ViewObj"/>,
except that the character table is is <Ref Func="Print"/>-ed instead of
<Ref Func="View"/>-ed.
<P/>
<E>Note</E> that if a class function is shown only with one of the
strings <C>"ClassFunction"</C>, <C>"VirtualCharacter"</C>,
it may still be that it is in fact a character;
just this was not known at the time when the class function was printed.
<P/>
In order to reduce the space that is needed to print a class function,
it may be useful to give a name (see&nbsp;<Ref Func="Name"/>) to the
underlying character table.
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg='chi' Label="for class functions"/>

<Description>
The default <Ref Func="Display"/> method for a class function <A>chi</A>
calls <Ref Func="Display"/> for its underlying character table
(see&nbsp;<Ref Sect="Printing Character Tables"/>),
with <A>chi</A> as the only entry in the <C>chars</C> list of the options
record.
<P/>
<Example><![CDATA[
gap> chi:= TrivialCharacter( CharacterTable( "A5" ) );
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
gap> Display( chi );
A5

     2  2  2  .  .  .
     3  1  .  1  .  .
     5  1  .  .  1  1

       1a 2a 3a 5a 5b
    2P 1a 1a 3a 5b 5a
    3P 1a 2a 1a 5b 5a
    5P 1a 2a 3a 1a 1a

Y.1     1  1  1  1  1
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Class Functions from Values Lists">
<Heading>Creating Class Functions from Values Lists</Heading>

<ManSection>
<Oper Name="ClassFunction" Arg='tbl, values'
 Label="for a character table and a list"/>
<Oper Name="ClassFunction" Arg='G, values'
 Label="for a group and a list"/>

<Description>
In the first form,
<Ref Oper="ClassFunction" Label="for a character table and a list"/>
returns the class function of the character table <A>tbl</A> with values
given by the list <A>values</A> of cyclotomics.
In the second form, <A>G</A> must be a group,
and the class function of its ordinary character table is returned.
<P/>
Note that <A>tbl</A> determines the underlying characteristic of the
returned class function
(see&nbsp;<Ref Attr="UnderlyingCharacteristic" Label="for a character"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="VirtualCharacter" Arg='tbl, values'
 Label="for a character table and a list"/>
<Oper Name="VirtualCharacter" Arg='G, values'
 Label="for a group and a list"/>

<Description>
<Ref Oper="VirtualCharacter" Label="for a character table and a list"/>
returns the virtual character
(see&nbsp;<Ref Func="IsVirtualCharacter"/>)
of the character table <A>tbl</A> or the group <A>G</A>,
respectively, with values given by the list <A>values</A>.
<P/>
It is <E>not</E> checked whether the given values really describe a
virtual character.
</Description>
</ManSection>

<ManSection>
<Oper Name="Character" Arg='tbl, values'
 Label="for a character table and a list"/>
<Oper Name="Character" Arg='G, values'
 Label="for a group and a list"/>

<Description>
<Ref Oper="Character" Label="for a character table and a list"/>
returns the character (see&nbsp;<Ref Func="IsCharacter"/>)
of the character table <A>tbl</A> or the group <A>G</A>,
respectively, with values given by the list <A>values</A>.
<P/>
It is <E>not</E> checked whether the given values really describe a
character.
<Example><![CDATA[
gap> g:= DihedralGroup( 8 );  tbl:= CharacterTable( g );
<pc group of size 8 with 3 generators>
CharacterTable( <pc group of size 8 with 3 generators> )
gap> SetName( tbl, "D8" );
gap> phi:= ClassFunction( g, [ 1, -1, 0, 2, -2 ] );
ClassFunction( D8, [ 1, -1, 0, 2, -2 ] )
gap> psi:= ClassFunction( tbl,
>              List( Irr( g ), chi -> ScalarProduct( chi, phi ) ) );
ClassFunction( D8, [ -3/8, 9/8, 5/8, 1/8, -1/4 ] )
gap> chi:= VirtualCharacter( g, [ 0, 0, 8, 0, 0 ] );
VirtualCharacter( D8, [ 0, 0, 8, 0, 0 ] )
gap> reg:= Character( tbl, [ 8, 0, 0, 0, 0 ] );
Character( D8, [ 8, 0, 0, 0, 0 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ClassFunctionSameType" Arg='tbl, chi, values'/>

<Description>
Let <A>tbl</A> be a character table, <A>chi</A> a class function object
(<E>not</E> necessarily a class function of <A>tbl</A>),
and <A>values</A> a list of cyclotomics.
<Ref Func="ClassFunctionSameType"/> returns the class function
<M>\psi</M> of <A>tbl</A> with values list <A>values</A>,
constructed with
<Ref Func="ClassFunction" Label="for a character table and a list"/>.
<P/>
If <A>chi</A> is known to be a (virtual) character then <M>\psi</M>
is also known to be a (virtual) character.
<P/>
<Example><![CDATA[
gap> h:= Centre( g );;
gap> centbl:= CharacterTable( h );;  SetName( centbl, "C2" );
gap> ClassFunctionSameType( centbl, phi, [ 1, 1 ] );
ClassFunction( C2, [ 1, 1 ] )
gap> ClassFunctionSameType( centbl, chi, [ 1, 1 ] );
VirtualCharacter( C2, [ 1, 1 ] )
gap> ClassFunctionSameType( centbl, reg, [ 1, 1 ] );
Character( C2, [ 1, 1 ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Class Functions using Groups">
<Heading>Creating Class Functions using Groups</Heading>

<ManSection>
<Heading>TrivialCharacter</Heading>
<Attr Name="TrivialCharacter" Arg='tbl' Label="for a character table"/>
<Attr Name="TrivialCharacter" Arg='G' Label="for a group"/>

<Description>
is the <E>trivial character</E> of the group <A>G</A>
or its character table <A>tbl</A>, respectively.
This is the class function with value equal to <M>1</M> for each class.
<P/>
<Example><![CDATA[
gap> TrivialCharacter( CharacterTable( "A5" ) );
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
gap> TrivialCharacter( SymmetricGroup( 3 ) );
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 1, 1, 1 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NaturalCharacter" Arg='G' Label="for a group"/>
<Attr Name="NaturalCharacter" Arg='hom' Label="for a homomorphism"/>

<Description>
If the argument is a permutation group <A>G</A> then
<Ref Attr="NaturalCharacter" Label="for a group"/>
returns the (ordinary) character of the natural permutation
representation of <A>G</A> on the set of moved points (see
<Ref Func="MovedPoints" Label="for a list or collection of permutations"/>),
that is, the value on each class is the number of points among the moved
points of <A>G</A> that are fixed by any permutation in that class.
<P/>
If the argument is a matrix group <A>G</A> in characteristic zero then
<Ref Attr="NaturalCharacter" Label="for a group"/> returns the
(ordinary) character of the natural matrix representation of <A>G</A>,
that is, the value on each class is the trace of any matrix in that class.
<P/>
If the argument is a group homomorphism <A>hom</A> whose image is a
permutation group or a matrix group then
<Ref Attr="NaturalCharacter" Label="for a homomorphism"/> returns the
restriction of the natural character of the image of <A>hom</A> to the
preimage of <A>hom</A>.
<P/>
<Example><![CDATA[
gap> NaturalCharacter( SymmetricGroup( 3 ) );
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 3, 1, 0 ] )
gap> NaturalCharacter( Group( [ [ 0, -1 ], [ 1, -1 ] ] ) );
Character( CharacterTable( Group([ [ [ 0, -1 ], [ 1, -1 ] ] ]) ), 
[ 2, -1, -1 ] )
gap> d8:= DihedralGroup( 8 );;  hom:= IsomorphismPermGroup( d8 );;
gap> NaturalCharacter( hom );
Character( CharacterTable( <pc group of size 8 with 3 generators> ), 
[ 8, 0, 0, 0, 0 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>PermutationCharacter</Heading>
<Oper Name="PermutationCharacter" Arg='G, D, opr'
 Label="for a group, an action domain, and a function"/>
<Oper Name="PermutationCharacter" Arg='G, U' Label="for two groups"/>

<Description>
Called with a group <A>G</A>, an action domain or proper set <A>D</A>,
and an action function <A>opr</A>
(see Chapter&nbsp;<Ref Chap="Group Actions"/>),
<Ref Oper="PermutationCharacter"
Label="for a group, an action domain, and a function"/>
returns the <E>permutation character</E> of the action
of <A>G</A> on <A>D</A> via <A>opr</A>,
that is, the value on each class is the number of points in <A>D</A>
that are fixed by an element in this class under the action <A>opr</A>.
<P/>
If the arguments are a group <A>G</A> and a subgroup <A>U</A> of <A>G</A>
then <Ref Oper="PermutationCharacter" Label="for two groups"/> returns
the permutation character of the action of <A>G</A> on the right cosets
of <A>U</A> via right multiplication.
<P/>
To compute the permutation character of a
<E>transitive permutation group</E>
<A>G</A> on the cosets of a point stabilizer <A>U</A>,
the attribute <Ref Func="NaturalCharacter" Label="for a group"/>
of <A>G</A> can be used instead of
<C>PermutationCharacter( <A>G</A>, <A>U</A> )</C>.
<P/>
More facilities concerning permutation characters are the transitivity
test (see Section&nbsp;<Ref Sect="Operations for Class Functions"/>)
and several tools for computing possible permutation characters
(see&nbsp;<Ref Sect="Possible Permutation Characters"/>,
<Ref Sect="Computing Possible Permutation Characters"/>).
<P/>
<Example><![CDATA[
gap> PermutationCharacter( GL(2,2), AsSSortedList( GF(2)^2 ), OnRight );
Character( CharacterTable( SL(2,2) ), [ 4, 2, 1 ] )
gap> s3:= SymmetricGroup( 3 );;  a3:= DerivedSubgroup( s3 );;
gap> PermutationCharacter( s3, a3 );
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 2, 0, 2 ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Class Functions">
<Heading>Operations for Class Functions</Heading>

In the description of the following operations,
the optional first argument <A>tbl</A> is needed only if the argument
<A>chi</A> is a plain list and not a class function object.
In this case, <A>tbl</A> must always be the character table of which
<A>chi</A> shall be regarded as a class function.

<ManSection>
<Prop Name="IsCharacter" Arg='[tbl, ]chi'/>

<Description>
<Index>ordinary character</Index>
An <E>ordinary character</E> of a group <M>G</M> is a class function of
<M>G</M> whose values are the traces of a complex matrix representation
of <M>G</M>.
<P/>
<Index>Brauer character</Index>
A <E>Brauer character</E> of <M>G</M> in characteristic <M>p</M> is
a class function of <M>G</M> whose values are the complex lifts of a
matrix representation of <M>G</M> with image a finite field of
characteristic <M>p</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsVirtualCharacter" Arg='[tbl, ]chi'/>

<Description>
<Index>virtual character</Index>
A <E>virtual character</E> is a class function that can be written as the
difference of two proper characters (see&nbsp;<Ref Func="IsCharacter"/>).
</Description>
</ManSection>

<ManSection>
<Prop Name="IsIrreducibleCharacter" Arg='[tbl, ]chi'/>

<Description>
<Index>irreducible character</Index>
A character is <E>irreducible</E> if it cannot be written as the sum of
two characters.
For ordinary characters this can be checked using the scalar product
of class functions
(see&nbsp;<Ref Func="ScalarProduct" Label="for characters"/>).
For Brauer characters there is no generic method for checking
irreducibility.
<P/>
<Example><![CDATA[
gap> S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );
gap> psi:= ClassFunction( S4, [ 1, 1, 1, -2, 1 ] );
ClassFunction( CharacterTable( S4 ), [ 1, 1, 1, -2, 1 ] )
gap> IsVirtualCharacter( psi );
true
gap> IsCharacter( psi );
false
gap> chi:= ClassFunction( S4, SizesCentralizers( CharacterTable( S4 ) ) );
ClassFunction( CharacterTable( S4 ), [ 24, 4, 8, 3, 4 ] )
gap> IsCharacter( chi );
true
gap> IsIrreducibleCharacter( chi );
false
gap> IsIrreducibleCharacter( TrivialCharacter( S4 ) );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="DegreeOfCharacter" Arg='chi'/>

<Description>
is the value of the character <A>chi</A> on the identity element.
This can also be obtained as <A>chi</A><C>[1]</C>.
<P/>
<Example><![CDATA[
gap> List( Irr( S4 ), DegreeOfCharacter );
[ 1, 3, 2, 3, 1 ]
gap> nat:= NaturalCharacter( S4 );
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
gap> nat[1];
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="ScalarProduct" Arg='[tbl, ]chi, psi' Label="for characters"/>

<Returns>
the scalar product of the class functions <A>chi</A> and <A>psi</A>,
which belong to the same character table <A>tbl</A>.
</Returns>
<Description>
<Index Subkey="of a group character">constituent</Index>
<Index Subkey="a group character">decompose</Index>
<Index Subkey="of constituents of a group character">multiplicity</Index>
<Index Subkey="of group characters">inner product</Index>
If <A>chi</A> and <A>psi</A> are class function objects,
the argument <A>tbl</A> is not needed,
but <A>tbl</A> is necessary if at least one of <A>chi</A>, <A>psi</A>
is just a plain list.
<P/>
The scalar product of two <E>ordinary</E> class functions <M>\chi</M>,
<M>\psi</M> of a group <M>G</M> is defined as
<P/>
<M>( \sum_{{g \in G}} \chi(g) \psi(g^{{-1}}) ) / |G|</M>.
<P/>
For two <E><M>p</M>-modular</E> class functions,
the scalar product is defined as
<M>( \sum_{{g \in S}} \chi(g) \psi(g^{{-1}}) ) / |G|</M>,
where <M>S</M> is the set of <M>p</M>-regular elements in <M>G</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="MatScalarProducts" Arg='[tbl, ]list[, list2]'/>

<Description>
Called with two lists <A>list</A>, <A>list2</A> of class functions of the
same character table (which may be given as the argument <A>tbl</A>),
<Ref Oper="MatScalarProducts"/> returns the matrix of scalar products
(see <Ref Oper="ScalarProduct" Label="for characters"/>)
More precisely, this matrix contains in the <M>i</M>-th row the list of
scalar products of <M><A>list2</A>[i]</M>
with the entries of <A>list</A>.
<P/>
If only one list <A>list</A> of class functions is given then
a lower triangular matrix of scalar products is returned,
containing (for <M>j \leq i</M>) in the <M>i</M>-th row in column
<M>j</M> the value
<C>ScalarProduct</C><M>( <A>tbl</A>, <A>list</A>[j], <A>list</A>[i] )</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="Norm" Arg='[tbl, ]chi' Label="for a class function"/>

<Description>
<Index Subkey="of character" Key="Norm"><C>Norm</C></Index>
For an ordinary class function <A>chi</A> of the group <M>G</M>, say,
we have <M><A>chi</A> = \sum_{{\chi \in Irr(G)}} a_{\chi} \chi</M>,
with complex coefficients <M>a_{\chi}</M>.
The <E>norm</E> of <A>chi</A> is defined as
<M>\sum_{{\chi \in Irr(G)}} a_{\chi} \overline{{a_{\chi}}}</M>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> ScalarProduct( TrivialCharacter( tbl ), Sum( Irr( tbl ) ) );
1
gap> ScalarProduct( tbl, [ 1, 1, 1, 1, 1 ], Sum( Irr( tbl ) ) );
1
gap> tbl2:= tbl mod 2;  
BrauerTable( "A5", 2 )
gap> chi:= Irr( tbl2 )[1];
Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] )
gap> ScalarProduct( chi, chi );
3/4
gap> ScalarProduct( tbl2, [ 1, 1, 1, 1 ], [ 1, 1, 1, 1 ] );
3/4
gap> chars:= Irr( tbl ){ [ 2 .. 4 ] };;
gap> chars:= Set( Tensored( chars, chars ) );;
gap> MatScalarProducts( Irr( tbl ), chars );
[ [ 0, 0, 0, 1, 1 ], [ 1, 1, 0, 0, 1 ], [ 1, 0, 1, 0, 1 ], 
  [ 0, 1, 0, 1, 1 ], [ 0, 0, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
gap> MatScalarProducts( tbl, chars );
[ [ 2 ], [ 1, 3 ], [ 1, 2, 3 ], [ 2, 2, 1, 3 ], [ 2, 1, 2, 2, 3 ], 
  [ 2, 3, 3, 3, 3, 5 ] ]
gap> List( chars, Norm );
[ 2, 3, 3, 3, 3, 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ConstituentsOfCharacter" Arg='[tbl, ]chi'/>

<Description>
is the set of irreducible characters that occur in the decomposition of
the (virtual) character <A>chi</A> with nonzero coefficient.
<P/>
<Example><![CDATA[
gap> nat:= NaturalCharacter( S4 );
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
gap> ConstituentsOfCharacter( nat );
[ Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( S4 ), [ 3, 1, -1, 0, -1 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="KernelOfCharacter" Arg='[tbl, ]chi'/>

<Description>
For a class function <A>chi</A> of the group <M>G</M>, say,
<Ref Func="KernelOfCharacter"/> returns the normal subgroup of <M>G</M>
that is formed by those conjugacy classes for which the value of
<A>chi</A> equals the degree of <A>chi</A>.
If the underlying character table of <A>chi</A> does not store the group
<M>G</M> then an error is signalled.
(See&nbsp;<Ref Func="ClassPositionsOfKernel"/> for a way to handle the
kernel implicitly,
by listing the positions of conjugacy classes in the kernel.)
<P/>
The returned group is the kernel of any representation of <M>G</M> that
affords <A>chi</A>.
<P/>
<Example><![CDATA[
gap> List( Irr( S4 ), KernelOfCharacter );
[ Alt( [ 1 .. 4 ] ), Group(()), Group([ (1,2)(3,4), (1,4)(2,3) ]),
  Group(()), Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfKernel" Arg='chi'/>

<Description>
is the list of positions of those conjugacy classes that form the kernel
of the character <A>chi</A>, that is, those positions with character
value equal to the character degree.
<P/>
<Example><![CDATA[
gap> List( Irr( S4 ), ClassPositionsOfKernel );
[ [ 1, 3, 4 ], [ 1 ], [ 1, 3 ], [ 1 ], [ 1, 2, 3, 4, 5 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CentreOfCharacter" Arg='[tbl, ]chi'/>

<Description>
<Index Subkey="of a character">centre</Index>
For a character <A>chi</A> of the group <M>G</M>, say,
<Ref Func="CentreOfCharacter"/> returns the <E>centre</E> of <A>chi</A>,
that is, the normal subgroup of all those elements of <M>G</M> for which
the quotient of the value of <A>chi</A> by the degree of <A>chi</A> is
a root of unity.
<P/>
If the underlying character table of <A>psi</A> does not store the group
<M>G</M> then an error is signalled.
(See&nbsp;<Ref Attr="ClassPositionsOfCentre" Label="for a character"/>
for a way to handle the centre implicitly,
by listing the positions of conjugacy classes in the centre.)
<P/>
<Example><![CDATA[
gap> List( Irr( S4 ), CentreOfCharacter );
[ Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]), Group(()), 
  Group([ (1,2)(3,4), (1,4)(2,3) ]), Group(()), Group([ (), (1,2), (1,
   2)(3,4), (1,2,3), (1,2,3,4) ]) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ClassPositionsOfCentre" Arg='chi' Label="for a character"/>

<Description>
is the list of positions of classes forming the centre of the character
<A>chi</A> (see&nbsp;<Ref Func="CentreOfCharacter"/>).
<P/>
<Example><![CDATA[
gap> List( Irr( S4 ), ClassPositionsOfCentre );
[ [ 1, 2, 3, 4, 5 ], [ 1 ], [ 1, 3 ], [ 1 ], [ 1, 2, 3, 4, 5 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="InertiaSubgroup" Arg='[tbl, ]G, chi'/>

<Description>
Let <A>chi</A> be a character of the group <M>H</M>, say,
and <A>tbl</A> the character table of <M>H</M>;
if the argument <A>tbl</A> is not given then the underlying character
table of <A>chi</A> (see&nbsp;<Ref Func="UnderlyingCharacterTable"/>) is
used instead.
Furthermore, let <A>G</A> be a group that contains <M>H</M> as a normal
subgroup.
<P/>
<Ref Func="InertiaSubgroup"/> returns the stabilizer in <A>G</A> of
<A>chi</A>, w.r.t.&nbsp;the action of <A>G</A> on the classes of <M>H</M>
via conjugation.
In other words, <Ref Func="InertiaSubgroup"/> returns the group of all
those elements <M>g \in <A>G</A></M> that satisfy
<M><A>chi</A>^g = <A>chi</A></M>.
<P/>
<Example><![CDATA[
gap> der:= DerivedSubgroup( S4 );
Alt( [ 1 .. 4 ] )
gap> List( Irr( der ), chi -> InertiaSubgroup( S4, chi ) );
[ S4, Alt( [ 1 .. 4 ] ), Alt( [ 1 .. 4 ] ), S4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CycleStructureClass" Arg='[tbl, ]chi, class'/>

<Description>
Let <A>permchar</A> be a permutation character, and <A>class</A> be the
position of a conjugacy class of the character table of <A>permchar</A>.
<Ref Oper="CycleStructureClass"/> returns a list describing
the cycle structure of each element in class <A>class</A> in the
underlying permutation representation, in the same format as the result
of <Ref Func="CycleStructurePerm"/>.
<P/>
<Example><![CDATA[
gap> nat:= NaturalCharacter( S4 );
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
gap> List( [ 1 .. 5 ], i -> CycleStructureClass( nat, i ) );
[ [  ], [ 1 ], [ 2 ], [ , 1 ], [ ,, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsTransitive" Arg='[tbl, ]chi' Label="for a character"/>

<Description>
For a permutation character <A>chi</A> of the group <M>G</M> that
corresponds to an action on the <M>G</M>-set <M>\Omega</M>
(see&nbsp;<Ref Func="PermutationCharacter"
Label="for a group, an action domain, and a function"/>),
<Ref Prop="IsTransitive" Label="for a group, an action domain, etc."/>
returns <K>true</K> if the action of <M>G</M> on <M>\Omega</M> is
transitive, and <K>false</K> otherwise.
</Description>
</ManSection>

<ManSection>
<Attr Name="Transitivity" Arg='[tbl, ]chi' Label="for a character"/>

<Description>
For a permutation character <A>chi</A> of the group <M>G</M>
that corresponds to an action on the <M>G</M>-set <M>\Omega</M>
(see&nbsp;<Ref Func="PermutationCharacter"
Label="for a group, an action domain, and a function"/>),
<Ref Attr="Transitivity" Label="for a character"/> returns the maximal
nonnegative integer <M>k</M> such that the action of <M>G</M> on
<M>\Omega</M> is <M>k</M>-transitive.
<P/>
<Example><![CDATA[
gap> IsTransitive( nat );  Transitivity( nat );
true
4
gap> Transitivity( 2 * TrivialCharacter( S4 ) );
0
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CentralCharacter" Arg='[tbl, ]chi'/>

<Description>
<Index>central character</Index>
For a character <A>chi</A> of the group <M>G</M>, say,
<Ref Func="CentralCharacter"/> returns
the <E>central character</E> of <A>chi</A>.
<P/>
The central character of <M>\chi</M> is the class function
<M>\omega_{\chi}</M> defined by
<M>\omega_{\chi}(g) = |g^G| \cdot \chi(g)/\chi(1)</M> for each
<M>g \in G</M>.
</Description>
</ManSection>

<ManSection>
<Attr Name="DeterminantOfCharacter" Arg='[tbl, ]chi'/>

<Description>
<Index>determinant character</Index>
<Ref Func="DeterminantOfCharacter"/> returns the
<E>determinant character</E> of the character <A>chi</A>.
This is defined to be the character obtained by taking the determinant of
representing matrices of any representation affording <A>chi</A>;
the determinant can be computed using <Ref Func="EigenvaluesChar"/>.
<P/>
It is also possible to call <Ref Func="Determinant"/> instead of
<Ref Func="DeterminantOfCharacter"/>.
<P/>
Note that the determinant character is well-defined for virtual
characters.
<P/>
<Example><![CDATA[
gap> CentralCharacter( TrivialCharacter( S4 ) );
ClassFunction( CharacterTable( S4 ), [ 1, 6, 3, 8, 6 ] )
gap> DeterminantOfCharacter( Irr( S4 )[3] );
Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EigenvaluesChar" Arg='[tbl, ]chi, class'/>

<Description>
Let <A>chi</A> be a character of the group <M>G</M>, say.
For an element <M>g \in G</M> in the <A>class</A>-th conjugacy class,
of order <M>n</M>, let <M>M</M> be a matrix of a representation affording
<A>chi</A>.
<P/>
<Ref Func="EigenvaluesChar"/> returns the list of length <M>n</M>
where at position <M>k</M> the multiplicity
of <C>E</C><M>(n)^k = \exp(2 \pi i k / n)</M>
as an eigenvalue of <M>M</M> is stored.
<P/>
We have
<C><A>chi</A>[ <A>class</A> ] = List( [ 1 .. n ], k -> E(n)^k )
         * EigenvaluesChar( <A>tbl</A>, <A>chi</A>, <A>class</A> )</C>.
<P/>
It is also possible to call <Ref Func="Eigenvalues"/> instead of
<Ref Func="EigenvaluesChar"/>.
<P/>
<Example><![CDATA[
gap> chi:= Irr( CharacterTable( "A5" ) )[2];
Character( CharacterTable( "A5" ), 
[ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] )
gap> List( [ 1 .. 5 ], i -> Eigenvalues( chi, i ) );
[ [ 3 ], [ 2, 1 ], [ 1, 1, 1 ], [ 0, 1, 1, 0, 1 ], [ 1, 0, 0, 1, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Tensored" Arg='chars1, chars2'/>

<Description>
Let <A>chars1</A> and <A>chars2</A> be lists of (values lists of) class
functions of the same character table.
<Ref Func="Tensored"/> returns the list of tensor products of all entries
in <A>chars1</A> with all entries in <A>chars2</A>.
<P/>
<Example><![CDATA[
gap> irra5:= Irr( CharacterTable( "A5" ) );;
gap> chars1:= irra5{ [ 1 .. 3 ] };;  chars2:= irra5{ [ 2, 3 ] };;
gap> Tensored( chars1, chars2 );
[ Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 9, 1, 0, -2*E(5)-E(5)^2-E(5)^3-2*E(5)^4, 
      -E(5)-2*E(5)^2-2*E(5)^3-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 9, 1, 0, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 9, 1, 0, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 9, 1, 0, -E(5)-2*E(5)^2-2*E(5)^3-E(5)^4, 
      -2*E(5)-E(5)^2-E(5)^3-2*E(5)^4 ] ) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Restricted and Induced Class Functions">
<Heading>Restricted and Induced Class Functions</Heading>

For restricting a class function of a group <M>G</M> to a subgroup
<M>H</M> and for inducing a class function of <M>H</M> to <M>G</M>,
the <E>class fusion</E> from <M>H</M> to <M>G</M> must be known
(see&nbsp;<Ref Sect="Class Fusions between Character Tables"/>).
<P/>
<Index>inflated class functions</Index>
If <M>F</M> is the factor group of <M>G</M> by the normal subgroup
<M>N</M> then each class function of <M>F</M> can be naturally regarded
as a class function of <M>G</M>, with <M>N</M> in its kernel.
For a class function of <M>F</M>, the corresponding class function of
<M>G</M> is called the <E>inflated</E> class function.
Restriction and inflation are in principle the same,
namely indirection of a class function by the appropriate fusion map,
and thus no extra operation is needed for this process.
But note that contrary to the case of a subgroup fusion, the factor
fusion can in general not be computed from the groups <M>G</M> and
<M>F</M>;
either one needs the natural homomorphism, or the factor fusion to the
character table of <M>F</M> must be stored on the table of <M>G</M>.
This explains the different syntax for computing restricted and inflated
class functions.
<P/>
In the following,
the meaning of the optional first argument <A>tbl</A> is the same as in
Section&nbsp;<Ref Sect="Operations for Class Functions"/>.

<ManSection>
<Oper Name="RestrictedClassFunction" Arg='[tbl, ]chi, target'/>

<Description>
Let <A>chi</A> be a class function of the group <M>G</M>, say,
and let <A>target</A> be either a subgroup <M>H</M> of <M>G</M>
or an injective homomorphism from <M>H</M> to <M>G</M>
or the character table of <A>H</A>.
Then <Ref Oper="RestrictedClassFunction"/> returns the class function of
<M>H</M> obtained by restricting <A>chi</A> to <M>H</M>.
<P/>
If <A>chi</A> is a class function of a <E>factor group</E> <M>G</M>of
<M>H</M>, where <A>target</A> is either the group <M>H</M>
or a homomorphism from <M>H</M> to <M>G</M>
or the character table of <M>H</M>
then the restriction can be computed in the case of the homomorphism;
in the other cases, this is possible only if the factor fusion from
<M>H</M> to <M>G</M> is stored on the character table of <M>H</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="RestrictedClassFunctions" Arg='[tbl, ]chars, target'/>

<Description>
<Ref Oper="RestrictedClassFunctions"/> is similar to
<Ref Oper="RestrictedClassFunction"/>,
the only difference is that it takes a list <A>chars</A> of class
functions instead of one class function,
and returns the list of restricted class functions.
<P/>
<Example><![CDATA[
gap> a5:= CharacterTable( "A5" );;  s5:= CharacterTable( "S5" );;
gap> RestrictedClassFunction( Irr( s5 )[2], a5 );
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
gap> RestrictedClassFunctions( Irr( s5 ), a5 );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 6, -2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
gap> hom:= NaturalHomomorphismByNormalSubgroup( S4, der );;
gap> RestrictedClassFunctions( Irr( Image( hom ) ), hom );
[ Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>InducedClassFunction</Heading>
<Oper Name="InducedClassFunction" Arg='[tbl, ]chi, H'
 Label="for a supergroup"/>
<Oper Name="InducedClassFunction" Arg='[tbl, ]chi, hom'
 Label="for a given monomorphism"/>
<Oper Name="InducedClassFunction" Arg='[tbl, ]chi, suptbl'
 Label="for the character table of a supergroup"/>

<Description>
Let <A>chi</A> be a class function of the group <M>G</M>, say,
and let <A>target</A> be either a supergroup <M>H</M> of <M>G</M>
or an injective homomorphism from <M>H</M> to <M>G</M>
or the character table of <A>H</A>.
Then <Ref Oper="InducedClassFunction" Label="for a supergroup"/>
returns the class function of <M>H</M> obtained by inducing <A>chi</A>
to <M>H</M>.
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedClassFunctions" Arg='[tbl, ]chars, target'/>

<Description>
<Ref Oper="InducedClassFunctions"/> is similar to
<Ref Oper="InducedClassFunction" Label="for a supergroup"/>,
the only difference is that it takes a list <A>chars</A> of class
functions instead of one class function,
and returns the list of induced class functions.
<P/>
<Example><![CDATA[
gap> InducedClassFunctions( Irr( a5 ), s5 );
[ Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 8, 0, 2, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 10, 2, -2, 0, 0, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="InducedClassFunctionsByFusionMap"
 Arg='subtbl, tbl, chars, fusionmap'/>

<Description>
Let <A>subtbl</A> and <A>tbl</A> be two character tables of groups
<M>H</M> and <M>G</M>, such that <M>H</M> is a subgroup of <M>G</M>,
let <A>chars</A> be a list of class functions of <A>subtbl</A>, and
let <A>fusionmap</A> be a fusion map from <A>subtbl</A> to <A>tbl</A>.
The function returns the list of induced class functions of <A>tbl</A>
that correspond to <A>chars</A>, w.r.t. the given fusion map.
<P/>
<Ref Func="InducedClassFunctionsByFusionMap"/> is the function that does
the work for <Ref Oper="InducedClassFunction"
Label="for the character table of a supergroup"/> and
<Ref Oper="InducedClassFunctions"/>.
<P/>
<Example><![CDATA[
gap> fus:= PossibleClassFusions( a5, s5 );
[ [ 1, 2, 3, 4, 4 ] ]
gap> InducedClassFunctionsByFusionMap( a5, s5, Irr( a5 ), fus[1] );
[ Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 8, 0, 2, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 10, 2, -2, 0, 0, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="InducedCyclic" Arg='tbl[, classes][, "all"]'/>

<Description>
<Ref Oper="InducedCyclic"/> calculates characters induced up from
cyclic subgroups of the ordinary character table <A>tbl</A>
to <A>tbl</A>, and returns the strictly sorted list of the induced
characters.
<P/>
If the string <C>"all"</C> is specified then all irreducible characters
of these subgroups are induced,
otherwise only the permutation characters are calculated.
<P/>
If a list <A>classes</A> is specified then only those cyclic subgroups
generated by these classes are considered,
otherwise all classes of <A>tbl</A> are considered.
<P/>
<Example><![CDATA[
gap> InducedCyclic( a5, "all" );
[ Character( CharacterTable( "A5" ), [ 12, 0, 0, 2, 2 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 12, 0, 0, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 12, 0, 0, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, -1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 60, 0, 0, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Reducing Virtual Characters">
<Heading>Reducing Virtual Characters</Heading>

The following operations are intended for the situation that one is
given a list of virtual characters of a character table and is interested
in the irreducible characters of this table.
The idea is to compute virtual characters of small norm from the given
ones, hoping to get eventually virtual characters of norm <M>1</M>.

<ManSection>
<Oper Name="ReducedClassFunctions"
 Arg='[tbl, ][constituents, ]reducibles'/>

<Description>
Let <A>reducibles</A> be a list of ordinary virtual characters
of the group <M>G</M>, say.
If <A>constituents</A> is given then it must also be a list of ordinary
virtual characters of <M>G</M>,
otherwise we have <A>constituents</A> equal to <A>reducibles</A>
in the following.
<P/>
<Ref Oper="ReducedClassFunctions"/> returns a record with the components
<C>remainders</C> and <C>irreducibles</C>,
both lists of virtual characters of <M>G</M>.
These virtual characters are computed as follows.
<P/>
Let <C>rems</C> be the set of nonzero class functions obtained by
subtraction of
<Display Mode="M">
\sum_{\chi} ( [<A>reducibles</A>[i], \chi] / [\chi, \chi] ) \cdot \chi
</Display>
from <M><A>reducibles</A>[i]</M>,
where the summation runs over <A>constituents</A>
and <M>[\chi, \psi]</M> denotes the scalar product of <M>G</M>-class
functions.
Let <C>irrs</C> be the list of irreducible characters in <C>rems</C>.
<P/>
We project <C>rems</C> into the orthogonal space of <C>irrs</C> and
all those irreducibles found this way until no new irreducibles arise.
Then the <C>irreducibles</C> list is the set of all found irreducible
characters, and the <C>remainders</C> list is the set of all nonzero
remainders.
</Description>
</ManSection>

<ManSection>
<Oper Name="ReducedCharacters" Arg='[tbl, ]constituents, reducibles'/>

<Description>
<Ref Oper="ReducedCharacters"/> is similar to
<Ref Oper="ReducedClassFunctions"/>,
the only difference is that <A>constituents</A> and <A>reducibles</A>
are assumed to be lists of characters.
This means that only those scalar products must be formed where the
degree of the character in <A>constituents</A> does not exceed the degree
of the character in <A>reducibles</A>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> chars:= Irr( tbl ){ [ 2 .. 4 ] };;
gap> chars:= Set( Tensored( chars, chars ) );;
gap> red:= ReducedClassFunctions( chars );
rec( 
  irreducibles := 
    [ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "A5" ), 
        [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
      Character( CharacterTable( "A5" ), 
        [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
      Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
      Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ], 
  remainders := [  ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IrreducibleDifferences"
 Arg='tbl, reducibles, reducibles2[, scprmat]'/>

<Description>
<Ref Func="IrreducibleDifferences"/> returns the list of irreducible
characters which occur as difference of an element of <A>reducibles</A>
and an element of <A>reducibles2</A>,
where these two arguments are lists of class functions of the character
table <A>tbl</A>.
<P/>
If <A>reducibles2</A> is the string <C>"triangle"</C> then the
differences of elements in <A>reducibles</A> are considered.
<P/>
If <A>scprmat</A> is not specified then it will be calculated,
otherwise we must have
<C><A>scprmat</A> =
MatScalarProducts( <A>tbl</A>, <A>reducibles</A>, <A>reducibles2</A> )</C>
or <C><A>scprmat</A> =
MatScalarProducts( <A>tbl</A>, <A>reducibles</A> )</C>,
respectively.
<P/>
<Example><![CDATA[
gap> IrreducibleDifferences( a5, chars, "triangle" );
[ Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="LLL" Arg='tbl, characters[, y][, "sort"][, "linearcomb"]'/>

<Description>
<Index Subkey="for virtual characters">LLL algorithm</Index>
<Index>short vectors spanning a lattice</Index>
<Index Subkey="for virtual characters">lattice basis reduction</Index>
<Ref Func="LLL"/> calls the LLL algorithm
(see&nbsp;<Ref Func="LLLReducedBasis"/>) in the case of
lattices spanned by the virtual characters <A>characters</A>
of the ordinary character table <A>tbl</A>
(see&nbsp;<Ref Func="ScalarProduct" Label="for characters"/>).
By finding shorter vectors in the lattice spanned by <A>characters</A>,
i.e., virtual characters of smaller norm,
in some cases <Ref Func="LLL"/> is able to find irreducible characters.
<P/>
<Ref Func="LLL"/> returns a record with at least components
<C>irreducibles</C> (the list of found irreducible characters),
<C>remainders</C> (a list of reducible virtual characters),
and <C>norms</C> (the list of norms of the vectors in <C>remainders</C>).
<C>irreducibles</C> together with <C>remainders</C> form a basis of the
<M>&ZZ;</M>-lattice spanned by <A>characters</A>.
<P/>
Note that the vectors in the <C>remainders</C> list are in general
<E>not</E> orthogonal (see&nbsp;<Ref Func="ReducedClassFunctions"/>)
to the irreducible characters in <C>irreducibles</C>.
<P/>
Optional arguments of <Ref Func="LLL"/> are
<P/>
<List>
<Mark><A>y</A></Mark>
<Item>
    controls the sensitivity of the algorithm,
    see&nbsp;<Ref Func="LLLReducedBasis"/>,
</Item>
<Mark><A>"sort"</A></Mark>
<Item>
    <Ref Func="LLL"/> sorts <A>characters</A> and the <C>remainders</C>
    component of the result according to the degrees,
</Item>
<Mark><A>"linearcomb"</A></Mark>
<Item>
    the returned record contains components <C>irreddecomp</C>
    and <C>reddecomp</C>, which are decomposition matrices of
    <C>irreducibles</C> and <C>remainders</C>,
    with respect to <A>characters</A>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> chars:= [ [ 8, 0, 0, -1, 0 ], [ 6, 0, 2, 0, 2 ],
>     [ 12, 0, -4, 0, 0 ], [ 6, 0, -2, 0, 0 ], [ 24, 0, 0, 0, 0 ],
>     [ 12, 0, 4, 0, 0 ], [ 6, 0, 2, 0, -2 ], [ 12, -2, 0, 0, 0 ],
>     [ 8, 0, 0, 2, 0 ], [ 12, 2, 0, 0, 0 ], [ 1, 1, 1, 1, 1 ] ];;
gap> LLL( s4, chars );
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ) ], 
  norms := [  ], remainders := [  ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Extract" Arg='tbl, reducibles, grammat[, missing ]'/>

<Description>
Let <A>tbl</A> be an ordinary character table,
<A>reducibles</A> a list of characters of <A>tbl</A>,
and <A>grammat</A> the matrix of scalar products of <A>reducibles</A>
(see&nbsp;<Ref Func="MatScalarProducts"/>).
<Ref Func="Extract"/> tries to find irreducible characters by drawing
conclusions out of the scalar products,
using combinatorial and backtrack means.
<P/>
The optional argument <A>missing</A> is the maximal number of irreducible
characters that occur as constituents of <A>reducibles</A>.
Specification of <A>missing</A> may accelerate <Ref Func="Extract"/>.
<P/>
<Ref Func="Extract"/> returns a record <A>ext</A> with the components
<C>solution</C> and <C>choice</C>,
where the value of <C>solution</C> is a list <M>[ M_1, \ldots, M_n ]</M>
of decomposition matrices <M>M_i</M> (up to permutations of rows)
with the property that <M>M_i^{tr} \cdot X</M> is equal to
the sublist at the positions <A>ext</A><C>.choice[i]</C> of
<A>reducibles</A>,
for a matrix <M>X</M> of irreducible characters;
the value of <C>choice</C> is a list of length <M>n</M> whose entries are
lists of indices.
<P/>
So the <M>j</M>-th column in each matrix <M>M_i</M> corresponds to
<M><A>reducibles</A>[j]</M>, and each row in <M>M_i</M> corresponds to an
irreducible character.
<Ref Func="Decreased"/> can be used to examine the solution for
computable irreducibles.
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> red:= [ [ 5, 1, 5, 2, 1 ], [ 2, 0, 2, 2, 0 ], [ 3, -1, 3, 0, -1 ],
>            [ 6, 0, -2, 0, 0 ], [ 4, 0, 0, 1, 2 ] ];;
gap> gram:= MatScalarProducts( s4, red, red );
[ [ 6, 3, 2, 0, 2 ], [ 3, 2, 1, 0, 1 ], [ 2, 1, 2, 0, 0 ], 
  [ 0, 0, 0, 2, 1 ], [ 2, 1, 0, 1, 2 ] ]
gap> ext:= Extract( s4, red, gram, 5 );
rec( choice := [ [ 2, 5, 3, 4, 1 ] ], 
  solution := 
    [ 
      [ [ 1, 1, 0, 0, 2 ], [ 1, 0, 1, 0, 1 ], [ 0, 1, 0, 1, 0 ], 
          [ 0, 0, 1, 0, 1 ], [ 0, 0, 0, 1, 0 ] ] ] )
gap> dec:= Decreased( s4, red, ext.solution[1], ext.choice[1] );
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ) ], 
  matrix := [  ], remainders := [  ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="OrthogonalEmbeddingsSpecialDimension"
Arg='tbl, reducibles, grammat[, "positive"], dim'/>

<Description>
<Ref Func="OrthogonalEmbeddingsSpecialDimension"/> is a variant of
<Ref Func="OrthogonalEmbeddings"/> for the situation
that <A>tbl</A> is an ordinary character table,
<A>reducibles</A> is a list of virtual characters of <A>tbl</A>,
<A>grammat</A> is the matrix of scalar products
(see&nbsp;<Ref Func="MatScalarProducts"/>),
and <A>dim</A> is an upper bound for the number of irreducible characters
of <A>tbl</A> that occur as constituents of <A>reducibles</A>;
if the vectors in <A>reducibles</A> are known to be proper characters then
the string <C>"positive"</C> may be entered as fourth argument.
(See&nbsp;<Ref Func="OrthogonalEmbeddings"/> for information why this may
help.)
<P/>
<Ref Func="OrthogonalEmbeddingsSpecialDimension"/> first uses
<Ref Func="OrthogonalEmbeddings"/> to compute all orthogonal embeddings
of <A>grammat</A> into a standard lattice of dimension up to <A>dim</A>,
and then calls <Ref Func="Decreased"/> in order to find irreducible
characters of <A>tbl</A>.
<P/>
<Ref Func="OrthogonalEmbeddingsSpecialDimension"/> returns a record with
the following components.
<P/>
<List>
<Mark><C>irreducibles</C></Mark>
<Item>
  a list of found irreducibles, the intersection of all lists of
  irreducibles found by <Ref Func="Decreased"/>,
  for all possible embeddings, and
</Item>
<Mark><C>remainders</C></Mark>
<Item>
  a list of remaining reducible virtual characters.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> s6:= CharacterTable( "S6" );;
gap> red:= InducedCyclic( s6, "all" );;
gap> Add( red, TrivialCharacter( s6 ) );
gap> lll:= LLL( s6, red );;
gap> irred:= lll.irreducibles;
[ Character( CharacterTable( "A6.2_1" ), 
    [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A6.2_1" ), 
    [ 9, 1, 0, 0, 1, -1, -3, -3, 1, 0, 0 ] ), 
  Character( CharacterTable( "A6.2_1" ), 
    [ 16, 0, -2, -2, 0, 1, 0, 0, 0, 0, 0 ] ) ]
gap> Set( Flat( MatScalarProducts( s6, irred, lll.remainders ) ) );
[ 0 ]
gap> dim:= NrConjugacyClasses( s6 ) - Length( lll.irreducibles );
8
gap> rem:= lll.remainders;;  Length( rem );
8
gap> gram:= MatScalarProducts( s6, rem, rem );;  RankMat( gram );
8
gap> emb1:= OrthogonalEmbeddings( gram, 8 );
rec( norms := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  solutions := [ [ 1, 2, 3, 7, 11, 12, 13, 15 ], 
      [ 1, 2, 4, 8, 10, 12, 13, 14 ], [ 1, 2, 5, 6, 9, 12, 13, 16 ] ],
  vectors := 
    [ [ -1, 0, 1, 0, 1, 0, 1, 0 ], [ 1, 0, 0, 1, 0, 1, 0, 0 ], 
      [ 0, 1, 1, 0, 0, 0, 1, 1 ], [ 0, 1, 1, 0, 0, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 1, 0 ], 
      [ 0, -1, 0, 0, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 1, 1 ], [ 0, 0, 1, 0, 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, -1, 1, 0, 0, 0 ], 
      [ 0, 0, 0, 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 1, 1 ], 
      [ 0, 0, 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 1 ] ] )
]]></Example>
<P/>
In the following example we temporarily decrease the line length limit
from its default value <M>80</M> to <M>62</M>
in order to get a nicer output format.
<P/>
<Example><![CDATA[
gap> emb2:= OrthogonalEmbeddingsSpecialDimension( s6, rem, gram, 8 );
rec( 
  irreducibles := 
    [ Character( CharacterTable( "A6.2_1" ), 
        [ 5, 1, -1, 2, -1, 0, 1, -3, -1, 1, 0 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 5, 1, 2, -1, -1, 0, -3, 1, -1, 0, 1 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 10, -2, 1, 1, 0, 0, -2, 2, 0, 1, -1 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 10, -2, 1, 1, 0, 0, 2, -2, 0, -1, 1 ] ) ], 
  remainders := 
    [ VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 0, 0, 3, -3, 0, 0, 4, -4, 0, 1, -1 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 6, 2, 3, 0, 0, 1, 2, -2, 0, -1, -2 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 10, 2, 1, 1, 2, 0, 2, 2, -2, -1, -1 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 14, 2, 2, -1, 0, -1, 6, 2, 0, 0, -1 ] ) ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Decreased" Arg='tbl, chars, decompmat[, choice]'/>

<Description>
Let <A>tbl</A> be an ordinary character table,
<A>chars</A> a list of virtual characters of <A>tbl</A>,
and <A>decompmat</A> a decomposition matrix, that is,
a matrix <M>M</M> with the property that
<M>M^{tr} \cdot X = <A>chars</A></M> holds,
where <M>X</M> is a list of irreducible characters of <A>tbl</A>.
<Ref Func="Decreased"/> tries to compute the irreducibles in <M>X</M> or
at least some of them.
<P/>
Usually <Ref Func="Decreased"/> is applied to the output of
<Ref Func="Extract"/> or <Ref Func="OrthogonalEmbeddings"/> or
<Ref Func="OrthogonalEmbeddingsSpecialDimension"/>.
In the case of <Ref Func="Extract"/>,
the choice component corresponding to the decomposition matrix must be
entered as argument <A>choice</A> of <Ref Func="Decreased"/>.
<P/>
<Ref Func="Decreased"/> returns <K>fail</K> if it can prove that no list
<M>X</M> of irreducible characters corresponding to the arguments exists;
otherwise <Ref Func="Decreased"/> returns a record with the following
components.
<P/>
<List>
<Mark><C>irreducibles</C></Mark>
<Item>
    the list of found irreducible characters,
</Item>
<Mark><C>remainders</C></Mark>
<Item>
    the remaining reducible characters, and
</Item>
<Mark><C>matrix</C></Mark>
<Item>
    the decomposition matrix of the characters in the <C>remainders</C>
    component.
</Item>
</List>
<P/>
In the following example we temporarily decrease the line length limit
from its default value <M>80</M> to <M>62</M>
in order to get a nicer output format.
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> x:= Irr( s4 );;
gap> red:= [ x[1]+x[2], -x[1]-x[3], -x[1]+x[3], -x[2]-x[4] ];;
gap> mat:= MatScalarProducts( s4, red, red );
[ [ 2, -1, -1, -1 ], [ -1, 2, 0, 0 ], [ -1, 0, 2, 0 ], 
  [ -1, 0, 0, 2 ] ]
gap> emb:= OrthogonalEmbeddings( mat );
rec( norms := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  solutions := [ [ 1, 6, 7, 12 ], [ 2, 5, 8, 11 ], [ 3, 4, 9, 10 ] ], 
  vectors := [ [ -1, 1, 1, 0 ], [ -1, 1, 0, 1 ], [ 1, -1, 0, 0 ], 
      [ -1, 0, 1, 1 ], [ -1, 0, 1, 0 ], [ -1, 0, 0, 1 ], 
      [ 0, -1, 1, 0 ], [ 0, -1, 0, 1 ], [ 0, 1, 0, 0 ], 
      [ 0, 0, -1, 1 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] )
gap> dec:= Decreased( s4, red, emb.vectors{ emb.solutions[1] } );
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ) ], 
  matrix := [  ], remainders := [  ] )
gap> Decreased( s4, red, emb.vectors{ emb.solutions[2] } );
fail
gap> Decreased( s4, red, emb.vectors{ emb.solutions[3] } );
fail
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DnLattice" Arg='tbl, grammat, reducibles'/>

<Description>
Let <A>tbl</A> be an ordinary character table,
and <A>reducibles</A> a list of virtual characters of <A>tbl</A>.
<P/>
<Ref Func="DnLattice"/> searches for sublattices isomorphic to root
lattices of type <M>D_n</M>, for <M>n \geq 4</M>,
in the lattice that is generated by <A>reducibles</A>;
each vector in <A>reducibles</A> must have norm <M>2</M>, and the matrix
of scalar products (see&nbsp;<Ref Func="MatScalarProducts"/>) of
<A>reducibles</A> must be entered as argument <A>grammat</A>.
<P/>
<Ref Func="DnLattice"/> is able to find irreducible characters if there
is a lattice of type <M>D_n</M> with <M>n > 4</M>.
In the case <M>n = 4</M>, <Ref Func="DnLattice"/> may fail to determine
irreducibles.
<P/>
<Ref Func="DnLattice"/> returns a record with components
<List>
<Mark><C>irreducibles</C></Mark>
<Item>
    the list of found irreducible characters,
</Item>
<Mark><C>remainders</C></Mark>
<Item>
    the list of remaining reducible virtual characters, and
</Item>
<Mark><C>gram</C></Mark>
<Item>
    the Gram matrix of the vectors in <C>remainders</C>.
</Item>
</List>
<P/>
The <C>remainders</C> list is transformed in such a way that the
<C>gram</C> matrix is a block diagonal matrix that exhibits the structure
of the lattice generated by the vectors in <C>remainders</C>.
So <Ref Func="DnLattice"/> might be useful even if it fails to find
irreducible characters.
<P/>
In the following example we temporarily decrease the line length limit
from its default value <M>80</M> to <M>62</M>
in order to get a nicer output format.
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> red:= [ [ 2, 0, 2, 2, 0 ], [ 4, 0, 0, 1, 2 ],
>            [ 5, -1, 1, -1, 1 ], [ -1, 1, 3, -1, -1 ] ];;
gap> gram:= MatScalarProducts( s4, red, red );
[ [ 2, 1, 0, 0 ], [ 1, 2, 1, -1 ], [ 0, 1, 2, 0 ], [ 0, -1, 0, 2 ] ]
gap> dn:= DnLattice( s4, gram, red );
rec( gram := [  ], 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ) ], 
  remainders := [  ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DnLatticeIterative" Arg='tbl, reducibles'/>

<Description>
Let <A>tbl</A> be an ordinary character table,
and <A>reducibles</A> either a list of virtual characters of <A>tbl</A>
or a record with components <C>remainders</C> and <C>norms</C>,
for example a record returned by <Ref Func="LLL"/>.
<P/>
<Ref Func="DnLatticeIterative"/> was designed for iterative use of
<Ref Func="DnLattice"/>.
<Ref Func="DnLatticeIterative"/> selects the vectors of norm <M>2</M>
among the given virtual character, calls <Ref Func="DnLattice"/> for
them, reduces the virtual characters with found irreducibles,
calls <Ref Func="DnLattice"/> again for the remaining virtual characters,
and so on, until no new irreducibles are found.
<P/>
<Ref Func="DnLatticeIterative"/> returns a record with the same
components and meaning of components as <Ref Func="LLL"/>.
<P/>
In the following example we temporarily decrease the line length limit
from its default value <M>80</M> to <M>62</M>
in order to get a nicer output format.
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> red:= [ [ 2, 0, 2, 2, 0 ], [ 4, 0, 0, 1, 2 ],
>            [ 5, -1, 1, -1, 1 ], [ -1, 1, 3, -1, -1 ] ];;
gap> dn:= DnLatticeIterative( s4, red );
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ) ], 
  norms := [  ], remainders := [  ] )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Symmetrizations of Class Functions">
<Heading>Symmetrizations of Class Functions</Heading>

<ManSection>
<Oper Name="Symmetrizations" Arg='[tbl, ]characters, n'/>

<Description>
<Index Subkey="symmetrizations of">characters</Index>
<Ref Oper="Symmetrizations"/> returns the list of symmetrizations
of the characters <A>characters</A> of the ordinary character table
<A>tbl</A> with the ordinary irreducible characters of the symmetric
group of degree <A>n</A>;
instead of the integer <A>n</A>,
the character table of the symmetric group can be entered.
<P/>
The symmetrization <M>\chi^{[\lambda]}</M> of the character <M>\chi</M>
of <A>tbl</A> with the character <M>\lambda</M> of the symmetric group
<M>S_n</M> of degree <M>n</M> is defined by
<Display Mode="M">
\chi^{[\lambda]}(g) = \left( \sum_{{\rho \in S_n}}
    \lambda(\rho) \prod_{{k=1}}^n \chi(g^k)^{{a_k(\rho)}} \right) / n! ,
</Display>
where <M>a_k(\rho)</M> is the number of cycles of length <M>k</M>
in <M>\rho</M>.
<P/>
For special kinds of symmetrizations,
see&nbsp;<Ref Func="SymmetricParts"/>, <Ref Func="AntiSymmetricParts"/>,
<Ref Func="MinusCharacter"/> and <Ref Func="OrthogonalComponents"/>,
<Ref Func="SymplecticComponents"/>.
<P/>
<E>Note</E> that the returned list may contain zero class functions,
and duplicates are not deleted.
<!-- describe the succession!!-->
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> Symmetrizations( Irr( tbl ){ [ 1 .. 3 ] }, 3 );
[ VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 8, 0, -1, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 8, 0, -1, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SymmetricParts" Arg='tbl, characters, n'/>

<Description>
<Index>symmetric power</Index>
is the list of symmetrizations of the characters <A>characters</A>
of the character table <A>tbl</A> with the trivial character of
the symmetric group of degree <A>n</A>
(see&nbsp;<Ref Oper="Symmetrizations"/>).
<P/>
<Example><![CDATA[
gap> SymmetricParts( tbl, Irr( tbl ), 3 );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 35, 3, 2, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AntiSymmetricParts" Arg='tbl, characters, n'/>

<Description>
<Index>exterior power</Index>
is the list of symmetrizations of the characters <A>characters</A>
of the character table <A>tbl</A> with the alternating character of
the symmetric group of degree <A>n</A>
(see&nbsp;<Ref Oper="Symmetrizations"/>).
<P/>
<Example><![CDATA[
gap> AntiSymmetricParts( tbl, Irr( tbl ), 3 );
[ VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="OrthogonalComponents" Arg='tbl, chars, m'/>

<Description>
<Index Subkey="orthogonal">symmetrizations</Index>
<Index>Frame</Index>
<Index>Murnaghan components</Index>
If <M>\chi</M> is a nonlinear character with indicator <M>+1</M>,
a splitting of the tensor power <M>\chi^m</M> is given by the so-called
Murnaghan functions (see&nbsp;<Cite Key="Mur58"/>).
These components in general have fewer irreducible constituents
than the symmetrizations with the symmetric group of degree <A>m</A>
(see&nbsp;<Ref Oper="Symmetrizations"/>).
<P/>
<Ref Func="OrthogonalComponents"/> returns the Murnaghan components
of the nonlinear characters of the character table <A>tbl</A>
in the list <A>chars</A> up to the power <A>m</A>,
where <A>m</A> is an integer between 2 and 6.
<P/>
The Murnaghan functions are implemented as in&nbsp;<Cite Key="Fra82"/>.
<P/>
<E>Note</E>:
If <A>chars</A> is a list of character objects
(see&nbsp;<Ref Func="IsCharacter"/>) then also
the result consists of class function objects.
It is not checked whether all characters in <A>chars</A> do really have
indicator <M>+1</M>;
if there are characters with indicator <M>0</M> or <M>-1</M>,
the result might contain virtual characters
(see also&nbsp;<Ref Func="SymplecticComponents"/>),
therefore the entries of the result do in general not know that they are
characters.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "A8" );;  chi:= Irr( tbl )[2];
Character( CharacterTable( "A8" ), [ 7, -1, 3, 4, 1, -1, 1, 2, 0, -1, 
  0, 0, -1, -1 ] )
gap> OrthogonalComponents( tbl, [ chi ], 3 );
[ ClassFunction( CharacterTable( "A8" ), 
    [ 21, -3, 1, 6, 0, 1, -1, 1, -2, 0, 0, 0, 1, 1 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 27, 3, 7, 9, 0, -1, 1, 2, 1, 0, -1, -1, -1, -1 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 105, 1, 5, 15, -3, 1, -1, 0, -1, 1, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 35, 3, -5, 5, 2, -1, -1, 0, 1, 0, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 77, -3, 13, 17, 2, 1, 1, 2, 1, 0, 0, 0, 2, 2 ] ) ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SymplecticComponents" Arg='tbl, chars, m'/>

<Description>
<Index Subkey="symplectic">symmetrizations</Index>
<Index>Murnaghan components</Index>
If <M>\chi</M> is a (nonlinear) character with indicator <M>-1</M>,
a splitting of the tensor power <M>\chi^m</M> is given in terms of the
so-called Murnaghan functions (see&nbsp;<Cite Key="Mur58"/>).
These components in general have fewer irreducible constituents
than the symmetrizations with the symmetric group of degree <A>m</A>
(see&nbsp;<Ref Oper="Symmetrizations"/>).
<P/>
<Ref Func="SymplecticComponents"/> returns the symplectic symmetrizations
of the nonlinear characters of the character table <A>tbl</A>
in the list <A>chars</A> up to the power <A>m</A>,
where <A>m</A> is an integer between <M>2</M> and <M>5</M>.
<P/>
<E>Note</E>:
If <A>chars</A> is a list of character objects
(see&nbsp;<Ref Func="IsCharacter"/>) then also
the result consists of class function objects.
It is not checked whether all characters in <A>chars</A> do really have
indicator <M>-1</M>;
if there are characters with indicator <M>0</M> or <M>+1</M>,
the result might contain virtual characters
(see also&nbsp;<Ref Func="OrthogonalComponents"/>),
therefore the entries of the result do in general not know that they are
characters.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "U3(3)" );;  chi:= Irr( tbl )[2];
Character( CharacterTable( "U3(3)" ), 
[ 6, -2, -3, 0, -2, -2, 2, 1, -1, -1, 0, 0, 1, 1 ] )
gap> SymplecticComponents( tbl, [ chi ], 3 );
[ ClassFunction( CharacterTable( "U3(3)" ), 
    [ 14, -2, 5, -1, 2, 2, 2, 1, 0, 0, 0, 0, -1, -1 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 21, 5, 3, 0, 1, 1, 1, -1, 0, 0, -1, -1, 1, 1 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 64, 0, -8, -2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 14, 6, -4, 2, -2, -2, 2, 0, 0, 0, 0, 0, -2, -2 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 56, -8, 2, 2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Molien Series">
<Heading>Molien Series</Heading>

<ManSection>
<Func Name="MolienSeries" Arg='[tbl, ]psi[, chi]'/>

<Description>
The <E>Molien series</E> of the character <M>\psi</M>,
relative to the character <M>\chi</M>, is the rational function given by
the series
<M>M_{{\psi,\chi}}(z) = \sum_{{d = 0}}^{\infty} [\chi,\psi^{[d]}] z^d</M>,
where <M>\psi^{[d]}</M> denotes the symmetrization of <M>\psi</M>
with the trivial character of the symmetric group <M>S_d</M>
(see&nbsp;<Ref Func="SymmetricParts"/>).
<P/>
<Ref Func="MolienSeries"/> returns the Molien series of <A>psi</A>,
relative to <A>chi</A>, where <A>psi</A> and <A>chi</A> must be
characters of the same character table;
this table must be entered as <A>tbl</A> if <A>chi</A> and <A>psi</A>
are only lists of character values.
The default for <A>chi</A> is the trivial character of <A>tbl</A>.
<P/>
The return value of <Ref Func="MolienSeries"/> stores a value for the
attribute <Ref Func="MolienSeriesInfo"/>.
This admits the computation of coefficients of the series with
<Ref Func="ValueMolienSeries"/>.
Furthermore, this attribute gives access to numerator and denominator
of the Molien series viewed as rational function,
where the denominator is a product of polynomials of the form
<M>(1-z^r)^k</M>; the Molien series is also displayed in this form.
Note that such a representation is not unique, one can use
<Ref Func="MolienSeriesWithGivenDenominator"/>
to obtain the series with a prescribed denominator.
<P/>
For more information about Molien series, see&nbsp;<Cite Key="NPP84"/>.
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( AlternatingGroup( 5 ) );;
gap> psi:= First( Irr( t ), x -> Degree( x ) = 3 );;
gap> mol:= MolienSeries( psi );
( 1-z^2-z^3+z^6+z^7-z^9 ) / ( (1-z^5)*(1-z^3)*(1-z^2)^2 )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="MolienSeriesInfo" Arg='ratfun'/>

<Description>
If the rational function <A>ratfun</A> was constructed by
<Ref Func="MolienSeries"/>,
a representation as quotient of polynomials is known such that the
denominator is a product of terms of the form <M>(1-z^r)^k</M>.
This information is encoded as value of <Ref Func="MolienSeriesInfo"/>.
Additionally, there is a special <Ref Func="PrintObj"/> method
for Molien series based on this.
<P/>
<Ref Func="MolienSeriesInfo"/> returns a record that describes the
rational function <A>ratfun</A> as a Molien series.
The components of this record are

<List>
<Mark><C>numer</C></Mark>
<Item>
     numerator of <A>ratfun</A> (in general a multiple of the numerator
     one gets by <Ref Func="NumeratorOfRationalFunction"/>),
</Item>
<Mark><C>denom</C></Mark>
<Item>
     denominator of <A>ratfun</A> (in general a multiple of the
     denominator one gets by <Ref Func="NumeratorOfRationalFunction"/>),
</Item>
<Mark><C>ratfun</C></Mark>
<Item>
     the rational function <A>ratfun</A> itself,
</Item>
<Mark><C>numerstring</C></Mark>
<Item>
     string corresponding to the polynomial <C>numer</C>,
     expressed in terms of <C>z</C>,
</Item>
<Mark><C>denomstring</C></Mark>
<Item>
     string corresponding to the polynomial <C>denom</C>,
     expressed in terms of <C>z</C>,
</Item>
<Mark><C>denominfo</C></Mark>
<Item>
     a list of the form <M>[ [ r_1, k_1 ], \ldots, [ r_n, k_n ] ]</M>
     such that <C>denom</C> is
     <M>\prod_{{i = 1}}^n (1-z^{{r_i}})^{{k_i}}</M>.
</Item>
<Mark><C>summands</C></Mark>
<Item>
     a list of records, each with the components <C>numer</C>, <C>r</C>,
     and <C>k</C>,
     describing the summand <C>numer</C><M> / (1-z^r)^k</M>,
</Item>
<Mark><C>size</C></Mark>
<Item>
     the order of the underlying matrix group,
</Item>
<Mark><C>degree</C></Mark>
<Item>
     the degree of the underlying matrix representation.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> HasMolienSeriesInfo( mol );
true
gap> MolienSeriesInfo( mol );
rec( degree := 3, 
  denom := x_1^12-2*x_1^10-x_1^9+x_1^8+x_1^7+x_1^5+x_1^4-x_1^3-2*x_1^2\
+1, denominfo := [ 5, 1, 3, 1, 2, 2 ], 
  denomstring := "(1-z^5)*(1-z^3)*(1-z^2)^2", 
  numer := -x_1^9+x_1^7+x_1^6-x_1^3-x_1^2+1, 
  numerstring := "1-z^2-z^3+z^6+z^7-z^9", 
  ratfun := ( 1-z^2-z^3+z^6+z^7-z^9 ) / ( (1-z^5)*(1-z^3)*(1-z^2)^2 ),
  size := 60, 
  summands := [ rec( k := 1, numer := [ -24, -12, -24 ], r := 5 ), 
      rec( k := 1, numer := [ -20 ], r := 3 ), 
      rec( k := 2, numer := [ -45/4, 75/4, -15/4, -15/4 ], r := 2 ), 
      rec( k := 3, numer := [ -1 ], r := 1 ), 
      rec( k := 1, numer := [ -15/4 ], r := 1 ) ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ValueMolienSeries" Arg='molser, i'/>

<Description>
is the <A>i</A>-th coefficient of the Molien series <A>series</A>
computed by <Ref Func="MolienSeries"/>.
<P/>
<Example><![CDATA[
gap> List( [ 0 .. 20 ], i -> ValueMolienSeries( mol, i ) );
[ 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 3, 0, 4, 0, 4, 1, 5, 1, 6, 1, 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MolienSeriesWithGivenDenominator" Arg='molser, list'/>

<Description>
is a Molien series equal to <A>molser</A> as rational function,
but viewed as quotient with denominator
<M>\prod_{{i = 1}}^n (1-z^{{r_i}})</M>,
where <M><A>list</A> = [ r_1, r_2, \ldots, r_n ]</M>.
If <A>molser</A> cannot be represented this way,
<K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> MolienSeriesWithGivenDenominator( mol, [ 2, 6, 10 ] );
( 1+z^15 ) / ( (1-z^10)*(1-z^6)*(1-z^2) )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Possible Permutation Characters">
<Heading>Possible Permutation Characters</Heading>

<Index Subkey="permutation">characters</Index>
<Index Subkey="for permutation characters">candidates</Index>
<Index>possible permutation characters</Index>
<Index Subkey="possible">permutation characters</Index>
For groups <M>H</M> and <M>G</M> with <M>H \leq G</M>,
the induced character <M>(1_G)^H</M> is called the
<E>permutation character</E> of the operation of <M>G</M>
on the right cosets of <M>H</M>.
If only the character table of <M>G</M> is available and not the group
<M>G</M> itself,
one can try to get information about possible subgroups of <M>G</M>
by inspection of those <M>G</M>-class functions that might be
permutation characters,
using that such a class function <M>\pi</M> must have at least the
following properties.
(For details, see&nbsp;<Cite Key="Isa76" Where="Theorem 5.18."/>), 

<List>
<Mark>(a)</Mark>
<Item>
    <M>\pi</M> is a character of <M>G</M>,
</Item>
<Mark>(b)</Mark>
<Item>
    <M>\pi(g)</M> is a nonnegative integer for all <M>g \in G</M>,
</Item>
<Mark>(c)</Mark>
<Item>
    <M>\pi(1)</M> divides <M>|G|</M>,
</Item>
<Mark>(d)</Mark>
<Item>
    <M>\pi(g^n) \geq \pi(g)</M> for <M>g \in G</M> and integers <M>n</M>,
</Item>
<Mark>(e)</Mark>
<Item>
    <M>[\pi, 1_G] = 1</M>,
</Item>
<Mark>(f)</Mark>
<Item>
    the multiplicity of any rational irreducible <M>G</M>-character
    <M>\psi</M> as a constituent of <M>\pi</M> is at most
    <M>\psi(1)/[\psi, \psi]</M>,
</Item>
<Mark>(g)</Mark>
<Item>
    <M>\pi(g) = 0</M> if the order of <M>g</M> does not divide
    <M>|G|/\pi(1)</M>,
</Item>
<Mark>(h)</Mark>
<Item>
    <M>\pi(1) |N_G(g)|</M> divides <M>\pi(g) |G|</M>
    for all <M>g \in G</M>,
</Item>
<Mark>(i)</Mark>
<Item>
    <M>\pi(g) \leq (|G| - \pi(1)) / (|g^G| |Gal_G(g)|)</M>
    for all nonidentity <M>g \in G</M>,
    where <M>|Gal_G(g)|</M> denotes the number of conjugacy classes
    of <M>G</M> that contain generators of the group
    <M>\langle g \rangle</M>,
</Item>
<Mark>(j)</Mark>
<Item>
    if <M>p</M> is a prime that divides <M>|G|/\pi(1)</M> only once then
    <M>s/(p-1)</M> divides <M>|G|/\pi(1)</M> and is congruent to <M>1</M>
    modulo <M>p</M>,
    where <M>s</M> is the number of elements of order <M>p</M> in the
    (hypothetical) subgroup <M>H</M> for which <M>\pi = (1_H)^G</M>
    holds.
    (Note that <M>s/(p-1)</M> equals the number of Sylow <M>p</M>
    subgroups in <M>H</M>.)
</Item>
</List>

Any <M>G</M>-class function with these properties is called a
<E>possible permutation character</E> in &GAP;.
<P/>
(Condition (d) is checked only for those power maps that are stored in
the character table of <M>G</M>;
clearly (d) holds for all integers if it holds for all prime divisors of
the group order <M>|G|</M>.)
<P/>
&GAP; provides some algorithms to compute
possible permutation characters (see&nbsp;<Ref Func="PermChars"/>),
and also provides functions to check a few more criteria whether a
given character can be a transitive permutation character
(see&nbsp;<Ref Func="TestPerm1"/>).
<P/>
Some information about the subgroup <M>U</M> can be computed from the
permutation character <M>(1_U)^G</M> using <Ref Func="PermCharInfo"/>.

<Index Subkey="for permutation characters">LaTeX</Index>
<ManSection>
<Func Name="PermCharInfo" Arg='tbl, permchars[, format ]'/>

<Description>
Let <A>tbl</A> be the ordinary character table of the group <M>G</M>,
and <A>permchars</A> either the permutation character <M>(1_U)^G</M>,
for a subgroup <M>U</M> of <M>G</M>, or a list of such permutation
characters.
<Ref Func="PermCharInfo"/> returns a record with the following components.
<List>
<Mark><C>contained</C>:</Mark>
<Item>
  a list containing, for each character <M>\psi = (1_U)^G</M> in
  <A>permchars</A>, a list containing at position <M>i</M> the number
  <M>\psi[i] |U| /</M> <C>SizesCentralizers( </C><A>tbl</A><C> )</C><M>[i]</M>,
  which equals the number of those elements of <M>U</M>
  that are contained in class <M>i</M> of <A>tbl</A>,
</Item>
<Mark><C>bound</C>:</Mark>
<Item>
  a list containing,
  for each character <M>\psi = (1_U)^G</M> in <A>permchars</A>,
  a list containing at position <M>i</M> the number
  <M>|U| / \gcd( |U|,</M> <C>SizesCentralizers( <A>tbl</A> )</C><M>[i] )</M>,
  which divides the class length in <M>U</M> of an element in class <M>i</M>
  of <A>tbl</A>,
</Item>
<Mark><C>display</C>:</Mark>
<Item>
  a record that can be used as second argument of <Ref Oper="Display"/>
  to display each permutation character in <A>permchars</A> and the
  corresponding components <C>contained</C> and <C>bound</C>,
  for those classes where at least one character of <A>permchars</A> is
  nonzero,
</Item>
<Mark><C>ATLAS</C>:</Mark>
<Item>
  a list of strings describing the decomposition of the permutation
  characters in <A>permchars</A> into the irreducible characters of
  <A>tbl</A>, given in an &ATLAS;-like notation.
  This means that the irreducible constituents are indicated by their
  degrees followed by lower case letters <C>a</C>, <C>b</C>, <C>c</C>,
  <M>\ldots</M>,
  which indicate the successive irreducible characters of <A>tbl</A>
  of that degree,
  in the order in which they appear in <C>Irr( </C><A>tbl</A><C> )</C>.
  A sequence of small letters (not necessarily distinct) after a single
  number indicates a sum of irreducible constituents all of the same
  degree, an exponent <A>n</A> for the letter <A>lett</A> means that
  <A>lett</A> is repeated <A>n</A> times.
  The default notation for exponentiation is
  <C><A>lett</A>^{<A>n</A>}</C>,
  this is also chosen if the optional third argument <A>format</A> is
  the string <C>"LaTeX"</C>;
  if the third argument is the string <C>"HTML"</C> then exponentiation
  is denoted by <C><A>lett</A>&lt;sup><A>n</A>&lt;/sup></C>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( "A6" );;
gap> psi:= Sum( Irr( t ){ [ 1, 3, 6 ] } );
Character( CharacterTable( "A6" ), [ 15, 3, 0, 3, 1, 0, 0 ] )
gap> info:= PermCharInfo( t, psi );
rec( ATLAS := [ "1a+5b+9a" ], bound := [ [ 1, 3, 8, 8, 6, 24, 24 ] ], 
  contained := [ [ 1, 9, 0, 8, 6, 0, 0 ] ], 
  display := 
    rec( 
      chars := [ [ 15, 3, 0, 3, 1, 0, 0 ], [ 1, 9, 0, 8, 6, 0, 0 ], 
          [ 1, 3, 8, 8, 6, 24, 24 ] ], classes := [ 1, 2, 4, 5 ], 
      letter := "I" ) )
gap> Display( t, info.display );
A6

     2  3  3  .  2
     3  2  .  2  .
     5  1  .  .  .

       1a 2a 3b 4a
    2P 1a 1a 3b 2a
    3P 1a 2a 1a 4a
    5P 1a 2a 3b 4a

I.1    15  3  3  1
I.2     1  9  8  6
I.3     1  3  8  6
gap> j1:= CharacterTable( "J1" );;
gap> psi:= TrivialCharacter( CharacterTable( "7:6" ) )^j1;
Character( CharacterTable( "J1" ), [ 4180, 20, 10, 0, 0, 2, 1, 0, 0, 
  0, 0, 0, 0, 0, 0 ] )
gap> PermCharInfo( j1, psi ).ATLAS;
[ "1a+56aabb+76aaab+77aabbcc+120aaabbbccc+133a^{4}bbcc+209a^{5}" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PermCharInfoRelative" Arg='tbl, tbl2, permchars'/>

<Description>
Let <A>tbl</A> and <A>tbl2</A> be the ordinary character tables of two
groups <M>H</M> and <M>G</M>, respectively,
where <M>H</M> is of index two in <M>G</M>,
and <A>permchars</A> either the permutation character <M>(1_U)^G</M>,
for a subgroup <M>U</M> of <M>G</M>,
or a list of such permutation characters.
<Ref Func="PermCharInfoRelative"/> returns a record with the same
components as <Ref Func="PermCharInfo"/>, the only exception is that the
entries of the <C>ATLAS</C> component are names relative to <A>tbl</A>.
<P/>
More precisely, the <M>i</M>-th entry of the <C>ATLAS</C> component is a
string describing the decomposition of the <M>i</M>-th entry in
<A>permchars</A>.
The degrees and distinguishing letters of the constituents refer to
the irreducibles of <A>tbl</A>, as follows.
The two irreducible characters of <A>tbl2</A> of degree <M>N</M>, say,
that extend the irreducible character <M>N</M> <C>a</C> of <A>tbl</A>
are denoted by <M>N</M> <C>a</C><M>^+</M> and <M>N </M><C>a</C><M>^-</M>.
The irreducible character of <A>tbl2</A> of degree <M>2N</M>, say, whose
restriction to <A>tbl</A> is the sum of the irreducible characters
<M>N</M> <C>a</C> and <M>N</M> <C>b</C> is denoted as <M>N</M> <C>ab</C>.
Multiplicities larger than <M>1</M> of constituents are denoted by
exponents.
<P/>
(This format is useful mainly for multiplicity free permutation
characters.)
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( "A5" );;
gap> t2:= CharacterTable( "A5.2" );;
gap> List( Irr( t2 ), x -> x[1] );
[ 1, 1, 6, 4, 4, 5, 5 ]
gap> List( Irr( t ), x -> x[1] );
[ 1, 3, 3, 4, 5 ]
gap> permchars:= List( [ [1], [1,2], [1,7], [1,3,4,4,6,6,7] ],
>                      l -> Sum( Irr( t2 ){ l } ) );
[ Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, 2, 0, 1, 0, 2, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 30, 2, 0, 0, 6, 0, 0 ] ) ]
gap> info:= PermCharInfoRelative( t, t2, permchars );;
gap> info.ATLAS;
[ "1a^+", "1a^{\\pm}", "1a^++5a^-", 
  "1a^++3ab+4(a^+)^{2}+5a^+a^{\\pm}" ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Computing Possible Permutation Characters">
<Heading>Computing Possible Permutation Characters</Heading>

<ManSection>
<Func Name="PermChars" Arg='tbl[, cond]'/>

<Description>
&GAP; provides several algorithms to determine
possible permutation characters from a given character table.
They are described in detail in&nbsp;<Cite Key="BP98"/>.
The algorithm is selected from the choice of the optional argument
<A>cond</A>.
The user is encouraged to try different approaches,
especially if one choice fails to come to an end.
<P/>
Regardless of the algorithm used in a specific case,
<Ref Func="PermChars"/> returns a list of <E>all</E>
possible permutation characters with the properties described by
<A>cond</A>.
There is no guarantee that a character of this list is in fact
a permutation character.
But an empty list always means there is no permutation character
with these properties (e.g., of a certain degree).
<P/>
Called with only one argument, a character table <A>tbl</A>,
<Ref Func="PermChars"/> returns the list of all possible permutation
characters of the group with this character table.
This list might be rather long for big groups,
and its computation might take much time.
The algorithm is described in <Cite Key="BP98" Where="Section 3.2"/>;
it depends on a preprocessing step, where the inequalities
arising from the condition <M>\pi(g) \geq 0</M> are transformed into
a system of inequalities that guides the search
(see&nbsp;<Ref Func="Inequalities"/>).
So the following commands compute the list of 39 possible permutation
characters of the Mathieu group <M>M_{11}</M>.
<P/>
<Example><![CDATA[
gap> m11:= CharacterTable( "M11" );;
gap> SetName( m11, "m11" );
gap> perms:= PermChars( m11 );;
gap> Length( perms );
39
]]></Example>
<P/>
There are two different search strategies for this algorithm.
The default strategy simply constructs all characters with nonnegative
values and then tests for each such character whether its degree
is a divisor of the order of the group.
The other strategy uses the inequalities to predict
whether a character of a certain degree can lie
in the currently searched part of the search tree.
To choose this strategy, enter a record as the second argument of
<Ref Func="PermChars"/>,
and set its component <C>degree</C> to the range of degrees
(which might also be a range containing all divisors of the group order)
you want to look for;
additionally, the record component <C>ineq</C> can take the inequalities
computed by <Ref Func="Inequalities"/> if they are needed more than once.
<P/>
If a positive integer is given as the second argument <A>cond</A>,
<Ref Func="PermChars"/> returns the list of all
possible permutation characters of <A>tbl</A> that have degree
<A>cond</A>.
For that purpose, a preprocessing step is performed where
essentially the rational character table is inverted
in order to determine boundary points for the simplex
in which the possible permutation characters of the given degree
must lie (see&nbsp;<Ref Func="PermBounds"/>).
The algorithm is described at the end of
<Cite Key="BP98" Where="Section 3.2"/>.
Note that inverting big integer matrices needs a lot of time and space.
So this preprocessing is restricted to groups with less than 100 classes,
say.
<P/>
<Example><![CDATA[
gap> deg220:= PermChars( m11, 220 );
[ Character( m11, [ 220, 4, 4, 0, 0, 4, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 12, 4, 4, 0, 0, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 20, 4, 0, 0, 2, 0, 0, 0, 0 ] ) ]
]]></Example>
<P/>
If a record is given as the second argument <A>cond</A>,
<Ref Func="PermChars"/> returns the list of all
possible permutation characters that have the properties described by
the components of this record.
One such situation has been mentioned above.
If <A>cond</A> contains a degree as value of the record component
<C>degree</C>
then <Ref Func="PermChars"/> will behave exactly as if this degree was
entered as <A>cond</A>.
<P/>
<Example><![CDATA[
gap> deg220 = PermChars( m11, rec( degree:= 220 ) );
true
]]></Example>
<P/>
For the meaning of additional components of <A>cond</A> besides
<C>degree</C>, see&nbsp;<Ref Func="PermComb"/>.
<P/>
Instead of <C>degree</C>, <A>cond</A> may have the component <C>torso</C>
bound to a list that contains some known values of the required
characters at the right positions;
at least the degree <A>cond</A><C>.torso[1]</C> must be an integer.
In this case, the algorithm described in
<Cite Key="BP98" Where="Section 3.3"/> is chosen.
The component <C>chars</C>, if present, holds a list of all those
<E>rational</E> irreducible characters of <A>tbl</A> that might be
constituents of the required characters.
<P/>
(<E>Note</E>: If <A>cond</A><C>.chars</C> is bound and does not contain
<E>all</E> rational irreducible characters of <A>tbl</A>,
&GAP; checks whether the scalar products of all class functions in the
result list with the omitted rational irreducible characters of
<A>tbl</A> are nonnegative;
so there should be nontrivial reasons for excluding a character
that is known to be not a constituent of the desired possible permutation
characters.)
<P/>
<Example><![CDATA[
gap> PermChars( m11, rec( torso:= [ 220 ] ) );
[ Character( m11, [ 220, 4, 4, 0, 0, 4, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 20, 4, 0, 0, 2, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 12, 4, 4, 0, 0, 0, 0, 0, 0 ] ) ]
gap> PermChars( m11, rec( torso:= [ 220,,,,, 2 ] ) );
[ Character( m11, [ 220, 20, 4, 0, 0, 2, 0, 0, 0, 0 ] ) ]
]]></Example>
<P/>
An additional restriction on the possible permutation characters computed
can be forced if <A>con</A> contains, in addition to <C>torso</C>,
the components <C>normalsubgroup</C> and <C>nonfaithful</C>,
with values a list of class positions of a normal subgroup <M>N</M> of
the group <M>G</M> of <A>tbl</A> and a possible permutation character
<M>\pi</M> of <M>G</M>, respectively, such that <M>N</M> is contained in
the kernel of <M>\pi</M>.
In this case, <Ref Func="PermChars"/> returns the list of those possible
permutation characters <M>\psi</M> of <A>tbl</A> coinciding with
<C>torso</C> wherever its values are bound
and having the property that no irreducible constituent of
<M>\psi - \pi</M> has <M>N</M> in its kernel.
If the component <C>chars</C> is bound in <A>cond</A> then the above
statements apply.
An interpretation of the computed characters is the following.
Suppose there exists a subgroup <M>V</M> of <M>G</M> such that
<M>\pi = (1_V)^G</M>;
Then <M>N \leq V</M>, and if a computed character is of the form
<M>(1_U)^G</M>, for a subgroup <M>U</M> of <M>G</M>, then <M>V = UN</M>.
<P/>
<Example><![CDATA[
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> nsg:= ClassPositionsOfDerivedSubgroup( s4 );;
gap> pi:= TrivialCharacter( s4 );;
gap> PermChars( s4, rec( torso:= [ 12 ], normalsubgroup:= nsg,
>                        nonfaithful:= pi ) );
[ Character( CharacterTable( "Sym(4)" ), [ 12, 2, 0, 0, 0 ] ) ]
gap> pi:= Sum( Filtered( Irr( s4 ),
>              chi -> IsSubset( ClassPositionsOfKernel( chi ), nsg ) ) );
Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, 2, 0 ] )
gap> PermChars( s4, rec( torso:= [ 12 ], normalsubgroup:= nsg,
>                        nonfaithful:= pi ) );
[ Character( CharacterTable( "Sym(4)" ), [ 12, 0, 4, 0, 0 ] ) ]
]]></Example>
<P/>
The class functions returned by <Ref Func="PermChars"/> have the
properties tested by <Ref Func="TestPerm1"/>, <Ref Func="TestPerm2"/>,
and <Ref Func="TestPerm3"/>.
So they are possible permutation characters.
See&nbsp;<Ref Func="TestPerm1"/> for criteria whether a
possible permutation character can in fact be a permutation character.
</Description>
</ManSection>

<ManSection>
<Heading>TestPerm1, ..., TestPerm5</Heading>
<Func Name="TestPerm1" Arg='tbl, char'/>
<Func Name="TestPerm2" Arg='tbl, char'/>
<Func Name="TestPerm3" Arg='tbl, chars'/>
<Func Name="TestPerm4" Arg='tbl, chars'/>
<Func Name="TestPerm5" Arg='tbl, chars, modtbl'/>

<Description>
The first three of these functions implement tests of the properties of
possible permutation characters listed in
Section&nbsp;<Ref Sect="Possible Permutation Characters"/>,
The other two implement test of additional properties.
Let <A>tbl</A> be the ordinary character table of a group <M>G</M>, say,
<A>char</A> a rational character of <A>tbl</A>,
and <A>chars</A> a list of rational characters of <A>tbl</A>.
For applying <Ref Func="TestPerm5"/>, the knowledge of a <M>p</M>-modular
Brauer table <A>modtbl</A> of <M>G</M> is required.
<Ref Func="TestPerm4"/> and <Ref Func="TestPerm5"/> expect the characters
in <A>chars</A> to satisfy the conditions checked by
<Ref Func="TestPerm1"/> and <Ref Func="TestPerm2"/> (see below).
<P/>
The return values of the functions were chosen parallel to the tests
listed in&nbsp;<Cite Key="NPP84"/>.
<P/>
<Ref Func="TestPerm1"/> return <C>1</C> or <C>2</C> if <A>char</A> fails
because of (T1) or (T2), respectively;
this corresponds to the criteria (b) and (d).
Note that only those power maps are considered that are stored on
<A>tbl</A>.
If <A>char</A> satisfies the conditions, <C>0</C> is returned.
<P/>
<Ref Func="TestPerm2"/> returns <C>1</C> if <A>char</A> fails because of
the criterion (c),
it returns <C>3</C>, <C>4</C>, or <C>5</C> if <A>char</A> fails because
of (T3), (T4), or (T5), respectively;
these tests correspond to (g), a weaker form of (h), and (j).
If <A>char</A> satisfies the conditions, <C>0</C> is returned.
<P/>
<Ref Func="TestPerm3"/> returns the list of all those class functions in
the list <A>chars</A> that satisfy criterion (h);
this is a stronger version of (T6).
<P/>
<Ref Func="TestPerm4"/> returns the list of all those class functions in
the list <A>chars</A> that satisfy (T8) and (T9) for each prime divisor
<M>p</M> of the order of <M>G</M>;
these tests use modular representation theory but do not require the
knowledge of decomposition matrices
(cf.&nbsp;<Ref Func="TestPerm5"/> below).
<P/>
(T8) implements the test of the fact that in the case that <M>p</M>
divides <M>|G|</M> and the degree of a transitive permutation character
<M>\pi</M> exactly once,
the projective cover of the trivial character is a summand of <M>\pi</M>.
(This test is omitted if the projective cover cannot be identified.)
<P/>
Given a permutation character <M>\pi</M> of a group <M>G</M> and a prime
integer <M>p</M>,
the restriction <M>\pi_B</M> to a <M>p</M>-block <M>B</M> of <M>G</M> has
the following property, which is checked by (T9).
For each <M>g \in G</M> such that <M>g^n</M> is a <M>p</M>-element of
<M>G</M>, <M>\pi_B(g^n)</M> is a nonnegative integer that satisfies
<M>|\pi_B(g)| \leq \pi_B(g^n) \leq \pi(g^n)</M>.
(This is <Cite Key="Sco73" Where="Corollary A on p. 113"/>.)
<P/>
<Ref Func="TestPerm5"/> requires the <M>p</M>-modular Brauer table
<A>modtbl</A> of <M>G</M>, for some prime <M>p</M> dividing the order of
<M>G</M>,
and checks whether those characters in the list <A>chars</A> whose degree
is divisible by the <M>p</M>-part of the order of <M>G</M> can be
decomposed into projective indecomposable characters;
<Ref Func="TestPerm5"/> returns the sublist of all those characters in
<A>chars</A> that either satisfy this condition or to which the test does
not apply.
<P/>
<!-- Say a word about (T7)?-->
<!-- This is the check whether the cycle structure of elements is well-defined;-->
<!-- the check is superfluous (at least) for elements of prime power order-->
<!-- or order equal to the product of two primes (see&nbsp;<Cite Key="NPP84"/>);-->
<!-- note that by construction, the numbers of <Q>cycles</Q> are always integral,-->
<!-- the only thing to test is whether they are nonnegative.-->
<Example><![CDATA[
gap> tbl:= CharacterTable( "A5" );;
gap> rat:= RationalizedMat( Irr( tbl ) );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 6, -2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
gap> tup:= Filtered( Tuples( [ 0, 1 ], 4 ), x -> not IsZero( x ) );
[ [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 0, 0 ], 
  [ 0, 1, 0, 1 ], [ 0, 1, 1, 0 ], [ 0, 1, 1, 1 ], [ 1, 0, 0, 0 ], 
  [ 1, 0, 0, 1 ], [ 1, 0, 1, 0 ], [ 1, 0, 1, 1 ], [ 1, 1, 0, 0 ], 
  [ 1, 1, 0, 1 ], [ 1, 1, 1, 0 ], [ 1, 1, 1, 1 ] ]
gap> lincomb:= List( tup, coeff -> coeff * rat );;
gap> List( lincomb, psi -> TestPerm1( tbl, psi ) );
[ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0 ]
gap> List( lincomb, psi -> TestPerm2( tbl, psi ) );
[ 0, 5, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1 ]
gap> Set( List( TestPerm3(tbl, lincomb), x -> Position(lincomb, x) ) );
[ 1, 4, 6, 7, 8, 9, 10, 11, 13 ]
gap> tbl:= CharacterTable( "A7" );
CharacterTable( "A7" )
gap> perms:= PermChars( tbl, rec( degree:= 315 ) );
[ Character( CharacterTable( "A7" ), [ 315, 3, 0, 0, 3, 0, 0, 0, 0 ] )
    , Character( CharacterTable( "A7" ), 
    [ 315, 15, 0, 0, 1, 0, 0, 0, 0 ] ) ]
gap> TestPerm4( tbl, perms );
[ Character( CharacterTable( "A7" ), [ 315, 15, 0, 0, 1, 0, 0, 0, 0 
     ] ) ]
gap> perms:= PermChars( tbl, rec( degree:= 15 ) );
[ Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ),
  Character( CharacterTable( "A7" ), [ 15, 3, 3, 0, 1, 0, 3, 1, 1 ] ) 
 ]
gap> TestPerm5( tbl, perms, tbl mod 5 );
[ Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ) 
 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PermBounds" Arg='tbl, d'/>

<Description>
Let <A>tbl</A> be the ordinary character table of the group <M>G</M>.
All <M>G</M>-characters <M>\pi</M> satisfying <M>\pi(g) > 0</M> and
<M>\pi(1) = <A>d</A></M>,
for a given degree <A>d</A>, lie in a simplex described by these
conditions.
<Ref Func="PermBounds"/> computes the boundary points of this simplex for
<M>d = 0</M>,
from which the boundary points for any other <A>d</A> are easily derived.
(Some conditions from the power maps of <A>tbl</A> are also involved.)
For this purpose, a matrix similar to the rational character table of
<M>G</M> has to be inverted.
These boundary points are used by <Ref Func="PermChars"/>
to construct all possible permutation characters
(see&nbsp;<Ref Sect="Possible Permutation Characters"/>) of a given
degree.
<Ref Func="PermChars"/> either calls <Ref Func="PermBounds"/> or takes
this information from the <C>bounds</C> component of its argument record.
</Description>
</ManSection>

<ManSection>
<Func Name="PermComb" Arg='tbl, arec'/>

<Description>
<Ref Func="PermComb"/> computes possible permutation characters of the
character table <A>tbl</A> by the improved combinatorial approach
described at the end of <Cite Key="BP98" Where="Section 3.2"/>.
<P/>
For computing the possible linear combinations <E>without</E> prescribing
better bounds (i.e., when the computation of bounds shall be suppressed),
enter
<P/>
<C><A>arec</A>:= rec( degree := <A>degree</A>, bounds := false )</C>,
<P/>
where <A>degree</A> is the character degree;
this is useful if the multiplicities are expected to be small,
and if this is forced by high irreducible degrees.
<P/>
A list of upper bounds on the multiplicities of the rational irreducibles
characters can be explicitly prescribed as a <C>maxmult</C> component in
<A>arec</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Inequalities" Arg='tbl, chars[, option]'/>

<Description>
Let <A>tbl</A> be the ordinary character table of a group <M>G</M>.
The condition <M>\pi(g) \geq 0</M> for every possible permutation
character <M>\pi</M> of <M>G</M> places restrictions on the
multiplicities <M>a_i</M> of the irreducible constituents <M>\chi_i</M>
of <M>\pi = \sum_{{i = 1}}^r a_i \chi_i</M>.
For every element <M>g \in G</M>,
we have <M>\sum_{{i = 1}}^r a_i \chi_i(g) \geq 0</M>.
The power maps provide even stronger conditions.
<P/>
This system of inequalities is kind of diagonalized,
resulting in a system of inequalities restricting <M>a_i</M>
in terms of <M>a_j</M>, <M>j &lt; i</M>.
These inequalities are used to construct characters with nonnegative
values (see&nbsp;<Ref Func="PermChars"/>).
<Ref Func="PermChars"/> either calls <Ref Oper="Inequalities"/> or takes
this information from the <C>ineq</C> component of its argument record.
<P/>
The number of inequalities arising in the process of diagonalization may
grow very strongly.
<P/>
There are two ways to organize the projection.
The first, which is chosen if no <A>option</A> argument is present,
is the straight approach which takes the rational irreducible
characters in their original order and by this guarantees the character
with the smallest degree to be considered first.
The other way, which is chosen if the string <C>"small"</C> is entered as
third argument <A>option</A>, tries to keep the number of intermediate
inequalities small by eventually changing the order of characters.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "M11" );;
gap> PermComb( tbl, rec( degree:= 110 ) );
[ Character( CharacterTable( "M11" ), 
    [ 110, 6, 2, 2, 0, 0, 2, 2, 0, 0 ] ), 
  Character( CharacterTable( "M11" ), 
    [ 110, 6, 2, 6, 0, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M11" ), [ 110, 14, 2, 2, 0, 2, 0, 0, 0, 
      0 ] ) ]
gap> # Now compute only multiplicity free permutation characters.
gap> bounds:= List( RationalizedMat( Irr( tbl ) ), x -> 1 );;
gap> PermComb( tbl, rec( degree:= 110, maxmult:= bounds ) );
[ Character( CharacterTable( "M11" ), 
    [ 110, 6, 2, 2, 0, 0, 2, 2, 0, 0 ] ) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Brauer Characters">
<Heading>Operations for Brauer Characters</Heading>

<ManSection>
<Func Name="FrobeniusCharacterValue" Arg='value, p'/>

<Description>
Let <A>value</A> be a cyclotomic whose coefficients over the rationals
are in the ring <M>&ZZ;_{<A>p</A>}</M> of <A>p</A>-local numbers,
where <A>p</A> is a prime integer.
Assume that <A>value</A> lies in <M>&ZZ;_{<A>p</A>}[\zeta]</M>
for <M>\zeta = \exp(<A>p</A>^n-1)</M>,
for some positive integer <M>n</M>.
<P/>
<Ref Func="FrobeniusCharacterValue"/> returns the image of <A>value</A>
under the ring homomorphism from <M>&ZZ;_{<A>p</A>}[\zeta]</M>
to the field with <M><A>p</A>^n</M> elements
that is defined with the help of Conway polynomials
(see&nbsp;<Ref Func="ConwayPolynomial"/>), more information can be found
in <Cite Key="JLPW95" Where="Sections 2-5"/>.
<P/>
If <A>value</A> is a Brauer character value in characteristic <A>p</A>
then the result can be described as the corresponding value of the
Frobenius character, that is, as the trace of a representing matrix
with the given Brauer character value.
<P/>
If the result of <Ref Func="FrobeniusCharacterValue"/> cannot be
expressed as an element of a finite field in &GAP;
(see Chapter&nbsp;<Ref Chap="Finite Fields"/>)
then <Ref Func="FrobeniusCharacterValue"/> returns <K>fail</K>.
<P/>
If the Conway polynomial of degree <M>n</M> is required for the
computation then it is computed only if
<Ref Func="IsCheapConwayPolynomial"/> returns <K>true</K> when it is
called with <A>p</A> and <M>n</M>,
otherwise <K>fail</K> is returned.
</Description>
</ManSection>

<ManSection>
<Attr Name="BrauerCharacterValue" Arg='mat'/>

<Description>
For an invertible matrix <A>mat</A> over a finite field <M>F</M>,
<Ref Attr="BrauerCharacterValue"/> returns the Brauer character value
of <A>mat</A> if the order of <A>mat</A> is coprime to the characteristic
of <M>F</M>, and <K>fail</K> otherwise.
<P/>
The <E>Brauer character value</E> of a matrix is the sum of complex lifts
of its eigenvalues.
<P/>
<Example><![CDATA[
gap> g:= SL(2,4);;           # 2-dim. irreducible representation of A5
gap> ccl:= ConjugacyClasses( g );;
gap> rep:= List( ccl, Representative );;
gap> List( rep, Order );
[ 1, 2, 5, 5, 3 ]
gap> phi:= List( rep, BrauerCharacterValue );
[ 2, fail, E(5)^2+E(5)^3, E(5)+E(5)^4, -1 ]
gap> List( phi{ [ 1, 3, 4, 5 ] }, x -> FrobeniusCharacterValue( x, 2 ) );
[ 0*Z(2), Z(2^2), Z(2^2)^2, Z(2)^0 ]
gap> List( rep{ [ 1, 3, 4, 5 ] }, TraceMat );
[ 0*Z(2), Z(2^2), Z(2^2)^2, Z(2)^0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SizeOfFieldOfDefinition" Arg='val, p'/>

<Description>
For a cyclotomic or a list of cyclotomics <A>val</A>,
and a prime integer <A>p</A>, <Ref Func="SizeOfFieldOfDefinition"/>
returns the size of the smallest finite field
in characteristic <A>p</A> that contains the <A>p</A>-modular reduction
of <A>val</A>.
<P/>
The reduction map is defined as in&nbsp;<Cite Key="JLPW95"/>,
that is, the complex <M>(<A>p</A>^d-1)</M>-th root of unity
<M>\exp(<A>p</A>^d-1)</M> is mapped to the residue class of the
indeterminate, modulo the ideal spanned by the Conway polynomial
(see&nbsp;<Ref Func="ConwayPolynomial"/>) of degree <M>d</M> over the
field with <M>p</M> elements.
<P/>
If <A>val</A> is a Brauer character then the value returned is the size
of the smallest finite field in characteristic <A>p</A> over which the
corresponding representation lives.
</Description>
</ManSection>

<ManSection>
<Func Name="RealizableBrauerCharacters" Arg='matrix, q'/>

<Description>
For a list <A>matrix</A> of absolutely irreducible Brauer characters
in characteristic <M>p</M>, and a power <A>q</A> of <M>p</M>,
<Ref Func="RealizableBrauerCharacters"/> returns a duplicate-free list of
sums of Frobenius conjugates of the rows of <A>matrix</A>,
each irreducible over the field with <A>q</A> elements.
<P/>
<Example><![CDATA[
gap> irr:= Irr( CharacterTable( "A5" ) mod 2 );
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
gap> List( irr, phi -> SizeOfFieldOfDefinition( phi, 2 ) );
[ 2, 4, 4, 2 ]
gap> RealizableBrauerCharacters( irr, 2 );
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  ClassFunction( BrauerTable( "A5", 2 ), [ 4, -2, -1, -1 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Domains Generated by Class Functions">
<Heading>Domains Generated by Class Functions</Heading>

&GAP; supports groups, vector spaces, and algebras generated by class
functions.
<!-- add examples:
gap> d8:= DihedralGroup( 8 );
<pc group of size 8 with 3 generators>
gap> lin:= LinearCharacters( d8 );;
gap> irr:= Irr( d8 );;
gap> g:= Group( lin, lin[1] );
<group with 4 generators>
gap> Size( g );
4
gap> IdGroup( g );
[ 4, 2 ]
gap> v:= VectorSpace( Rationals, lin );;
gap> w:= VectorSpace( Rationals, irr );;
gap> Dimension( v );
4
gap> Dimension( w );
5

Note that for generating a group of class functions,
one should use the two-argument version of
<Ref Func="Group" Label="for a list of generators (and an identity element)"/>,
because a call of the one-argument version will return the cyclic matrix
group generated by the matrix of the intended generating class functions
if this matrix is invertible.
% Otherwise it seems to work, but why?

gap> g:= CyclicGroup( 4 );;
gap> irr:= Irr( g );;
gap> Size( Group( irr ) );
infinity
gap> Size( Group( irr, TrivialCharacter( g ) ) );
4
-->


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  ctblmaps.msk                GAP documentation               Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: ctblmaps.msk,v 1.17 2004/01/19 09:52:53 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Maps Concerning Character Tables">
<Heading>Maps Concerning Character Tables</Heading>

<Index>maps</Index>
<Index>parametrized maps</Index>

Besides the characters, <E>power maps</E> are an important part of a
character table, see Section&nbsp;<Ref Sect="Power Maps"/>.
Often their computation is not easy, and if the table has no access to
the underlying group then in general they cannot be obtained from the
matrix of irreducible characters;
so it is useful to store them on the table.
<P/>
If not only a single table is considered but different tables of a group
and a subgroup or of a group and a factor group are used,
also <E>class fusion maps</E>
(see Section&nbsp;<Ref Sect="Class Fusions between Character Tables"/>)
must be known to get information about the embedding or simply to induce
or restrict characters,
see Section&nbsp;<Ref Sect="Restricted and Induced Class Functions"/>).
<P/>
These are examples of functions from conjugacy classes which will be
called <E>maps</E> in the following.
(This should not be confused with the term mapping,
cf. Chapter&nbsp;<Ref Chap="Mappings"/>.)
In &GAP;, maps are represented by lists.
Also each character, each list of element orders, of centralizer orders,
or of class lengths are maps,
and the list returned by <Ref Func="ListPerm"/>,
when this function is called with a permutation of classes, is a map.
<P/>
When maps are constructed without access to a group, often one only knows
that the image of a given class is contained in a set of possible images,
e. g., that the image of a class under a subgroup fusion is in the set of
all classes with the same element order.
Using further information, such as centralizer orders, power maps and the
restriction of characters, the sets of possible images can be restricted
further.
In many cases, at the end the images are uniquely determined.
<P/>
Because of this approach, many functions in this chapter work not only
with maps but with <E>parametrized maps</E>
(or <E>paramaps</E> for short).
More about parametrized maps can be found
in Section&nbsp;<Ref Sect="Parametrized Maps"/>.
<P/>
The implementation follows&nbsp;<Cite Key="Bre91"/>,
a description of the main ideas together with several examples
can be found in&nbsp;<Cite Key="Bre99"/>.

<P/>
Several examples in this chapter require the &GAP; Character Table Library
to be available.
If it is not yet loaded then we load it now.
<P/>
<Example><![CDATA[
gap> LoadPackage( "ctbllib" );
true
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Power Maps">
<Heading>Power Maps</Heading>

The <M>n</M>-th power map of a character table is represented by a list
that stores at position <M>i</M> the position of the class containing
the <M>n</M>-th powers of the elements in the <M>i</M>-th class.
The <M>n</M>-th power map can be composed from the power maps of the
prime divisors of <M>n</M>,
so usually only power maps for primes are actually stored in the
character table.
<P/>
For an ordinary character table <A>tbl</A> with access to its underlying
group <M>G</M>,
the <M>p</M>-th power map of <A>tbl</A> can be computed using the
identification of the conjugacy classes of <M>G</M> with the classes of
<A>tbl</A>.
For an ordinary character table without access to a group,
in general the <M>p</M>-th power maps (and hence also the element orders)
for prime divisors <M>p</M> of the group order are not uniquely
determined by the matrix of irreducible characters.
So only necessary conditions can be checked in this case,
which in general yields only a list of several possibilities for the
desired power map.
Character tables of the &GAP; character table library store all
<M>p</M>-th power maps for prime divisors <M>p</M> of the group order.
<P/>
Power maps of Brauer tables can be derived from the power maps of the
underlying ordinary tables.
<P/>
For (computing and) accessing the <M>n</M>-th power map of a character
table, <Ref Func="PowerMap"/> can be used;
if the <M>n</M>-th power map cannot be uniquely determined then
<Ref Func="PowerMap"/> returns <K>fail</K>.
<P/>
The list of all possible <M>p</M>-th power maps of a table in the sense
that certain necessary conditions are satisfied can be computed with
<Ref Func="PossiblePowerMaps"/>.
This provides a default strategy, the subroutines are listed in
Section&nbsp;<Ref Sect="Subroutines for the Construction of Power Maps"/>.

<ManSection>
<Oper Name="PowerMap" Arg='tbl, n[, class]'/>
<Oper Name="PowerMapOp" Arg='tbl, n[, class]'/>
<Attr Name="ComputedPowerMaps" Arg='tbl'/>

<Description>
Called with first argument a character table <A>tbl</A>
and second argument an integer <A>n</A>,
<Ref Oper="PowerMap"/> returns the <A>n</A>-th power map of <A>tbl</A>.
This is a list containing at position <M>i</M> the position of the class
of <A>n</A>-th powers of the elements in the <M>i</M>-th class of
<A>tbl</A>.
<P/>
If the additional third argument <A>class</A> is present then the
position of <A>n</A>-th powers of the <A>class</A>-th class is returned.
<P/>
If the <A>n</A>-th power map is not uniquely determined by <A>tbl</A>
then <K>fail</K> is returned.
This can happen only if <A>tbl</A> has no access to its underlying group.
<P/>
The power maps of <A>tbl</A> that were computed already by
<Ref Oper="PowerMap"/> are stored in <A>tbl</A> as value of the attribute
<Ref Attr="ComputedPowerMaps"/>,
the <M>n</M>-th power map at position <M>n</M>.
<Ref Oper="PowerMap"/> checks whether the desired power map is already
stored, computes it using the operation <Ref Oper="PowerMapOp"/> if it is
not yet known, and stores it.
So methods for the computation of power maps can be installed for
the operation <Ref Oper="PowerMapOp"/>.
<!-- % For power maps of groups, see&nbsp;<Ref Attr="PowerMapOfGroup"/>. -->
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "L3(2)" );;
gap> ComputedPowerMaps( tbl );
[ , [ 1, 1, 3, 2, 5, 6 ], [ 1, 2, 1, 4, 6, 5 ],,,, 
  [ 1, 2, 3, 4, 1, 1 ] ]
gap> PowerMap( tbl, 5 );
[ 1, 2, 3, 4, 6, 5 ]
gap> ComputedPowerMaps( tbl );
[ , [ 1, 1, 3, 2, 5, 6 ], [ 1, 2, 1, 4, 6, 5 ],, [ 1, 2, 3, 4, 6, 5 ],
  , [ 1, 2, 3, 4, 1, 1 ] ]
gap> PowerMap( tbl, 137, 2 );
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PossiblePowerMaps" Arg='tbl, p[, options]'/>

<Description>
For the ordinary character table <A>tbl</A> of the group <M>G</M>, say,
and a prime integer <A>p</A>,
<Ref Oper="PossiblePowerMaps"/> returns the list of all maps that have
the following properties of the <M>p</M>-th power map of <A>tbl</A>.
(Representative orders are used only if the
<Ref Func="OrdersClassRepresentatives"/> value of <A>tbl</A> is known.

<Enum>
<Item>
  For class <M>i</M>, the centralizer order of the image is a multiple of
  the <M>i</M>-th centralizer order;
  if the elements in the <M>i</M>-th class have order coprime to <M>p</M>
  then the centralizer orders of class <M>i</M> and its image are equal.
</Item>
<Item>
  Let <M>n</M> be the order of elements in class <M>i</M>.
  If <A>prime</A> divides <M>n</M> then the images have order <M>n/p</M>;
  otherwise the images have order <M>n</M>.
  These criteria are checked in <Ref Func="InitPowerMap"/>.
</Item>
<Item>
  For each character <M>\chi</M> of <M>G</M> and each element <M>g</M>
  in <M>G</M>, the values <M>\chi(g^p)</M> and
  <C>GaloisCyc</C><M>( \chi(g), p )</M> are
  algebraic integers that are congruent modulo <M>p</M>;
  if <M>p</M> does not divide the element order of <M>g</M>
  then the two values are equal.
  This congruence is checked for the characters specified below in
  the discussion of the <A>options</A> argument;
  For linear characters <M>\lambda</M> among these characters,
  the condition <M>\chi(g)^p = \chi(g^p)</M> is checked.
  The corresponding function is
  <Ref Func="Congruences" Label="for character tables"/>.
</Item>
<Item>
  For each character <M>\chi</M> of <M>G</M>, the kernel is a normal
  subgroup <M>N</M>, and <M>g^p \in N</M> for all <M>g \in N</M>;
  moreover, if <M>N</M> has index <M>p</M> in <M>G</M> then
  <M>g^p \in N</M> for all <M>g \in G</M>,
  and if the index of <M>N</M> in <M>G</M> is coprime to <M>p</M> then
  <M>g^p \not \in N</M> for each <M>g \not \in N</M>.
  These conditions are checked for the kernels of all characters
  <M>\chi</M> specified below,
  the corresponding function is <Ref Func="ConsiderKernels"/>.
</Item>
<Item>
  If <M>p</M> is larger than the order <M>m</M> of an element
  <M>g \in G</M> then the class of <M>g^p</M> is determined by the power
  maps for primes dividing the residue of <M>p</M> modulo <M>m</M>.
  If these power maps are stored in the <Ref Func="ComputedPowerMaps"/>
  value of <A>tbl</A> then this information is used.
  This criterion is checked in <Ref Func="ConsiderSmallerPowerMaps"/>.
</Item>
<Item>
  For each character <M>\chi</M> of <M>G</M>,
  the symmetrization <M>\psi</M> defined by
  <M>\psi(g) = (\chi(g)^p - \chi(g^p))/p</M> is a character.
  This condition is checked for the kernels of all characters
  <M>\chi</M> specified below,
  the corresponding function is
  <Ref Func="PowerMapsAllowedBySymmetrizations"/>.
</Item>
</Enum>
<P/>
If <A>tbl</A> is a Brauer table, the possibilities are computed
from those for the underlying ordinary table.
<P/>
The optional argument <A>options</A>, if given, must be a record that may
have the following components:
<List>
<Mark><C>chars</C>:</Mark>
<Item>
  a list of characters which are used for the check of the criteria
  3., 4., and 6.;
  the default is <C>Irr( <A>tbl</A> )</C>,
</Item>
<Mark><C>powermap</C>:</Mark>
<Item>
  a parametrized map which is an approximation of the desired map
</Item>
<Mark><C>decompose</C>:</Mark>
<Item>
  a Boolean;
  a <K>true</K> value indicates that all constituents of the
  symmetrizations of <C>chars</C> computed for criterion 6. lie in
  <C>chars</C>,
  so the symmetrizations can be decomposed into elements of <C>chars</C>;
  the default value of <C>decompose</C> is <K>true</K> if <C>chars</C>
  is not bound and <C>Irr( <A>tbl</A> )</C> is known,
  otherwise <K>false</K>,
</Item>
<Mark><C>quick</C>:</Mark>
<Item>
  a Boolean;
  if <K>true</K> then the subroutines are called with value <K>true</K>
  for the argument <A>quick</A>;
  especially, as soon as only one candidate remains
  this candidate is returned immediately;
  the default value is <K>false</K>,
</Item>
<Mark><C>parameters</C>:</Mark>
<Item>
  a record with components <C>maxamb</C>, <C>minamb</C> and <C>maxlen</C>
  which control the subroutine
  <Ref Func="PowerMapsAllowedBySymmetrizations"/>;
  it only uses characters with current indeterminateness up to
  <C>maxamb</C>,
  tests decomposability only for characters with current
  indeterminateness at least <C>minamb</C>,
  and admits a branch according to a character only if there is one
  with at most <C>maxlen</C> possible symmetrizations.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "U4(3).4" );;
gap> PossiblePowerMaps( tbl, 2 );
[ [ 1, 1, 3, 4, 5, 2, 2, 8, 3, 4, 11, 12, 6, 14, 9, 1, 1, 2, 2, 3, 4, 
      5, 6, 8, 9, 9, 10, 11, 12, 16, 16, 16, 16, 17, 17, 18, 18, 18, 
      18, 20, 20, 20, 20, 22, 22, 24, 24, 25, 26, 28, 28, 29, 29 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ElementOrdersPowerMap" Arg='powermap'/>

<Description>
Let <A>powermap</A> be a nonempty list containing at position <M>p</M>,
if bound, the <M>p</M>-th power map of a character table or group.
<Ref Func="ElementOrdersPowerMap"/> returns a list of the same length as
each entry in <A>powermap</A>, with entry at position <M>i</M> equal to
the order of elements in class <M>i</M> if this order is uniquely
determined by <A>powermap</A>,
and equal to an unknown (see Chapter&nbsp;<Ref Chap="Unknowns"/>)
otherwise.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "U4(3).4" );;
gap> known:= ComputedPowerMaps( tbl );;
gap> Length( known );
7
gap> sub:= ShallowCopy( known );;  Unbind( sub[7] );
gap> ElementOrdersPowerMap( sub );
[ 1, 2, 3, 3, 3, 4, 4, 5, 6, 6, Unknown(1), Unknown(2), 8, 9, 12, 2, 
  2, 4, 4, 6, 6, 6, 8, 10, 12, 12, 12, Unknown(3), Unknown(4), 4, 4, 
  4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 12, 12, 12, 12, 20, 20, 24, 24, 
  Unknown(5), Unknown(6), Unknown(7), Unknown(8) ]
gap> ord:= ElementOrdersPowerMap( known );
[ 1, 2, 3, 3, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 12, 2, 2, 4, 4, 6, 6, 6, 
  8, 10, 12, 12, 12, 14, 14, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 
  12, 12, 12, 12, 20, 20, 24, 24, 28, 28, 28, 28 ]
gap> ord = OrdersClassRepresentatives( tbl );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PowerMapByComposition" Arg='tbl, n'/>

<Description>
<A>tbl</A> must be a nearly character table,
and <A>n</A> a positive integer.
If the power maps for all prime divisors of <A>n</A> are stored in the
<Ref Attr="ComputedPowerMaps"/> list of <A>tbl</A> then
<Ref Func="PowerMapByComposition"/> returns
the <A>n</A>-th power map of <A>tbl</A>.
Otherwise <K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "U4(3).4" );;  exp:= Exponent( tbl );
2520
gap> PowerMapByComposition( tbl, exp );
[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1 ]
gap> Length( ComputedPowerMaps( tbl ) );
7
gap> PowerMapByComposition( tbl, 11 );
fail
gap> PowerMap( tbl, 11 );;
gap> PowerMapByComposition( tbl, 11 );
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
  20, 21, 22, 23, 24, 26, 25, 27, 28, 29, 31, 30, 33, 32, 35, 34, 37, 
  36, 39, 38, 41, 40, 43, 42, 45, 44, 47, 46, 49, 48, 51, 50, 53, 52 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Orbits on Sets of Possible Power Maps">
<Heading>Orbits on Sets of Possible Power Maps</Heading>

The permutation group of matrix automorphisms
(see&nbsp;<Ref Func="MatrixAutomorphisms"/>)
acts on the possible power maps returned by
<Ref Func="PossiblePowerMaps"/>
by permuting a list via <Ref Func="Permuted"/>
and then mapping the images via <Ref Func="OnPoints"/>.
Note that by definition, the group of <E>table</E> automorphisms
acts trivially.

<ManSection>
<Func Name="OrbitPowerMaps" Arg='map, permgrp'/>

<Description>
returns the orbit of the power map <A>map</A> under the action of the
permutation group <A>permgrp</A>
via a combination of <Ref Func="Permuted"/> and <Ref Func="OnPoints"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="RepresentativesPowerMaps" Arg='listofmaps, permgrp'/>

<Description>
<Index>matrix automorphisms</Index>
returns a list of orbit representatives of the power maps in the list
<A>listofmaps</A> under the action of the permutation group
<A>permgrp</A>
via a combination of <Ref Func="Permuted"/> and <Ref Func="OnPoints"/>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "3.McL" );;
gap> grp:= MatrixAutomorphisms( Irr( tbl ) );  Size( grp );
<permutation group with 5 generators>
32
gap> poss:= PossiblePowerMaps( CharacterTable( "3.McL" ), 3 );
[ [ 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 11, 11, 11, 14, 14, 14, 17, 17, 17, 
      4, 4, 4, 4, 4, 4, 29, 29, 29, 26, 26, 26, 32, 32, 32, 9, 8, 37, 
      37, 37, 40, 40, 40, 43, 43, 43, 11, 11, 11, 52, 52, 52, 49, 49, 
      49, 14, 14, 14, 14, 14, 14, 37, 37, 37, 37, 37, 37 ], 
  [ 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 11, 11, 11, 14, 14, 14, 17, 17, 17, 
      4, 4, 4, 4, 4, 4, 29, 29, 29, 26, 26, 26, 32, 32, 32, 8, 9, 37, 
      37, 37, 40, 40, 40, 43, 43, 43, 11, 11, 11, 52, 52, 52, 49, 49, 
      49, 14, 14, 14, 14, 14, 14, 37, 37, 37, 37, 37, 37 ] ]
gap> reps:= RepresentativesPowerMaps( poss, grp );
[ [ 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 11, 11, 11, 14, 14, 14, 17, 17, 17, 
      4, 4, 4, 4, 4, 4, 29, 29, 29, 26, 26, 26, 32, 32, 32, 8, 9, 37, 
      37, 37, 40, 40, 40, 43, 43, 43, 11, 11, 11, 52, 52, 52, 49, 49, 
      49, 14, 14, 14, 14, 14, 14, 37, 37, 37, 37, 37, 37 ] ]
gap> orb:= OrbitPowerMaps( reps[1], grp );
[ [ 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 11, 11, 11, 14, 14, 14, 17, 17, 17, 
      4, 4, 4, 4, 4, 4, 29, 29, 29, 26, 26, 26, 32, 32, 32, 8, 9, 37, 
      37, 37, 40, 40, 40, 43, 43, 43, 11, 11, 11, 52, 52, 52, 49, 49, 
      49, 14, 14, 14, 14, 14, 14, 37, 37, 37, 37, 37, 37 ], 
  [ 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 11, 11, 11, 14, 14, 14, 17, 17, 17, 
      4, 4, 4, 4, 4, 4, 29, 29, 29, 26, 26, 26, 32, 32, 32, 9, 8, 37, 
      37, 37, 40, 40, 40, 43, 43, 43, 11, 11, 11, 52, 52, 52, 49, 49, 
      49, 14, 14, 14, 14, 14, 14, 37, 37, 37, 37, 37, 37 ] ]
gap> Parametrized( orb );
[ 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 11, 11, 11, 14, 14, 14, 17, 17, 17, 
  4, 4, 4, 4, 4, 4, 29, 29, 29, 26, 26, 26, 32, 32, 32, [ 8, 9 ], 
  [ 8, 9 ], 37, 37, 37, 40, 40, 40, 43, 43, 43, 11, 11, 11, 52, 52, 
  52, 49, 49, 49, 14, 14, 14, 14, 14, 14, 37, 37, 37, 37, 37, 37 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Class Fusions between Character Tables">
<Heading>Class Fusions between Character Tables</Heading>

<Index>fusions</Index><Index>subgroup fusions</Index>
For a group <M>G</M> and a subgroup <M>H</M> of <M>G</M>,
the fusion map between the character table of <M>H</M> and the character
table of <M>G</M> is represented by a list that stores at position
<M>i</M> the position of the <M>i</M>-th class of the table of <M>H</M>
in the classes list of the table of <M>G</M>.
<P/>
For ordinary character tables <A>tbl1</A> and <A>tbl2</A> of <M>H</M> and
<M>G</M>, with access to the groups <M>H</M> and <M>G</M>,
the class fusion between <A>tbl1</A> and <A>tbl2</A> can be computed
using the identifications of the conjugacy classes of <M>H</M> with the
classes of <A>tbl1</A> and the conjugacy classes of <M>G</M> with the
classes of <A>tbl2</A>.
For two ordinary character tables without access to an underlying group,
or in the situation that the group stored in <A>tbl1</A> is not
physically a subgroup of the group stored in <A>tbl2</A> but an
isomorphic copy, in general the class fusion is not uniquely determined
by the information stored on the tables such as irreducible characters
and power maps.
So only necessary conditions can be checked in this case,
which in general yields only a list of several possibilities for the
desired class fusion.
Character tables of the &GAP; character table library store various
class fusions that are regarded as important,
for example fusions from maximal subgroups
(see&nbsp;<Ref Func="ComputedClassFusions"/>
and <Ref Attr="Maxes" BookName="ctbllib"/> in the manual for the &GAP;
Character Table Library).
<P/>
Class fusions between Brauer tables can be derived from the class fusions
between the underlying ordinary tables.
The class fusion from a Brauer table to the underlying ordinary table is
stored when the Brauer table is constructed from the ordinary table,
so no method is needed to compute such a fusion.
<P/>
For (computing and) accessing the class fusion between two character
tables,
<Ref Func="FusionConjugacyClasses" Label="for two character tables"/>
can be used;
if the class fusion cannot be uniquely determined then
<Ref Func="FusionConjugacyClasses" Label="for two character tables"/>
returns <K>fail</K>.
<P/>
The list of all possible class fusion between two tables in the sense
that certain necessary conditions are satisfied can be computed with
<Ref Func="PossibleClassFusions"/>.
This provides a default strategy, the subroutines are listed in
Section <Ref Sect="Subroutines for the Construction of Class Fusions"/>.
<P/>
It should be noted that all the following functions except
<Ref Func="FusionConjugacyClasses" Label="for two character tables"/>
deal only with the situation of class fusions from subgroups.
The computation of <E>factor fusions</E> from a character table to the
table of a factor group is not dealt with here.
Since the ordinary character table of a group <M>G</M> determines the
character tables of all factor groups of <M>G</M>, the factor fusion to a
given character table of a factor group of <M>G</M> is determined up to
table automorphisms (see&nbsp;<Ref Func="AutomorphismsOfTable"/>) once
the class positions of the kernel of the natural epimorphism have been
fixed.

<ManSection>
<Heading>FusionConjugacyClasses</Heading>
<Oper Name="FusionConjugacyClasses" Arg='tbl1, tbl2'
 Label="for two character tables"/>
<Oper Name="FusionConjugacyClasses" Arg='H, G'
 Label="for two groups"/>
<Oper Name="FusionConjugacyClasses" Arg='hom[, tbl1, tbl2]'
 Label="for a homomorphism"/>
<Oper Name="FusionConjugacyClassesOp" Arg='tbl1, tbl2'
 Label="for two character tables"/>
<Attr Name="FusionConjugacyClassesOp" Arg='hom'
 Label="for a homomorphism"/>

<Description>
Called with two character tables <A>tbl1</A> and <A>tbl2</A>,
<Ref Oper="FusionConjugacyClasses" Label="for two character tables"/>
returns the fusion of conjugacy classes between <A>tbl1</A> and
<A>tbl2</A>.
(If one of the tables is a Brauer table,
it will delegate this task to the underlying ordinary table.)
<P/>
Called with two groups <A>H</A> and <A>G</A> where <A>H</A> is a subgroup
of <A>G</A>,
<Ref Oper="FusionConjugacyClasses" Label="for two groups"/> returns
the fusion of conjugacy classes between <A>H</A> and <A>G</A>.
This is done by delegating to the ordinary character tables of <A>H</A>
and <A>G</A>,
since class fusions are stored only for character tables and not for
groups.
<P/>
Note that the returned class fusion refers to the ordering of conjugacy
classes in the character tables if the arguments are character tables
and to the ordering of conjugacy classes in the groups if the arguments
are groups
(see&nbsp;<Ref Attr="ConjugacyClasses" Label="for character tables"/>).
<P/>
Called with a group homomorphism <A>hom</A>,
<Ref Oper="FusionConjugacyClasses" Label="for a homomorphism"/> returns
the fusion of conjugacy classes between the preimage and the image of
<A>hom</A>;
contrary to the two cases above,
also factor fusions can be handled by this variant.
If <A>hom</A> is the only argument then the class fusion refers to the
ordering of conjugacy classes in the groups.
If the character tables of preimage and image are given as <A>tbl1</A>
and <A>tbl2</A>, respectively (each table with its group stored),
then the fusion refers to the ordering of classes in these tables.
<P/>
If no class fusion exists or if the class fusion is not uniquely
determined, <K>fail</K> is returned; this may happen when
<Ref Oper="FusionConjugacyClasses" Label="for two character tables"/> is
called with two character tables that do not know compatible underlying
groups.
<P/>
Methods for the computation of class fusions can be installed for
the operation
<Ref Oper="FusionConjugacyClassesOp" Label="for two character tables"/>.
<P/>
<Example><![CDATA[
gap> s4:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> tbls4:= CharacterTable( s4 );;
gap> d8:= SylowSubgroup( s4, 2 );
Group([ (1,2), (3,4), (1,3)(2,4) ])
gap> FusionConjugacyClasses( d8, s4 );
[ 1, 2, 3, 3, 5 ]
gap> tbls5:= CharacterTable( "S5" );;
gap> FusionConjugacyClasses( CharacterTable( "A5" ), tbls5 );
[ 1, 2, 3, 4, 4 ]
gap> FusionConjugacyClasses(CharacterTable("A5"), CharacterTable("J1"));
fail
gap> PossibleClassFusions(CharacterTable("A5"), CharacterTable("J1"));
[ [ 1, 2, 3, 4, 5 ], [ 1, 2, 3, 5, 4 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="ComputedClassFusions" Arg='tbl'/>

<Description>
The class fusions from the character table <A>tbl</A> that have been
computed already by
<Ref Oper="FusionConjugacyClasses" Label="for two character tables"/> or
explicitly stored by <Ref Func="StoreFusion"/>
are stored in the <Ref Attr="ComputedClassFusions"/> list of <A>tbl1</A>.
Each entry of this list is a record with the following components.

<List>
<Mark><C>name</C></Mark>
<Item>
  the <Ref Attr="Identifier" Label="for character tables"/> value
  of the character table to which the fusion maps,
</Item>
<Mark><C>map</C></Mark>
<Item>
  the list of positions of image classes,
</Item>
<Mark><C>text</C> (optional)</Mark>
<Item>
  a string giving additional information about the fusion map,
  for example whether the map is uniquely determined by the character
  tables,
</Item>
<Mark><C>specification</C> (optional, rarely used)</Mark>
<Item>
  a value that distinguishes different fusions between the same tables.
</Item>
</List>
<P/>
Note that stored fusion maps may differ from the maps returned by
<Ref Func="GetFusionMap"/> and the maps entered by
<Ref Func="StoreFusion"/> if the table <A>destination</A> has a
nonidentity <Ref Attr="ClassPermutation"/> value.
So if one fetches a fusion map from a table <A>tbl1</A> to a table
<A>tbl2</A> via access to the data in the
<Ref Attr="ComputedClassFusions"/> list of <A>tbl1</A> then the stored
value must be composed with the <Ref Attr="ClassPermutation"/> value of
<A>tbl2</A> in order to obtain the correct class fusion.
(If one handles fusions only via <Ref Func="GetFusionMap"/> and
<Ref Func="StoreFusion"/> then this adjustment is made automatically.)
<P/>
Fusions are identified via the
<Ref Attr="Identifier" Label="for character tables"/> value of the
destination table and not by this table itself because many fusions
between character tables in the &GAP; character table library are stored
on library tables,
and it is not desirable to load together with a library table also all
those character tables that occur as destinations of fusions from this
table.
<P/>
For storing fusions and accessing stored fusions,
see also&nbsp;<Ref Func="GetFusionMap"/>, <Ref Func="StoreFusion"/>.
For accessing the identifiers of tables that store a fusion into a
given character table, see&nbsp;<Ref Func="NamesOfFusionSources"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="GetFusionMap" Arg='source, destination[, specification]'/>

<Description>
For two ordinary character tables <A>source</A> and <A>destination</A>,
<Ref Func="GetFusionMap"/> checks whether the
<Ref Attr="ComputedClassFusions"/> list of <A>source</A>
contains a record with <C>name</C> component
<C>Identifier( <A>destination</A> )</C>,
and returns returns the <C>map</C> component of the first such record.
<C>GetFusionMap( <A>source</A>, <A>destination</A>,
<A>specification</A> )</C> fetches
that fusion map for which the record additionally has the
<C>specification</C> component <A>specification</A>.
<P/>
If both <A>source</A> and <A>destination</A> are Brauer tables,
first the same is done, and if no fusion map was found then
<Ref Func="GetFusionMap"/> looks whether a fusion map between the
ordinary tables is stored;
if so then the fusion map between <A>source</A> and <A>destination</A>
is stored on <A>source</A>, and then returned.
<P/>
If no appropriate fusion is found, <Ref Func="GetFusionMap"/> returns
<K>fail</K>.
For the computation of class fusions, see
<Ref Func="FusionConjugacyClasses" Label="for two character tables"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="StoreFusion" Arg='source, fusion, destination'/>

<Description>
For two character tables <A>source</A> and <A>destination</A>,
<Ref Func="StoreFusion"/> stores the fusion <A>fusion</A> from
<A>source</A> to <A>destination</A> in the
<Ref Attr="ComputedClassFusions"/> list of <A>source</A>,
and adds the <Ref Attr="Identifier" Label="for character tables"/> string
of <A>destination</A> to the <Ref Attr="NamesOfFusionSources"/> list of
<A>destination</A>.
<P/>
<A>fusion</A> can either be a fusion map (that is, the list of positions
of the image classes) or a record as described
in&nbsp;<Ref Func="ComputedClassFusions"/>.
<P/>
If fusions to <A>destination</A> are already stored on <A>source</A> then
another fusion can be stored only if it has a record component
<C>specification</C> that distinguishes it from the stored fusions.
In the case of such an ambiguity, <Ref Func="StoreFusion"/> raises an
error.
<P/>
<Example><![CDATA[
gap> tbld8:= CharacterTable( d8 );;
gap> ComputedClassFusions( tbld8 );
[ rec( map := [ 1, 2, 3, 3, 5 ], name := "CT1" ) ]
gap> Identifier( tbls4 );
"CT1"
gap> GetFusionMap( tbld8, tbls4 );
[ 1, 2, 3, 3, 5 ]
gap> GetFusionMap( tbls4, tbls5 );
fail
gap> poss:= PossibleClassFusions( tbls4, tbls5 );
[ [ 1, 5, 2, 3, 6 ] ]
gap> StoreFusion( tbls4, poss[1], tbls5 );
gap> GetFusionMap( tbls4, tbls5 );
[ 1, 5, 2, 3, 6 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="NamesOfFusionSources" Arg='tbl'/>

<Description>
For a character table <A>tbl</A>,
<Ref Attr="NamesOfFusionSources"/> returns the list of identifiers of all
those character tables that are known to have fusions to <A>tbl</A>
stored.
The <Ref Attr="NamesOfFusionSources"/> value is updated whenever a fusion
to <A>tbl</A> is stored using <Ref Func="StoreFusion"/>.
<P/>
<Example><![CDATA[
gap> NamesOfFusionSources( tbls4 );
[ "CT2" ]
gap> Identifier( CharacterTable( d8 ) );
"CT2"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="PossibleClassFusions" Arg='subtbl, tbl[, options]'/>

<Description>
For two ordinary character tables <A>subtbl</A> and <A>tbl</A> of the
groups <M>H</M> and <M>G</M>, say,
<Ref Oper="PossibleClassFusions"/> returns the list of all maps that have
the following properties of class fusions from <A>subtbl</A> to
<A>tbl</A>.

<Enum>
<Item>
  For class <M>i</M>, the centralizer order of the image in <M>G</M> is a
  multiple of the <M>i</M>-th centralizer order in <M>H</M>,
  and the element orders in the <M>i</M>-th class and its image are
  equal.
  These criteria are checked in <Ref Func="InitFusion"/>.
</Item>
<Item>
  The class fusion commutes with power maps.
  This is checked using <Ref Func="TestConsistencyMaps"/>.
</Item>
<Item>
  If the permutation character of <M>G</M> corresponding to the action of
  <M>G</M> on the cosets of <M>H</M> is specified (see the discussion of
  the <A>options</A> argument below)
  then it prescribes for each class <M>C</M> of
  <M>G</M> the number of elements of <M>H</M> fusing into <M>C</M>.
  The corresponding function is <Ref Func="CheckPermChar"/>.
</Item>
<Item>
  The table automorphisms of <A>tbl</A>
  (see&nbsp;<Ref Func="AutomorphismsOfTable"/>) are
  used in order to compute only orbit representatives.
  (But note that the list returned by <Ref Oper="PossibleClassFusions"/>
  contains the full orbits.)
</Item>
<Item>
  For each character <M>\chi</M> of <M>G</M>, the restriction to <M>H</M>
  via the class fusion is a character of <M>H</M>.
  This condition is checked for all characters specified below,
  the corresponding function is
  <Ref Func="FusionsAllowedByRestrictions"/>.
</Item>
<Item>
  The class multiplication coefficients in <A>subtbl</A> do not exceed
  the corresponding coefficients in <A>tbl</A>.
  This is checked in <Ref Func="ConsiderStructureConstants"/>,
  see also the comment on the parameter <C>verify</C> below.
</Item>
</Enum>
<P/>
If <A>subtbl</A> and <A>tbl</A> are Brauer tables then the possibilities
are computed from those for the underlying ordinary tables.
<P/>
The optional argument <A>options</A> must be a record that may have the
following components:

<List>
<Mark><C>chars</C></Mark>
<Item>
  a list of characters of <A>tbl</A> which are used for the check
  of&nbsp;5.; the default is <C>Irr( <A>tbl</A> )</C>,
</Item>
<Mark><C>subchars</C></Mark>
<Item>
  a list of characters of <A>subtbl</A> which are constituents of the
  restrictions of <C>chars</C>,
  the default is <C>Irr( <A>subtbl</A> )</C>,
</Item>
<Mark><C>fusionmap</C></Mark>
<Item>
  a parametrized map which is an approximation of the desired map,
</Item>
<Mark><C>decompose</C></Mark>
<Item>
  a Boolean;
  a <K>true</K> value indicates that all constituents of the restrictions
  of <C>chars</C> computed for criterion 5. lie in <C>subchars</C>,
  so the restrictions can be decomposed into elements of <C>subchars</C>;
  the default value of <C>decompose</C> is <K>true</K> if <C>subchars</C>
  is not bound and <C>Irr( <A>subtbl</A> )</C> is known,
  otherwise <K>false</K>,
</Item>
<Mark><C>permchar</C></Mark>
<Item>
  (a values list of) a permutation character; only those fusions
  affording that permutation character are computed,
</Item>
<Mark><C>quick</C></Mark>
<Item>
  a Boolean;
  if <K>true</K> then the subroutines are called with value <K>true</K>
  for the argument <A>quick</A>;
  especially, as soon as only one possibility remains
  then this possibility is returned immediately;
  the default value is <K>false</K>,
</Item>
<Mark><C>verify</C></Mark>
<Item>
  a Boolean;
  if <K>false</K> then <Ref Func="ConsiderStructureConstants"/> is called
  only if more than one orbit of possible class fusions exists,
  under the action of the groups of table automorphisms;
  the default value is <K>false</K> (because the computation of the
  structure constants is usually very time consuming, compared with
  checking the other criteria),
</Item>
<Mark><C>parameters</C></Mark>
<Item>
  a record with components <C>maxamb</C>, <C>minamb</C> and <C>maxlen</C>
  which control the subroutine
  <Ref Func="FusionsAllowedByRestrictions"/>;
  it only uses characters with current indeterminateness up to
  <C>maxamb</C>,
  tests decomposability only for characters with current
  indeterminateness at least <C>minamb</C>,
  and admits a branch according to a character only if there is one
  with at most <C>maxlen</C> possible restrictions.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "U3(3)" );;  tbl:= CharacterTable( "J4" );;
gap> PossibleClassFusions( subtbl, tbl );
[ [ 1, 2, 4, 4, 5, 5, 6, 10, 12, 13, 14, 14, 21, 21 ], 
  [ 1, 2, 4, 4, 5, 5, 6, 10, 13, 12, 14, 14, 21, 21 ], 
  [ 1, 2, 4, 4, 6, 6, 6, 10, 12, 13, 15, 15, 22, 22 ], 
  [ 1, 2, 4, 4, 6, 6, 6, 10, 12, 13, 16, 16, 22, 22 ], 
  [ 1, 2, 4, 4, 6, 6, 6, 10, 13, 12, 15, 15, 22, 22 ], 
  [ 1, 2, 4, 4, 6, 6, 6, 10, 13, 12, 16, 16, 22, 22 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ConsiderStructureConstants"
 Arg='subtbl, tbl, fusions, quick'/>

<Description>
Let <A>subtbl</A> and <A>tbl</A> be ordinary character tables and
<A>fusions</A> be a list of possible class fusions from <A>subtbl</A> to
<A>tbl</A>.
<Ref Func="ConsiderStructureConstants"/> returns the list of those maps
<M>\sigma</M> in <A>fusions</A> with the property that for all triples
<M>(i,j,k)</M> of class positions,
<C>ClassMultiplicationCoefficient</C><M>( <A>subtbl</A>, i, j, k )</M>
is not bigger than
<C>ClassMultiplicationCoefficient</C><M>( <A>tbl</A>, \sigma[i],
\sigma[j], \sigma[k] )</M>;
see&nbsp;<Ref Func="ClassMultiplicationCoefficient"
Label="for character tables"/>
for the definition of class multiplication coefficients/structure
constants.
<P/>
The argument <A>quick</A> must be a Boolean; if it is <K>true</K> then
only those triples are checked for which for which at least two entries
in <A>fusions</A> have different images.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Orbits on Sets of Possible Class Fusions">
<Heading>Orbits on Sets of Possible Class Fusions</Heading>

The permutation groups of table automorphisms
(see&nbsp;<Ref Func="AutomorphismsOfTable"/>)
of the subgroup table <A>subtbl</A> and the supergroup table <A>tbl</A>
act on the possible class fusions from <A>subtbl</A> to <A>tbl</A>
that are returned by <Ref Func="PossibleClassFusions"/>,
the former by permuting a list via <Ref Func="Permuted"/>,
the latter by mapping the images via <Ref Func="OnPoints"/>.
<P/>
If a set of possible fusions with certain properties was computed
that are not invariant under the full groups of table automorphisms
then only a smaller group acts on this set.
This may happen for example if a permutation character or if an explicit
approximation of the fusion map was prescribed in the call of
<Ref Oper="PossibleClassFusions"/>.

<ManSection>
<Func Name="OrbitFusions"
 Arg='subtblautomorphisms, fusionmap, tblautomorphisms'/>

<Description>
returns the orbit of the class fusion map <A>fusionmap</A> under the
actions of the permutation groups <A>subtblautomorphisms</A> and
<A>tblautomorphisms</A> of automorphisms of the character table of the
subgroup and the supergroup, respectively.
</Description>
</ManSection>

<ManSection>
<Func Name="RepresentativesFusions" Arg='subtbl, listofmaps, tbl'/>

<Description>
<Index>table automorphisms</Index>
Let <A>listofmaps</A> be a list of class fusions from the character table
<A>subtbl</A> to the character table <A>tbl</A>.
<Ref Func="RepresentativesFusions"/> returns a list of orbit
representatives of the class fusions under the action of maximal
admissible subgroups of the table automorphism groups of these character
tables.
<P/>
Instead of the character tables <A>subtbl</A> and <A>tbl</A>,
also the permutation groups of their table automorphisms
(see <Ref Attr="AutomorphismsOfTable"/>) may be entered.
<P/>
<Example><![CDATA[
gap> fus:= GetFusionMap( subtbl, tbl );
[ 1, 2, 4, 4, 5, 5, 6, 10, 12, 13, 14, 14, 21, 21 ]
gap> orb:= OrbitFusions( AutomorphismsOfTable( subtbl ), fus,
>              AutomorphismsOfTable( tbl ) );
[ [ 1, 2, 4, 4, 5, 5, 6, 10, 12, 13, 14, 14, 21, 21 ], 
  [ 1, 2, 4, 4, 5, 5, 6, 10, 13, 12, 14, 14, 21, 21 ] ]
gap> rep:= RepresentativesFusions( subtbl, orb, tbl );
[ [ 1, 2, 4, 4, 5, 5, 6, 10, 12, 13, 14, 14, 21, 21 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Parametrized Maps">
<Heading>Parametrized Maps</Heading>

<Index Subkey="parametrized">map</Index>
<Index>class functions</Index>
A <E>parametrized map</E> is a list whose <M>i</M>-th entry is either
unbound (which means that nothing is known about the image(s) of the
<M>i</M>-th class) or the image of the <M>i</M>-th class
(i.e., an integer for fusion maps, power maps, element orders etc.,
and a cyclotomic for characters),
or a list of possible images of the <M>i</M>-th class.
In this sense, maps are special parametrized maps.
We often identify a parametrized map <A>paramap</A> with the set of all
maps <A>map</A> with the property that either
<C><A>map</A>[i] = <A>paramap</A>[i]</C> or
<C><A>map</A>[i]</C> is contained in the list <C><A>paramap</A>[i]</C>;
we say then that <A>map</A> is contained in <A>paramap</A>.
<P/>
This definition implies that parametrized maps cannot be used to describe
sets of maps where lists are possible images.
An exception are strings which naturally arise as images when class names
are considered.
So strings and lists of strings are allowed in parametrized maps,
and character constants
(see Chapter&nbsp;<Ref Chap="Strings and Characters"/>)
are not allowed in maps.

<ManSection>
<Func Name="CompositionMaps" Arg='paramap2, paramap1[, class]'/>

<Description>
The composition of two parametrized maps <A>paramap1</A>, <A>paramap2</A>
is defined as the parametrized map <A>comp</A> that contains
all compositions <M>f_2 \circ f_1</M> of elements <M>f_1</M> of
<A>paramap1</A> and <M>f_2</M> of <A>paramap2</A>.
For example, the composition of a character <M>\chi</M> of a group
<M>G</M> by a parametrized class fusion map from a subgroup <M>H</M> to
<M>G</M> is the parametrized map that contains all restrictions of
<M>\chi</M> by elements of the parametrized fusion map.
<P/>
<C>CompositionMaps(<A>paramap2</A>, <A>paramap1</A>)</C>
is a parametrized map with entry
<C>CompositionMaps(<A>paramap2</A>, <A>paramap1</A>, <A>class</A>)</C>
at position <A>class</A>.
If <C><A>paramap1</A>[<A>class</A>]</C> is an integer then
<C>CompositionMaps(<A>paramap2</A>, <A>paramap1</A>, <A>class</A>)</C>
is equal to <C><A>paramap2</A>[ <A>paramap1</A>[ <A>class</A> ] ]</C>.
Otherwise it is the union of <C><A>paramap2</A>[<A>i</A>]</C> for
<A>i</A> in <C><A>paramap1</A>[ <A>class</A> ]</C>.
<P/>
<Example><![CDATA[
gap> map1:= [ 1, [ 2 .. 4 ], [ 4, 5 ], 1 ];;
gap> map2:= [ [ 1, 2 ], 2, 2, 3, 3 ];;
gap> CompositionMaps( map2, map1 );
[ [ 1, 2 ], [ 2, 3 ], 3, [ 1, 2 ] ]
gap> CompositionMaps( map1, map2 );
[ [ 1, 2, 3, 4 ], [ 2, 3, 4 ], [ 2, 3, 4 ], [ 4, 5 ], [ 4, 5 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="InverseMap" Arg='paramap'/>

<Description>
For a parametrized map <A>paramap</A>,
<Ref Func="InverseMap"/> returns a mutable parametrized map whose
<M>i</M>-th entry is unbound if <M>i</M> is not in the image of
<A>paramap</A>, equal to <M>j</M> if <M>i</M> is (in) the image of
<C><A>paramap</A>[<A>j</A>]</C> exactly for <M>j</M>,
and equal to the set of all preimages of <M>i</M> under <A>paramap</A>
otherwise.
<P/>
We have
<C>CompositionMaps( <A>paramap</A>, InverseMap( <A>paramap</A> ) )</C>
the identity map.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "2.A5" );;  f:= CharacterTable( "A5" );;
gap> fus:= GetFusionMap( tbl, f );
[ 1, 1, 2, 3, 3, 4, 4, 5, 5 ]
gap> inv:= InverseMap( fus );
[ [ 1, 2 ], 3, [ 4, 5 ], [ 6, 7 ], [ 8, 9 ] ]
gap> CompositionMaps( fus, inv );
[ 1, 2, 3, 4, 5 ]
gap> # transfer a power map ``up'' to the factor group
gap> pow:= PowerMap( tbl, 2 );
[ 1, 1, 2, 4, 4, 8, 8, 6, 6 ]
gap> CompositionMaps( fus, CompositionMaps( pow, inv ) );
[ 1, 1, 3, 5, 4 ]
gap> last = PowerMap( f, 2 );
true
gap> # transfer a power map of the factor group ``down'' to the group
gap> CompositionMaps( inv, CompositionMaps( PowerMap( f, 2 ), fus ) );
[ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ], [ 4, 5 ], [ 4, 5 ], [ 8, 9 ], 
  [ 8, 9 ], [ 6, 7 ], [ 6, 7 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectionMap" Arg='fusionmap'/>

<Description>
For a map <A>fusionmap</A>,
<Ref Func="ProjectionMap"/> returns a parametrized map
whose <M>i</M>-th entry is unbound if <M>i</M> is not in the image of
<A>fusionmap</A>,
and equal to <M>j</M> if <M>j</M> is the smallest position such that
<M>i</M> is the image of <A>fusionmap</A><C>[</C><M>j</M><C>]</C>.
<P/>
We have
<C>CompositionMaps( <A>fusionmap</A>, ProjectionMap( <A>fusionmap</A> ) )</C>
the identity map, i.e., first projecting and then fusing yields the
identity.
Note that <A>fusionmap</A> must <E>not</E> be a parametrized map.
<P/>
<Example><![CDATA[
gap> ProjectionMap( [ 1, 1, 1, 2, 2, 2, 3, 4, 5, 5, 5, 6, 6, 6 ] );
[ 1, 4, 7, 8, 9, 12 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Indirected" Arg='character, paramap'/>

<Description>
For a map <A>character</A> and a parametrized map <A>paramap</A>,
<Ref Func="Indirected"/> returns a parametrized map whose entry at
position <M>i</M> is
<A>character</A><C>[ </C><A>paramap</A><C>[</C><M>i</M><C>] ]</C>
if <A>paramap</A><C>[</C><M>i</M><C>]</C> is an integer,
and an unknown (see Chapter&nbsp;<Ref Chap="Unknowns"/>) otherwise.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "M12" );;
gap> fus:= [ 1, 3, 4, [ 6, 7 ], 8, 10, [ 11, 12 ], [ 11, 12 ],
>            [ 14, 15 ], [ 14, 15 ] ];;
gap> List( Irr( tbl ){ [ 1 .. 6 ] }, x -> Indirected( x, fus ) );
[ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  [ 11, 3, 2, Unknown(9), 1, 0, Unknown(10), Unknown(11), 0, 0 ], 
  [ 11, 3, 2, Unknown(12), 1, 0, Unknown(13), Unknown(14), 0, 0 ], 
  [ 16, 0, -2, 0, 1, 0, 0, 0, Unknown(15), Unknown(16) ], 
  [ 16, 0, -2, 0, 1, 0, 0, 0, Unknown(17), Unknown(18) ], 
  [ 45, -3, 0, 1, 0, 0, -1, -1, 1, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Parametrized" Arg='list'/>

<Description>
For a list <A>list</A> of (parametrized) maps of the same length,
<Ref Func="Parametrized"/> returns the smallest parametrized map
containing all elements of <A>list</A>.
<P/>
<Ref Func="Parametrized"/> is the inverse function to
<Ref Func="ContainedMaps"/>.
<P/>
<Example><![CDATA[
gap> Parametrized( [ [ 1, 2, 3, 4, 5 ], [ 1, 3, 2, 4, 5 ],
>                    [ 1, 2, 3, 4, 6 ] ] );
[ 1, [ 2, 3 ], [ 2, 3 ], 4, [ 5, 6 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ContainedMaps" Arg='paramap'/>

<Description>
For a parametrized map <A>paramap</A>,
<Ref Func="ContainedMaps"/> returns the set of all
maps contained in <A>paramap</A>.
<P/>
<Ref Func="ContainedMaps"/> is the inverse function to
<Ref Func="Parametrized"/> in the sense that
<C>Parametrized( ContainedMaps( <A>paramap</A> ) )</C>
is equal to <A>paramap</A>.
<P/>
<Example><![CDATA[
gap> ContainedMaps( [ 1, [ 2, 3 ], [ 2, 3 ], 4, [ 5, 6 ] ] );
[ [ 1, 2, 2, 4, 5 ], [ 1, 2, 2, 4, 6 ], [ 1, 2, 3, 4, 5 ], 
  [ 1, 2, 3, 4, 6 ], [ 1, 3, 2, 4, 5 ], [ 1, 3, 2, 4, 6 ], 
  [ 1, 3, 3, 4, 5 ], [ 1, 3, 3, 4, 6 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="UpdateMap" Arg='character, paramap, indirected'/>

<Description>
Let <A>character</A> be a map, <A>paramap</A> a parametrized map,
and <A>indirected</A> a parametrized map that is contained in
<C>CompositionMaps( <A>character</A>, <A>paramap</A> )</C>.
<P/>
Then <Ref Func="UpdateMap"/> changes <A>paramap</A> to the parametrized
map containing exactly the maps whose composition with <A>character</A>
is equal to <A>indirected</A>.
<P/>
If a contradiction is detected then <K>false</K> is returned immediately,
otherwise <K>true</K>.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable("S4(4).2");; tbl:= CharacterTable("He");;
gap> fus:= InitFusion( subtbl, tbl );;
gap> fus;
[ 1, 2, 2, [ 2, 3 ], 4, 4, [ 7, 8 ], [ 7, 8 ], 9, 9, 9, [ 10, 11 ], 
  [ 10, 11 ], 18, 18, 25, 25, [ 26, 27 ], [ 26, 27 ], 2, [ 6, 7 ], 
  [ 6, 7 ], [ 6, 7, 8 ], 10, 10, 17, 17, 18, [ 19, 20 ], [ 19, 20 ] ]
gap> chi:= Irr( tbl )[2];
Character( CharacterTable( "He" ), [ 51, 11, 3, 6, 0, 3, 3, -1, 1, 2, 
  0, 3*E(7)+3*E(7)^2+3*E(7)^4, 3*E(7)^3+3*E(7)^5+3*E(7)^6, 2, 
  E(7)+E(7)^2+2*E(7)^3+E(7)^4+2*E(7)^5+2*E(7)^6, 
  2*E(7)+2*E(7)^2+E(7)^3+2*E(7)^4+E(7)^5+E(7)^6, 1, 1, 0, 0, 
  -E(7)-E(7)^2-E(7)^4, -E(7)^3-E(7)^5-E(7)^6, E(7)+E(7)^2+E(7)^4, 
  E(7)^3+E(7)^5+E(7)^6, 1, 0, 0, -1, -1, 0, 0, E(7)+E(7)^2+E(7)^4, 
  E(7)^3+E(7)^5+E(7)^6 ] )
gap> filt:= Filtered( Irr( subtbl ), x -> x[1] = 50 );
[ Character( CharacterTable( "S4(4).2" ), 
    [ 50, 10, 10, 2, 5, 5, -2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, -1, 
      10, 2, 2, 2, 1, 1, 0, 0, 0, -1, -1 ] ), 
  Character( CharacterTable( "S4(4).2" ), 
    [ 50, 10, 10, 2, 5, 5, -2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, -1, 
      -10, -2, -2, -2, -1, -1, 0, 0, 0, 1, 1 ] ) ]
gap> UpdateMap( chi, fus, filt[1] + TrivialCharacter( subtbl ) );
true
gap> fus;
[ 1, 2, 2, 3, 4, 4, 8, 7, 9, 9, 9, 10, 10, 18, 18, 25, 25, 
  [ 26, 27 ], [ 26, 27 ], 2, [ 6, 7 ], [ 6, 7 ], [ 6, 7 ], 10, 10, 
  17, 17, 18, [ 19, 20 ], [ 19, 20 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MeetMaps" Arg='paramap1, paramap2'/>

<Description>
For two parametrized maps <A>paramap1</A> and <A>paramap2</A>,
<Ref Func="MeetMaps"/> changes <A>paramap1</A> such that the image of
class <M>i</M> is the intersection of
<A>paramap1</A><C>[</C><M>i</M><C>]</C>
and <A>paramap2</A><C>[</C><M>i</M><C>]</C>.
<P/>
If this implies that no images remain for a class, the position of such a
class is returned.
If no such inconsistency occurs,
<Ref Func="MeetMaps"/> returns <K>true</K>.
<P/>
<Example><![CDATA[
gap> map1:= [ [ 1, 2 ], [ 3, 4 ], 5, 6, [ 7, 8, 9 ] ];;
gap> map2:= [ [ 1, 3 ], [ 3, 4 ], [ 5, 6 ], 6, [ 8, 9, 10 ] ];;
gap> MeetMaps( map1, map2 );  map1;
true
[ 1, [ 3, 4 ], 5, 6, [ 8, 9 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CommutativeDiagram"
Arg='paramap1, paramap2, paramap3, paramap4[, improvements]'/>

<Description>
Let <A>paramap1</A>, <A>paramap2</A>, <A>paramap3</A>, <A>paramap4</A> be
parametrized maps covering parametrized maps <M>f_1</M>, <M>f_2</M>,
<M>f_3</M>, <M>f_4</M> with the property
that <C>CompositionMaps</C><M>( f_2, f_1 )</M> is equal to
<C>CompositionMaps</C><M>( f_4, f_3 )</M>.
<P/>
<Ref Func="CommutativeDiagram"/> checks this consistency,
and changes the arguments such that all possible images are removed that
cannot occur in the parametrized maps <M>f_i</M>.
<P/>
The return value is <K>fail</K> if an inconsistency was found.
Otherwise a record with the components <C>imp1</C>, <C>imp2</C>,
<C>imp3</C>, <C>imp4</C> is returned, each bound to the list of positions
where the corresponding parametrized map was changed,
<P/>
The optional argument <A>improvements</A> must be a record with
components <C>imp1</C>, <C>imp2</C>, <C>imp3</C>, <C>imp4</C>.
If such a record is specified then only diagrams are considered where
entries of the <M>i</M>-th component occur as preimages of the
<M>i</M>-th parametrized map.
<P/>
When an inconsistency is detected,
<Ref Func="CommutativeDiagram"/> immediately returns <K>fail</K>.
Otherwise a record is returned that contains four lists <C>imp1</C>,
<M>\ldots</M>, <C>imp4</C>:
The <M>i</M>-th component is the list of classes where the <M>i</M>-th
argument was changed.
<P/>
<Example><![CDATA[
gap> map1:= [[ 1, 2, 3 ], [ 1, 3 ]];; map2:= [[ 1, 2 ], 1, [ 1, 3 ]];;
gap> map3:= [ [ 2, 3 ], 3 ];;  map4:= [ , 1, 2, [ 1, 2 ] ];;
gap> imp:= CommutativeDiagram( map1, map2, map3, map4 );
rec( imp1 := [ 2 ], imp2 := [ 1 ], imp3 := [  ], imp4 := [  ] )
gap> map1;  map2;  map3;  map4;
[ [ 1, 2, 3 ], 1 ]
[ 2, 1, [ 1, 3 ] ]
[ [ 2, 3 ], 3 ]
[ , 1, 2, [ 1, 2 ] ]
gap> imp2:= CommutativeDiagram( map1, map2, map3, map4, imp );
rec( imp1 := [  ], imp2 := [  ], imp3 := [  ], imp4 := [  ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CheckFixedPoints" Arg='inside1, between, inside2'/>

<Description>
Let <A>inside1</A>, <A>between</A>, <A>inside2</A> be parametrized maps,
where <A>between</A> is assumed to map each fixed point of <A>inside1</A>
(that is, <A>inside1</A><C>[</C><M>i</M><C>] = </C><A>i</A>)
to a fixed point of <A>inside2</A>
(that is, <A>between</A><C>[</C><M>i</M><C>]</C> is either an integer
that is fixed by <A>inside2</A> or a list that has nonempty intersection
with the union of its images under <A>inside2</A>).
<Ref Func="CheckFixedPoints"/> changes <A>between</A> and <A>inside2</A>
by removing all those entries violate this condition.
<P/>
When an inconsistency is detected,
<Ref Func="CheckFixedPoints"/> immediately returns <K>fail</K>.
Otherwise the list of positions is returned where changes occurred.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "L4(3).2_2" );;
gap> tbl:= CharacterTable( "O7(3)" );;
gap> fus:= InitFusion( subtbl, tbl );;  fus{ [ 48, 49 ] };
[ [ 54, 55, 56, 57 ], [ 54, 55, 56, 57 ] ]
gap> CheckFixedPoints( ComputedPowerMaps( subtbl )[5], fus,
>        ComputedPowerMaps( tbl )[5] );
[ 48, 49 ]
gap> fus{ [ 48, 49 ] };
[ [ 56, 57 ], [ 56, 57 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TransferDiagram"
 Arg='inside1, between, inside2[, improvements]'/>

<Description>
Let <A>inside1</A>, <A>between</A>, <A>inside2</A> be parametrized maps
covering parametrized maps <M>m_1</M>, <M>f</M>, <M>m_2</M> with the
property that <C>CompositionMaps</C><M>( m_2, f )</M> is equal to
<C>CompositionMaps</C><M>( f, m_1 )</M>.
<P/>
<Ref Func="TransferDiagram"/> checks this consistency, and changes the
arguments such that all possible images are removed that cannot occur in
the parametrized maps <M>m_i</M> and <M>f</M>.
<P/>
So <Ref Func="TransferDiagram"/> is similar to
<Ref Func="CommutativeDiagram"/>,
but <A>between</A> occurs twice in each diagram checked.
<P/>
If a record <A>improvements</A> with fields <C>impinside1</C>,
<C>impbetween</C>, and <C>impinside2</C> is specified,
only those diagrams with elements of <C>impinside1</C> as preimages of
<A>inside1</A>, elements of <C>impbetween</C> as preimages of
<A>between</A> or elements of <C>impinside2</C> as preimages of
<A>inside2</A> are considered.
<P/>
When an inconsistency is detected,
<Ref Func="TransferDiagram"/> immediately returns <K>fail</K>.
Otherwise a record is returned that contains three lists
<C>impinside1</C>, <C>impbetween</C>, and <C>impinside2</C> of positions
where the arguments were changed.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "2F4(2)" );;  tbl:= CharacterTable( "Ru" );;
gap> fus:= InitFusion( subtbl, tbl );;
gap> permchar:= Sum( Irr( tbl ){ [ 1, 5, 6 ] } );;
gap> CheckPermChar( subtbl, tbl, fus, permchar );; fus;
[ 1, 2, 2, 4, 5, 7, 8, 9, 11, 14, 14, [ 13, 15 ], 16, [ 18, 19 ], 20, 
  [ 25, 26 ], [ 25, 26 ], 5, 5, 6, 8, 14, [ 13, 15 ], [ 18, 19 ], 
  [ 18, 19 ], [ 25, 26 ], [ 25, 26 ], 27, 27 ]
gap> tr:= TransferDiagram(PowerMap( subtbl, 2), fus, PowerMap(tbl, 2));
rec( impbetween := [ 12, 23 ], impinside1 := [  ], impinside2 := [  ] 
 )
gap> tr:= TransferDiagram(PowerMap(subtbl, 3), fus, PowerMap( tbl, 3 ));
rec( impbetween := [ 14, 24, 25 ], impinside1 := [  ], 
  impinside2 := [  ] )
gap> tr:= TransferDiagram( PowerMap(subtbl, 3), fus, PowerMap(tbl, 3),
>             tr );
rec( impbetween := [  ], impinside1 := [  ], impinside2 := [  ] )
gap> fus;
[ 1, 2, 2, 4, 5, 7, 8, 9, 11, 14, 14, 15, 16, 18, 20, [ 25, 26 ], 
  [ 25, 26 ], 5, 5, 6, 8, 14, 13, 19, 19, [ 25, 26 ], [ 25, 26 ], 27, 
  27 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TestConsistencyMaps"
 Arg='powermap1, fusionmap, powermap2[, fusimp]'/>

<Description>
Let <A>powermap1</A> and <A>powermap2</A> be lists of parametrized maps,
and <A>fusionmap</A> a parametrized map,
such that for each <M>i</M>, the <M>i</M>-th entry in <A>powermap1</A>,
<A>fusionmap</A>, and the <M>i</M>-th entry in <A>powermap2</A>
(if bound) are valid arguments for <Ref Func="TransferDiagram"/>.
So a typical situation for applying <Ref Func="TestConsistencyMaps"/> is
that <A>fusionmap</A> is an approximation of a class fusion,
and <A>powermap1</A>, <A>powermap2</A> are the lists of power maps of the
subgroup and the group.
<P/>
<Ref Func="TestConsistencyMaps"/> repeatedly applies
<Ref Func="TransferDiagram"/> to these arguments for all <M>i</M> until
no more changes occur.
<P/>
If a list <A>fusimp</A> is specified then only those diagrams with
elements of <A>fusimp</A> as preimages of <A>fusionmap</A> are
considered.
<P/>
When an inconsistency is detected,
<Ref Func="TestConsistencyMaps"/> immediately returns <K>false</K>.
Otherwise <K>true</K> is returned.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "2F4(2)" );;  tbl:= CharacterTable( "Ru" );;
gap> fus:= InitFusion( subtbl, tbl );;
gap> permchar:= Sum( Irr( tbl ){ [ 1, 5, 6 ] } );;
gap> CheckPermChar( subtbl, tbl, fus, permchar );; fus;
[ 1, 2, 2, 4, 5, 7, 8, 9, 11, 14, 14, [ 13, 15 ], 16, [ 18, 19 ], 20, 
  [ 25, 26 ], [ 25, 26 ], 5, 5, 6, 8, 14, [ 13, 15 ], [ 18, 19 ], 
  [ 18, 19 ], [ 25, 26 ], [ 25, 26 ], 27, 27 ]
gap> TestConsistencyMaps( ComputedPowerMaps( subtbl ), fus,
>        ComputedPowerMaps( tbl ) );
true
gap> fus;
[ 1, 2, 2, 4, 5, 7, 8, 9, 11, 14, 14, 15, 16, 18, 20, [ 25, 26 ], 
  [ 25, 26 ], 5, 5, 6, 8, 14, 13, 19, 19, [ 25, 26 ], [ 25, 26 ], 27, 
  27 ]
gap> Indeterminateness( fus );
16
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Indeterminateness" Arg='paramap'/>

<Description>
For a parametrized map <A>paramap</A>, <Ref Func="Indeterminateness"/>
returns the number of maps contained in <A>paramap</A>, that is,
the product of lengths of lists in <A>paramap</A> denoting lists of
several images.
<P/>
<Example><![CDATA[
gap> Indeterminateness([ 1, [ 2, 3 ], [ 4, 5 ], [ 6, 7, 8, 9, 10 ], 11 ]);
20
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PrintAmbiguity" Arg='list, paramap'/>

<Description>
For each map in the list <A>list</A>, <Ref Func="PrintAmbiguity"/> prints
its position in <A>list</A>,
the indeterminateness (see&nbsp;<Ref Func="Indeterminateness"/>) of the
composition with the parametrized map <A>paramap</A>,
and the list of positions where a list of images occurs in this
composition.
<P/>
<Example><![CDATA[
gap> paramap:= [ 1, [ 2, 3 ], [ 3, 4 ], [ 2, 3, 4 ], 5 ];;
gap> list:= [ [ 1, 1, 1, 1, 1 ], [ 1, 1, 2, 2, 3 ], [ 1, 2, 3, 4, 5 ] ];;
gap> PrintAmbiguity( list, paramap );
1 1 [  ]
2 4 [ 2, 4 ]
3 12 [ 2, 3, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ContainedSpecialVectors"
 Arg='tbl, chars, paracharacter, func'/>
<Func Name="IntScalarProducts" Arg='tbl, chars, candidate'/>
<Func Name="NonnegIntScalarProducts" Arg='tbl, chars, candidate'/>
<Func Name="ContainedPossibleVirtualCharacters"
 Arg='tbl, chars, paracharacter'/>
<Func Name="ContainedPossibleCharacters"
 Arg='tbl, chars, paracharacter'/>

<Description>
Let <A>tbl</A> be an ordinary character table,
<A>chars</A> a list of class functions (or values lists),
<A>paracharacter</A> a parametrized class function of <A>tbl</A>,
and <A>func</A> a function that expects the three arguments <A>tbl</A>,
<A>chars</A>, and a values list of a class function, and that returns
either <K>true</K> or <K>false</K>.
<P/>
<Ref Func="ContainedSpecialVectors"/> returns
the list of all those elements <A>vec</A> of <A>paracharacter</A> that
have integral norm,
have integral scalar product with the principal character of <A>tbl</A>,
and that satisfy
<A>func</A><C>( </C><A>tbl</A>, <A>chars</A>, <A>vec</A> <C>) = </C><K>true</K>.
<P/>
Two special cases of <A>func</A> are the check whether the scalar
products in <A>tbl</A> between the vector <A>vec</A> and all lists in
<A>chars</A> are integers or nonnegative integers, respectively.
These functions are accessible as global variables
<Ref Func="IntScalarProducts"/> and
<Ref Func="NonnegIntScalarProducts"/>,
and <Ref Func="ContainedPossibleVirtualCharacters"/> and
<Ref Func="ContainedPossibleCharacters"/> provide access to these special
cases of <Ref Func="ContainedSpecialVectors"/>.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "HSM12" );;  tbl:= CharacterTable( "HS" );;
gap> fus:= InitFusion( subtbl, tbl );;
gap> rest:= CompositionMaps( Irr( tbl )[8], fus );
[ 231, [ -9, 7 ], [ -9, 7 ], [ -9, 7 ], 6, 15, 15, [ -1, 15 ], 
  [ -1, 15 ], 1, [ 1, 6 ], [ 1, 6 ], [ 1, 6 ], [ 1, 6 ], [ -2, 0 ], 
  [ 1, 2 ], [ 1, 2 ], [ 1, 2 ], 0, 0, 1, 0, 0, 0, 0 ]
gap> irr:= Irr( subtbl );;
gap> # no further condition
gap> cont1:= ContainedSpecialVectors( subtbl, irr, rest,
>                function( tbl, chars, vec ) return true; end );;
gap> Length( cont1 );
24
gap> # require scalar products to be integral
gap> cont2:= ContainedSpecialVectors( subtbl, irr, rest,
>                IntScalarProducts );
[ [ 231, 7, -9, -9, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, 7, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, -9, 6, 15, 15, 15, 15, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, 7, 6, 15, 15, 15, 15, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ] ]
gap> # additionally require scalar products to be nonnegative
gap> cont3:= ContainedSpecialVectors( subtbl, irr, rest,
>                NonnegIntScalarProducts );
[ [ 231, 7, -9, -9, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, 7, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ] ]
gap> cont2 = ContainedPossibleVirtualCharacters( subtbl, irr, rest );
true
gap> cont3 = ContainedPossibleCharacters( subtbl, irr, rest );
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CollapsedMat" Arg='mat, maps'/>

<Description>
is a record with the components
<P/>
<List>
<Mark><C>fusion</C></Mark>
<Item>
   fusion that collapses those columns of <A>mat</A> that are equal in
   <A>mat</A> and also for all maps in the list <A>maps</A>,
</Item>
<Mark><C>mat</C></Mark>
<Item>
   the image of <A>mat</A> under that fusion.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> mat:= [ [ 1, 1, 1, 1 ], [ 2, -1, 0, 0 ], [ 4, 4, 1, 1 ] ];;
gap> coll:= CollapsedMat( mat, [] );
rec( fusion := [ 1, 2, 3, 3 ], 
  mat := [ [ 1, 1, 1 ], [ 2, -1, 0 ], [ 4, 4, 1 ] ] )
gap> List( last.mat, x -> x{ last.fusion } ) = mat;
true
gap> coll:= CollapsedMat( mat, [ [ 1, 1, 1, 2 ] ] );
rec( fusion := [ 1, 2, 3, 4 ], 
  mat := [ [ 1, 1, 1, 1 ], [ 2, -1, 0, 0 ], [ 4, 4, 1, 1 ] ] )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ContainedDecomposables"
 Arg='constituents, moduls, parachar, func'/>
<Func Name="ContainedCharacters" Arg='tbl, constituents, parachar'/>

<Description>
For these functions, 
let <A>constituents</A> be a list of <E>rational</E> class functions,
<A>moduls</A> a list of positive integers,
<A>parachar</A> a parametrized rational class function,
<A>func</A> a function that returns either <K>true</K> or <K>false</K>
when called with (a values list of) a class function,
and <A>tbl</A> a character table.
<P/>
<Ref Func="ContainedDecomposables"/> returns the set of all elements
<M>\chi</M> of <A>parachar</A> that satisfy
<A>func</A><M>( \chi ) =</M> <K>true</K>
and that lie in the <M>&ZZ;</M>-lattice spanned by <A>constituents</A>,
modulo <A>moduls</A>.
The latter means they lie in the <M>&ZZ;</M>-lattice spanned by
<A>constituents</A> and the set
<M>\{ <A>moduls</A>[i] \cdot e_i; 1 \leq i \leq n \}</M>
where <M>n</M> is the length of <A>parachar</A> and  <M>e_i</M> is the
<M>i</M>-th standard basis vector.
<P/>
One application of <Ref Func="ContainedDecomposables"/> is the following.
<A>constituents</A> is a list of (values lists of) rational characters of
an ordinary character table <A>tbl</A>,
<A>moduls</A> is the list of centralizer orders of <A>tbl</A>
(see&nbsp;<Ref Func="SizesCentralizers"/>),
and <A>func</A> checks whether a vector in the lattice mentioned above
has nonnegative integral scalar product in <A>tbl</A> with all entries of
<A>constituents</A>.
This situation is handled by <Ref Func="ContainedCharacters"/>.
Note that the entries of the result list are <E>not</E> necessary linear
combinations of <A>constituents</A>,
and they are <E>not</E> necessarily characters of <A>tbl</A>.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "HSM12" );;  tbl:= CharacterTable( "HS" );;
gap> rat:= RationalizedMat( Irr( subtbl ) );;
gap> fus:= InitFusion( subtbl, tbl );;
gap> rest:= CompositionMaps( Irr( tbl )[8], fus );
[ 231, [ -9, 7 ], [ -9, 7 ], [ -9, 7 ], 6, 15, 15, [ -1, 15 ], 
  [ -1, 15 ], 1, [ 1, 6 ], [ 1, 6 ], [ 1, 6 ], [ 1, 6 ], [ -2, 0 ], 
  [ 1, 2 ], [ 1, 2 ], [ 1, 2 ], 0, 0, 1, 0, 0, 0, 0 ]
gap> # compute all vectors in the lattice
gap> ContainedDecomposables( rat, SizesCentralizers( subtbl ), rest,
>        ReturnTrue );
[ [ 231, 7, -9, -9, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, -9, 6, 15, 15, 15, 15, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, 7, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, 7, 6, 15, 15, 15, 15, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ] ]
gap> # compute only those vectors that are characters
gap> ContainedDecomposables( rat, SizesCentralizers( subtbl ), rest,
>        x -> NonnegIntScalarProducts( subtbl, Irr( subtbl ), x ) );
[ [ 231, 7, -9, -9, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ], 
  [ 231, 7, -9, 7, 6, 15, 15, -1, -1, 1, 6, 6, 1, 1, -2, 1, 2, 2, 0, 
      0, 1, 0, 0, 0, 0 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subroutines for the Construction of Power Maps">
<Heading>Subroutines for the Construction of Power Maps</Heading>

In the argument lists of the functions
<Ref Func="Congruences" Label="for character tables"/>,
<Ref Func="ConsiderKernels"/>,
and <Ref Func="ConsiderSmallerPowerMaps"/>,
<A>tbl</A> is an ordinary character table,
<A>chars</A> a list of (values lists of) characters of <A>tbl</A>,
<A>prime</A> a prime integer,
<A>approxmap</A> a parametrized map that is an approximation for the
<A>prime</A>-th power map of <A>tbl</A>
(e.g., a list returned by <Ref Func="InitPowerMap"/>,
and <A>quick</A> a Boolean.
<P/>
The <A>quick</A> value <K>true</K> means that only those classes are
considered for which <A>approxmap</A> lists more than one possible image.

<ManSection>
<Func Name="InitPowerMap" Arg='tbl, prime'/>

<Description>
For an ordinary character table <A>tbl</A> and a prime <A>prime</A>,
<Ref Func="InitPowerMap"/> returns a parametrized map that is a first
approximation of the <A>prime</A>-th powermap of <A>tbl</A>,
using the conditions 1.&nbsp;and 2.&nbsp;listed in the description of
<Ref Func="PossiblePowerMaps"/>.
<P/>
If there are classes for which no images are possible, according to these
criteria, then <K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( "U4(3).4" );;
gap> pow:= InitPowerMap( t, 2 );
[ 1, 1, 3, 4, 5, [ 2, 16 ], [ 2, 16, 17 ], 8, 3, [ 3, 4 ], 
  [ 11, 12 ], [ 11, 12 ], [ 6, 7, 18, 19, 30, 31, 32, 33 ], 14, 
  [ 9, 20 ], 1, 1, 2, 2, 3, [ 3, 4, 5 ], [ 3, 4, 5 ], 
  [ 6, 7, 18, 19, 30, 31, 32, 33 ], 8, 9, 9, [ 9, 10, 20, 21, 22 ], 
  [ 11, 12 ], [ 11, 12 ], 16, 16, [ 2, 16 ], [ 2, 16 ], 17, 17, 
  [ 6, 18, 30, 31, 32, 33 ], [ 6, 18, 30, 31, 32, 33 ], 
  [ 6, 7, 18, 19, 30, 31, 32, 33 ], [ 6, 7, 18, 19, 30, 31, 32, 33 ], 
  20, 20, [ 9, 20 ], [ 9, 20 ], [ 9, 10, 20, 21, 22 ], 
  [ 9, 10, 20, 21, 22 ], 24, 24, [ 15, 25, 26, 40, 41, 42, 43 ], 
  [ 15, 25, 26, 40, 41, 42, 43 ], [ 28, 29 ], [ 28, 29 ], [ 28, 29 ], 
  [ 28, 29 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Congruences" Arg='tbl, chars, approxmap, prime, quick'
Label="for character tables"/>

<Description>
<Ref Func="Congruences" Label="for character tables"/>
replaces the entries of <A>approxmap</A> by improved values,
according to condition 3.&nbsp;listed in the description
of <Ref Func="PossiblePowerMaps"/>.
<P/>
For each class for which no images are possible according to the tests,
the new value of <A>approxmap</A> is an empty list.
<Ref Func="Congruences" Label="for character tables"/>
returns <K>true</K> if no such inconsistencies occur,
and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> Congruences( t, Irr( t ), pow, 2, false );  pow;
true
[ 1, 1, 3, 4, 5, 2, 2, 8, 3, 4, 11, 12, [ 6, 7 ], 14, 9, 1, 1, 2, 2, 
  3, 4, 5, [ 6, 7 ], 8, 9, 9, 10, 11, 12, 16, 16, 16, 16, 17, 17, 18, 
  18, [ 18, 19 ], [ 18, 19 ], 20, 20, 20, 20, 22, 22, 24, 24, 
  [ 25, 26 ], [ 25, 26 ], 28, 28, 29, 29 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ConsiderKernels" Arg='tbl, chars, approxmap, prime, quick'/>

<Description>
<Ref Func="ConsiderKernels"/> replaces the entries of <A>approxmap</A> by
improved values, according to condition 4.&nbsp;listed in the description
of <Ref Func="PossiblePowerMaps"/>.
<P/>
<Ref Func="Congruences" Label="for character tables"/>
returns <K>true</K> if the orders of the
kernels of all characters in <A>chars</A> divide the order of the group
of <A>tbl</A>, and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( "A7.2" );;  init:= InitPowerMap( t, 2 );
[ 1, 1, 3, 4, [ 2, 9, 10 ], 6, 3, 8, 1, 1, [ 2, 9, 10 ], 3, [ 3, 4 ], 
  6, [ 7, 12 ] ]
gap> ConsiderKernels( t, Irr( t ), init, 2, false );
true
gap> init;
[ 1, 1, 3, 4, 2, 6, 3, 8, 1, 1, 2, 3, [ 3, 4 ], 6, 7 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ConsiderSmallerPowerMaps"
 Arg='tbl, approxmap, prime, quick'/>

<Description>
<Ref Func="ConsiderSmallerPowerMaps"/> replaces the entries of
<A>approxmap</A> by improved values,
according to condition 5.&nbsp;listed in the description of
<Ref Func="PossiblePowerMaps"/>.
<P/>
<Ref Func="ConsiderSmallerPowerMaps"/> returns <K>true</K> if each class
admits at least one image after the checks, otherwise <K>false</K> is
returned.
If no element orders of <A>tbl</A> are stored
(see&nbsp;<Ref Func="OrdersClassRepresentatives"/>) then <K>true</K> is
returned without any tests.
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( "3.A6" );;  init:= InitPowerMap( t, 5 );
[ 1, [ 2, 3 ], [ 2, 3 ], 4, [ 5, 6 ], [ 5, 6 ], [ 7, 8 ], [ 7, 8 ], 
  9, [ 10, 11 ], [ 10, 11 ], 1, [ 2, 3 ], [ 2, 3 ], 1, [ 2, 3 ], 
  [ 2, 3 ] ]
gap> Indeterminateness( init );
4096
gap> ConsiderSmallerPowerMaps( t, init, 5, false );
true
gap> Indeterminateness( init );
256
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MinusCharacter" Arg='character, primepowermap, prime'/>

<Description>
Let <A>character</A> be (the list of values of) a class function
<M>\chi</M>, <A>prime</A> a prime integer <M>p</M>, and
<A>primepowermap</A> a parametrized map that is an approximation of the
<M>p</M>-th power map for the character table of <M>\chi</M>.
<Ref Func="MinusCharacter"/> returns the parametrized map of values of
<M>\chi^{{p-}}</M>,
which is defined by
<M>\chi^{{p-}}(g) = ( \chi(g)^p - \chi(g^p) ) / p</M>.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "S7" );;  pow:= InitPowerMap( tbl, 2 );;
gap> pow;
[ 1, 1, 3, 4, [ 2, 9, 10 ], 6, 3, 8, 1, 1, [ 2, 9, 10 ], 3, [ 3, 4 ], 
  6, [ 7, 12 ] ]
gap> chars:= Irr( tbl ){ [ 2 .. 5 ] };;
gap> List( chars, x -> MinusCharacter( x, pow, 2 ) );
[ [ 0, 0, 0, 0, [ 0, 1 ], 0, 0, 0, 0, 0, [ 0, 1 ], 0, 0, 0, [ 0, 1 ] ]
    , 
  [ 15, -1, 3, 0, [ -2, -1, 0 ], 0, -1, 1, 5, -3, [ 0, 1, 2 ], -1, 0, 
      0, [ 0, 1 ] ], 
  [ 15, -1, 3, 0, [ -1, 0, 2 ], 0, -1, 1, 5, -3, [ 1, 2, 4 ], -1, 0, 
      0, 1 ], 
  [ 190, -2, 1, 1, [ 0, 2 ], 0, 1, 1, -10, -10, [ 0, 2 ], -1, -1, 0, 
      [ -1, 0 ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PowerMapsAllowedBySymmetrizations"
 Arg='tbl, subchars, chars, approxmap, prime, parameters'/>

<Description>
Let <A>tbl</A> be an ordinary character table,
<A>prime</A> a prime integer,
<A>approxmap</A> a parametrized map that is an approximation of the
<A>prime</A>-th power map of <A>tbl</A>
(e.g., a list returned by <Ref Func="InitPowerMap"/>,
<A>chars</A> and <A>subchars</A> two lists of (values lists of)
characters of <A>tbl</A>,
and <A>parameters</A> a record with components
<C>maxlen</C>, <C>minamb</C>, <C>maxamb</C> (three integers),
<C>quick</C> (a Boolean),
and <C>contained</C> (a function).
Usual values of <C>contained</C> are <Ref Func="ContainedCharacters"/> or
<Ref Func="ContainedPossibleCharacters"/>.
<P/>
<Ref Func="PowerMapsAllowedBySymmetrizations"/> replaces the entries of
<A>approxmap</A> by improved values,
according to condition 6.&nbsp;listed in the description of
<Ref Func="PossiblePowerMaps"/>.
<P/>
More precisely, the strategy used is as follows.
<P/>
First, for each <M>\chi \in <A>chars</A></M>,
let <C>minus:= MinusCharacter(</C><M>\chi</M><C>, <A>approxmap</A>,
<A>prime</A>)</C>.
<List>
<Item>
  If <C>Indeterminateness( minus )</C><M> = 1</M> and
  <C><A>parameters</A>.quick = false</C> then the scalar products of
  <C>minus</C> with <A>subchars</A> are checked;
  if not all scalar products are nonnegative integers then
  an empty list is returned,
  otherwise <M>\chi</M> is deleted from the list of characters to
  inspect.
</Item>
<Item>
  Otherwise if <C>Indeterminateness( minus )</C> is smaller than
  <C><A>parameters</A>.minamb</C> then <M>\chi</M> is deleted from the
  list of characters.
</Item>
<Item>
  If <C><A>parameters</A>.minamb</C> <M>\leq</M>
  <C>Indeterminateness( minus )</C> <M>\leq</M>
  <C><A>parameters</A>.maxamb</C> then
  construct the list of contained class functions
  <C>poss:= <A>parameters</A>.contained(<A>tbl</A>, <A>subchars</A>,
  minus)</C> and <C>Parametrized( poss )</C>,
  and improve the approximation of the power map using
  <Ref Func="UpdateMap"/>.
</Item>
</List>
<P/>
If this yields no further immediate improvements then we branch.
If there is a character from <A>chars</A> left with less or equal
<C><A>parameters</A>.maxlen</C> possible symmetrizations,
compute the union of power maps allowed by these possibilities.
Otherwise we choose a class <M>C</M> such that the possible
symmetrizations of a character in <A>chars</A> differ at <M>C</M>,
and compute recursively the union of all allowed power maps with image
at <M>C</M> fixed in the set given by the current approximation of the
power map.
<P/>
<Example><![CDATA[
gap> tbl:= CharacterTable( "U4(3).4" );;
gap> pow:= InitPowerMap( tbl, 2 );;
gap> Congruences( tbl, Irr( tbl ), pow, 2 );;  pow;
[ 1, 1, 3, 4, 5, 2, 2, 8, 3, 4, 11, 12, [ 6, 7 ], 14, 9, 1, 1, 2, 2, 
  3, 4, 5, [ 6, 7 ], 8, 9, 9, 10, 11, 12, 16, 16, 16, 16, 17, 17, 18, 
  18, [ 18, 19 ], [ 18, 19 ], 20, 20, 20, 20, 22, 22, 24, 24, 
  [ 25, 26 ], [ 25, 26 ], 28, 28, 29, 29 ]
gap> PowerMapsAllowedBySymmetrizations( tbl, Irr( tbl ), Irr( tbl ),
>       pow, 2, rec( maxlen:= 10, contained:= ContainedPossibleCharacters,
>       minamb:= 2, maxamb:= infinity, quick:= false ) );
[ [ 1, 1, 3, 4, 5, 2, 2, 8, 3, 4, 11, 12, 6, 14, 9, 1, 1, 2, 2, 3, 4, 
      5, 6, 8, 9, 9, 10, 11, 12, 16, 16, 16, 16, 17, 17, 18, 18, 18, 
      18, 20, 20, 20, 20, 22, 22, 24, 24, 25, 26, 28, 28, 29, 29 ] ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subroutines for the Construction of Class Fusions">
<Heading>Subroutines for the Construction of Class Fusions</Heading>

<ManSection>
<Func Name="InitFusion" Arg='subtbl, tbl'/>

<Description>
For two ordinary character tables <A>subtbl</A> and <A>tbl</A>,
<Ref Func="InitFusion"/> returns a parametrized map that is a first
approximation of the class fusion from <A>subtbl</A> to <A>tbl</A>,
using condition&nbsp;1.&nbsp;listed in the description of
<Ref Func="PossibleClassFusions"/>.
<P/>
If there are classes for which no images are possible, according to this
criterion, then <K>fail</K> is returned.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "2F4(2)" );;  tbl:= CharacterTable( "Ru" );;
gap> fus:= InitFusion( subtbl, tbl );
[ 1, 2, 2, 4, [ 5, 6 ], [ 5, 6, 7, 8 ], [ 5, 6, 7, 8 ], [ 9, 10 ], 
  11, 14, 14, [ 13, 14, 15 ], [ 16, 17 ], [ 18, 19 ], 20, [ 25, 26 ], 
  [ 25, 26 ], [ 5, 6 ], [ 5, 6 ], [ 5, 6 ], [ 5, 6, 7, 8 ], 
  [ 13, 14, 15 ], [ 13, 14, 15 ], [ 18, 19 ], [ 18, 19 ], [ 25, 26 ], 
  [ 25, 26 ], [ 27, 28, 29 ], [ 27, 28, 29 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CheckPermChar" Arg='subtbl, tbl, approxmap, permchar'/>

<Description>
<Index>permutation character</Index>
<Ref Func="CheckPermChar"/> replaces the entries of the parametrized map
<A>approxmap</A> by improved values,
according to condition&nbsp;3.&nbsp;listed in the description of
<Ref Func="PossibleClassFusions"/>.
<P/>
<Ref Func="CheckPermChar"/> returns <K>true</K> if no inconsistency
occurred, and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> permchar:= Sum( Irr( tbl ){ [ 1, 5, 6 ] } );;
gap> CheckPermChar( subtbl, tbl, fus, permchar ); fus;
true
[ 1, 2, 2, 4, 5, 7, 8, 9, 11, 14, 14, [ 13, 15 ], 16, [ 18, 19 ], 20, 
  [ 25, 26 ], [ 25, 26 ], 5, 5, 6, 8, 14, [ 13, 15 ], [ 18, 19 ], 
  [ 18, 19 ], [ 25, 26 ], [ 25, 26 ], 27, 27 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ConsiderTableAutomorphisms" Arg='approxmap, grp'/>

<Description>
<Index>table automorphisms</Index>
<Ref Func="ConsiderTableAutomorphisms"/> replaces the entries of the
parametrized map <A>approxmap</A> by improved values, according to
condition&nbsp;4.&nbsp;listed in the description of
<Ref Func="PossibleClassFusions"/>.
<P/>
Afterwards exactly one representative of fusion maps (contained in
<A>approxmap</A>) in each orbit under the action of the permutation group
<A>grp</A> is contained in the modified parametrized map.
<P/>
<Ref Func="ConsiderTableAutomorphisms"/> returns the list of positions
where <A>approxmap</A> was changed.
<P/>
<Example><![CDATA[
gap> ConsiderTableAutomorphisms( fus, AutomorphismsOfTable( tbl ) );
[ 16 ]
gap> fus;
[ 1, 2, 2, 4, 5, 7, 8, 9, 11, 14, 14, [ 13, 15 ], 16, [ 18, 19 ], 20, 
  25, [ 25, 26 ], 5, 5, 6, 8, 14, [ 13, 15 ], [ 18, 19 ], [ 18, 19 ], 
  [ 25, 26 ], [ 25, 26 ], 27, 27 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FusionsAllowedByRestrictions"
 Arg='subtbl, tbl, subchars, chars, approxmap, parameters'/>

<Description>
Let <A>subtbl</A> and <A>tbl</A> be ordinary character tables,
<A>subchars</A> and <A>chars</A> two lists of (values lists of)
characters of <A>subtbl</A> and <A>tbl</A>, respectively,
<A>approxmap</A> a parametrized map that is an approximation of the class
fusion of <A>subtbl</A> in <A>tbl</A>,
and <A>parameters</A> a record with components
<C>maxlen</C>, <C>minamb</C>, <C>maxamb</C> (three integers),
<C>quick</C> (a Boolean),
and <C>contained</C> (a function).
Usual values of <C>contained</C> are
<Ref Func="ContainedCharacters"/> or
<Ref Func="ContainedPossibleCharacters"/>.
<P/>
<Ref Func="FusionsAllowedByRestrictions"/> replaces the entries of
<A>approxmap</A> by improved values,
according to condition 5.&nbsp;listed in the description of
<Ref Func="PossibleClassFusions"/>.
<P/>
More precisely, the strategy used is as follows.
<P/>
First, for each <M>\chi \in <A>chars</A></M>,
let <C>restricted:= CompositionMaps( </C><M>\chi</M><C>,
<A>approxmap</A> )</C>.
<List>
<Item>
  If <C>Indeterminateness( restricted )</C><M> = 1</M> and
  <C><A>parameters</A>.quick = false</C> then the scalar products of
  <C>restricted</C> with <A>subchars</A> are checked;
  if not all scalar products are nonnegative integers then
  an empty list is returned,
  otherwise <M>\chi</M> is deleted from the list of characters to
  inspect.
</Item>
<Item>
  Otherwise if <C>Indeterminateness( minus )</C> is smaller than
  <C><A>parameters</A>.minamb</C> then <M>\chi</M> is deleted from the
  list of characters.
</Item>
<Item>
  If <C><A>parameters</A>.minamb</C> <M>\leq</M>
  <C>Indeterminateness( restricted )</C>
  <M>\leq</M> <C><A>parameters</A>.maxamb</C> then construct
  <C>poss:= <A>parameters</A>.contained( <A>subtbl</A>, <A>subchars</A>,
  restricted )</C>
  and <C>Parametrized( poss )</C>,
  and improve the approximation of the fusion map using
  <Ref Func="UpdateMap"/>.
</Item>
</List>
<!-- #T Would it help to exploit that the restriction of a <E>linear</E> character-->
<!-- #T is again a linear character (not only a linear combination of linear-->
<!-- #T characters?-->
<!-- #T Branching in these cases would yield a short list of possibilities,-->
<!-- #T so it should be recommended ...-->
<P/>
If this yields no further immediate improvements then we branch.
If there is a character from <A>chars</A> left with less or equal
<A>parameters</A><C>.maxlen</C> possible restrictions,
compute the union of fusion maps allowed by these possibilities.
Otherwise we choose a class <M>C</M> such that the possible restrictions
of a character in <A>chars</A> differ at <M>C</M>,
and compute recursively the union of all allowed fusion maps with image
at <M>C</M> fixed in the set given by the current approximation of the
fusion map.
<P/>
<Example><![CDATA[
gap> subtbl:= CharacterTable( "U3(3)" );;  tbl:= CharacterTable( "J4" );;
gap> fus:= InitFusion( subtbl, tbl );;
gap> TestConsistencyMaps( ComputedPowerMaps( subtbl ), fus,
>        ComputedPowerMaps( tbl ) );
true
gap> fus;
[ 1, 2, 4, 4, [ 5, 6 ], [ 5, 6 ], [ 5, 6 ], 10, [ 12, 13 ], 
  [ 12, 13 ], [ 14, 15, 16 ], [ 14, 15, 16 ], [ 21, 22 ], [ 21, 22 ] ]
gap> ConsiderTableAutomorphisms( fus, AutomorphismsOfTable( tbl ) );
[ 9 ]
gap> fus;
[ 1, 2, 4, 4, [ 5, 6 ], [ 5, 6 ], [ 5, 6 ], 10, 12, [ 12, 13 ], 
  [ 14, 15, 16 ], [ 14, 15, 16 ], [ 21, 22 ], [ 21, 22 ] ]
gap> FusionsAllowedByRestrictions( subtbl, tbl, Irr( subtbl ),
>        Irr( tbl ), fus, rec( maxlen:= 10,
>        contained:= ContainedPossibleCharacters, minamb:= 2,
>        maxamb:= infinity, quick:= false ) );
[ [ 1, 2, 4, 4, 5, 5, 6, 10, 12, 13, 14, 14, 21, 21 ], 
  [ 1, 2, 4, 4, 6, 6, 6, 10, 12, 13, 15, 15, 22, 22 ], 
  [ 1, 2, 4, 4, 6, 6, 6, 10, 12, 13, 16, 16, 22, 22 ] ]
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  unknown.msk                  GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %H  @(#)<M>Id: unknown.msk,v 1.8 2002/04/15 10:02:34 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1999 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Unknowns">
<Heading>Unknowns</Heading>

<Index Subkey="unknown">data type</Index>

Sometimes the result of an operation does not allow further
computations with it.
In many cases, then an error is signalled,
and the computation is stopped.
<P/>
This is not appropriate for some applications in character theory.
For example, if one wants to induce a character of a group to a
supergroup (see&nbsp;<Ref Func="InducedClassFunction"
Label="for the character table of a supergroup"/>)
but the class fusion is only a parametrized map
(see Chapter&nbsp;<Ref Chap="Maps Concerning Character Tables"/>),
there may be values of the induced character which are determined by the
fusion map, whereas other values are not known.
<P/>
For this and other situations, &GAP; provides the data type
<E>unknown</E>.
An object of this type, further on called an <E>unknown</E>,
may stand for any cyclotomic
(see Chapter&nbsp;<Ref Chap="Cyclotomic Numbers"/>),
in particular its family (see&nbsp;<Ref Sect="Families"/>)
is <C>CyclotomicsFamily</C>.
<P/>
Unknowns are parametrized by positive integers.
When a &GAP; session is started, no unknowns exist.
<P/>
The only ways to create unknowns are to call the function
<Ref Oper="Unknown"/> or a function that calls it,
or to do arithmetical operations with unknowns.
<P/>
&GAP; objects containing unknowns will contain <E>fixed</E> unknowns
when they are printed to files, i.e.,
function calls <C>Unknown(</C><M>n</M><C>)</C> instead of
<C>Unknown()</C>.
So be careful to read files printed in different &GAP; sessions,
since there may be the same unknown at different places.
<P/>
The rest of this chapter contains information about the unknown
constructor, the category,
and comparison of and arithmetical operations for unknowns.
More is not known about unknowns in &GAP;.



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Unknown">
<Heading>More about Unknowns</Heading>

<ManSection>
<Oper Name="Unknown" Arg='[n]'/>

<Description>
Called without argument, <Ref Oper="Unknown"/> returns a new unknown
value, i.e., the first one that is larger than all unknowns which exist
in the current &GAP; session.
<P/>
Called with a positive integer <A>n</A>, <Ref Oper="Unknown"/> returns
the <A>n</A>-th unknown; if this did not exist yet, it is created.
</Description>
</ManSection>

<ManSection>
<Var Name="LargestUnknown"/>

<Description>
<Ref Var="LargestUnknown"/> is the largest <A>n</A> that is used in any
<C>Unknown( <A>n</A> )</C> in the current &GAP; session.
This is used in <Ref Oper="Unknown"/> which increments this value
when asked to make a new unknown.
</Description>
</ManSection>

<ManSection>
<Filt Name="IsUnknown" Arg='obj' Type='Category'/>

<Description>
is the category of unknowns in &GAP;.
<Example><![CDATA[
gap> Unknown();  List( [ 1 .. 20 ], i -> Unknown() );;
Unknown(1)
gap> Unknown();   # note that we have already created 21 unknowns.
Unknown(22)
gap> Unknown(2000);  Unknown();
Unknown(2000)
Unknown(2001)
gap> LargestUnknown;
2001
gap> IsUnknown( Unknown );  IsUnknown( Unknown() );
false
true
]]></Example>
</Description>
</ManSection>

<Subsection>
<Heading>Comparison of Unknowns</Heading>

Unknowns can be <E>compared</E> via <C>=</C> and <C>&lt;</C>
with all cyclotomics and with certain other &GAP; objects
(see&nbsp;<Ref Sect="Comparisons"/>).
We have <C>Unknown( <A>n</A> ) >= Unknown( <A>m</A> )</C>
if and only if <C><A>n</A> >= <A>m</A></C> holds,
unknowns are larger than all cyclotomics that are not unknowns.
<P/>
<Example><![CDATA[
gap> Unknown() >= Unknown();  Unknown(2) < Unknown(3);
false
true
gap> Unknown() > 3;  Unknown() > E(3);
true
true
gap> Unknown() > Z(8);  Unknown() > [];
false
false
]]></Example>
</Subsection>

<Subsection>
<Heading>Arithmetical Operations for Unknowns</Heading>

The usual arithmetic operations <C>+</C>, <C>-</C>, <C>*</C> and <C>/</C>
are defined for addition, subtraction, multiplication and division
of unknowns and cyclotomics.
The result will be a new unknown except in one of the following cases.
<P/>
Multiplication with zero yields zero,
and multiplication with one or addition of zero yields the old unknown.
<E>Note</E> that division by an unknown causes an error,
since an unknown might stand for zero.
<P/>
As unknowns are cyclotomics, dense lists of unknowns and other
cyclotomics are row vectors and
they can be added and multiplied in the usual way.
Consequently, lists of such row vectors of equal length are (ordinary)
matrices (see&nbsp;<Ref Func="IsOrdinaryMatrix"/>).
</Subsection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  ctblmono.msk                GAP documentation               Thomas Breuer -->
<!-- %A                                                         & Erzsébet Horváth -->
<!-- %% -->
<!-- %A  @(#)<M>Id: ctblmono.msk,v 1.14 2006/03/07 16:14:25 jjm Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Monomiality Questions">
<Heading>Monomiality Questions</Heading>

This chapter describes functions dealing with the monomiality
of finite (solvable) groups and their characters.
<P/>
All these functions assume <E>characters</E> to be class function objects
as described in Chapter&nbsp;<Ref Chap="Class Functions"/>,
lists of character <E>values</E> are not allowed.
<P/>
The usual <E>property tests</E> of &GAP; that return either <K>true</K>
or <K>false</K> are not sufficient for us.
When we ask whether a group character <M>\chi</M> has a certain property,
such as quasiprimitivity,
we usually want more information than just yes or no.
Often we are interested in the reason <E>why</E> a group character
<M>\chi</M> was proved to have a certain property,
e.g., whether monomiality of <M>\chi</M> was proved by the observation
that the underlying group is nilpotent,
or whether it was necessary to construct a linear character of a subgroup
from which <M>\chi</M> can be induced.
In the latter case we also may be interested in this linear character.
Therefore we need test functions that return a record containing such
useful information.
For example, the record returned by the function
<Ref Attr="TestQuasiPrimitive"/> contains the component
<C>isQuasiPrimitive</C> (which is the known boolean property flag),
and additionally the component <C>comment</C>,
a string telling the reason for the value of the <C>isQuasiPrimitive</C>
component,
and in the case that the argument <M>\chi</M> was <E>not</E>
quasiprimitive also the component <C>character</C>,
which is an irreducible constituent of a nonhomogeneous restriction
of <M>\chi</M> to a normal subgroup.
Besides these test functions there are also the known properties,
e.g., the property <Ref Prop="IsQuasiPrimitive"/>
which will call the attribute <Ref Attr="TestQuasiPrimitive"/>,
and return the value of the <C>isQuasiPrimitive</C> component of the
result.
<P/>
A few words about how to use the monomiality functions seem to be
necessary.
Monomiality questions usually involve computations in many subgroups
and factor groups of a given group,
and for these groups often expensive calculations such as that of
the character table are necessary.
So one should be careful not to construct the same group over and over
again, instead the same group object should be reused,
such that its character table need to be computed only once.
For example,
suppose you want to restrict a character to a normal subgroup
<M>N</M> that was constructed as a normal closure of some group elements,
and suppose that you have already computed with normal subgroups
(by calls to <Ref Attr="NormalSubgroups"/> or
<Ref Attr="MaximalNormalSubgroups"/>)
and their character tables.
Then you should look in the lists of known normal subgroups
whether <M>N</M> is contained,
and if so you can use the known character table.
A mechanism that supports this for normal subgroups is described in
<Ref Sect="Storing Normal Subgroup Information"/>.
<P/>
Also the following hint may be useful in this context.
If you know that sooner or later you will compute the character table of
a group <M>G</M> then it may be advisable to compute it as soon as
possible.
For example, if you need the normal subgroups of <M>G</M> then they can
be computed more efficiently if the character table of <M>G</M> is known,
and they can be stored compatibly to the contained <M>G</M>-conjugacy
classes.
This correspondence of classes list and normal subgroup can be used very
often.

<P/>
Several <E>examples</E> in this chapter use the symmetric group <M>S_4</M>
and the special linear group <M>SL(2,3)</M>.
For running the examples, you must first define the groups,
for example as follows.
<P/>
<Example><![CDATA[
gap> S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );
gap> Sl23:= SL( 2, 3 );;
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:InfoMonomial">
<Heading>InfoMonomial (Info Class)</Heading>

<ManSection>
<InfoClass Name="InfoMonomial"/>

<Description>
Most of the functions described in this chapter print some
(hopefully useful) <E>information</E> if the info level of the info class
<Ref InfoClass="InfoMonomial"/> is at least <M>1</M>,
see&nbsp;<Ref Sect="Info Functions"/> for details.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Character Degrees and Derived Length">
<Heading>Character Degrees and Derived Length</Heading>

<ManSection>
<Attr Name="Alpha" Arg='G'/>

<Description>
For a group <A>G</A>, <Ref Attr="Alpha"/> returns a list
whose <M>i</M>-th entry is the maximal derived length of groups
<M><A>G</A> / \ker(\chi)</M> for <M>\chi \in Irr(<A>G</A>)</M> with
<M>\chi(1)</M> at most the <M>i</M>-th irreducible degree of <A>G</A>.
</Description>
</ManSection>

<ManSection>
<Attr Name="Delta" Arg='G'/>

<Description>
For a group <A>G</A>, <Ref Attr="Delta"/> returns the list
<M>[ 1, alp[2] - alp[1], \ldots, alp[<A>n</A>] - alp[<A>n</A>-1] ]</M>,
where <M>alp = </M><C>Alpha( <A>G</A> )</C>
(see&nbsp;<Ref Func="Alpha"/>).
</Description>
</ManSection>

<ManSection>
<Heading>IsBergerCondition</Heading>
<Prop Name="IsBergerCondition" Arg='G' Label="for a group"/>
<Prop Name="IsBergerCondition" Arg='chi' Label="for a character"/>

<Description>
Called with an irreducible character <A>chi</A> of a group <M>G</M>,
<Ref Prop="IsBergerCondition" Label="for a group"/> returns <K>true</K>
if <A>chi</A> satisfies <M>M' \leq \ker(\chi)</M> for every normal
subgroup <M>M</M> of <M>G</M> with the property that
<M>M \leq \ker(\psi)</M> holds for all <M>\psi \in Irr(G)</M> with
<M>\psi(1) &lt; \chi(1)</M>, and <K>false</K> otherwise.
<P/>
Called with a group <A>G</A>,
<Ref Prop="IsBergerCondition" Label="for a character"/> returns
<K>true</K> if all irreducible characters of <A>G</A> satisfy the
inequality above, and <K>false</K> otherwise.
<P/>
For groups of odd order the result is always <K>true</K> by a theorem of
T.&nbsp;R.&nbsp;Berger (see&nbsp;<Cite Key="Ber76" Where="Thm. 2.2"/>).
<P/>
In the case that <K>false</K> is returned,
<Ref InfoClass="InfoMonomial"/> tells about
a degree for which the inequality is violated.
<P/>
<Example><![CDATA[
gap> Alpha( Sl23 );
[ 1, 3, 3 ]
gap> Alpha( S4 );
[ 1, 2, 3 ]
gap> Delta( Sl23 );
[ 1, 2, 0 ]
gap> Delta( S4 );
[ 1, 1, 1 ]
gap> IsBergerCondition( S4 );
true
gap> IsBergerCondition( Sl23 );
false
gap> List( Irr( Sl23 ), IsBergerCondition );
[ true, true, true, false, false, false, true ]
gap> List( Irr( Sl23 ), Degree );
[ 1, 1, 1, 2, 2, 2, 3 ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Primitivity of Characters">
<Heading>Primitivity of Characters</Heading>

<ManSection>
<Func Name="TestHomogeneous" Arg='chi, N'/>

<Description>
For a group character <A>chi</A> of the group <M>G</M>, say,
and a normal subgroup <A>N</A> of <M>G</M>,
<Ref Func="TestHomogeneous"/> returns a record with information whether
the restriction of <A>chi</A> to <A>N</A> is homogeneous,
i.e., is a multiple of an irreducible character.
<P/>
<A>N</A> may be given also as list of conjugacy class positions
w.r.t.&nbsp;the character table of <M>G</M>.
<P/>
The components of the result are
<P/>
<List>
<Mark><C>isHomogeneous</C></Mark>
<Item>
   <K>true</K> or <K>false</K>,
</Item>
<Mark><C>comment</C></Mark>
<Item>
   a string telling a reason for the value of the
   <C>isHomogeneous</C> component,
</Item>
<Mark><C>character</C></Mark>
<Item>
   irreducible constituent of the restriction,
   only bound if the restriction had to be checked,
</Item>
<Mark><C>multiplicity</C></Mark>
<Item>
   multiplicity of the <C>character</C> component in the
   restriction of <A>chi</A>.
</Item>
</List>
<P/>
<Example><![CDATA[
gap> n:= DerivedSubgroup( Sl23 );;
gap> chi:= Irr( Sl23 )[7];
Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] )
gap> TestHomogeneous( chi, n );
rec( character := Character( CharacterTable( Group(
    [ [ [ 0*Z(3), Z(3) ], [ Z(3)^0, 0*Z(3) ] ], 
      [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3) ] ], 
      [ [ Z(3), Z(3)^0 ], [ Z(3)^0, Z(3)^0 ] ] ]) ),
  [ 1, -1, 1, -1, 1 ] ), comment := "restriction checked",
  isHomogeneous := false, multiplicity := 1 )
gap> chi:= Irr( Sl23 )[4];
Character( CharacterTable( SL(2,3) ), [ 2, 1, 1, -2, -1, -1, 0 ] )
gap> cln:= ClassPositionsOfNormalSubgroup( CharacterTable( Sl23 ), n );
[ 1, 4, 7 ]
gap> TestHomogeneous( chi, cln );
rec( comment := "restricts irreducibly", isHomogeneous := true )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Prop Name="IsPrimitiveCharacter" Arg='chi'/>

<Description>
For a character <A>chi</A> of the group <M>G</M>, say,
<Ref Prop="IsPrimitiveCharacter"/> returns <K>true</K> if <A>chi</A> is
not induced from any proper subgroup, and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> IsPrimitive( Irr( Sl23 )[4] );
true
gap> IsPrimitive( Irr( Sl23 )[7] );
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="TestQuasiPrimitive" Arg='chi'/>
<Prop Name="IsQuasiPrimitive" Arg='chi'/>

<Description>
<Ref Attr="TestQuasiPrimitive"/> returns a record with information about
quasiprimitivity of the group character <A>chi</A>,
i.e., whether <A>chi</A> restricts homogeneously to every normal subgroup
of its group.
The result record contains at least the components
<C>isQuasiPrimitive</C> (with value either <K>true</K> or <K>false</K>)
and <C>comment</C> (a string telling a reason for the value of the
component <C>isQuasiPrimitive</C>).
If <A>chi</A> is not quasiprimitive then there is additionally a
component <C>character</C>, with value an irreducible constituent of a
nonhomogeneous restriction of <A>chi</A>.
<P/>
<Ref Prop="IsQuasiPrimitive"/> returns <K>true</K> or <K>false</K>,
depending on whether the character <A>chi</A> is quasiprimitive.
<P/>
Note that for solvable groups, quasiprimitivity is the same as
primitivity (see&nbsp;<Ref Prop="IsPrimitiveCharacter"/>).
<P/>
<Example><![CDATA[
gap> chi:= Irr( Sl23 )[4];
Character( CharacterTable( SL(2,3) ), [ 2, 1, 1, -2, -1, -1, 0 ] )
gap> TestQuasiPrimitive( chi );
rec( comment := "all restrictions checked", isQuasiPrimitive := true )
gap> chi:= Irr( Sl23 )[7];
Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] )
gap> TestQuasiPrimitive( chi );
rec( character := Character( CharacterTable( Group(
    [ [ [ 0*Z(3), Z(3) ], [ Z(3)^0, 0*Z(3) ] ], 
      [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3) ] ], 
      [ [ Z(3), Z(3)^0 ], [ Z(3)^0, Z(3)^0 ] ] ]) ),
  [ 1, -1, 1, -1, 1 ] ), comment := "restriction checked",
  isQuasiPrimitive := false )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TestInducedFromNormalSubgroup" Arg='chi[, N]'/>
<Prop Name="IsInducedFromNormalSubgroup" Arg='chi'/>

<Description>
<Ref Func="TestInducedFromNormalSubgroup"/> returns a record with
information whether the irreducible character <A>chi</A> of the group
<M>G</M>, say, is induced from a proper normal subgroup of <M>G</M>.
If the second argument <A>N</A> is present,
which must be a normal subgroup of <M>G</M>
or the list of class positions of a normal subgroup of <M>G</M>,
it is checked whether <A>chi</A> is induced from <A>N</A>.
<P/>
The result contains always the components
<C>isInduced</C> (either <K>true</K> or <K>false</K>) and
<C>comment</C> (a string telling a reason for the value of the component
<C>isInduced</C>).
In the <K>true</K> case there is a  component <C>character</C> which
contains a character of a maximal normal subgroup from which <A>chi</A>
is induced.
<P/>
<Ref Prop="IsInducedFromNormalSubgroup"/> returns <K>true</K> if
<A>chi</A> is induced from a proper normal subgroup of <M>G</M>,
and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> List( Irr( Sl23 ), IsInducedFromNormalSubgroup );
[ false, false, false, false, false, false, true ]
gap> List( Irr( S4 ){ [ 1, 3, 4 ] },
>          TestInducedFromNormalSubgroup );
[ rec( comment := "linear character", isInduced := false ), 
  rec( character := Character( CharacterTable( Alt( [ 1 .. 4 ] ) ), 
        [ 1, 1, E(3)^2, E(3) ] ), 
      comment := "induced from component '.character'", 
      isInduced := true ), 
  rec( comment := "all maximal normal subgroups checked", 
      isInduced := false ) ]
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Testing Monomiality">
<Heading>Testing Monomiality</Heading>

A character <M>\chi</M> of a finite group <M>G</M> is called
<E>monomial</E> if <M>\chi</M> is induced from a linear character of a
subgroup of <M>G</M>.
A finite group <M>G</M> is called <E>monomial</E>
(or <E><M>M</M>-group</E>) if each
ordinary irreducible character of <M>G</M> is monomial.
<P/>
<!--
There are &GAP; properties <Ref Prop="IsMonomialGroup"/>
and <C>IsMonomialCharacter</C>,
but one can use <Ref Func="IsMonomial" Label="for groups"> instead.
<Index Key="IsMonomial" Subkey="for groups"><C>IsMonomial</C></Index>
<Index Key="IsMonomial" Subkey="for characters"><C>IsMonomial</C></Index>
-->

<ManSection>
<Heading>TestMonomial</Heading>
<Attr Name="TestMonomial" Arg='chi' Label="for a character"/>
<Attr Name="TestMonomial" Arg='G' Label="for a group"/>
<Oper Name="TestMonomial" Arg='chi, uselattice'
      Label="for a character and a Boolean"/>
<Oper Name="TestMonomial" Arg='G, uselattice'
      Label="for a group and a Boolean"/>

<Description>
Called with a group character <A>chi</A> of a group <A>G</A>,
<Ref Attr="TestMonomial" Label="for a character"/>
returns a record containing information about monomiality of the group
<A>G</A> or the group character <A>chi</A>, respectively.
<P/>
If <Ref Attr="TestMonomial" Label="for a character"/> proves
the character <A>chi</A> to be monomial then the result contains
components <C>isMonomial</C> (with value <K>true</K>),
<C>comment</C> (a string telling a reason for monomiality),
and if it was necessary to compute a linear character from which
<A>chi</A> is induced, also a component <C>character</C>.
<P/>
If <Ref Attr="TestMonomial" Label="for a character"/> proves <A>chi</A>
or <A>G</A> to be nonmonomial
then the value of the component <C>isMonomial</C> is <K>false</K>,
and in the case of <A>G</A> a nonmonomial character is the value
of the component <C>character</C> if it had been necessary to compute it.
<P/>
A Boolean can be entered as the second argument <A>uselattice</A>;
if the value is <K>true</K> then the subgroup lattice of the underlying
group is used if necessary,
if the value is <K>false</K> then the subgroup lattice is used only for
groups of order at most <Ref Var="TestMonomialUseLattice"/>.
The default value of <A>uselattice</A> is <K>false</K>.
<P/>
For a group whose lattice must not be used, it may happen that 
<Ref Attr="TestMonomial" Label="for a group"/> cannot prove or disprove
monomiality; then the result
record contains the component <C>isMonomial</C> with value <C>"?"</C>.
This case occurs in the call for a character <A>chi</A> if and only if
<A>chi</A> is not induced from the inertia subgroup of a component of any
reducible restriction to a normal subgroup.
It can happen that <A>chi</A> is monomial in this situation.
For a group, this case occurs if no irreducible character can be proved
to be nonmonomial, and if no decision is possible for at least one
irreducible character.
<P/>
<Example><![CDATA[
gap> TestMonomial( S4 );
rec( comment := "abelian by supersolvable group", isMonomial := true )
gap> TestMonomial( Sl23 );
rec( comment := "list Delta( G ) contains entry > 1", 
  isMonomial := false )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="TestMonomialUseLattice"/>

<Description>
This global variable controls for which groups the operation
<Ref Oper="TestMonomial" Label="for a group and a Boolean"/> may compute
the subgroup lattice.
The value can be set to a positive integer or <Ref Var="infinity"/>,
the default is <M>1000</M>.
</Description>
</ManSection>

<ManSection>
<Prop Name="IsMonomialNumber" Arg='n'/>

<Description>
For a positive integer <A>n</A>,
<Ref Prop="IsMonomialNumber"/> returns <K>true</K> if every solvable
group of order <A>n</A> is monomial, and <K>false</K> otherwise.
One can also use <C>IsMonomial</C> instead.
<Index Key="IsMonomial" Subkey="for positive integers">
<C>IsMonomial</C></Index>
<P/>
Let <M>\nu_p(n)</M> denote the multiplicity of the prime <M>p</M> as
factor of <M>n</M>, and <M>ord(p,q)</M> the multiplicative order of
<M>p \pmod{q}</M>.
<P/>
Then there exists a solvable nonmonomial group of order <M>n</M>
if and only if one of the following conditions is satisfied.
<P/>
<List>
<Mark>1.</Mark>
<Item>
  <M>\nu_2(n) \geq 2</M> and there is a <M>p</M> such that
  <M>\nu_p(n) \geq 3</M> and <M>p \equiv -1 \pmod{4}</M>,
</Item>
<Mark>2.</Mark>
<Item>
  <M>\nu_2(n) \geq 3</M> and there is a <M>p</M> such that
  <M>\nu_p(n) \geq 3</M> and <M>p \equiv  1 \pmod{4}</M>,
</Item>
<Mark>3.</Mark>
<Item>
  there are odd prime divisors <M>p</M> and <M>q</M> of <M>n</M>
  such that <M>ord(p,q)</M> is even and <M>ord(p,q) &lt; \nu_p(n)</M>
  (especially <M>\nu_p(n) \geq 3</M>),
</Item>
<Mark>4.</Mark>
<Item>
  there is a prime divisor <M>q</M> of <M>n</M> such that
  <M>\nu_2(n) \geq 2 ord(2,q) + 2</M>
  (especially <M>\nu_2(n) \geq 4</M>),
</Item>
<Mark>5.</Mark>
<Item>
  <M>\nu_2(n) \geq 2</M> and there is a <M>p</M> such that
  <M>p \equiv  1 \pmod{4}</M>, <M>ord(p,q)</M> is odd,
  and <M>2 ord(p,q) &lt; \nu_p(n)</M>
  (especially <M>\nu_p(n) \geq 3</M>).
</Item>
</List>
<P/>
These five possibilities correspond to the five types of solvable minimal
nonmonomial groups (see&nbsp;<Ref Func="MinimalNonmonomialGroup"/>)
that can occur as subgroups and factor groups of groups of order
<A>n</A>.
<P/>
<Example><![CDATA[
gap> Filtered( [ 1 .. 111 ], x -> not IsMonomial( x ) );
[ 24, 48, 72, 96, 108 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>TestMonomialQuick</Heading>
<Attr Name="TestMonomialQuick" Arg='chi' Label="for a character"/>
<Attr Name="TestMonomialQuick" Arg='G' Label="for a group"/>

<Description>
<Ref Attr="TestMonomialQuick" Label="for a group"/> does some cheap tests
whether the irreducible character <A>chi</A> or the group <A>G</A>,
respectively, is monomial.
Here <Q>cheap</Q> means in particular that no computations of character
tables are involved.
The return value is a record with components
<List>
<Mark><C>isMonomial</C></Mark>
<Item>
   either <K>true</K> or <K>false</K> or the string <C>"?"</C>,
   depending on whether (non)monomiality could be proved, and
</Item>
<Mark><C>comment</C></Mark>
<Item>
   a string telling the reason for the value of the
   <C>isMonomial</C> component.
</Item>
</List>
<P/>
A group <A>G</A> is proved to be monomial by
<Ref Attr="TestMonomialQuick" Label="for a group"/> if
<A>G</A> is nilpotent or Sylow abelian by supersolvable,
or if <A>G</A> is solvable and its order is not divisible by the third
power of a prime,
Nonsolvable groups are proved to be nonmonomial by
<Ref Attr="TestMonomialQuick" Label="for a group"/>.
<P/>
An irreducible character <A>chi</A> is proved to be monomial if
it is linear, or if its codegree is a prime power,
or if its group knows to be monomial,
or if the factor group modulo the kernel can be proved to be monomial by
<Ref Attr="TestMonomialQuick" Label="for a character"/>.
<P/>
<Example><![CDATA[
gap> TestMonomialQuick( Irr( S4 )[3] );
rec( comment := "whole group is monomial", isMonomial := true )
gap> TestMonomialQuick( S4 );
rec( comment := "abelian by supersolvable group", isMonomial := true )
gap> TestMonomialQuick( Sl23 );
rec( comment := "no decision by cheap tests", isMonomial := "?" )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>TestSubnormallyMonomial</Heading>
<Attr Name="TestSubnormallyMonomial" Arg='G' Label="for a group"/>
<Attr Name="TestSubnormallyMonomial" Arg='chi' Label="for a character"/>
<Prop Name="IsSubnormallyMonomial" Arg='G' Label="for a group"/>
<Prop Name="IsSubnormallyMonomial" Arg='chi' Label="for a character"/>

<Description>
A character of the group <M>G</M> is called <E>subnormally monomial</E>
(SM for short) if it is induced from a linear character of a subnormal
subgroup of <M>G</M>.
A group <M>G</M> is called SM if all its irreducible characters are SM.
<P/>
<Ref Attr="TestSubnormallyMonomial" Label="for a group"/> returns
a record with information whether the group <A>G</A> or the irreducible
character <A>chi</A> of <A>G</A> is SM.
<P/>
The result has the components
<C>isSubnormallyMonomial</C> (either <K>true</K> or <K>false</K>) and
<C>comment</C> (a string telling a reason for the value of the component
<C>isSubnormallyMonomial</C>);
in the case that the <C>isSubnormallyMonomial</C> component has value
<K>false</K> there is also a component <C>character</C>,
with value an irreducible character of <M>G</M> that is not SM.
<P/>
<Ref Prop="IsSubnormallyMonomial" Label="for a group"/> returns
<K>true</K> if the group <A>G</A> or the group character <A>chi</A>
is subnormally monomial, and <K>false</K> otherwise.
<P/>
<Example><![CDATA[
gap> TestSubnormallyMonomial( S4 );
rec( character := Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 
     ] ), comment := "found non-SM character", 
  isSubnormallyMonomial := false )
gap> TestSubnormallyMonomial( Irr( S4 )[4] );
rec( comment := "all subnormal subgroups checked", 
  isSubnormallyMonomial := false )
gap> TestSubnormallyMonomial( DerivedSubgroup( S4 ) );
rec( comment := "all irreducibles checked", 
  isSubnormallyMonomial := true )
]]></Example>
</Description>
</ManSection>

<ManSection>
<Heading>TestRelativelySM</Heading>
<Attr Name="TestRelativelySM" Arg='G' Label="for a group"/>
<Attr Name="TestRelativelySM" Arg='chi' Label="for a character"/>
<Oper Name="TestRelativelySM" Arg='G, N'
      Label="for a group and a normal subgroup"/>
<Oper Name="TestRelativelySM" Arg='chi, N'
      Label="for a character and a normal subgroup"/>
<Prop Name="IsRelativelySM" Arg='G' Label="for a group"/>
<Prop Name="IsRelativelySM" Arg='chi' Label="for a character"/>

<Description>
In the first two cases,
<Ref Attr="TestRelativelySM" Label="for a group"/> returns a record with
information whether the argument, which must be a SM group <A>G</A> or
an irreducible character <A>chi</A> of a SM group <M>G</M>,
is relatively SM with respect to every normal subgroup of <A>G</A>.
<P/>
In the second two cases, a normal subgroup <A>N</A> of <A>G</A> is the
second argument.
Here
<Ref Oper="TestRelativelySM" Label="for a group and a normal subgroup"/>
returns a record with information whether
the first argument is relatively SM with respect to <A>N</A>,
i.e, whether there is a subnormal subgroup <M>H</M> of <M>G</M> that
contains <A>N</A> such that the character <A>chi</A>
resp.&nbsp;every irreducible character of <M>G</M> is induced from a
character <M>\psi</M> of <M>H</M> such that the restriction of
<M>\psi</M> to <A>N</A> is irreducible.
<P/>
The result record has the components
<C>isRelativelySM</C> (with value either <K>true</K> or <K>false</K>) and
<C>comment</C> (a string that describes a reason).
If the argument is a group <A>G</A> that is not relatively SM
with respect to a normal subgroup then additionally the component
<C>character</C> is bound,
with value a not relatively SM character of such a normal subgroup.
<P/>
<Ref Prop="IsRelativelySM" Label="for a group"/> returns <K>true</K>
if the SM group <A>G</A> or the irreducible character <A>chi</A>
of the SM group <A>G</A> is relatively SM with respect to every
normal subgroup of <A>G</A>,
and <K>false</K> otherwise.
<P/>
<E>Note</E> that it is <E>not</E> checked whether <A>G</A> is SM.
<P/>
<Example><![CDATA[
gap> IsSubnormallyMonomial( DerivedSubgroup( S4 ) );
true
gap> TestRelativelySM( DerivedSubgroup( S4 ) );
rec( 
  comment := "normal subgroups are abelian or have nilpotent factor gr\
oup", isRelativelySM := true )
]]></Example>
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Minimal Nonmonomial Groups">
<Heading>Minimal Nonmonomial Groups</Heading>

<ManSection>
<Prop Name="IsMinimalNonmonomial" Arg='G'/>

<Description>
A group <A>G</A> is called <E>minimal nonmonomial</E> if it is
nonmonomial, and all proper subgroups and factor groups are monomial.
<P/>
<Example><![CDATA[
gap> IsMinimalNonmonomial( Sl23 );  IsMinimalNonmonomial( S4 );
true
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MinimalNonmonomialGroup" Arg='p, factsize'/>

<Description>
is a solvable minimal nonmonomial group described by the parameters
<A>factsize</A> and <A>p</A> if such a group exists,
and <K>false</K> otherwise.
<P/>
Suppose that the required group <M>K</M> exists.
Then <A>factsize</A> is the size of the Fitting factor <M>K / F(K)</M>,
and this value is 4, 8, an odd prime, twice an odd prime,
or four times an odd prime.
In the case that <A>factsize</A> is twice an odd prime,
the centre <M>Z(K)</M> is cyclic of order <M>2^{{<A>p</A>+1}}</M>.
In all other cases <A>p</A> is the (unique) prime that divides
the order of <M>F(K)</M>.
<P/>
The solvable minimal nonmonomial groups were classified by van der Waall,
see&nbsp;<Cite Key="vdW76"/>.
<P/>
<Example><![CDATA[
gap> MinimalNonmonomialGroup(  2,  3 ); # the group SL(2,3)
2^(1+2):3
gap> MinimalNonmonomialGroup(  3,  4 );
3^(1+2):4
gap> MinimalNonmonomialGroup(  5,  8 );
5^(1+2):Q8
gap> MinimalNonmonomialGroup( 13, 12 );
13^(1+2):2.D6
gap> MinimalNonmonomialGroup(  1, 14 );
2^(1+6):D14
gap> MinimalNonmonomialGroup(  2, 14 );
(2^(1+6)Y4):D14
]]></Example>
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  gappkg.msk                GAP documentation             Werner Nickel -->
<!-- %W                                                       Alexander Hulpke -->
<!-- %% -->
<!-- %H  @(#)<M>Id: gappkg.msk,v 1.18 2004/01/26 10:09:20 gap Exp </M> -->
<!-- %% -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="GAP Packages">
<Heading>Using GAP Packages</Heading>

<Index>package</Index>
The  functionality  of  &GAP;  can  be  extended  by  loading  &GAP;
packages. 
&GAP; distribution already contains all currently redistributed with 
&GAP; packages in the <F>&GAPDIRNAME;/pkg</F> directory.
<P/>
&GAP; packages are written by (groups  of) &GAP; users which may not
be  members  of the  &GAP;  developer  team. The  responsibility  and
copyright of a &GAP; package remains with the original author(s).
<P/>
&GAP;  packages  have  their  own  documentation  which  is  smoothly
integrated into the &GAP; help system.
<P/>
All  &GAP;  users   who  develop  new  code  are   invited  to  share
the  results  of their  efforts  with  other  &GAP; users  by  making
the  code  and its  documentation  available  in  form of  a  package.
Information how  to do  this is  available from  the &GAP;  Web pages
(<URL>http://www.gap-system.org</URL>)
and in the &GAP; package <Package>Example</Package>
(see <URL>http://www.gap-system.org/Packages/example.html</URL>).
There  are  possibilities  to get  a  package  distributed together  with
&GAP;  and it  is possible  to submit  a package  to a formal refereeing
process.
<P/>
In this chapter we describe how to use existing packages.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Installing a GAP Package">
<Heading>Installing a GAP Package</Heading>

Before a  package can be  used it must  be installed. With  a standard
installation of  &GAP; there should  be all currently redistributed with 
&GAP; packages already available. But since &GAP; packages are released 
independently of the main  &GAP; system  it  may be  sensible to  upgrade  
or install new packages between upgrades of your &GAP; installation.
<P/>
A package consists of a collection  of files within a single directory
that must  be a subdirectory of  the <F>pkg</F>  directory   in one  of the
&GAP; root directories, see <Ref Sect="GAP Root Directories"/>. (If you don't
have access  to the <F>pkg</F>  directory in your main  &GAP; installation
you can add private root directories as explained in that section.)
<P/>
Whenever  you  get from  somewhere  an  archive  of a  &GAP;  package
it  should be  accompanied  with  a <F>README</F>  file  that explains  its
installation.  Some packages  just  consist  of  &GAP;  code and  the
installation  is  done  by  unpacking   the  archive  in  one  of  the
places  described above.  There are  also packages  that need  further
installation steps,  there may be  for example some  external programs
which  have  to  be  compiled  (this is  often  done  by  just  saying
<C>./configure; make</C>  inside the unpacked package  directory, but check
the individual <F>README</F> files). Note that if you use Windows you may not 
be able to use some or all external binaries.
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Loading a GAP Package">
<Heading>Loading a GAP Package</Heading>

<Index>automatic loading of GAP packages</Index>
<Index>disable automatic loading</Index>
Some &GAP; packages are prepared for <E>automatic loading</E>,
that is they will be loaded automatically with &GAP;,
others must in each case be separately loaded by a call to
<Ref Func="LoadPackage"/>.

<ManSection>
<Func Name="LoadPackage" Arg='name[, version][, banner]'/>

<Description>
loads the &GAP; package with name <A>name</A>.
<P/>
As an example, the following loads the &GAP; package
<Package>SONATA</Package> (case insensitive) which provides methods for the
construction and analysis of finite nearrings:
<P/>
<Log><![CDATA[
gap> LoadPackage("sonata");
... some more lines with package banner(s) ...
true
]]></Log>
<P/>
The package name may be appropriately abbreviated. For example,
<C>LoadPackage("semi");</C> will load the <Package>Semigroups</Package>
package, and <C>LoadPackage("d");</C> will load the
<Package>DESIGN</Package> package. If the abbreviation can not be uniquely
completed, further suggestions will be offered.
<P/>
If the optional version string <A>version</A> is given,
the package will only be loaded in a version number at least as large as
<A>version</A>,
or equal to <A>version</A> if its first character is <C>=</C>
(see&nbsp;<Ref Func="CompareVersionNumbers"/>).
The argument <A>name</A> is case insensitive.
<P/>
<Ref Func="LoadPackage"/> will return <K>true</K> if the package has been
successfully loaded
and will return <K>fail</K> if the package could not be loaded.
The latter may be the case if the package is not installed, if necessary
binaries have not been compiled, or if the version number of the
available version is too small.
If the package cannot be loaded, <Ref Func="TestPackageAvailability"/>
can be used to find the reasons. Also,
<Ref Func="DisplayPackageLoadingLog"/> can be used to find out more
about the failure reasons. To see the problems directly, one can
change the verbosity using the user preference
<C>InfoPackageLoadingLevel</C>, see <Ref InfoClass="InfoPackageLoading"/>
for details.
<P/>
If the package <A>name</A> has already been loaded in a version number
at least or equal to <A>version</A>, respectively,
<Ref Func="LoadPackage"/> returns <K>true</K> without doing anything
else.
<P/>
The argument <A>name</A> may be the prefix of a package name.
If no package with name <A>name</A> is installed,
the behaviour is as follows.
If <A>name</A> is the prefix of exactly one name of an installed package
then <Ref Func="LoadPackage"/> is called with this name;
if the names of several installed packages start with <A>name</A> then
the these names are printed, and <Ref Func="LoadPackage"/> returns
<K>fail</K>.
Thus the names of <E>all</E> installed packages can be shown by calling
<Ref Func="LoadPackage"/> with an empty string.
<P/>
If the optional argument <A>banner</A> is present then it must be either
<K>true</K> or <K>false</K>;
in the latter case, the effect is that no package banner is printed.
<P/>
After a package has been loaded its code and documentation should be
available as other parts of the &GAP; library are.
<P/>
When &GAP; is started then some packages are loaded automatically.
These are the packages listed in
<C>GAPInfo.Dependencies.NeededOtherPackages</C> and
(if this is not disabled, see below)
<C>UserPreference( "PackagesToLoad" )</C>.
<P/>
A &GAP; package may also install only its documentation automatically
but still need loading by <Ref Func="LoadPackage"/>.
In this situation the online
help displays <C>(not loaded)</C> in the header lines of the manual
pages belonging to this &GAP; package.
<P/>
If for some reason you don't want certain packages to be automatically
loaded, &GAP; provides three levels for disabling autoloading:
<P/>
<Index Key="NOAUTO"><C>NOAUTO</C></Index>
The autoloading of specific packages can be overwritten <E>for the whole
&GAP; installation</E> by putting a file <F>NOAUTO</F> into a <F>pkg</F>
directory that contains lines with the names of packages which should
not be automatically loaded.
<P/>
Furthermore, <E>individual users</E> can disable the autoloading of
specific packages by putting the names of these packages into the list
that is assigned to the user preference <Q>ExcludeFromAutoload</Q>,
for example in the user's <F>gap.ini</F> file
(see&nbsp;<Ref Subsect="subsect:gap.ini file"/>).
<P/>
Using the <C>-A</C> command line option when starting up &GAP;
(see&nbsp;<Ref Sect="Command Line Options"/>),
automatic loading of packages is switched off
<E>for this &GAP; session</E>.
<P/>
In any of the above three cases, the packages listed in
<C>GAPInfo.Dependencies.NeededOtherPackages</C> are still loaded
automatically, and an error is signalled if not all of these packages
are available.
<P/>
See <Ref Func="SetPackagePath"/> for a possibility to force that a
prescribed package version will be loaded.
See also <Ref Func="ExtendRootDirectories"/> for a possibility to
add directories containing packages after &GAP; has been started.
</Description>
</ManSection>

<ManSection>
<Func Name="SetPackagePath" Arg='pkgname, pkgpath'/>

<Description>
Let <A>pkgname</A> and <A>pkgpath</A> be strings denoting the name of a
&GAP; package and the path to a directory where a version of this package
can be found (i.&nbsp;e., calling <Ref Func="Directory"/> with the
argument <A>pkgpath</A> will yield a directory that contains the file
<F>PackageInfo.g</F> of the package).
<P/>
If the package <A>pkgname</A> is already loaded with an installation path
different from <A>pkgpath</A> then <Ref Func="SetPackagePath"/> signals
an error.
If the package <A>pkgname</A> is not yet loaded then
<Ref Func="SetPackagePath"/> erases the information about available
versions of the package <A>pkgname</A>, and stores the record that is
contained in the <F>PackageInfo.g</F> file at <A>pkgpath</A> instead,
such that only the version installed at <A>pkgpath</A> can be loaded
with <Ref Func="LoadPackage"/>.
<P/>
This function can be used to force &GAP; to load a particular version of
a package, although newer versions of the package might be available.
</Description>
</ManSection>

<ManSection>
<Func Name="ExtendRootDirectories" Arg='paths'/>

<Description>
Let <A>paths</A> be a list of strings that denote paths to intended
&GAP; root directories (see <Ref Sect="GAP Root Directories"/>).
The function <Ref Func="ExtendRootDirectories"/> adds these paths to
the global list <C>GAPInfo.RootPaths</C> and calls the initialization of
available &GAP; packages,
such that later calls to <Ref Func="LoadPackage"/> will find the &GAP;
packages that are contained in <F>pkg</F> subdirectories of the
directories given by <A>paths</A>.
<P/>
Note that the purpose of this function is to make &GAP; packages in the
given directories available.
It cannot be used to influence the start of &GAP;,
because the &GAP; library is loaded before
<Ref Func="ExtendRootDirectories"/> can be called
(and because <C>GAPInfo.RootPaths</C> is not used for reading the
&GAP; library).
</Description>
</ManSection>

<ManSection>
<Func Name="DisplayPackageLoadingLog" Arg='[severity]'/>
<InfoClass Name="InfoPackageLoading"/>
<Var Name="PACKAGE_ERROR"/>
<Var Name="PACKAGE_WARNING"/>
<Var Name="PACKAGE_INFO"/>
<Var Name="PACKAGE_DEBUG"/>
<Func Name="LogPackageLoadingMessage" Arg='severity, message[, name]'/>

<Description>
Whenever &GAP; considers loading a package, log messages are collected
in a global list.
The messages for the current &GAP; session can be displayed with
<Ref Func="DisplayPackageLoadingLog"/>.
To each message, a <Q>severity</Q> is assigned,
which is one of <Ref Var="PACKAGE_ERROR"/>, <Ref Var="PACKAGE_WARNING"/>,
<Ref Var="PACKAGE_INFO"/>, <Ref Var="PACKAGE_DEBUG"/>,
in increasing order.
The function <Ref Func="DisplayPackageLoadingLog"/> shows only the
messages whose severity is at most <A>severity</A>,
the default for <A>severity</A> is <Ref Var="PACKAGE_WARNING"/>.
<P/>
The intended meaning of the severity levels is as follows.
<P/>
<List>
<Mark>PACKAGE_ERROR</Mark>
<Item>
  should be used whenever &GAP; will run into an error
  during package loading,
  where the reason of the error shall be documented in the global list.
</Item>
<Mark>PACKAGE_WARNING</Mark>
<Item>
  should be used whenever &GAP; has detected a reason why a package
  cannot be loaded,
  and where the message describes how to solve this problem,
  for example if a package binary is missing.
</Item>
<Mark>PACKAGE_INFO</Mark>
<Item>
  should be used whenever &GAP; has detected a reason why a package
  cannot be loaded,
  and where it is not clear how to solve this problem,
  for example if the package is not compatible with other installed
  packages.
</Item>
<Mark>PACKAGE_DEBUG</Mark>
<Item>
  should be used for other messages reporting what &GAP; does when it
  loads packages (checking dependencies, reading files, etc.).
  One purpose is to record in which order packages have been considered
  for loading or have actually been loaded.
</Item>
</List>
<P/>
The log messages are created either by the functions of &GAP;'s
package loading mechanism or in the code of your package, for example
in the <C>AvailabilityTest</C> function of the package's
<F>PackageInfo.g</F> file (see <Ref Sect="The PackageInfo.g File"/>),
using <Ref Func="LogPackageLoadingMessage"/>.
The arguments of this function are <A>severity</A>
(which must be one of the above severity levels),
<A>message</A> (which must be either a string or a list of strings),
and optionally <A>name</A> (which must be the name of the package to
which the message belongs).
The argument <A>name</A> is not needed if the function is called from
a call of a package's <C>AvailabilityTest</C> function
(see <Ref Sect="The PackageInfo.g File"/>)
or is called from a package file that is read from <F>init.g</F> or
<F>read.g</F>; in these cases, the name of the current package
(stored in the record <C>GAPInfo.PackageCurrent</C>) is taken.
According to the above list, the <A>severity</A> argument of
<Ref Func="LogPackageLoadingMessage"/> calls in a package's
<C>AvailabilityTest</C> function is either <Ref Var="PACKAGE_WARNING"/>
or <Ref Var="PACKAGE_INFO"/>.
<P/>
If you want to see the log messages already during the package loading
process, you can set the level of the info class
<Ref Var="InfoPackageLoading"/> to one of the severity values
listed above;
afterwards the messages with at most this severity are shown immediately
when they arise.
In order to make this work already for autoloaded packages,
you can call <C>SetUserPreference("InfoPackageLoadingLevel",
<A>lev</A>);</C> to set the desired severity level <A>lev</A>.
This can for example be done in your <F>gap.ini</F> file,
see Section <Ref Subsect="subsect:gap.ini file"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Functions for GAP Packages">
<Heading>Functions for GAP Packages</Heading>

The following functions are mainly used in files contained in  a
package and not by users of a package.

<ManSection>
<Func Name="ReadPackage" Arg='[name, ]file'/>
<Func Name="RereadPackage" Arg='[name, ]file'/>

<Description>
Called with two strings <A>name</A> and <A>file</A>,
<Ref Func="ReadPackage"/> reads the file <A>file</A>
of the &GAP; package <A>name</A>,
where <A>file</A> is given as a path relative to the home directory
of <A>name</A>. Note that <A>file</A> is read in the namespace
of the package, see Section <Ref Sect="Namespaces"/> for details.
<P/>
If only one argument <A>file</A> is given,
this should be the path of a file relative to the <F>pkg</F> subdirectory
of &GAP; root paths (see&nbsp;<Ref Sect="GAP Root Directories"/>).
Note that in this case, the package name is assumed to be equal to the
first part of <A>file</A>,
<E>so the one argument form is not recommended</E>.
<P/>
The absolute path is determined as follows.
If the package in question has already been loaded then the file in the
directory of the loaded version is read.
If the package is available but not yet loaded then the directory given
by <Ref Func="TestPackageAvailability"/> is used, without
prescribed version number.
(Note that the <Ref Func="ReadPackage"/> call does <E>not</E> force the
package to be loaded.)
<P/>
If the file is readable then <K>true</K> is returned,
otherwise <K>false</K>.
<P/>
Each of <A>name</A> and <A>file</A> should be a string.
The <A>name</A> argument is case insensitive.
<P/>
<Ref Func="RereadPackage"/> does the same as <Ref Func="ReadPackage"/>,
except that also read-only global variables are overwritten
(cf.&nbsp;<Ref Func="Reread"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="TestPackageAvailability" Arg='name[, version][, checkall]'/>

<Description>
For strings <A>name</A> and <A>version</A>, this function tests
whether the  &GAP; package <A>name</A> is available for loading in a
version that is at least <A>version</A>, or equal to <A>version</A>
if the first character of <A>version</A> is <C>=</C>
(see <Ref Func="CompareVersionNumbers"/> for further
details about version numbers).
<P/>
The result is <K>true</K> if the package is already loaded,
<K>fail</K> if it is not available,
and the string denoting the &GAP; root path where the package resides
if it is available, but not yet loaded.
So the package <A>name</A> is available if the result of
<Ref Func="TestPackageAvailability"/> is not equal to <K>fail</K>.
<P/>
If the optional argument <A>checkall</A> is <K>true</K> then all
dependencies are checked, even if some have turned out to be not
satisfied.
This is useful when one is interested in the reasons why the package
<A>name</A> cannot be loaded.
In this situation, calling first <Ref Func="TestPackageAvailability"/>
and then <Ref Func="DisplayPackageLoadingLog"/> with argument
<Ref Var="PACKAGE_INFO"/> will give an overview of these reasons.
<P/>
You should <E>not</E> call <Ref Func="TestPackageAvailability"/> in
the test function of a package (the value of the component
<C>AvailabilityTest</C> in the <F>PackageInfo.g</F> file of the package,
see <Ref Sect="The PackageInfo.g File"/>),
because <Ref Func="TestPackageAvailability"/> calls this test function.
<!-- otherwise we run into an infinite recursion -->
<P/>
The argument <A>name</A> is case insensitive.
</Description>
</ManSection>

<ManSection>
<Func Name="InstalledPackageVersion" Arg='name'/>

<Description>
If the &GAP; package with name <A>name</A> has already been loaded then
<Ref Func="InstalledPackageVersion"/> returns the string denoting
the version number of this version of the package.
If the package is available but has not yet been loaded then the version
number string for that version of the package that currently would be
loaded.
(Note that loading <E>another</E> package might force loading
another version of the package <A>name</A>,
so the result of <Ref Func="InstalledPackageVersion"/> will be
different afterwards.)
If the package is not available then <K>fail</K> is returned.
<P/>
The argument <A>name</A> is case insensitive.
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoriesPackageLibrary" Arg='name[, path]'/>

<Description>
takes the string <A>name</A>, a name of a &GAP; package,
and returns a list of directory objects for those sub-directory/ies
containing the library functions of this &GAP; package,
for the version that is already loaded
or is currently going to be loaded
or would be the first version &GAP; would try to load if no other version
is explicitly prescribed.
(If the package <A>name</A> is not yet loaded then we cannot guarantee
that the returned directories belong to a version that really can be
loaded.)
<P/>
The default is that the library functions are in the subdirectory
<F>lib</F> of the &GAP; package's home directory.
If this is not the case, then the second argument <A>path</A> needs to be
present and must be a string that is a path name relative to the home
directory  of the &GAP; package with name <A>name</A>.
<P/>
Note that <Ref Func="DirectoriesPackageLibrary"/> is likely to be called
in the <C>AvailabilityTest</C> function in the package's
<F>PackageInfo.g</F> file (see <Ref Sect="The PackageInfo.g File"/>).
<P/>
As an example, the following returns a directory object for the library
functions of the &GAP; package <Package>Example</Package>:
<P/>
<Log><![CDATA[
gap> DirectoriesPackageLibrary( "Example", "gap" );
[ dir("/home/werner/gap/4.0/pkg/example/gap/") ]
]]></Log>
<P/>
Observe that we needed the second argument <C>"gap"</C> here,
since <Package>Example</Package>'s library functions are in the
subdirectory <F>gap</F> rather than <F>lib</F>.
<P/>
In order to find a subdirectory deeper than one level in a package
directory, the second argument is again necessary whether or not the
desired subdirectory relative to the package's directory begins with
<F>lib</F>.
The directories in <A>path</A> should be separated by <C>/</C> (even on
systems, like Windows, which use <C>\</C> as the directory separator).
For example, suppose there is a package <C>somepackage</C> with a
subdirectory <F>m11</F> in the directory <F>data</F>,
then we might expect the following:
<P/>
<Log><![CDATA[
gap> DirectoriesPackageLibrary( "somepackage", "data/m11" );
[ dir("/home/werner/gap/4.0/pkg/somepackage/data/m11") ]
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="DirectoriesPackagePrograms" Arg='name'/>

<Description>
<Index Key="GAPInfo.Architecture"><C>GAPInfo.Architecture</C></Index>
returns a list of the <C>bin/</C><A>architecture</A> subdirectories
of all packages <A>name</A> where <A>architecture</A> is the architecture
on which &GAP; has been compiled
(this can be accessed as <C>GAPInfo.Architecture</C>,
see <Ref Var="GAPInfo"/>)
and the version of the installed package coincides with
the version of the package <A>name</A> that is already loaded
or is currently going to be loaded
or would be the first version &GAP; would try to load if no other version
is explicitly prescribed.
(If the package <A>name</A> is not yet loaded then we cannot guarantee
that the returned directories belong to a version that really can be
loaded.)
<P/>
Note that <Ref Func="DirectoriesPackagePrograms"/> is likely to be called
in the <C>AvailabilityTest</C> function in the package's
<F>PackageInfo.g</F> file (see <Ref Sect="The PackageInfo.g File"/>).
<P/>
The directories returned by <Ref Func="DirectoriesPackagePrograms"/>
are the place where external binaries of the &GAP; package <A>name</A>
for the current package version and the current architecture
should be located.
<P/>
<Log><![CDATA[
gap> DirectoriesPackagePrograms( "nq" );
[ dir("/home/gap/4.0/pkg/nq/bin/x86_64-unknown-linux-gnu-gcc/64-bit/"),
  dir("/home/gap/4.0/pkg/nq/bin/x86_64-unknown-linux-gnu-gcc/") ]
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="CompareVersionNumbers" Arg='supplied, required[, "equal"]'/>

<Description>
A version number is a string which contains nonnegative integers separated
by non-numeric characters. Examples of valid version numbers are for
example:
<P/>
<Log><![CDATA[
"1.0"   "3.141.59"  "2-7-8.3" "5 release 2 patchlevel 666"
]]></Log>
<P/>
<Ref Func="CompareVersionNumbers"/>
compares two version numbers, given as strings.
They are split at non-digit characters,
the resulting integer lists are compared lexicographically.
The routine tests whether <A>supplied</A> is at least as large as
<A>required</A>, and returns <K>true</K> or <K>false</K> accordingly.
A version number ending in <C>dev</C> is considered to be infinite.
</Description>
</ManSection>

<ManSection>
<Func Name="IsPackageMarkedForLoading" Arg='name, version'/>

<Description>
This function can be used in the code of a package <M>A</M>, say,
for testing whether the package <A>name</A> in version <A>version</A>
will be loaded after the <Ref Func="LoadPackage"/> call for the package
<M>A</M> has been executed.
This means that the package <A>name</A> had been loaded before,
or has been (directly or indirectly) requested as a needed or suggested
package of the package <M>A</M> or of a package whose loading
requested that <M>A</M> was loaded.
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareAutoreadableVariables"
 Arg='pkgname, filename, varlist'/>

<Description>
Let <A>pkgname</A> be the name of a package,
let <A>filename</A> be the name of a file relative to the home directory
of this package,
and let <A>varlist</A> be a list of strings that are the names of global
variables which get bound when the file is read.
<Ref Func="DeclareAutoreadableVariables"/> notifies the names in
<A>varlist</A> such that the first attempt to access one of the variables
causes the file to be read.
</Description>
</ManSection>


<Subsection Label="Kernel modules">
<Heading>Kernel modules in &GAP; packages</Heading>

<Index Key="gac"><C>gac</C></Index>
If the package has a kernel module, then it can be compiled using the 
<Package>gac</Package> script. A kernel module is implemented in C
and follows certain conventions to comply with the &GAP; kernel interface,
which we plan to document later. In the meantime, we advice to get in touch
with &GAP; developers if you plan to develop such a package.
<P/>
<!-- %%  The gac script works only on UNIX systems. It was written by -->
<!-- %%  Ferenc&nbsp;R{\'a}k{\'o}czi and Martin Sch{\"o}nert. -->
To use the <Package>gac</Package> script to produce dynamically loadable 
modules, call it with the <C>-d</C> option, for example:
<P/>
<Log><![CDATA[
$ gap4/bin/i386-ibm-linux-gcc2/gac -d test.c
]]></Log>
<P/>
This will produce a file <File>test.so</File>, which then can be loaded into &GAP;
with <Ref Func="LoadDynamicModule"/>.

</Subsection>

<ManSection>
<Func Name="LoadDynamicModule" Arg='filename[, crc]'/>

<Description>
To load a compiled file, the command <Ref Func="LoadDynamicModule"/> is used.
This command loads <A>filename</A> as module. If given, the CRC checksum 
<A>crc</A> must match the value of the module (see <Ref Sect="CrcFile"/>).
<P/>
<Log><![CDATA[
gap> LoadDynamicModule("./test.so");
gap> CrcFile("test.so");
2906458206
gap> LoadDynamicModule("./test.so",1);
Error, <crc> mismatch (or no support for dynamic loading) called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
gap> LoadDynamicModule("./test.so",2906458206);
]]></Log>
<P/>
On some operating systems, once you have loaded a dynamic module with
a certain filename, loading another with the same filename will have
no effect, even if the file on disk has changed.
</Description>
</ManSection>

<Subsection Label="The PackageInfo.g File">
<Heading>The PackageInfo.g File</Heading>

Each package has the file <F>PackageInfo.g</F> which
contains meta-information about  the package
(package  name,  version,  author(s),  relations  to  other  packages,
homepage, download archives, banner, etc.). This file is used by the package
loading mechanism and also for the distribution of a package to other
users.
</Subsection>

<ManSection>
<Func Name="ValidatePackageInfo" Arg='info'/>

<Description>
This function is intended to support package authors who create or
modify <F>PackageInfo.g</F> files.
(It is <E>not</E> called when these files are read during the startup of
&GAP; or when packages are actually loaded.)
<P/>
The argument <A>info</A> must be either a record as is contained in a
<F>PackageInfo.g</F> file
or a a string which describes the path to such a file.
The result is <K>true</K> if the record or the contents of the file,
respectively, has correct format, and <K>false</K> otherwise;
in the latter case information about the incorrect components is printed.
<P/>
Note that the components used for package loading are checked as well as
the components that are needed for composing the package overview web
page or for updating the package archives.
<P/>
If <A>info</A> is a string then <Ref Func="ValidatePackageInfo"/> checks
additionally whether those package files exist that are mentioned in the
file <F>info</F>, for example the <F>manual.six</F> file of the package
documentation.
</Description>
</ManSection>

<ManSection>
<Func Name="ShowPackageVariables" Arg='pkgname[, version][, arec]'/>
<Func Name="PackageVariablesInfo" Arg='pkgname, version'/>

<Description>
Let <A>pkgname</A> be the name of a &GAP; package.
If the package <A>pkgname</A> is available but not yet loaded then
<Ref Func="ShowPackageVariables"/> prints a list of global variables
that become bound and of methods that become installed
when the package is loaded.
(For that, &GAP; actually loads the package.)
<P/>
If a version number <A>version</A> is given
(see Section&nbsp;<Ref Sect="Version Numbers" BookName="Example"/>)
then this version of the package is considered.
<P/>
An error message is printed if (the given version of) the package
is not available or already loaded.
<P/>
Information is printed about new and redeclared global variables,
and about names of global variables introduced in the package
that differ from existing globals only by case;
note that the &GAP; help system is case insensitive,
so it is difficult to document identifiers that differ only by case.
<P/>
Info lines for undocumented variables are marked with an asterisk
<C>*</C>.
<P/>
The following entries are omitted from the list:
default setter methods for attributes and properties that are declared
in the package,
and <C>Set<A>attr</A></C> and <C>Has<A>attr</A></C> type variables
where <A>attr</A> is an attribute or property.
<P/>
The output can be customized using the optional record <A>arec</A>,
the following components of this record are supported.
<List>
<Mark><C>show</C></Mark>
<Item>
  a list of strings describing those kinds of variables which shall be
  shown, such as <C>"new global functions"</C>;
  the default are all kinds that appear in the package,
</Item>
<Mark><C>showDocumented</C></Mark>
<Item>
  <K>true</K> (the default) if documented variables shall be shown,
  and <K>false</K> otherwise,
</Item>
<Mark><C>showUndocumented</C></Mark>
<Item>
  <K>true</K> (the default) if undocumented variables shall be shown,
  and <K>false</K> otherwise,
</Item>
<Mark><C>showPrivate</C></Mark>
<Item>
  <K>true</K> (the default) if variables from the package's name space
  (see Section <Ref Sect="Namespaces"/>) shall be shown,
  and <K>false</K> otherwise,
</Item>
<Mark><C>Display</C></Mark>
<Item>
  a function that takes a string and shows it on the screen;
  the default is <Ref Func="Print"/>,
  another useful value is <Ref Func="Pager"/>.
</Item>
</List>
<P/>
An interactive variant of <Ref Func="ShowPackageVariables"/> is the
function <Ref Func="BrowsePackageVariables" BookName="browse"/> that is
provided by the &GAP; package <Package>Browse</Package>.
For this function, it is not sensible to assume that the package
<A>pkgname</A> is not yet loaded before the function call,
because one might be interested in packages that must be loaded before
<Package>Browse</Package> itself can be loaded.
The solution is that
<Ref Func="BrowsePackageVariables" BookName="browse"/> takes the output
of <Ref Func="PackageVariablesInfo"/> as its second argument.
The function <Ref Func="PackageVariablesInfo"/> is used by both
<Ref Func="ShowPackageVariables"/> and
<Ref Func="BrowsePackageVariables" BookName="browse"/> for collecting the
information about the package in question, and can be called before the
package <Package>Browse</Package> is loaded.
</Description>
</ManSection>

<ManSection>
<Func Name="BibEntry" Arg='pkgname[, key]'/>

<Returns>
a string in BibXMLext format
(see <Ref Sect="The BibXMLext Format" BookName="gapdoc"/>)
that can be used for referencing the &GAP; system or a &GAP; package.
</Returns>

<Description>
If the argument <A>pkgname</A> is the string <C>"GAP"</C>,
the function returns an entry for the current version of &GAP;.
<P/>
Otherwise, if a string <A>pkgname</A> is given, which is the name of a
&GAP; package, an entry for this package is returned;
this entry is computed from the <F>PackageInfo.g</F> file of
<E>the current version</E> of the package,
see <Ref Func="InstalledPackageVersion"/>.
If no package with name <A>pkgname</A> is installed then the empty string
is returned.
<P/>
A string for <E>a different version</E> of &GAP; or a package
can be computed by entering, as the argument <A>pkgname</A>,
the desired record from the <F>PackageInfo.g</F> file.
(One can access these records using the function <C>PackageInfo</C>.)
<P/>
In each of the above cases, an optional argument <A>key</A> can be
given, a string which is then used as the key of the Bib&TeX; entry
instead of the default key that is generated from the system/package name
and the version number.
<P/>
<Ref Func="BibEntry"/> requires the functions
<Ref Func="FormatParagraph" BookName="gapdoc"/> and
<Ref Func="NormalizedNameAndKey" BookName="gapdoc"/>
from the &GAP; package &GAPDoc;.
<P/>
The functions <Ref Func="ParseBibXMLextString" BookName="gapdoc"/>
and <Ref Func="StringBibXMLEntry" BookName="gapdoc"/>
can be used to create for example a Bib&TeX; entry from the return value,
as follows.
<P/>
<Log><![CDATA[
gap> bib:= BibEntry( "GAP", "GAP4.5" );;
gap> Print( bib, "\n" );
<entry id="GAP4.5"><misc>
  <title><C>GAP</C> &ndash; <C>G</C>roups, <C>A</C>lgorithms,
         and <C>P</C>rogramming, <C>V</C>ersion 4.5.1</title>
  <howpublished><URL>http://www.gap-system.org</URL></howpublished>
  <key>GAP</key>
  <keywords>groups; *; gap; manual</keywords>
  <other type="organization">The GAP <C>G</C>roup</other>
</misc></entry>
gap> parse:= ParseBibXMLextString( bib );;
gap> Print( StringBibXMLEntry( parse.entries[1], "BibTeX" ) );
@misc{ GAP4.5,
  title =            {{GAP}   {\textendash}   {G}roups,   {A}lgorithms,  and
                      {P}rogramming, {V}ersion 4.5.1},
  organization =     {The GAP {G}roup},
  howpublished =     {\href                      {http://www.gap-system.org}
                      {\texttt{http://www.gap-system.org}}},
  key =              {GAP},
  keywords =         {groups; *; gap; manual}
}
]]></Log>
</Description>
</ManSection>

<ManSection>
<Func Name="Cite" Arg='[pkgname[, key]]'/>

<Description>
Used with no arguments or with argument <C>"GAP"</C> (case-insensitive),
<Ref Func="Cite"/> displays instructions on citing the version of &GAP;
that is being used. Suggestions are given in plain text, HTML, BibXML
and BibTeX formats. The same instructions are also contained in the
<F>CITATION</F> file in the &GAP; root directory.
<P/>
If <A>pkgname</A> is the name of a &GAP; package, instructions on
citing this package will be displayed. They will be produced from the
<F>PackageInfo.g</F> file of the working version of this package that
must be available in the &GAP; installation being used. Otherwise, one
will get a warning that no working version of the package is available.
<P/>
The optional 2nd argument <A>key</A> has the same meaning as in
<Ref Func="BibEntry"/>.
</Description>
</ManSection>


</Section>

</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  obsolete.tex             GAP documentation               Frank Lübeck -->
<!-- %%   -->
<!-- %H  @(#)<M>Id: obsolete.tex,v 4.3 2005/08/24 14:31:34 gap Exp </M> -->
<!-- %%   -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Replaced and Removed Command Names">
<Heading>Replaced and Removed Command Names</Heading>

<Index>obsolete</Index>
<Index>deprecated</Index>
<Index>legacy</Index>

In general we try to keep &GAP;&nbsp;4 compatible with former releases
as much as possible.
Nevertheless,
from time to time it seems appropriate to remove some commands
or to change the names of some commands or variables.
There are various reasons for that:
Some functionality was improved and got another (hopefully better)
interface,
names turned out to be too special or too general for the underlying
functionality,
or names are found to be unintuitive or inconsistent with other names.
<P/>
In this chapter we collect such old names while pointing to the sections
which explain how to substitute them.
Usually, old names will be available for several releases;
they may be removed when they don't seem to be used any more.
<P/>
The obsolete &GAP; code is collected in two library files,
<F>lib/obsolete.gd</F> and <F>lib/obsolete.gi</F>.
By default, these files are read when &GAP; is started.
It may be useful to omit reading these files,
for example in order to make sure that one's own &GAP; code does not rely
on the obsolete variables.
For that, one can use the <C>-O</C> command line option 
(see <Ref Label="Command Line Options"/>) or set the component 
<C>ReadObsolete</C> in the file <F>gap.ini</F> to <K>false</K> 
(see <Ref Sect="sect:gap.ini"/>). Note that <C>-O</C> command 
line option overrides <C>ReadObsolete</C>.
<P/>
(Note that the condition whether the library files with the obsolete
&GAP; code shall be read has changed.
In &GAP;&nbsp;4.3 and 4.4, the global variables <C>GAP_OBSOLESCENT</C>
and <C>GAPInfo.ReadObsolete</C>
&ndash;to be set in the user's <F>.gaprc</F> file&ndash;
were used to control this behaviour.)



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Group Actions - Name Changes">
<Heading>Group Actions &ndash; Name Changes</Heading>

<Index>group operations</Index>

The concept of a group action is sometimes referred to as a
<Q>group operation</Q>.
In &GAP;&nbsp;3 as well as in older versions of &GAP;&nbsp;4 the term
<C>Operation</C> was used instead of <C>Action</C>.
We decided to change the names to avoid confusion with the term
<Q>operation</Q> as in <Ref Func="DeclareOperation"/> and
<Q>operations for Xyz</Q>.
<P/>
Here are some examples of such name changes.
<P/>
<Index Key="Operation"><C>Operation</C></Index>
<Index Key="RepresentativeOperation"><C>RepresentativeOperation</C></Index>
<Index Key="OperationHomomorphism"><C>OperationHomomorphism</C></Index>
<Index Key="FunctionOperation"><C>FunctionOperation</C></Index>
<Table Align="l|l">
<Row>
  <Item><E>OLD</E></Item>
  <Item><E>NOW USE</E></Item>
</Row>
<HorLine/>
<Row>
  <Item><C>Operation</C></Item>
  <Item><Ref Func="Action" Label="for a group, an action domain, etc."/></Item>
</Row>
<Row>
  <Item><C>RepresentativeOperation</C></Item>
  <Item><Ref Func="RepresentativeAction"/></Item>
</Row>
<Row>
  <Item><C>OperationHomomorphism</C></Item>
  <Item><Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/></Item>
</Row>
<Row>
  <Item><C>FunctionOperation</C></Item>
  <Item><Ref Func="FunctionAction"/></Item>
</Row>
</Table>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Package Interface - Obsolete Functions and Name Changes">
<Heading>Package Interface &ndash; Obsolete Functions and Name Changes</Heading>

With &GAP;&nbsp;4.4 the package interface was changed. Thereby some functions
became obsolete and the names of some others were made more consistent.
<P/>
<Index Key="DeclarePackage"><C>DeclarePackage</C></Index>
<Index Key="DeclareAutoPackage"><C>DeclareAutoPackage</C></Index>
<Index Key="DeclarePackageDocumentation">
<C>DeclarePackageDocumentation</C></Index>
<Index Key="DeclarePackageAutoDocumentation">
<C>DeclarePackageAutoDocumentation</C></Index>
The following functions are no longer needed:
<C>DeclarePackage</C>,
<C>DeclareAutoPackage</C>,
<C>DeclarePackageDocumentation</C> and 
<C>DeclarePackageAutoDocumentation</C>.
They are substituted by entries in the packages' <F>PackageInfo.g</F> files,
see <Ref Sect="The PackageInfo.g File"/>. 
<P/>
Furthermore, the global variable <C>PACKAGES_VERSIONS</C> is no longer needed,
since this information is now contained in the <C>GAPInfo.PackagesInfo</C> record
(see <Ref Subsect="GAPInfo"/>). The global variable <C>Revisions</C> is also
no longer needed, since the function <C>DisplayRevision</C> was made obsolete in
&GAP;&nbsp;4.5.
<P/>

The following function names were changed.
<P/>
<Index Key="RequirePackage"><C>RequirePackage</C></Index>
<Index Key="ReadPkg"><C>ReadPkg</C></Index>
<Index Key="RereadPkg"><C>RereadPkg</C></Index>
<Table Align="l|l">
<Row>
  <Item><E>OLD</E></Item>
  <Item><E>NOW USE</E></Item>
</Row>
<HorLine/>
<Row>
  <Item><C>RequirePackage</C></Item>
  <Item><Ref Func="LoadPackage"/></Item>
</Row>
<Row>
  <Item><C>ReadPkg</C></Item>
  <Item><Ref Func="ReadPackage"/></Item>
</Row>
<Row>
  <Item><C>RereadPkg</C></Item>
  <Item><Ref Func="RereadPackage"/></Item>
</Row>
</Table>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Normal Forms of Integer Matrices - Name Changes">
<Heading>Normal Forms of Integer Matrices &ndash; Name Changes</Heading>

<Index>Smith normal form</Index>
<Index>Hermite normal form</Index>

Former versions of &GAP;&nbsp;4 documented several functions for computing
the Smith or Hermite normal form of integer matrices.
Some of them were never implemented and it was unclear which commands to use.
The functionality of all of these commands is now available with
<Ref Func="NormalFormIntMat"/> and a few interface functions.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Miscellaneous Name Changes or Removed Names">
<Heading>Miscellaneous Name Changes or Removed Names</Heading>

<Index Key="QUIET"><C>QUIET</C></Index>
<Index Key="BANNER"><C>BANNER</C></Index>

In former releases of &GAP;&nbsp;4 there were some global variable names
bound to general information about the running &GAP;,
such as path names or command line options.
Although they were not officially documented they were used by several users
and in some packages.
We mention here <C>BANNER</C> and <C>QUIET</C>.
This type of information is now collected in the global record
<Ref Var="GAPInfo"/>.
<P/>
Here are some further name changes.
<P/>
<Index Key="MonomialTotalDegreeLess"><C>MonomialTotalDegreeLess</C></Index>
<Index Key="NormedVectors"><C>NormedVectors</C></Index>
<Index Key="MutableIdentityMat"><C>MutableIdentityMat</C></Index>
<Index Key="MutableNullMat"><C>MutableNullMat</C></Index>
<Table Align="l|l">
<Row>
  <Item><E>OLD</E></Item>
  <Item><E>NOW USE</E></Item>
</Row>
<HorLine/>
<Row>
  <Item><C>MonomialTotalDegreeLess</C></Item>
  <Item><Ref Func="MonomialExtGrlexLess"/></Item>
</Row>
<Row>
  <Item><C>NormedVectors</C></Item>
  <Item><Ref Func="NormedRowVectors"/></Item>
</Row>
<Row>
  <Item><C>MutableIdentityMat</C></Item>
  <Item><Ref Func="IdentityMat"/></Item>
</Row>
<Row>
  <Item><C>MutableNullMat</C></Item>
  <Item><Ref Func="NullMat"/></Item>
</Row>
</Table>


<Index Key="PositionFirstComponent"><C>PositionFirstComponent</C></Index>
The operation <C>PositionFirstComponent</C> has been deprecated in GAP
4.8 and later due to issues with its documentation and implementation.
Instead of <C>PositionFirstComponent(list,obj)</C>, you may use
<C>PositionSorted(list,[obj])</C> or
<C>PositionProperty(list,x->x[1]=obj)</C> as a replacement, depending on
your specific use case.


<ManSection>
<Var Name="InfoObsolete"/>
<Description>
is an info class to display warnings when an obsolete variable is used.
By default, these warnings are switched off since the info level for 
this class is 0. Setting it to 1 will trigger warnings if &GAP; will 
detect that an obsolete variable is used at runtime (this detection is
possible, however, only for obsolete variables declared using 
<C>DeclareObsoleteSynonym</C>). 
<P/>
To check that the &GAP; code does not use obsolete variables at the 
parsing time, and not at a runtime, use <C>-O</C> command line option,
see <Ref Sect="Command Line Options"/>. 
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="obsolete-gaprc">
<Heading>The former .gaprc file</Heading>

Up to &GAP;&nbsp;4.4, a file <F>.gaprc</F> in the user's home directory
(if available, and &GAP; was started without <C>-r</C> option) was 
read automatically during startup,
early enough for influencing the autoloading of packages and
late enough for being allowed to execute any &GAP; code.  On Windows 
machines this file was called <F>gap.rc</F>.
<P/>
In &GAP;&nbsp;4.5 the startup mechanism has changed, see 
<Ref Sect="sect:gap.ini"/> for details. These new configuration
files are now contained in a directory <C>GAPInfo.UserGapRoot</C>.
<P/>
For the sake of partial backwards compatibility,
also the former file <F>~/.gaprc</F> is still supported for such
initializations, but this file is read only if the directory 
<C>GAPInfo.UserGapRoot</C> does not exist.
In that case the <F>~/.gaprc</F> is read at the same time as <F>gaprc</F>
would be read, i.&nbsp;e., too late for influencing the startup of &GAP;.
<P/>
As before, the command line option <C>-r</C> disables reading
<F>~/.gaprc</F>, see <Ref Sect="Command Line Options"/>.
<P/>
To migrate from the old setup to the new one introduced with &GAP;&nbsp;4.5,
first have a look at the function <Ref Func="WriteGapIniFile"/>. Many users
will find that all or most of what was set in the old <F>~/.gaprc</F> file
can now be done via the user preferences in a <F>gap.ini</F> file.
If you had code for new functions or abbreviations in your old <F>~/.gaprc</F> 
file or you were reading additional files, then move this into
the file <F>gaprc</F> (without the leading dot, same name for all operating
systems) in the directory <C>GAPInfo.UserGapRoot</C>.

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="obsolete-semigroups-properties">
  <Heading>Properties of semigroups</Heading>

  Until Version 4.8 of &GAP; there was inconsistent use of the following
  properties of semigroups: <C>IsGroupAsSemigroup</C>, <C>IsMonoidAsSemigroup</C>, 
  and <C>IsSemilatticeAsSemigroup</C>. <C>IsGroupAsSemigroup</C> was true for
  semigroups that mathematically defined a group, and for semigroups in the
  category <Ref Filt = "IsGroup"/>; <C>IsMonoidAsSemigroup</C> was true for
  semigroups that mathematically defined monoids, but did not belong to the
  category <Ref Filt = "IsMonoid"/>; and <C>IsSemilatticeAsSemigroup</C> was
  simply a property of semigroups, there is no category <C>IsSemilattice</C>. 
  <P/>

  From Version 4.8 onwards, <C>IsSemilatticeAsSemigroup</C> is renamed
  <C>IsSemilattice</C>, and <C>IsMonoidAsSemigroup</C> returns <C>true</C> for
  semigroups in the category <Ref Filt = "IsMonoid"/>.
  
  <ManSection>
<Prop Name="IsSemilatticeAsSemigroup" Arg='S'/>

<Description>
  <C>IsSemilatticeAsSemigroup</C> returns <K>true</K> if the semigroup
  <A>S</A> is a semilattice and <K>false</K> if it is not. <P/>

  A semigroup is a <E>semilattice</E> if it is commutative and every
  element is an idempotent. The idempotents of an inverse semigroup form a
  semilattice.

  This is identical to <Ref Prop="IsSemilattice" BookName = "Semigroups"/> #
  and is present in &GAP;&nbsp;4.8 #  only for the sake of compatibility with
  beta-releases.  #  It should <E>not</E> be used in new code.
</Description>
</ManSection>

</Section>

</Chapter>




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  methsel.tex               GAP manual                    Thomas Breuer -->
<!-- %W                                                       Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: methsel.tex,v 4.26 2006/09/13 12:31:52 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Method Selection">
<Heading>Method Selection</Heading>

<Index>operation</Index><Index>method</Index>
This chapter explains how &GAP; decides which function to call for which
types of objects.
It assumes that you have read the chapters about objects
(Chapter&nbsp;<Ref Chap="Objects and Elements"/>) and types
(Chapter&nbsp;<Ref Chap="Types of Objects"/>).
<P/>
An <E>operation</E> is a special &GAP; function that bundles a set of
functions, its <E>methods</E>.
<P/>
All methods of an operation compute the same result.
But each method is installed for specific types of arguments.
<P/>
If an operation is called with a tuple of arguments,
one of the applicable methods is selected and called.
<P/>
Special cases of methods are partial methods, immediate methods,
and logical implications.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations and Methods">
<Heading>Operations and Methods</Heading>
<P/>
Operations are functions in the category
<Ref Func="IsOperation"/>.
<P/>
So on the one hand, <E>operations</E> are &GAP; functions, that is,
they can be applied to arguments and return a result or cause a
side-effect.
<P/>
On the other hand, operations are more.
Namely, an operation corresponds to a set of &GAP; functions,
called the <E>methods</E> of the operation.
<P/>
Each call of an operation causes a suitable method to be selected
and then called.
The choice of which method to select is made according to the types
of the arguments,
the underlying mechanism is described in the following sections.
<P/>
Examples of operations are the binary infix operators <C>=</C>, <C>+</C> etc.,
and <Ref Func="PrintObj"/> is the operation that is called
for each argument of <Ref Func="Print"/>.
<P/>
Also all attributes and properties are operations.
Each attribute has a special method which is called
if the attribute value is already stored;
this method of course simply returns this value.
<P/>
The setter of an attribute is called automatically
if an attribute value has been computed.
Attribute setters are operations, too.
They have a default method that ignores the request to store the value.
Depending on the type of the object,
there may be another method to store the value in a suitable way,
and then set the attribute tester for the object to <K>true</K>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Method Installation">
<Heading>Method Installation</Heading>

In order to describe what it means to select a method of an operation,
we must describe how the methods are connected to their operations.
<P/>
For attributes and properties there is <Ref Func="InstallImmediateMethod"/>.
<P/>
For declaring that a filter is implied by other filters there is
<Ref Func="InstallTrueMethod"/>.

<ManSection>
<Func Name="InstallMethod"
 Arg="opr[,info][,famp],args-filts[,val],method"/>

<Description>
installs a function method <A>method</A> for the operation <A>opr</A>;
<A>args-filts</A> should be a list of requirements for the arguments,
each entry being a filter;
if supplied <A>info</A> should be a short but informative string
that describes for what situation the method is installed,
<A>famp</A> should be a function to be applied to the families
of the arguments,
and <A>val</A> should be an integer that measures the priority
of the method.
<P/>
The default values for <A>info</A>, <A>famp</A>, and <A>val</A> are
the empty string,
the function <Ref Func="ReturnTrue"/>,
and the integer zero, respectively.
<P/>
The exact meaning of the arguments <A>famp</A>, <A>args-filts</A>,
and <A>val</A> is explained in
Section&nbsp;<Ref Sect="Applicable Methods and Method Selection"/>.
<P/>
<A>opr</A> expects its methods to require certain filters for their
arguments.
For example, the argument of a method for the operation
<Ref Func="Zero"/> must be
in the category <Ref Func="IsAdditiveElementWithZero"/>.
It is not possible to use <Ref Func="InstallMethod"/> to install
a method for which the entries of <A>args-filts</A> do not imply
the respective requirements of the operation <A>opr</A>.
If one wants to override this restriction,
one has to use <Ref Func="InstallOtherMethod"/> instead.
</Description>
</ManSection>

<ManSection>
<Func Name="InstallOtherMethod"
 Arg="opr[,info][,famp],args-filts[,val],method"/>

<Description>
installs a function method <A>method</A> for the operation <A>opr</A>,
in the same way as for <Ref Func="InstallMethod"/>,
but without the restriction that the number of arguments must match
a declaration of <A>opr</A>
and without the restriction that <A>args-filts</A> imply the respective
requirements of the operation <A>opr</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Applicable Methods and Method Selection">
<Heading>Applicable Methods and Method Selection</Heading>

A method installed as above is <E>applicable</E> for an arguments tuple
if the following conditions are satisfied.
<P/>
The number of arguments equals the length of the list <A>args-filts</A>,
the <M>i</M>-th argument lies in the filter <A>args-filts</A><M>[i]</M>,
and <A>famp</A> returns <K>true</K> when applied to the families of the arguments.
The maximal number of arguments supported for methods is six,
one gets an error message if one tries to install a method with at least
seven arguments.
<P/>
So <A>args-filt</A> describes conditions for each argument,
and <A>famp</A> describes a relation between the arguments.
<P/>
For unary operations such as attributes and properties,
there is no such relation to postulate,
<A>famp</A> is <Ref Func="ReturnTrue"/> for these operations,
a function that always returns <K>true</K>.
For binary operations, the usual value of <A>famp</A> is
<Ref Func="IsIdenticalObj"/>,
which means that both arguments must lie in the same family.
<P/>
Note that any properties which occur among the filters in the filter list
will <E>not</E> be tested by the method selection if they are not yet known.
(More exact: if <A>prop</A> is a property then the filter implicitly uses not
<A>prop</A> but <C>Has<A>prop</A> and <A>prop</A></C>.) If this is desired you must explicitly
enforce a test (see section&nbsp;<Ref Sect="Redispatching"/>) below.
<P/>
If no method is applicable,
the error message <Q>no method found</Q> is signaled.
<P/>
Otherwise, the applicable method with highest <E>rank</E> is selected and then
called.
This rank is given by the sum of the ranks of the filters in the list
<A>args-filt</A>,
<E>including involved filters</E>,
plus the number <A>val</A> used in the call of
<Ref Func="InstallMethod"/>.
So the argument <A>val</A> can be used to raise the priority of a method
relative to other methods for <A>opr</A>.
<P/>
Note that from the applicable methods,
an efficient one shall be selected.
This is a method that needs only little time and storage for the
computations.
<P/>
It seems to be impossible for &GAP; to select an optimal
method in all cases.
The present ranking of methods is based on the assumption
that a method installed for a special situation shall be preferred
to a method installed for a more general situation.
<P/>
For example, a method for computing a Sylow subgroup of a nilpotent
group is expected to be more efficient than a method for arbitrary
groups.
So the more specific method will be selected if &GAP; knows that the
group given as argument is nilpotent.
<P/>
Of course there is no obvious way to decide between the efficiency of
incommensurable methods.
For example, take an operation with one method for permutation groups,
another method for nilpotent groups,
but no method for nilpotent permutation groups,
and call this operation with a permutation group known to be
nilpotent.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Partial Methods">
<Heading>Partial Methods</Heading>

<ManSection>
<Func Name="TryNextMethod" Arg =""/>

<Description>
After a method has been selected and called,
the method may recognize that it cannot compute the desired result,
and give up by calling <C>TryNextMethod()</C>.
<P/>
In effect, the execution of the method is terminated,
and the method selection calls the next method that is applicable w.r.t.
the original arguments.
In other words, the applicable method is called that is subsequent to the
one that called <Ref Func="TryNextMethod"/>,
according to decreasing rank of the methods.
<P/>
For example, since every finite group of odd order is solvable,
one may install a method for the property
<Ref Func="IsSolvableGroup"/> that checks
whether the size of the argument is an odd integer,
returns <K>true</K> if so,
and gives up otherwise.
<P/>
Care is  needed  if a  partial  method  might  modify the  type of  one  of its
arguments, for example by computing an attribute  or property. If this happens,
and the type  has   really changed, then  the  method  should not  exit   using
<C>TryNextMethod()</C> but  should call the operation again,  as the new information
in the type may   cause  some methods  previously   judged inapplicable to   be
applicable. For  example, if  the  above method  for
<Ref Func="IsSolvableGroup"/> actually
computes the size, (rather than  just examining  a  stored size), then it  must
take care to check whether the type of the group has changed.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Redispatching">
<Heading>Redispatching</Heading>

As mentioned above the method selection will not test unknown properties.
In situations, in which algorithms are only known (or implemented) under
certain conditions, however such a test might be actually desired.
<P/>
One way to achieve this would be to install the method under weaker
conditions and explicitly test the properties first, exiting via
<Ref Func="TryNextMethod"/> if some of them are not fulfilled.
A problem of this approach however is that such methods then automatically
are ranked lower and that the code does not look nice.
<P/>
A much better way is to use redispatching: Before deciding that no method
has been found one tests these properties and if they turn out to be true
the method selection is started anew (and will then find a method).
<P/>
This can be achieved via the following function:

<ManSection>
<Func Name="RedispatchOnCondition" Arg="oper[, info], fampred, reqs, cond, val"/>

<Description>
This function installs a method for the operation <A>oper</A> under the
conditions <A>fampred</A> and <A>reqs</A> which has absolute value
<A>val</A>;
that is, the value of the filters <A>reqs</A> is disregarded.
<A>cond</A> is a list of filters.
If not all the values of properties involved in these filters are already
known for actual arguments of the method,
they are explicitly tested and if they are fulfilled <E>and</E> stored
after this test, the operation is dispatched again.
Otherwise the method exits with <Ref Func="TryNextMethod"/>.
If supplied, <A>info</A> should be a short but informative string
that describes these conditions.
This can be used to enforce tests like
<Ref Func="IsFinite"/> in situations when all
existing methods require this property.
The list <A>cond</A> may have unbound entries in which case
the corresponding argument is ignored for further tests.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Immediate Methods">
<Heading>Immediate Methods</Heading>

Usually a method is called only if its operation has been called
and if this method has been selected, see <Ref Func="InstallMethod"/>.
<P/>
For attributes and properties,
one can install also <E>immediate methods</E>.

<ManSection>
<Func Name="InstallImmediateMethod"
 Arg='opr[, info], filter, rank, method'/>

<Description>
<Ref Func="InstallImmediateMethod"/> installs <A>method</A> as an
immediate method for <A>opr</A>, which must be an attribute or a
property, with requirement <A>filter</A> and rank <A>rank</A>.
The rank must be an integer value that measures the priority of
<A>method</A> among the immediate methods for <A>opr</A>.
If supplied, <A>info</A> should be a short but informative string
that describes the situation in which the method is called.
<P/>
An immediate method is called automatically as soon as the object lies 
in <A>filter</A>, provided that the value is not yet known.
Afterwards the attribute setter is called in order to store the value, 
unless the method exits via <Ref Func="TryNextMethod"/>.
<P/>
Note the difference to <Ref Func="InstallMethod"/>
that no family predicate occurs
because <A>opr</A> expects only one argument,
and that <A>filter</A> is not a list of requirements but the argument
requirement itself.
<P/>
Immediate methods are thought of as a possibility for objects to gain
useful knowledge.
They must not be used to force the storing of <Q>defining information</Q>
in an object.
In other words, &GAP; should work even if all immediate methods are
completely disabled.
Therefore, the call to <Ref Func="InstallImmediateMethod"/> installs
<A>method</A> also as an ordinary method for <A>opr</A>
with requirement <A>filter</A>.
<P/>
Note that in such a case &GAP; executes a computation for which
it was not explicitly asked by the user.
So one should install only those methods as immediate methods
that are <E>extremely cheap</E>.
To emphasize this,
immediate methods are also called <E>zero cost methods</E>.
The time for their execution should really be approximately zero.
<P/>
For example, the size of a permutation group can be computed very cheaply
if a stabilizer chain of the group is known.
So it is reasonable to install an immediate method for
<Ref Func="Size"/> with requirement
<C>IsGroup and Tester( <A>stab</A> )</C>,
where <A>stab</A> is the attribute corresponding to the stabilizer chain.
<P/>
Another example would be the implementation of the conclusion that
every finite group of prime power order is nilpotent.
This could be done by installing an immediate method for the attribute
<Ref Func="IsNilpotentGroup"/> with requirement
<C>IsGroup and Tester( Size )</C>.
This method would then check whether the size is a finite prime power,
return <K>true</K> in this case and otherwise call
<Ref Func="TryNextMethod"/>.
But this requires factoring of an integer,
which cannot be guaranteed to be very cheap,
so one should not install this method as an immediate method.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Logical Implications">
<Heading>Logical Implications</Heading>

<ManSection>
<Func Name="InstallTrueMethod" Arg="newfil, filt"/>

<Description>
It may happen that a filter <A>newfil</A> shall be implied by another
filter <A>filt</A>, which is usually a meet of other properties,
or the meet of some properties and some categories.
Such a logical implication can be installed as an <Q>immediate method</Q>
for <A>newfil</A> that requires <A>filt</A> and that always returns
<K>true</K>.
(This should not be mixed up with the methods installed via
<Ref Func="InstallImmediateMethod"/>, which have to be called at runtime
for the actual objects.)
<P/>
<Ref Func="InstallTrueMethod"/> has the effect that <A>newfil</A> becomes
an implied filter of <A>filt</A>,
see&nbsp;<Ref Sect="Filters"/>.
<P/>
For example, each cyclic group is abelian,
each finite vector space is finite dimensional,
and each division ring is integral.
The first of these implications is installed as follows.
<P/>
<Log><![CDATA[
InstallTrueMethod( IsCommutative, IsGroup and IsCyclic );
]]></Log>
<P/>
Contrary to the immediate methods installed with
<Ref Func="InstallImmediateMethod"/>, logical implications cannot be
switched off.
This means that after the above implication has been installed,
one can rely on the fact that every object in the filter
<C>IsGroup and IsCyclic</C> will also be in the filter
<Ref Func="IsCommutative"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations and Mathematical Terms">
<Heading>Operations and Mathematical Terms</Heading>

<Index>overload</Index>
Usually an operation stands for a mathematical concept,
and the name of the operation describes this uniquely.
Examples are the property <Ref Func="IsFinite"/>
and the attribute <Ref Func="Size"/>.
But there are cases where the same mathematical term is used 
to denote different concepts,
for example <C>Degree</C> is defined for polynomials, group characters,
and permutation actions,
and <C>Rank</C> is defined for matrices, free modules, <M>p</M>-groups,
and transitive permutation actions.
<P/>
It is in principle possible to install methods for the operation
<C>Rank</C> that are applicable to the different types of arguments,
corresponding to the different contexts.
But this is not the approach taken in the &GAP; library.
Instead there are operations such as <Ref Func="RankMat"/>
for matrices and <Ref Func="DegreeOfCharacter"/>
(in fact these are attributes)
which are installed as methods of the <Q>ambiguous</Q> operations
<C>Rank</C> and <C>Degree</C>.
<P/>
The idea is to distinguish between on the one hand different ways
to compute the same thing (e.g.&nbsp;different methods for
<Ref Func="\="/>,
<Ref Func="Size"/>, etc.),
and on the other hand genuinely different things
(such as the degree of a polynomial and a permutation action).
<P/>
The former is the basic purpose of operations and attributes.
The latter is provided as a user convenience where mathematical usage
forces it on us <E>and</E> where no conflicts arise.
In programming the library, we use the underlying mathematically
precise operations or attributes,
such as <Ref Func="RankMat"/> and
<C>RankOperation</C>.
These should be attributes if appropriate, and the only role of the
operation <C>Rank</C> is to decide which attribute the user meant.
That way, stored information is stored with <Q>full mathematical precision</Q>
and is less likely to be retrieved for a wrong purpose later.
<P/>
One word about possible conflicts.
A typical example is the mathematical term <Q>centre</Q>,
which is defined as <M>\{ x \in M | a * x = x * a \forall a \in M \}</M>
for a magma <M>M</M>, and as <M>\{ x \in L | l * x = 0 \forall l \in L \}</M>
for a Lie algebra <M>L</M>.
Here it is <E>not</E> possible to introduce an operation
<Ref Func="Centre"/> that
delegates to attributes <C>CentreOfMagma</C> and <C>CentreOfLieAlgebra</C>,
depending on the type of the argument.
This is because any Lie algebra in &GAP; is also a magma,
so both <C>CentreOfMagma</C> and <C>CentreOfLieAlgebra</C> would be defined
for a Lie algebra, with different meaning if the characteristic is two.
So we cannot achieve that one operation in &GAP; corresponds to
the mathematical term <Q>centre</Q>.
<P/>
<Q>Ambiguous</Q> operations such as <C>Rank</C> are declared in the library file
<F>lib/overload.g</F>.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  create.tex                GAP manual                    Thomas Breuer -->
<!-- %A                                                       Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: create.tex,v 4.48 2005/10/20 07:39:10 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Creating New Objects">
<Heading>Creating New Objects</Heading>

This chapter is divided into three parts.
<P/>
In the first part, it is explained how to create
filters (see&nbsp;<Ref Sect="Creating Categories"/>, <Ref Sect="Creating Representations"/>,
<Ref Sect="Creating Attributes and Properties"/>, <Ref Sect="Creating Other Filters"/>),
operations (see&nbsp;<Ref Sect="Creating Operations"/>),
families (see&nbsp;<Ref Sect="Creating Families"/>),
types (see&nbsp;<Ref Sect="Creating Types"/>),
and objects with given type (see&nbsp;<Ref Sect="Creating Objects"/>).
<P/>
In the second part, first a few small examples are given,
for dealing with the usual cases of
component objects (see&nbsp;<Ref Sect="Component Objects"/>)
and positional objects (see&nbsp;<Ref Sect="Positional Objects"/>),
and for the implementation of new kinds of lists
(see&nbsp;<Ref Sect="Implementing New List Objects"/>
and&nbsp;<Ref Sect="Arithmetic Issues in the Implementation of New Kinds of Lists"/>).
Finally, the external representation of objects is introduced
(see&nbsp;<Ref Sect="External Representation"/>),
as a tool for representation independent access to an object.
<P/>
The third part deals with some rules concerning the organization
of the &GAP; library;
namely, some commands for creating global variables are explained
(see&nbsp;<Ref Sect="Global Variables in the Library"/>)
that correspond to the ones discussed in the first part of the chapter,
and the idea of distinguishing declaration and implementation part
of &GAP; packages is outlined (see&nbsp;<Ref Sect="Declaration and Implementation Part"/>).
<P/>
See also Chapter&nbsp;<Ref Chap="An Example -- Residue Class Rings"/> for examples
how the functions from the first part are used,
and why it is useful to have a declaration part and an implementation part.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Categories">
<Heading>Creating Categories</Heading>

<ManSection>
<Func Name="NewCategory" Arg='name, super[, rank]'/>

<Description>
<Ref Func="NewCategory"/> returns a new category <A>cat</A> that has the
name <A>name</A> and is contained in the filter <A>super</A>,
see&nbsp;<Ref Sect="Filters"/>.
This means that every object in <A>cat</A> lies automatically also in
<A>super</A>.
We say also that <A>super</A> is an implied filter of <A>cat</A>.
<P/>
For example, if one wants to create a category of group elements
then <A>super</A> should be
<Ref Func="IsMultiplicativeElementWithInverse"/>
or a subcategory of it.
If no specific supercategory of <A>cat</A> is known,
<A>super</A> may be <Ref Func="IsObject"/>.
<P/>
The optional third argument <A>rank</A> denotes the incremental rank
(see&nbsp;<Ref Sect="Filters"/>) of <A>cat</A>,
the default value is 1.
</Description>
</ManSection>

<ManSection>
<Func Name="CategoryFamily" Arg='cat'/>

<Description>
For a category <A>cat</A>,
<Ref Func="CategoryFamily"/> returns the <E>family category</E>
of <A>cat</A>.
This is a category in which all families lie that know from their
creation that all their elements are in the category <A>cat</A>,
see&nbsp;<Ref Sect="Creating Families"/>.
<P/>
For example, a family of associative words is in the category
<C>CategoryFamily( IsAssocWord )</C>,
and one can distinguish such a family from others by this category.
So it is possible to install methods for operations that require one
argument to be a family of associative words.
<P/>
<Ref Func="CategoryFamily"/> is quite technical,
and in fact of minor importance.
</Description>
</ManSection>


<P/>

See also <Ref Func="CategoryCollections"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Representations">
<Heading>Creating Representations</Heading>

<ManSection>
<Func Name="NewRepresentation" Arg='name, super, slots[, req]'/>

<Description>
<Ref Func="NewRepresentation"/> returns a new representation <A>rep</A>
that has the name <A>name</A> and is a subrepresentation of the
representation <A>super</A>.
This means that every object in <A>rep</A> lies automatically also in
<A>super</A>.
We say also that <A>super</A> is an implied filter of <A>rep</A>.
<P/>
Each representation in &GAP; is a subrepresentation of exactly one
of the four representations <C>IsInternalRep</C>, <C>IsDataObjectRep</C>,
<C>IsComponentObjectRep</C>, <C>IsPositionalObjectRep</C>.
The data describing objects in the former two can be accessed only via
&GAP; kernel functions, the data describing objects in the latter two
is accessible also in library functions,
see&nbsp;<Ref Sect="Component Objects"/>
and&nbsp;<Ref Sect="Positional Objects"/> for the details.
<P/>
The third argument <A>slots</A> is a list either of integers or of
strings.
In the former case, <A>rep</A> must be <C>IsPositionalObjectRep</C> or a
subrepresentation of it, and <A>slots</A> tells what positions of the
objects in the representation <A>rep</A> may be bound.
In the latter case, <A>rep</A> must be <C>IsComponentObjectRep</C> or a
subrepresentation of, and <A>slots</A> lists the admissible names of
components that objects in the representation <A>rep</A> may have.
The admissible positions resp. component names of <A>super</A> need not
be be listed in <A>slots</A>.
<P/>
The incremental rank (see&nbsp;<Ref Sect="Filters"/>)
of <A>rep</A> is 1.
<P/>
Note that for objects in the representation <A>rep</A>,
of course some of the component names and positions reserved via
<A>slots</A> may be unbound.
<P/>
Examples for the use of <Ref Func="NewRepresentation"/> can be found
in&nbsp;<Ref Sect="Component Objects"/>,
<Ref Sect="Positional Objects"/>, and also in
<Ref Sect="A Second Attempt to Implement Elements of Residue Class Rings"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Attributes and Properties">
<Heading>Creating Attributes and Properties</Heading>

Each method that is installed for an attribute or a property
via <Ref Func="InstallMethod"/> must require exactly one argument,
and this must lie in the filter <A>filter</A> that was entered as second
argument of <Ref Func="NewAttribute"/> resp. <Ref Func="NewProperty"/>.
<P/>
As for any operation (see&nbsp;<Ref Sect="Creating Operations"/>),
for attributes and properties one can install a method taking an argument
that does not lie in <A>filt</A> via <Ref Func="InstallOtherMethod"/>,
or a method for more than one argument;
in the latter case,
clearly the result value is <E>not</E> stored in any of the arguments.

<ManSection>
<Func Name="NewAttribute" Arg='name, filter[, "mutable"][, rank]'/>

<Description>
<Ref Func="NewAttribute"/> returns a new attribute getter with name
<A>name</A> that is applicable to objects with the property
<A>filter</A>.
<P/>
Contrary to the situation with categories and representations,
the tester of the new attribute does <E>not</E> imply <A>filter</A>.
This is exactly because of the possibility to install methods
that do not require <A>filter</A>.
<P/>
For example, the attribute <Ref Func="Size"/> was created
with second argument a list or a collection,
but there is also a method for <Ref Func="Size"/> that is
applicable to a character table,
which is neither a list nor a collection.
<P/>
If the optional third argument is given then there are two possibilities.
Either it is an integer <A>rank</A>,
then the attribute tester has this incremental rank
(see&nbsp;<Ref Sect="Filters"/>).
Or it is the string <C>"mutable"</C>,
then the values of the attribute shall be mutable;
more precisely, when a value of such a mutable attribute is set
then this value itself is stored, not an immutable copy of it.
(So it is the user's responsibility to set an object that is in fact
mutable.)
This is useful for an attribute whose value is some partial information
that may be completed later.
For example, there is an attribute <C>ComputedSylowSubgroups</C>
for the list holding those Sylow subgroups of a group that have been
computed already by the function
<Ref Func="SylowSubgroup"/>,
and this list is mutable because one may want to enter groups into it
as they are computed.
<!-- in the current implementation, one can overwrite values of mutable-->
<!-- attributes; is this really intended?-->
<!-- if yes then it should be documented!-->
<P/>
If no third argument is given then the rank of the tester is 1.
<P/>
Each method for the new attribute that does <E>not</E> require
its argument to lie in <A>filter</A> must be installed using
<Ref Func="InstallOtherMethod"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="NewProperty" Arg='name, filter[, rank]'/>

<Description>
<Ref Func="NewProperty"/> returns a new property <A>prop</A> with name
<A>name</A> (see also&nbsp;<Ref Sect="Properties"/>).
The filter <A>filter</A> describes the involved filters of <A>prop</A>.
As in the case of attributes,
<A>filter</A> is not implied by <A>prop</A>.
<P/>
The optional third argument <A>rank</A> denotes the incremental rank
(see&nbsp;<Ref Sect="Filters"/>) of the property
<A>prop</A> itself, i.e. <E>not</E> of its tester;
the default value is 1.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Other Filters">
<Heading>Creating Other Filters</Heading>

In order to change the value of <A>filt</A> for an object <A>obj</A>,
one can use logical implications
(see&nbsp;<Ref Sect="Logical Implications"/>) or
<Ref Func="SetFilterObj"/>, <Ref Func="ResetFilterObj"/>.

<ManSection>
<Func Name="NewFilter" Arg="name[, rank]"/>

<Description>
<Ref Func="NewFilter"/> returns a simple filter with name <A>name</A>
(see&nbsp;<Ref Sect="Other Filters"/>).
The optional second argument <A>rank</A> denotes the incremental rank
(see&nbsp;<Ref Sect="Filters"/>) of the filter,
the default value is 1.
<P/>
The default value of the new simple filter for each object is
<K>false</K>.
</Description>
</ManSection>

<ManSection>
<Func Name="SetFilterObj" Arg='obj, filter'/>

<Description>
<Ref Func="SetFilterObj"/> sets the value of <A>filter</A>
(and of all filters implied by <A>filter</A>) for <A>obj</A> to
<K>true</K>,
</Description>
</ManSection>

<ManSection>
<Func Name="ResetFilterObj" Arg='obj, filter'/>

<Description>
<Ref Func="ResetFilterObj"/> sets the value of <A>filter</A> for
<A>obj</A> to <K>false</K>.
(Implied filters of <A>filt</A> are not touched.
This might create inconsistent situations if applied carelessly).
</Description>
</ManSection>


<!-- %T Categories and representations should not be operations, -->
<!-- %T the same for filters made by <C>NewFilter</C>! -->
<!-- %AK Now everything is displayed properly -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Operations">
<Heading>Creating Operations</Heading>

<ManSection>
<Func Name="NewOperation" Arg='name, args-filts'/>

<Description>
<Ref Func="NewOperation"/> returns an operation <A>opr</A> with name
<A>name</A>.
The list <A>args-filts</A> describes requirements about the arguments
of <A>opr</A>, namely the number of arguments must be equal to the length
of <A>args-filts</A>, and the <M>i</M>-th argument must lie in the filter
<A>args-filts</A><M>[i]</M>.
<P/>
Each method that is installed for <A>opr</A> via
<Ref Func="InstallMethod"/> must require that the <M>i</M>-th argument
lies in the filter <A>args-filts</A><M>[i]</M>.
<P/>
One can install methods for other arguments tuples via
<Ref Func="InstallOtherMethod"/>,
this way it is also possible to install methods for a different number
of arguments than the length of <A>args-filts</A>.
</Description>
</ManSection>


</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Constructors">
<Heading>Creating Constructors</Heading>

<ManSection>
<Func Name="NewConstructor" Arg='name, args-filts'/>

<Description>
<Ref Func="NewConstructor"/> returns a constructor <A>cons</A> with name
<A>name</A>.
The list <A>args-filts</A> describes requirements about the arguments
of <A>constr</A>, namely the number of arguments must be equal to the length
of <A>args-filts</A>, and the <M>i</M>-th argument must lie in the filter
<A>args-filts</A><M>[i]</M>. Additionally a constructor expects the first
argument to be a filter to then select a method to construct an object.
<P/>
Each method that is installed for <A>cons</A> via
<Ref Func="InstallMethod"/> must require that the <M>i</M>-th argument
lies in the filter <A>args-filts</A><M>[i]</M>.
<P/>
One can install methods for other arguments tuples via
<Ref Func="InstallOtherMethod"/>,
this way it is also possible to install methods for a different number
of arguments than the length of <A>args-filts</A>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Families">
<Heading>Creating Families</Heading>

Families are probably the least obvious part of the &GAP; type system,
so some remarks about the role of families are necessary.
When one uses &GAP; as it is, one will (better: should) not meet
families at all.
The two situations where families come into play are the following.
<P/>
First, since families are used to describe relations between arguments of
operations in the method selection mechanism
(see Chapter&nbsp;<Ref Chap="Method Selection"/>,
and also Chapter&nbsp;<Ref Chap="Types of Objects"/>),
one has to prescribe such a relation in each method installation
(see&nbsp;<Ref Sect="Method Installation"/>);
usual relations are <Ref Func="ReturnTrue"/>
(which means that any relation of the actual arguments is admissible),
<Ref Func="IsIdenticalObj"/> (which means that
there are two arguments that lie in the same family),
and <C>IsCollsElms</C>
(which means that there are two arguments,
the first being a collection of elements that lie in the same family
as the second argument).
<P/>
Second &ndash;and this is the more complicated situation&ndash;
whenever one creates a new kind of objects,
one has to decide what its family shall be.
If the new object shall be equal to existing objects,
for example if it is just represented in a different way,
there is no choice:
The new object must lie in the same family as all objects
that shall be equal to it.
So only if the new object is different
(w.r.t.&nbsp;the equality <Q><C>=</C></Q>)
from all other &GAP; objects, we are likely to create a new family
for it.
Note that enlarging an existing family by such new objects
may be problematic because of implications that have been
installed for all  objects of the family in question.
The choice of families depends on the applications one has in mind.
For example, if the new objects in question are not likely to be
arguments of operations for which family relations are relevant
(for example binary arithmetic operations),
one could create one family for all such objects,
and regard it as <Q>the family of all those &GAP; objects that would
in fact not need a family</Q>.
On the other extreme, if one wants to create domains of the new objects
then one has to choose the family in such a way that all intended
elements of a domain do in fact lie in the same family.
(Remember that a domain is a collection,
see Chapter&nbsp;<Ref Sect="Domains"/>,
and that a collection consists of elements in the same family,
see Chapter&nbsp;<Ref Chap="Collections"/>
and Section&nbsp;<Ref Sect="Families"/>.)
<P/>
Let us look at an example.
Suppose that no permutations are available in &GAP;,
and that we want to implement permutations.
Clearly we want to support permutation groups,
but it is not a priori clear how to distribute the new permutations
into families.
We can put all permutations into one family;
this is how in fact permutations are implemented in &GAP;.
But it would also be possible to put all permutations of a given degree
into a family of their own;
this would for example mean that for each degree,
there would be distinguished trivial permutations,
and that the stabilizer of the point <C>5</C> in the symmetric group on the
points <C>1</C>, <C>2</C>, <M>\ldots</M>, <C>5</C> is not regarded as equal to the
symmetric group on <C>1</C>, <C>2</C>, <C>3</C>, <C>4</C>.
Note that the latter approach would have the advantage that it is
no problem to construct permutations and permutation groups acting on
arbitrary (finite) sets,
for example by constructing first the symmetric group on the set
and then generating any desired permutation group as a subgroup of this
symmetric group.
<P/>
So one aspect concerning a reasonable choice of families is
to make the families large enough for being able to form interesting
domains of elements in the family.
But on the other hand,
it is useful to choose the families small enough for admitting
meaningful relations between objects.
For example, the elements of different free groups in &GAP;
lie in different families;
the multiplication of free group elements is installed only for the
case that the two operands lie in the same family,
with the effect that one cannot erroneously form the product of
elements from different free groups.
In this case, families appear as a tool for providing useful
restrictions.
<P/>
As another example, note that an element and a collection containing
this element never lie in the same family,
by the general implementation of collections;
namely, the family of a collection of elements in the family <A>Fam</A>
is the collections family of <A>Fam</A> (see&nbsp;<Ref Func="CollectionsFamily"/>).
This means that for a collection, we need not (because we cannot)
decide about its family.
<P/>
A few functions in &GAP; return families,
see <Ref Func="CollectionsFamily"/> and <Ref Func="ElementsFamily"/>.

<ManSection>
<Func Name="NewFamily" Arg='name[, req[, imp[, famfilter]]]'/>

<Description>
<Ref Func="NewFamily"/> returns a new family <A>fam</A> with name
<A>name</A>.
The argument <A>req</A>, if present, is a filter of which <A>fam</A>
shall be a subset.
If one tries to create an object in <A>fam</A> that does not lie in the
filter <A>req</A>, an error message is printed.
Also the argument <A>imp</A>, if present,
is a filter of which <A>fam</A> shall be a subset.
Any object that is created in the family <A>fam</A> will lie
automatically in the filter <A>imp</A>.
<P/>
The filter <A>famfilter</A>, if given, specifies a filter that will hold
for the family <A>fam</A> (not for objects in <A>fam</A>).
<P/>
Families are always represented as component objects
(see&nbsp;<Ref Sect="Component Objects"/>).
This means that components can be used to store and access
useful information about the family.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Types">
<Heading>Creating Types</Heading>

<ManSection>
<Func Name="NewType" Arg='family, filter[, data]'/>

<Description>
<Ref Func="NewType"/> returns the type given by the family <A>family</A>
and the filter <A>filter</A>.
The optional third argument <A>data</A> is any object that denotes
defining data of the desired type.
<P/>
For examples where <Ref Func="NewType"/> is used,
see&nbsp;<Ref Sect="Component Objects"/>,
<Ref Sect="Positional Objects"/>,
and the example in Chapter
<Ref Chap="An Example -- Residue Class Rings"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Objects">
<Heading>Creating Objects</Heading>

<ManSection>
<Func Name="Objectify" Arg="type, data"/>

<Description>
New objects are created by <Ref Func="Objectify"/>.
<A>data</A> is a list or a record, and <A>type</A> is the type that the
desired object shall have.
<Ref Func="Objectify"/> turns <A>data</A> into an object with type
<A>type</A>.
That is, <A>data</A> is changed, and afterwards it will not be a list or a
record unless <A>type</A> is of type list resp. record.
<P/>
If <A>data</A> is a list then <Ref Func="Objectify"/> turns it into a
positional object, if <A>data</A> is a record then
<Ref Func="Objectify"/> turns it into a component object
(for examples, see&nbsp;<Ref Sect="Component Objects"/>
and&nbsp;<Ref Sect="Positional Objects"/>).
<P/>
<Ref Func="Objectify"/> does also return the object that it made out of
<A>data</A>.
<P/>
For examples where <Ref Func="Objectify"/> is used,
see&nbsp;<Ref Sect="Component Objects"/>,
<Ref Sect="Positional Objects"/>, and the example in
Chapter&nbsp;<Ref Chap="An Example -- Residue Class Rings"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="ObjectifyWithAttributes"
 Arg='obj, type, attr1, val1, attr2, val2, ...'/>

<Description>
Attribute assignments will change the type of an object.
If you create many objects, code of the form
<P/>
<Log><![CDATA[
o:=Objectify(type,rec());
SetMyAttribute(o,value);
]]></Log>
<P/>
will take a lot of time for type changes.
You can avoid this  by  setting the attributes immediately while the
object is created, as follows.
<Ref Func="ObjectifyWithAttributes"/>
changes the type of object <A>obj</A> to type <A>type</A>
and sets attribute <A>attr1</A> to <A>val1</A>,
sets attribute <A>attr2</A> to <A>val2</A> and so forth.
<P/>
If the filter list of <A>type</A> includes that these attributes are set
(and the properties also include values of the properties)
and if no special setter methods are installed for any of the involved
attributes then they are set simultaneously without type changes.
This can produce a substantial speedup.
<P/>
If the conditions of the last sentence are not fulfilled, an ordinary
<Ref Func="Objectify"/> with subsequent setter calls for the attributes
is performed instead.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Component Objects">
<Heading>Component Objects</Heading>

A <E>component object</E> is an object in the representation
<C>IsComponentObjectRep</C> or a subrepresentation of it.
Such an object <A>cobj</A> is built from subobjects that can be accessed via
<C><A>cobj</A>!.<A>name</A></C>, similar to components of a record.
Also analogously to records, values can be assigned to components of
<A>cobj</A> via <C><A>cobj</A>!.<A>name</A>:= <A>val</A></C>.
For the creation of component objects, see&nbsp;<Ref Sect="Creating Objects"/>.

One must be <E>very careful</E> when using the <C>!.</C> operator,
in order to interpret the component in the right way,
and even more careful when using the assignment to components using <C>!.</C>,
in order to keep the information stored in <A>cobj</A> consistent.
<P/>
First of all, in the access or assignment to a component as shown above,
<A>name</A> must be among the admissible component names
for the representation of <A>cobj</A>, see&nbsp;<Ref Sect="Creating Representations"/>.
Second, preferably only few low level functions should use <C>!.</C>,
whereas this operator should not occur in <Q>user interactions</Q>.
<P/>
Note that even if <A>cobj</A> claims that it is immutable, i.e.,
if <A>cobj</A> is not in the category <Ref Func="IsMutable"/>,
access and assignment via <C>!.</C> and <C>!.:=</C> work.
This is necessary for being able to store newly discovered information
in immutable objects.
<P/>
The following example shows the implementation of an iterator
(see&nbsp;<Ref Sect="Iterators"/>) for the domain of integers,
which is represented as component object.
See&nbsp;<Ref Sect="Positional Objects"/> for an implementation using positional objects.
(In practice, such an iterator can be implemented more elegantly using
<Ref Func="IteratorByFunctions"/>,
see&nbsp;<Ref Sect="Example -- Constructing Iterators"/>.)
<P/>
The used succession of integers is <M>0, 1, -1, 2, -2, 3, -3, \ldots</M>,
that is, <M>a_n = n/2</M> if <M>n</M> is even,
and <M>a_n = (1-n)/2</M> otherwise.
<P/>
<Log><![CDATA[
IsIntegersIteratorCompRep := NewRepresentation( "IsIntegersIteratorRep",
    IsComponentObjectRep, [ "counter" ] );
]]></Log>
<P/>
The above command creates a new representation (see&nbsp;<Ref Func="NewRepresentation"/>)
<C>IsIntegersIteratorCompRep</C>,
as a subrepresentation of <C>IsComponentObjectRep</C>,
and with one admissible component <C>counter</C>.
So no other components than <C>counter</C> will be needed.
<P/>
<Log><![CDATA[
InstallMethod( Iterator,
    "method for `Integers'",
    [ IsIntegers ],
    function( Integers )
    return Objectify( NewType( IteratorsFamily,
                                   IsIterator
                               and IsIntegersIteratorCompRep ),
                      rec( counter := 0 ) );
    end );
]]></Log>
<P/>
After the above method installation, one can already ask for
<C>Iterator( Integers )</C>.
Note that exactly the domain of integers is described by
the filter <Ref Func="IsIntegers"/>.
<P/>
By the call to <Ref Func="NewType"/>, the returned object lies in the family
containing all iterators, which is <C>IteratorsFamily</C>,
it lies in the category <Ref Func="IsIterator"/>
and in the representation <C>IsIntegersIteratorCompRep</C>;
furthermore, it has the component <C>counter</C> with value <C>0</C>.
<P/>
What is missing now are methods for the two basic operations
of iterators, namely <Ref Func="IsDoneIterator"/> and
<Ref Func="NextIterator"/>.
The former must always return <K>false</K>, since there are infinitely
many integers.
The latter must return the next integer in the iteration,
and update the information stored in the iterator,
that is, increase the value of the component <C>counter</C>.
<P/>
<Log><![CDATA[
InstallMethod( IsDoneIterator,
    "method for iterator of `Integers'",
    [ IsIterator and IsIntegersIteratorCompRep ],
    ReturnFalse );

InstallMethod( NextIterator,
    "method for iterator of `Integers'",
    [ IsIntegersIteratorCompRep ],
    function( iter )
    iter!.counter:= iter!.counter + 1;
    if iter!.counter mod 2 = 0 then
      return iter!.counter / 2;
    else
      return ( 1 - iter!.counter ) / 2;
    fi;
    end );
]]></Log>

<ManSection>
<Func Name="NamesOfComponents" Arg='comobj'/>

<Description>
For a component object <A>comobj</A>,
<Ref Func="NamesOfComponents"/> returns a list of strings,
which are the names of components currently bound in <A>comobj</A>.
<P/>
For a record <A>comobj</A>,
<Ref Func="NamesOfComponents"/> returns the result of
<Ref Func="RecNames"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Positional Objects">
<Heading>Positional Objects</Heading>

A <E>positional object</E> is an object in the representation
<C>IsPositionalObjectRep</C> or a subrepresentation of it.
Such an object <A>pobj</A> is built from subobjects that can be accessed via
<C><A>pobj</A>![<A>pos</A>]</C>, similar to positions in a list.
Also analogously to lists, values can be assigned to positions of
<A>pobj</A> via <C><A>pobj</A>![<A>pos</A>]:= <A>val</A></C>.
For the creation of positional objects, see&nbsp;<Ref Sect="Creating Objects"/>.
<P/>
One must be <E>very careful</E> when using the <C>![]</C> operator,
in order to interpret the position in the right way,
and even more careful when using the assignment to positions using <C>![]</C>,
in order to keep the information stored in <A>pobj</A> consistent.
<P/>
First of all, in the access or assignment to a position as shown above,
<A>pos</A> must be among the admissible positions
for the representation of <A>pobj</A>, see&nbsp;<Ref Sect="Creating Representations"/>.
Second, preferably only few low level functions should use <C>![]</C>,
whereas this operator should not occur in <Q>user interactions</Q>.
<P/>
Note that even if <A>pobj</A> claims that it is immutable, i.e.,
if <A>pobj</A> is not in the category <Ref Func="IsMutable"/>,
access and assignment via <C>![]</C> work.
This is necessary for being able to store newly discovered information
in immutable objects.
<P/>
The following example shows the implementation of an iterator
(see&nbsp;<Ref Sect="Iterators"/>) for the domain of integers,
which is represented as positional object.
See&nbsp;<Ref Sect="Component Objects"/> for an implementation using component objects,
and more details.
<P/>
<Log><![CDATA[
IsIntegersIteratorPosRep := NewRepresentation( "IsIntegersIteratorRep",
    IsPositionalObjectRep, [ 1 ] );
]]></Log>
<P/>
The above command creates a new representation (see&nbsp;<Ref Func="NewRepresentation"/>)
<C>IsIntegersIteratorPosRep</C>,
as a subrepresentation of <C>IsComponentObjectRep</C>,
and with only the first position being admissible for storing data.
<P/>
<Log><![CDATA[
InstallMethod( Iterator,
    "method for `Integers'",
    [ IsIntegers ],
    function( Integers )
    return Objectify( NewType( IteratorsFamily,
                                   IsIterator
                               and IsIntegersIteratorRep ),
                      [ 0 ] );
    end );
]]></Log>
<P/>
After the above method installation, one can already ask for
<C>Iterator( Integers )</C>.
Note that exactly the domain of integers is described by
the filter <Ref Func="IsIntegers"/>.
<P/>
By the call to <Ref Func="NewType"/>, the returned object lies in the family
containing all iterators, which is <C>IteratorsFamily</C>,
it lies in the category <Ref Func="IsIterator"/>
and in the representation <C>IsIntegersIteratorPosRep</C>;
furthermore, the first position has value <C>0</C>.
<P/>
What is missing now are methods for the two basic operations
of iterators, namely <Ref Func="IsDoneIterator"/>
and <Ref Func="NextIterator"/>.
The former must always return <K>false</K>, since there are infinitely
many integers.
The latter must return the next integer in the iteration,
and update the information stored in the iterator,
that is, increase the value stored in the first position.
<P/>
<Log><![CDATA[
InstallMethod( IsDoneIterator,
    "method for iterator of `Integers'",
    [ IsIterator and IsIntegersIteratorPosRep ],
    ReturnFalse );

InstallMethod( NextIterator,
    "method for iterator of `Integers'",
    [ IsIntegersIteratorPosRep ],
    function( iter )
    iter![1]:= iter![1] + 1;
    if iter![1] mod 2 = 0 then
      return iter![1] / 2;
    else
      return ( 1 - iter![1] ) / 2;
    fi;
    end );
]]></Log>
<P/>
It should be noted that one can of course install both the methods shown
in Section&nbsp;<Ref Sect="Component Objects"/> and <Ref Sect="Positional Objects"/>.
The call <C>Iterator( Integers )</C> will cause one of the methods to be
selected, and for the returned iterator, which will have one of the
representations we constructed,
the right <Ref Func="NextIterator"/> method will be chosen.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Implementing New List Objects">
<Heading>Implementing New List Objects</Heading>

This section gives some hints for the quite usual situation that one wants
to implement new objects that are lists.
More precisely, one either wants to deal with lists that have additional
features, or one wants that some objects also behave as lists.
An example can be found in&nbsp;<Ref Sect="Example -- Constructing Enumerators"/>.
<P/>
A <E>list</E> in &GAP; is an object in the category
<Ref Func="IsList"/>.
Basic operations for lists are <Ref Func="Length"/>,
<Ref Func="\[\]"/>,
and <Ref Func="IsBound\[\]"/>
(see&nbsp;<Ref Sect="Basic Operations for Lists"/>).
<P/>
Note that the access to the position <A>pos</A> in the list <A>list</A>
via <C><A>list</A>[<A>pos</A>]</C> is handled by the call
<C>\[\]( <A>list</A>, <A>pos</A> )</C>
to the operation <Ref Func="\[\]"/>.
To explain the somewhat strange name <C>\[\]</C> of this operation,
note that non-alphanumeric characters like <C>[</C> and <C>]</C> may occur in
&GAP; variable names only if they are escaped by a <C>\</C> character.
<P/>
Analogously, the check <C>IsBound( <A>list</A>[<A>pos</A>] )</C> whether the position
<A>pos</A> of the list <A>list</A> is bound is handled by the call
<C>IsBound\[\]( <A>list</A>, <A>pos</A> )</C> to the operation
<Ref Func="IsBound\[\]"/>.
<P/>
For mutable lists, also assignment to positions and unbinding of
positions via the operations <Ref Func="\[\]\:\="/>
and <Ref Func="Unbind\[\]"/>
are basic operations.
The assignment <C><A>list</A>[<A>pos</A>]:= <A>val</A></C>
is handled by the call
<C>\[\]\:\=( <A>list</A>, <A>pos</A>, <A>val</A> )</C>,
and <C>Unbind( <A>list</A>[<A>pos</A>] )</C> is handled by the call
<C>Unbind\[\]( <A>list</A>, <A>pos</A> )</C>.
<P/>
All other operations for lists, e.g., <Ref Func="Add"/>,
<Ref Func="Append"/>, <Ref Func="Sum"/>,
are based on these operations.
This means that it is sufficient to install methods for the new list
objects only for the basic operations.
<P/>
So if one wants to implement new list objects then one creates them
as objects in the category <Ref Func="IsList"/>,
and installs methods for <Ref Func="Length"/>,
<Ref Func="\[\]"/>,
and <Ref Func="IsBound\[\]"/>.
If the new lists shall be mutable, one needs to install also methods
for <Ref Func="\[\]\:\="/> and
<Ref Func="Unbind\[\]"/>.
<P/>
One application for this is the implementation of <E>enumerators</E>
for domains.
An enumerator for the domain <M>D</M> is a dense list whose entries are
in bijection with the elements of <M>D</M>.
If <M>D</M> is large then it is not useful to write down all elements.
Instead one can implement such a bijection implicitly.
This works also for infinite domains.
<P/>
In this situation, one implements a new representation of the
lists that are already available in &GAP;,
in particular the family of such a list is the same as the family of
the domain <M>D</M>.
<P/>
But it is also possible to implement new kinds of lists that lie in
new families, and thus are not equal to lists that were available
in &GAP; before.
An example for this is the implementation of matrices
whose multiplication via <Q><C>*</C></Q> is the Lie product of matrices.
<P/>
In this situation, it makes no sense to put the new matrices into the
same family as the original matrices.
Note that the product of two Lie matrices shall be defined but not the
product of an ordinary matrix and a Lie matrix.
So it is possible to have two lists that have the same entries but that
are not equal w.r.t. <Q><C>=</C></Q> because they lie in different families.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Example -- Constructing Enumerators">
<Heading>Example &ndash; Constructing Enumerators</Heading>

When dealing with countable sets, a usual task is to define enumerations,
i.e., bijections to the positive integers.
In &GAP;, this can be implemented via <E>enumerators</E>
(see&nbsp;<Ref Sect="Enumerators"/>).
These are lists containing the elements in a specified ordering,
and the operations <Ref Func="Position"/>
and list access via <Ref Func="\[\]"/> define the
desired bijection.
For implementing such an enumerator, one mainly needs to install the
appropriate functions for these operations.
<P/>
A general setup for creating such lists is given by
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>.
<P/>
If the set in question is a domain <A>D</A> for which a
<Ref Func="Size"/> method is
available then all one has to do is to write down the functions for
computing the <M>n</M>-th element of the list and for computing the position
of a given &GAP; object in the list, to put them into the components
<C>ElementNumber</C> and <C>NumberElement</C> of a record, and to call
<Ref Func="EnumeratorByFunctions" Label="for a domain and a record"/>
with the domain <A>D</A> and this record as arguments.
For example, the following lines of code install an
<Ref Func="Enumerator"/> method
for the case that <A>D</A> is the domain of rational integers.
(Note that <Ref Func="IsIntegers"/> is a filter
that describes exactly the domain of rational integers.)
<P/>
<Log><![CDATA[
InstallMethod( Enumerator,
    "for integers",
    [ IsIntegers ],
    Integers -> EnumeratorByFunctions( Integers, rec(
                    ElementNumber := function( e, n ) ... end,
                    NumberElement := function( e, x ) ... end ) ) );
]]></Log>
<P/>
The bodies of the functions have been omitted above;
here is the code that is actually used in &GAP;.
(The ordering coincides with that for the iterators for the domain of
rational integers that have been discussed in&nbsp;<Ref Sect="Component Objects"/>
and&nbsp;<Ref Sect="Positional Objects"/>.)
<P/>
<Example><![CDATA[
gap> enum:= Enumerator( Integers );
<enumerator of Integers>
gap> Print( enum!.NumberElement, "\n" );
function ( e, x )
    local  pos;
    if not IsInt( x )  then
        return fail;
    elif 0 < x  then
        pos := 2 * x;
    else
        pos := -2 * x + 1;
    fi;
    return pos;
end
gap> Print( enum!.ElementNumber, "\n" );
function ( e, n )
    if n mod 2 = 0  then
        return n / 2;
    else
        return (1 - n) / 2;
    fi;
    return;
end
]]></Example>
<P/>
The situation becomes slightly more complicated if the set <M>S</M> in question
is not a domain.
This is because one must provide also at least a method for computing the
length of the list, and because one has to determine the family in which
it lies (see&nbsp;<Ref Sect="Creating Objects"/>).
The latter should usually not be a problem since either <M>S</M> is nonempty and
all its elements lie in the same family &ndash;in this case one takes the
collections family of any element in <M>S</M>&ndash; or the family of the enumerator
must be <C>ListsFamily</C>.
<P/>
An example in the &GAP; library is an enumerator for the set of <M>k</M>-tuples
over a finite set; the function is called
<Ref Func="EnumeratorOfTuples"/>.
<!-- % The functions <C>ExtendedVectors</C> and <C>OneDimSubspacesTransversal</C> are -->
<!-- % also examples but are currently also undocumented ... -->
<P/>
<Example><![CDATA[
gap> Print( EnumeratorOfTuples, "\n" );
function ( set, k )
    local  enum;
    if k = 0  then
        return Immutable( [ [  ] ] );
    elif IsEmpty( set )  then
        return Immutable( [  ] );
    fi;
    enum 
     := EnumeratorByFunctions( CollectionsFamily( FamilyObj( set ) ), 
       rec(
          ElementNumber := function ( enum, n )
                local  nn, t, i;
                nn := n - 1;
                t := [  ];
                for i  in [ 1 .. enum!.k ]  do
                    t[i] := RemInt( nn, Length( enum!.set ) ) + 1;
                    nn := QuoInt( nn, Length( enum!.set ) );
                od;
                if nn <> 0  then
                    Error( "<enum>[", n, 
                     "] must have an assigned value" );
                fi;
                nn := enum!.set{Reversed( t )};
                MakeImmutable( nn );
                return nn;
            end,
          NumberElement := function ( enum, elm )
                local  n, i;
                if not IsList( elm )  then
                    return fail;
                fi;
                elm := List( elm, function ( x )
                        return Position( enum!.set, x );
                    end );
                if fail in elm or Length( elm ) <> enum!.k  then
                    return fail;
                fi;
                n := 0;
                for i  in [ 1 .. enum!.k ]  do
                    n := Length( enum!.set ) * n + elm[i] - 1;
                od;
                return n + 1;
            end,
          Length := function ( enum )
                return Length( enum!.set ) ^ enum!.k;
            end,
          PrintObj := function ( enum )
                Print( "EnumeratorOfTuples( ", enum!.set, ", ", 
                 enum!.k, " )" );
                return;
            end,
          set := Set( set ),
          k := k ) );
    SetIsSSortedList( enum, true );
    return enum;
end
]]></Example>
<P/>
We see that the enumerator is a homogeneous list that stores individual
functions <C>ElementNumber</C>, <C>NumberElement</C>,
<C>Length</C>, and <C>PrintObj</C>;
besides that, the data components <M>S</M> and <M>k</M> are contained.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Example -- Constructing Iterators">
<Heading>Example &ndash; Constructing Iterators</Heading>

Iterators are a kind of objects that is implemented for several collections
in the &GAP; library and which might be interesting also in other cases,
see&nbsp;<Ref Sect="Iterators"/>.
A general setup for implementing new iterators is provided by
<Ref Func="IteratorByFunctions"/>.
<P/>
All one has to do is to write down the functions for
<Ref Func="NextIterator"/>,
<Ref Func="IsDoneIterator"/>,
and <Ref Func="ShallowCopy"/>, and to call
<Ref Func="IteratorByFunctions"/> with this record as argument.
For example, the following lines of code install an
<Ref Func="Iterator"/> method
for the case that the argument is the domain of rational integers.
<P/>
(Note that <Ref Func="IsIntegers"/> is a filter
that describes exactly the domain of rational integers.)
<P/>
<Log><![CDATA[
InstallMethod( Iterator,
    "for integers",
    [ IsIntegers ],
    Integers -> IteratorByFunctions( rec(
                    NextIterator:= function( iter ) ... end,
                    IsDoneIterator := ReturnFalse,
                    ShallowCopy := function( iter ) ... end ) ) );
]]></Log>
<P/>
The bodies of two of the functions have been omitted above;
here is the code that is actually used in &GAP;.
(The ordering coincides with that for the iterators for the domain of
rational integers that have been discussed in&nbsp;<Ref Sect="Component Objects"/>
and&nbsp;<Ref Sect="Positional Objects"/>.)
<P/>
<Example><![CDATA[
gap> iter:= Iterator( Integers );
<iterator of Integers at 0>
gap> Print( iter!.NextIterator, "\n" );
function ( iter )
    iter!.counter := iter!.counter + 1;
    if iter!.counter mod 2 = 0  then
        return iter!.counter / 2;
    else
        return (1 - iter!.counter) / 2;
    fi;
    return;
end
gap> Print( iter!.ShallowCopy, "\n" );   
function ( iter )
    return rec(
        counter := iter!.counter );
end
]]></Example>
<P/>
Note that the <C>ShallowCopy</C> component of the record must be a function
that does not return an iterator but a record that can be used as the
argument of <Ref Func="IteratorByFunctions"/>
in order to create the desired shallow copy.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Issues in the Implementation of New Kinds of Lists">
<Heading>Arithmetic Issues in the Implementation of New Kinds of Lists</Heading>

When designing a new kind of list objects in &GAP;,
defining the arithmetic behaviour of these objects is an issue.
<P/>
There are situations where arithmetic operations of list objects
are unimportant in the sense that adding two such lists need not be
represented in a special way.
In such cases it might be useful either to support no arithmetics at all
for the new lists, or to enable the default arithmetic methods.
The former can be achieved by not setting the filters
<Ref Func="IsGeneralizedRowVector"/> and
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>
in the types of the lists,
the latter can be achieved by setting the filter
<Ref Func="IsListDefault"/>.
(for details,
see&nbsp;<Ref Sect="Filters Controlling the Arithmetic Behaviour of Lists"/>).
An example for <Q>wrapped lists</Q> with default behaviour are vector space
bases;
they are lists with additional properties concerning the computation of
coefficients, but arithmetic properties are not important.
So it is no loss to enable the default methods for these lists.
<P/>
However, often the arithmetic behaviour of new list objects is important,
and one wants to keep these lists away from default methods for addition,
multiplication etc.
For example, the sum and the product of (compatible) block matrices shall
be represented as a block matrix, so the default methods for sum and
product of matrices shall not be applicable,
although the results will be equal to those of the default methods
in the sense that their entries at corresponding positions are equal.
<P/>
So one does not set the filter <Ref Func="IsListDefault"/>
in such cases,
and thus one can implement one's own methods for arithmetic operations.
<!-- % It should be stated explicitly what <Q>arithmetic operations</Q> means! -->
(Of course <Q>can</Q> means on the other hand that one <E>must</E> implement such
methods if one is interested in arithmetics of the new lists.)
<P/>
The specific binary arithmetic methods for the new lists will usually cover
the case that both arguments are of the new kind,
and perhaps also the interaction between a list of the new kind and certain
other kinds of lists may be handled if this appears to be useful.
<P/>
For the last situation, interaction between a new kind of lists and other
kinds of lists, &GAP; provides already a setup.
Namely, there are the categories
<Ref Func="IsGeneralizedRowVector"/> and
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>,
which are concerned with the
additive and the multiplicative behaviour, respectively, of lists. 
For lists in these filters, the structure of the results of arithmetic
operations is prescribed (see&nbsp;<Ref Sect="Additive Arithmetic for Lists"/> and
<Ref Sect="Multiplicative Arithmetic for Lists"/>).
<P/>
For example,
if one implements block matrices in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>
then automatically the product of such a block matrix and a (plain) list
of such block matrices will be defined as the obvious list of matrix
products, and a default method for plain lists will handle this
multiplication.
(Note that this method will rely on a method for computing the product of
the block matrices, and of course no default method is available for that.)
Conversely, if the block matrices are not in
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>
then the product of a block matrix
and a (plain) list of block matrices is not defined.
(There is no default method for it, and one can define the result and
provide a method for computing it.)
<P/>
Thus if one decides to set the filters
<Ref Func="IsGeneralizedRowVector"/> and
<Ref Func="IsMultiplicativeGeneralizedRowVector"/>
for the new lists,
on the one hand one loses freedom in defining arithmetic behaviour,
but on the other hand one gains several default methods for a more
or less natural behaviour.
<P/>
If a list in the filter <Ref Func="IsGeneralizedRowVector"/>
(<Ref Func="IsMultiplicativeGeneralizedRowVector"/>)
lies in <C>IsAttributeStoringRep</C>,
the values of additive (multiplicative) nesting depth is stored in
the list and need not be calculated for each arithmetic operation.
One can then store the value(s) already upon creation of the lists,
with the effect that the default arithmetic operations will access
elements of these lists only if this is unavoidable.
For example, the sum of two plain lists of <Q>wrapped matrices</Q> with
stored nesting depths are computed via the method for adding two such
wrapped lists, and without accessing any of their rows
(which might be expensive).
In this sense, the wrapped lists are treated as black boxes.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="External Representation">
<Heading>External Representation</Heading>

An operation is defined for elements rather than for objects in the sense
that if the arguments are replaced by objects that are equal to the old
arguments w.r.t. the equivalence relation <Q><C>=</C></Q> then the result must be
equal to the old result w.r.t.&nbsp;<Q><C>=</C></Q>.
<P/>
But the implementation of many methods is representation dependent in the
sense that certain representation dependent subobjects are accessed.
<P/>
For example, a method that implements the addition of univariate
polynomials may access coefficients lists of its arguments
only if they are really stored,
while in the case of sparsely represented polynomials a different approach
is needed.
<P/>
In spite of this, for many operations one does not want to write an own
method for each possible representations of each argument,
for example because none of the methods could in fact take advantage
of the actually given representations of the objects.
Another reason could be that one wants to install first a representation
independent method, and then add specific methods as they are needed to
gain more efficiency, by really exploiting the fact that the arguments
have certain representations.
<P/>
For the purpose of admitting representation independent code,
one can define an <E>external representation</E> of objects in a given family,
install methods to compute this external representation for each
representation of the objects,
and then use this external representation of the objects whenever they
occur.
<P/>
We cannot provide conversion functions that allow us to first convert
any object in question to one particular <Q>standard representation</Q>,
and then access the data in the way defined for this representation,
simply because it may be impossible to choose such a <Q>standard
representation</Q> uniformly for all objects in the given family.
<P/>
So the aim of an external representation of an object <A>obj</A> is a
different one, namely to describe the data from which <A>obj</A> is composed.
In particular, the external representation of <A>obj</A> is <E>not</E> one possible
(<Q>standard</Q>) representation of <A>obj</A>,
in fact the external representation of <A>obj</A> is in general different
from <A>obj</A> w.r.t.&nbsp;<Q><C>=</C></Q>,
first  of all because the external representation of <A>obj</A> does in general
not lie in the same family as <A>obj</A>.
<P/>
For example the external representation of a rational function is a list
of length two or three, the first entry being the zero coefficient,
the second being a list describing the coefficients and monomials of the
numerator, and the third, if bound, being a list describing the coefficients
and monomials of the denominator.
In particular, the external representation of a polynomial is a list
and not a polynomial.
<P/>
The other way round, the external representation of <A>obj</A> encodes <A>obj</A>
in such a way that from this data and the family of <A>obj</A>,
one can create an object that is equal to <A>obj</A>.
Usually the external representation of an object is a list or a record.
<P/>
Although the external representation of <A>obj</A> is by definition independent
of the actually available representations for <A>obj</A>,
it is usual that a representation of <A>obj</A> exists for which the
computation of the external representation is obtained by just
<Q>unpacking</Q> <A>obj</A>,
in the sense that the desired data is stored in a component or a position
of <A>obj</A>, if <A>obj</A> is a component object (see&nbsp;<Ref Sect="Component Objects"/>)
or a positional object (see&nbsp;<Ref Sect="Positional Objects"/>).
<P/>
To implement an external representation means to install methods for the
following two operations.

<ManSection>
<Func Name="ExtRepOfObj" Arg='obj'/>
<Func Name="ObjByExtRep" Arg='fam, data'/>

<Description>
<Ref Func="ExtRepOfObj"/> returns the external representation of its argument,
and <Ref Func="ObjByExtRep"/> returns an object in the family <A>fam</A>
that has external representation <A>data</A>.
<P/>
Of course,
<C>ObjByExtRep( FamilyObj( <A>obj</A> ), ExtRepOfObj( <A>obj</A> ) )</C>
must be equal to <A>obj</A> w.r.t. the operation
<Ref Func="\="/>.
But it is <E>not</E> required that equal objects have equal external
representations.
<P/>
Note that if one defines a new representation of objects for which an
external representation does already exist
then one <E>must</E> install a method to compute this external representation
for the objects in the new representation.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Mutability and Copying">
<Heading>Mutability and Copying</Heading>

Any &GAP; object is either mutable or immutable. This can be tested
with the function <Ref Func="IsMutable"/>.
The intended meaning of (im)mutability is a mathematical one:
an immutable object should never change in
such a way that it represents a different Element. Objects <E>may</E>
change in other ways, for instance to store more information, or
represent an element in a different way.
<P/>
Immutability is enforced in different ways for built-in objects (like
records, or lists) and for external objects (made using
<Ref Func="Objectify"/>).
<P/>
For built-in objects which are immutable, the kernel will prevent
you from changing them. Thus
<P/>
<Example><![CDATA[
gap> l := [1,2,4];
[ 1, 2, 4 ]
gap> MakeImmutable(l);
[ 1, 2, 4 ]
gap> l[3] := 5;
Error, Lists Assignment: <list> must be a mutable list
]]></Example>
<P/>
For external objects, the situation is different. An external object which
claims to be immutable (i.e. its type does not contain
<Ref Func="IsMutable"/>)
should not admit any methods which change the element it represents.
The kernel does <E>not</E> prevent the use of <C>!.</C> and <C>![</C>
to change the underlying data structure.
This is used for instance by the code that stores attribute values for reuse.
In general, these <C>!</C> operations should only be used in methods
which depend on the representation of the object.
Furthermore, we would <E>not</E>
recommend users to install methods which depend on the representations of
objects created by the library or by &GAP; packages, as there is certainly no
guarantee of the representations being the same in future versions of &GAP;.
<P/>
Here we see an immutable object (the group <M>S_4</M>), in which we improperly
install a new component.
<P/>
<Example><![CDATA[
gap> g := SymmetricGroup(IsPermGroup,4);
Sym( [ 1 .. 4 ] )
gap> IsMutable(g);
false
gap> NamesOfComponents(g);
[ "Size", "NrMovedPoints", "MovedPoints", 
  "GeneratorsOfMagmaWithInverses" ]
gap> g!.silly := "rubbish";
"rubbish"
gap> NamesOfComponents(g);
[ "Size", "NrMovedPoints", "MovedPoints", 
  "GeneratorsOfMagmaWithInverses", "silly" ]
gap> g!.silly;
"rubbish"
]]></Example>
<P/>
On the other hand, if we form an immutable externally represented list, we
find that &GAP; will not let us change the object.
<P/>
<Example><![CDATA[
gap> e := Enumerator(g);
<enumerator of perm group>
gap> IsMutable(e);
false
gap> IsList(e);
true
gap> e[3];
(1,2,4)
gap> e[3] := false;
Error, The list you are trying to assign to is immutable
]]></Example>
<P/>
When we consider copying objects, another filter
<Ref Func="IsCopyable"/>, enters the game and we find that
<Ref Func="ShallowCopy"/> and
<Ref Func="StructuralCopy"/> behave quite
differently. Objects can be divided for this purpose into three:
mutable objects, immutable but copyable objects, and non-copyable
objects (called constants).
<P/>
A mutable or copyable object should have a method for the operation
<Ref Func="ShallowCopy"/>,
which should make a new mutable object, sharing its top-level
subobjects with the original. The exact definition of top-level subobject may
be defined by the implementor for new kinds of object.
<P/>
<Ref Func="ShallowCopy"/> applied to a constant
simply returns the constant.
<P/>
<Ref Func="StructuralCopy"/> is expected to be much less used
than <Ref Func="ShallowCopy"/>.
Applied to a mutable object, it returns a new mutable
object which shares no mutable sub-objects with the input. Applied to
an immutable object (even a copyable one), it just returns the
object. It is not an operation (indeed, it's a rather special kernel
function).
<P/>
<Example><![CDATA[
gap> e1 := StructuralCopy(e);
<enumerator of perm group>
gap> IsMutable(e1);
false
gap> e2 := ShallowCopy(e);
[ (), (1,4), (1,2,4), (1,3,4), (2,4), (1,4,2), (1,2), (1,3,4,2), 
  (2,3,4), (1,4,2,3), (1,2,3), (1,3)(2,4), (3,4), (1,4,3), (1,2,4,3), 
  (1,3), (2,4,3), (1,4,3,2), (1,2)(3,4), (1,3,2), (2,3), (1,4)(2,3), 
  (1,2,3,4), (1,3,2,4) ]
gap> 
]]></Example>
<P/>
There are two other related functions:
<Ref Func="Immutable"/>, which makes a new
immutable object which shares no mutable subobjects with its input and
<Ref Func="MakeImmutable"/> which changes an object and its
mutable subobjects <E>in place</E> to be immutable.
It should only be used on <Q>new</Q> objects that
you have just created, and which cannot share mutable subobjects with
anything else.
<P/>
Both <Ref Func="Immutable"/> and
<Ref Func="MakeImmutable"/> work on external objects by just
resetting the <Ref Func="IsMutable"/> filter
in the object's type. This should make
ineligible any methods that might change the object. As a consequence,
you must allow for the possibility of immutable versions of any
objects you create.
<P/>
So, if you are implementing your own external objects. The rules amount to the
following:
<P/>
<Enum>
  <Item>
    You decide if your objects should be mutable or copyable or constants, by
    fixing whether their type includes <Ref Func="IsMutable"/>
    or <Ref Func="IsCopyable"/>.
  </Item>
  <Item>
    You install methods for your objects respecting that decision:
    <List>
      <Mark>for constants:</Mark>
      <Item>
        no methods change the underlying elements;
      </Item>
      <Mark>for copyables:</Mark>
      <Item>
        you provide a method for <Ref Func="ShallowCopy"/>;
      </Item>
      <Mark>for mutables:</Mark>
      <Item>
        you may have methods that change the underlying elements
        and these should explicitly require
        <Ref Func="IsMutable"/>.
      </Item>
    </List>
  </Item>
</Enum>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Global Variables in the Library">
<Heading>Global Variables in the Library</Heading>

Global variables in the &GAP; library are usually read-only in order to
avoid their being overwritten accidentally.

See also Section <Ref Sect="More About Global Variables"/>.

<ManSection>
<Func Name="DeclareCategory" Arg='name, super[, rank]'/>

<Description>
does the same as <Ref Func="NewCategory"/>
and additionally makes the variable <A>name</A> read-only.
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareRepresentation" Arg='name, super, slots [,req]'/>

<Description>
does the same as <Ref Func="NewRepresentation"/>
and additionally makes the variable <A>name</A> read-only.
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareAttribute" Arg='name, filter[, "mutable"][, rank]'/>

<Description>
does the same as <Ref Func="NewAttribute"/>,
additionally makes the variable <A>name</A> read-only
and also binds read-only global variables with names
<C>Has<A>name</A></C> and <C>Set<A>name</A></C>
for the tester and setter of the attribute (see Section
<Ref Sect="Setter and Tester for Attributes"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareProperty" Arg='name, filter [,rank]'/>

<Description>
does the same as <Ref Func="NewProperty"/>,
additionally makes the variable <A>name</A> read-only
and also binds read-only global variables with names
<C>Has<A>name</A></C> and <C>Set<A>name</A></C>
for the tester and setter of the property (see Section
<Ref Sect="Setter and Tester for Attributes"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareFilter" Arg="name[, rank]"/>

<Description>
does the same as <Ref Func="NewFilter"/>
and additionally makes the variable <A>name</A> read-only.
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareOperation" Arg='name, filters'/>

<Description>
does the same as <Ref Func="NewOperation"/> and
additionally makes the variable <A>name</A> read-only.
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareGlobalFunction" Arg='name, info'/>
<Func Name="InstallGlobalFunction" Arg='oper, func'/>

<Description>
<Ref Func="DeclareGlobalFunction"/> 
&GAP; functions that are not operations and that are intended to be
called by users should be notified to &GAP; in the declaration part
of the respective package
(see Section&nbsp;<Ref Sect="Declaration and Implementation Part"/>)
via <Ref Func="DeclareGlobalFunction"/>, which returns a function that
serves as a place holder for the function that will be installed later,
and that will print an error message if it is called.
See also&nbsp;<Ref Func="DeclareSynonym"/>.
<P/>
A global function declared with <Ref Func="DeclareGlobalFunction"/>
can be given its value <A>func</A> via
<Ref Func="InstallGlobalFunction"/>;
<A>gvar</A> is the global variable (or a string denoting its name)
named with the <A>name</A> argument of the call to
<Ref Func="DeclareGlobalFunction"/>.
For example, a declaration like
<P/>
<Log><![CDATA[
DeclareGlobalFunction( "SumOfTwoCubes" );
]]></Log>
<P/>
in the <Q>declaration part</Q>
(see Section&nbsp;<Ref Sect="Declaration and Implementation Part"/>)
might have a corresponding <Q>implementation part</Q> of:
<P/>
<Log><![CDATA[
InstallGlobalFunction( SumOfTwoCubes, function(x, y) return x^3 + y^3; end);
]]></Log>
<P/>
<!-- Commented out by AK after the withdrowal of completion files:
<E>Note:</E> <A>func</A> must be a function which has <E>not</E> been
declared with <Ref Func="DeclareGlobalFunction"/> itself.
Otherwise completion files
(see&nbsp;<Ref Sect="Completion Files"/>) get confused! -->
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareGlobalVariable" Arg="name[, description]"/>

<Description>
For global variables that are <E>not</E> functions,
instead of using <Ref Func="BindGlobal"/> one can also declare the
variable with <Ref Func="DeclareGlobalVariable"/>
which creates a new global variable named by the string <A>name</A>.
If the second argument <A>description</A> is entered then this must be
a string that describes the meaning of the global variable.
<Ref Func="DeclareGlobalVariable"/> shall be used in the declaration part
of the respective package
(see&nbsp;<Ref Sect="Declaration and Implementation Part"/>),
values can then be assigned to the new variable with
<Ref Func="InstallValue"/>, <Ref Func="InstallFlushableValue"/> or
<Ref Func="InstallFlushableValueFromFunction"/>,
in the implementation part
(again, see&nbsp;<Ref Sect="Declaration and Implementation Part"/>).
</Description>
</ManSection>

<ManSection>
<Func Name="InstallValue" Arg="gvar, value"/>
<Func Name="InstallFlushableValue" Arg="gvar, value"/>
<Func Name="InstallFlushableValueFromFunction" Arg="gvar, func"/>

<Description>
<Ref Func="InstallValue"/> assigns the value <A>value</A> to the global
variable <A>gvar</A>.
<Ref Func="InstallFlushableValue"/> does the same but additionally
provides that each call of <Ref Func="FlushCaches"/>
will assign a structural copy of <A>value</A> to <A>gvar</A>.
<Ref Func="InstallFlushableValueFromFunction"/> instead assigns
the result of <A>func</A> to <A>gvar</A> (<A>func</A> is re-evaluated
for each invocation of <Ref Func="FlushCaches"/>
<P/>
<Ref Func="InstallValue"/> does <E>not</E> work if <A>value</A> is an
<Q>immediate object</Q>, i.e., an internally represented small integer or
finite field element. It also fails for booleans.
Furthermore, <Ref Func="InstallFlushableValue"/> works only if
<A>value</A> is a list or a record.
(Note that <Ref Func="InstallFlushableValue"/> makes sense only for
<E>mutable</E> global variables.)
</Description>
</ManSection>

<ManSection>
<Func Name="DeclareSynonym" Arg='name, value'/>
<Func Name="DeclareSynonymAttr" Arg='name, value'/>

<Description>
<Ref Func="DeclareSynonym"/> assigns the string <A>name</A> to a global
variable as a synonym for <A>value</A>.
Two typical intended usages are to declare an <Q>and-filter</Q>, e.g.
<P/>
<Log><![CDATA[
DeclareSynonym( "IsGroup", IsMagmaWithInverses and IsAssociative );
]]></Log>
<P/>
and to provide a previously declared global function with an alternative
name, e.g.
<P/>
<Log><![CDATA[
DeclareGlobalFunction( "SizeOfSomething" );
DeclareSynonym( "OrderOfSomething", SizeOfSomething );
]]></Log>
<P/>
<E>Note:</E> Before using <Ref Func="DeclareSynonym"/> in the way of this
second example,
one should determine whether the synonym is really needed.
Perhaps an extra index entry in the documentation would be sufficient.
<P/>
When <A>value</A> is actually an attribute then
<Ref Func="DeclareSynonymAttr"/> should be used;
this binds also globals variables <C>Set</C><A>name</A> and
<C>Has</C><A>name</A> for its setter and tester, respectively.
<P/>
<Log><![CDATA[
DeclareSynonymAttr( "IsField", IsDivisionRing and IsCommutative );
DeclareAttribute( "GeneratorsOfDivisionRing", IsDivisionRing );
DeclareSynonymAttr( "GeneratorsOfField", GeneratorsOfDivisionRing );
]]></Log>
</Description>
</ManSection>

<ManSection>
<Oper Name="FlushCaches" Arg=""/>

<Description>
<Ref Func="FlushCaches"/> resets the value of each global variable that
has been declared with <Ref Func="DeclareGlobalVariable"/> and for which
the initial value has been set with <Ref Func="InstallFlushableValue"/>
or <Ref Func="InstallFlushableValueFromFunction"/>
to this initial value.
<P/>
<Ref Func="FlushCaches"/> should be used only for debugging purposes,
since the involved global variables include for example lists that store
finite fields and cyclotomic fields used in the current &GAP; session,
in order to avoid that these fields are constructed anew in each call
to <Ref Func="GF" Label="for field size"/> and
<Ref Func="CF" Label="for (subfield and) conductor"/>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Declaration and Implementation Part">
<Heading>Declaration and Implementation Part</Heading>

Each package of &GAP; code consists of two parts,
the <E>declaration part</E> that defines the new categories and operations for
the objects the package deals with,
and the <E>implementation part</E> where the corresponding methods are
installed.
The declaration part should be representation independent,
representation dependent information should be dealt with in the
implementation part.
<P/>
&GAP; functions that are not operations and that are intended to be
called by users should be notified to &GAP; in the declaration part via
<Ref Func="DeclareGlobalFunction"/>.
Values for these functions can be installed in the implementation part
via <Ref Func="InstallGlobalFunction"/>.
<P/>
Calls to the following functions belong to the declaration part.
<P/>
<Ref Func="DeclareAttribute"/>,
<P/>
<Ref Func="DeclareCategory"/>,
<P/>
<Ref Func="DeclareFilter"/>,
<P/>
<Ref Func="DeclareOperation"/>,
<P/>
<Ref Func="DeclareGlobalFunction"/>,
<P/>
<Ref Func="DeclareSynonym"/>,
<P/>
<Ref Func="DeclareSynonymAttr"/>,
<P/>
<Ref Func="DeclareProperty"/>,
<P/>
<Ref Func="InstallTrueMethod"/>.
<P/>
Calls to the following functions belong to the implementation part.
<P/>
<Ref Func="DeclareRepresentation"/>,
<P/>
<Ref Func="InstallGlobalFunction"/>,
<P/>
<Ref Func="InstallMethod"/>,
<P/>
<Ref Func="InstallImmediateMethod"/>,
<P/>
<Ref Func="InstallOtherMethod"/>,
<P/>
<Ref Func="NewFamily"/>,
<P/>
<Ref Func="NewType"/>,
<P/>
<Ref Func="Objectify"/>.
<P/>
<Index Key="DeclareRepresentation" Subkey="belongs to implementation part">
<C>DeclareRepresentation</C></Index>
Whenever both a <C>New</C><A>Something</A> and a
<C>Declare</C><A>Something</A> variant of a function exist
(see&nbsp;<Ref Sect="Global Variables in the Library"/>),
the use of <C>Declare</C><A>Something</A> is recommended
because this protects the variables in question from being overwritten.
Note that there are <E>no</E> functions <C>DeclareFamily</C> and
<C>DeclareType</C> since families and types are created dynamically,
hence usually no global variables are associated to them.
Further note that <Ref Func="DeclareRepresentation"/> is regarded as
belonging to the implementation part,
because usually representations of objects are accessed only in very
few places, and all code that involves a particular representation
is contained in one file;
additionally, representations of objects are often not interesting
for the user, so there is no need to provide a user interface
or documentation about representations.
<P/>
It should be emphasized that <Q>declaration</Q> means only an explicit
notification of mathematical or technical terms or of concepts to &GAP;.
For example, declaring a category or property with name <C>IsInteresting</C>
does of course not tell &GAP; what this shall mean,
and it is necessary to implement possibilities to create objects that
know already that they lie in <C>IsInteresting</C> in the case that it is a
category, or to install implications or methods in order to
compute for a given object whether <C>IsInteresting</C> is <K>true</K> or <K>false</K>
for it in the case that <C>IsInteresting</C> is a property.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- % This file was created automatically from intrfc.msk. -->
<!-- % DO NOT EDIT! -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  intrfc.msk              GAP manual                   Alexander Hulpke -->
<!-- %W                                                       Andrew Solomon -->
<!-- %% -->
<!-- %H  @(#)<M>Id: intrfc.msk,v 1.12 2002/10/02 12:12:00 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Examples of Extending the System">
<Heading>Examples of Extending the System</Heading>

This chapter gives a few examples of how one can extend the functionality of
&GAP;.
<P/>
They are arranged in ascending difficulty. We show how to install new
methods, add new operations and attributes and how to implement new features
using categories and representations.  (As we do not introduce completely
new kinds of objects in these example it will not be necessary to declare
any families.)
Finally we show a simple way how to create new objects with an own
arithmetic.
<P/>
The examples given are all very rudimentary &ndash; no particular error checks
are performed and the user interface sometimes is quite clumsy. These examples
may be constructed for presentation purposes only and they do not necessarily
constitute parts of the &GAP; library.
<P/>

Even more complex examples that create whole classes of objects anew will be
given in the following two chapters <Ref Chap="An Example -- Residue Class Rings"/> and
<Ref Chap="An Example -- Designing Arithmetic Operations"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Addition of a Method">
<Heading>Addition of a Method</Heading>

The easiest case is the addition of a new algorithm as a method for an
existing operation for the existing structures.
<P/>
For example, assume we wanted to implement a better method for computing the
exponent of a nilpotent group (it is the product of the exponents of the
Sylow subgroups).
<P/>
The first task is to find which operation is used by &GAP;
(it is <Ref Func="Exponent"/>) and how it is declared.
We can find this in the Reference Manual (in our particular case
in section&nbsp;<Ref Sect="Numerical Group Attributes"/>)
and the declaration in the library file <F>lib/grp.gd</F>.
The easiest way to find the place of the declaration is usually to
<C>grep</C> over all <C>.gd</C> and <C>.g</C> files,
see section&nbsp;<Ref Chap="Library Files"/>.
<P/>
In our example the declaration in the library is:
<Log><![CDATA[
DeclareAttribute("Exponent",IsGroup);
]]></Log>
<P/>
Similarly we find that the filter
<Ref Func="IsNilpotentGroup"/> 
represents the concept of being nilpotent.
<P/>
We then write a function that implements the new algorithm which takes the
right set of arguments and install it as a method. In our example this
installation would be:
<Log><![CDATA[
InstallMethod(Exponent,"for nilpotent groups",
  [IsGroup and IsNilpotent],
function(G)
  [function body omitted]
end);
]]></Log>
<P/>
We have left out the optional rank argument of <Ref Func="InstallMethod"/>,
which normally is a wise choice
&ndash;&GAP; automatically uses an internal ranking based on the filters
that is only offset by the given rank.
So our method will certainly be regarded as <Q>better</Q> than
a method that has been installed for mere groups or for solvable groups but
will be ranked lower than the library method for abelian groups.
<P/>
That's all.
Using <Ref Sect="ApplicableMethod"/> we can
check for a nilpotent group that indeed our new method will be used.
<P/>
When testing, remember that the method selection will not check for
properties that are not known. (This is done internally by checking the
property tester first.) Therefore the method would not be applicable
for the group <C>g</C> in the following definition but only for the
&ndash;mathematically identical but endowed with more knowledge by &GAP;&ndash;
group <C>h</C>.
(Section&nbsp;<Ref Sect="Enforcing Property Tests"/> shows a way around this.)
<P/>
<Example><![CDATA[
gap> g:=Group((1,2),(1,3)(2,4));;
gap> h:=Group((1,2),(1,3)(2,4));;
gap> IsNilpotentGroup(h); # enforce test
true
gap> HasIsNilpotentGroup(g);
false
gap> HasIsNilpotentGroup(h);
true
]]></Example>
<P/>
Let's now look at a slightly more complicated example:
We want to implement a better method for computing 
normalizers in a nilpotent permutation group.
(Such an algorithm can be found for example in
<Cite Key="luksrakocziwright97"/>.)
<P/>
We already know <Ref Func="IsNilpotentGroup"/>,
the filter <Ref Func="IsPermGroup"/> 
represents the concept of being a group of permutations.
<P/>
&GAP; uses <Ref Func="Normalizer" Label="for two groups"/>
to compute normalizers,
however the declaration is a bit more complicated.
In the library we find
<P/>
<Log><![CDATA[
InParentFOA( "Normalizer", IsGroup, IsObject, NewAttribute );
]]></Log>
<P/>
The full mechanism of <Ref Func="InParentFOA"/> is described in
chapter&nbsp;<Ref Chap="Function-Operation-Attribute Triples"/>,
however for our purposes it is sufficient to know that for such a function
the actual work is done by an operation <C>NormalizerOp</C>, an underlying 
operation for <Ref Oper="Normalizer" Label="for two groups"/> (and all the
complications are just there to be able to remember certain results) and that
the declaration of this operation is given by the first arguments, it would
be:
<Log><![CDATA[
DeclareOperation( "NormalizerOp", [IsGroup, IsObject] );
]]></Log>
<P/>
This time we decide to enter a non-default family predicate in the call to
<Ref Func="InstallMethod"/>.
We could just leave it out as in the previous call;
this would yield the default value,
the function <Ref Func="ReturnTrue"/> of arbitrary
many arguments which always returns <K>true</K>.
However, then the method might be called in some cases of inconsistent input
(for example matrix groups in different characteristics) that ought to fall
through the method selection to raise an error.
<P/>
In our situation, we want the second group to be a subgroup of the first, so
necessarily both must have the same family and we can use
<Ref Func="IsIdenticalObj"/> as family predicate.
<P/>
Now we can install the method. Again this manual is lazy and does not show
you the actual code:
<Log><![CDATA[
InstallMethod(NormalizerOp,"for nilpotent permutation groups",IsIdenticalObj,
  [IsPermGroup and IsNilpotentGroup,
   IsPermGroup and IsNilpotentGroup],
function(G,U)
  [ function body omitted ]
end);
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Extending the Range of Definition of an Existing Operation">
<Heading>Extending the Range of Definition of an Existing Operation</Heading>

It might be that the operation has been defined so far only for a set of
objects that is too restrictive for our purposes (or we want to install a
method that takes another number of arguments). If this is the case,
the call to <Ref Func="InstallMethod"/> causes an error message.
We can avoid this by using <Ref Func="InstallOtherMethod"/> instead.
It is also possible to re-declare an operation with another number of 
arguments and/or different filters for its arguments.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Enforcing Property Tests">
<Heading>Enforcing Property Tests</Heading>

As mentioned in Section <Ref Sect="Applicable Methods and Method Selection"/>,
&GAP; does not check unknown properties to test whether
a method might be applicable. In some cases one wants to enforce this,
however, because the gain from knowing the property outweighs the cost of
its determination.
<P/>
In this situation one has to install a method <E>without</E> the additional
property (so it can be tried even if the property is not yet known) and at high
rank (so it will be used before other methods). The first thing to do in the
actual function then is to test the property and to bail out with
<Ref Func="TryNextMethod"/> if it turns out to be <K>false</K>.
<P/>
The above <Ref Func="Exponent"/> example thus would become:
<!-- %T The above example mentioned nilpotency ... -->
<Log><![CDATA[
InstallMethod(Exponent,"test abelianity", [IsGroup],
  50,# enforced high rank
function(G)
  if not IsAbelian(G) then
    TryNextMethod();
  fi;
  [remaining function body omitted]
end);
]]></Log>
<P/>
The value <Q>50</Q> used in this example is quite arbitrary. A better way is to
use values that are given by the system inherently: We want this method
still to be ranked as high,
<E>as if it had</E> the <Ref Func="IsAbelian"/> requirement.
So we have &GAP; compute the extra rank of this:
<Log><![CDATA[
InstallMethod(Exponent,"test abelianity", [IsGroup],
  # enforced absolute rank of `IsGroup and IsAbelian' installation: Subtract
  # the rank of `IsGroup' and add the rank of `IsGroup and IsAbelian':
  SIZE_FLAGS(FLAGS_FILTER(IsGroup and IsAbelian))
  -SIZE_FLAGS(FLAGS_FILTER(IsGroup)),
function(G)
]]></Log>
the slightly complicated construction of addition and subtraction is
necessary because <Ref Func="IsGroup"/> and
<Ref Func="IsAbelian"/> might imply the <E>same</E>
elementary filters which we otherwise would count twice.
<P/>
A somehow similar situation occurs with matrix groups. Most methods for
matrix groups are only applicable if the group is known to be finite.
<P/>
However we should not enforce a finiteness test early (someone else later might
install good methods for infinite groups while the finiteness test would be
too expensive) but just before &GAP; would give a <Q>no method found</Q>
error. This is done by redispatching, see&nbsp;<Ref Sect="Redispatching"/>. For example to
enforce such a final finiteness test for normalizer calculations could be
done by:
<Log><![CDATA[
RedispatchOnCondition(NormalizerOp,IsIdenticalObj,
  [IsMatrixGroup,IsMatrixGroup],[IsFinite,IsFinite],0);
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Adding a new Operation">
<Heading>Adding a new Operation</Heading>

Next, we will consider how to add own operations. As an example we take the Sylow
normalizer in a group of a given prime. This operation gets two arguments,
the first has to be a group, the second a prime number.
<P/>
There is a function <Ref Func="IsPrimeInt"/>,
but no property for being prime (which
would be pointless as integers cannot store property values anyhow). So the
second argument gets specified only as positive integer:
<Log><![CDATA[
SylowNormalizer:=NewOperation("SylowNormalizer",[IsGroup,IsPosInt]);
]]></Log>
(Note that we are using <Ref Func="NewOperation"/> instead of 
<Ref Func="DeclareOperation"/> as used in the library.
The only difference other than that <Ref Func="DeclareOperation"/> saves
some typing,
is that it also protects the variables against overwriting. 
When testing code (when one probably wants to change things) 
this might be restricting. If this does not bother you, you can use
<P/>
<Log><![CDATA[
DeclareOperation("SylowNormalizer",[IsGroup,IsPosInt]);
]]></Log>
as well.)
<P/>
The filters <Ref Func="IsGroup"/> and
<Ref Func="IsPosInt"/> given are <E>only</E> used to test that
<Ref Func="InstallMethod"/> installs methods with suitable 
arguments and will be completely ignored when using
<Ref Func="InstallOtherMethod"/>. Technically one could
therefore simply use <Ref Func="IsObject"/> for all arguments
in the declaration. The
main point of using more specific filters here is to help documenting with
which arguments the function is to be used (so for example a call
<C>SylowNormalizer(5,G)</C> would be invalid).
<P/>
Of course initially there are no useful methods for newly declared
operations; you will have to write and install them yourself.
<P/>
If the operation only takes one argument and has reproducible results
without side effects, it might be worth declaring it as an attribute
instead; see Section <Ref Sect="Adding a new Attribute"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Adding a new Attribute">
<Heading>Adding a new Attribute</Heading>

<Index Key="NewAttribute" Subkey="example"><C>NewAttribute</C></Index>
<Index Key="DeclareAttribute" Subkey="example"><C>DeclareAttribute</C></Index>
Now we look at an example of how to add a new attribute. As example we
consider the set of all primes that divide the size of a group.
<P/>
First we have to declare the attribute:
<P/>
<Log><![CDATA[
PrimesDividingSize:=NewAttribute("PrimesDividingSize",IsGroup);
]]></Log>
<P/>
(See&nbsp;<Ref Func="NewAttribute"/>).
This implicitly declares attribute tester and setter, it is convenient
however to assign these to variables as well:
<P/>
<Log><![CDATA[
HasPrimesDividingSize:=Tester(PrimesDividingSize);
SetPrimesDividingSize:=Setter(PrimesDividingSize);
]]></Log>
<P/>
Alternatively, there is a declaration command 
<Ref Func="DeclareAttribute"/> that executes all three
assignments simultaneously and protects the variables against overwriting:
<P/>
<Log><![CDATA[
DeclareAttribute("PrimesDividingSize",IsGroup);
]]></Log>
<P/>
Next we have to install method(s) for the attribute that compute its value.
(This is not strictly necessary. We could use the attribute also without
methods only for storing and retrieving information, but calling it for objects
for which the value is not known would produce a <Q>no method found</Q> error.)
For this purpose we can imagine the attribute simply as an one-argument
operation:
<P/>
<Log><![CDATA[
InstallMethod(PrimesDividingSize,"for finite groups",
  [IsGroup and IsFinite],
function(G)
  if Size(G)=1 then return [];
  else return Set(Factors(Size(G)));fi;
end);
]]></Log>
<P/>
<Index Key="IsAttributeStoringRep"><C>IsAttributeStoringRep</C></Index>
The function installed <E>must</E> always return a value (or call
<Ref Func="TryNextMethod"/>).
If the object is in the representation
<C>IsAttributeStoringRep</C> this return value once computed will be automatically
stored and retrieved if the attribute is called a second time. We don't have
to call setter or tester ourselves. (This storage happens by &GAP;
internally calling the attribute setter with the return value of the
function. Retrieval is by a high-ranking method which is installed under the
condition <C>HasPrimesDividingSize</C>. This method was installed automatically
when the attribute was declared.)

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Adding a new Representation">
<Heading>Adding a new Representation</Heading>

<Index Key="NewRepresentation" Subkey="example"><C>NewRepresentation</C></Index>
<Index Key="DeclareRepresentation" Subkey="example"><C>DeclareRepresentation</C></Index>
<Index Key="IsComponentObjectRep"><C>IsComponentObjectRep</C></Index>
<Index Key="IsAttributeStoringRep"><C>IsAttributeStoringRep</C></Index>
Next, we look at the implementation of a new representation of existing
objects. In most cases we want to implement this representation only for
efficiency reasons while keeping all the existing functionality.
<P/>
For example, assume we wanted (following <Cite Key="wielandt69"/>)
to implement permutation groups defined by relations.
<P/>
Next, we have to decide a few basics about the representation. All existing
permutation groups in the library are attribute storing and we probably want
to keep this for our new objects. Thus the representation must be a
subrepresentation of <C>IsComponentObjectRep and IsAttributeStoringRep</C>.
Furthermore we want each object to be a permutation group and we can imply
this directly in the representation.
<P/>
We also decide that we store the degree (the largest point that might be
moved)
in a component <C>degree</C> and the defining relations in a component
<C>relations</C> (we do not specify the format of relations here. In an actual
implementation one would have to design this as well, but it does not affect
the declarations this chapter is about).
<P/>
<Log><![CDATA[
IsPermutationGroupByRelations:=NewRepresentation(
  "IsPermutationGroupByRelations",
  IsComponentObjectRep and IsAttributeStoringRep and IsPermGroup,
  ["degree","relations"]);
]]></Log>
<P/>
(If we wanted to implement sparse matrices we might for example rather
settle for a positional object in which we store a list of the nonzero
entries.)
<P/>
We can make the new representation a subrepresentation of an existing one.
In such a case of course we have to provide all structure of this <Q>parent</Q>
representation as well.
<P/>
Next we need to check in which family our new objects will be. This will be
the same family as of every other permutation group, namely the
<C>CollectionsFamily(PermutationsFamily)</C> (where the family
<C>PermutationsFamily = FamilyObj((1,2,3))</C> has been defined already in the
library).
<P/>
Now we can write a function to create our new objects. Usually it is helpful
to look at functions from the library that are used in similar situations (for
example <Ref Oper="GroupByGenerators"/> in our case)
to make sure we have not forgotten
any further requirements in the declaration we might have to add here.
However in most cases the function is straightforward:
<P/>
<Log><![CDATA[
PermutationGroupByRelations:=function(degree,relations)
local g
  g:=Objectify(NewType(CollectionsFamily(PermutationsFamily),
		       IsPermutationGroupByRelations),
               rec(degree:=degree,relations:=relations));
end;
]]></Log>
<P/>
It also is a good idea to install a <Ref Func="PrintObj"/>
and possibly also a <Ref Func="ViewObj"/> method
&ndash;otherwise testing becomes quite hard:
<P/>
<Log><![CDATA[
InstallMethod(PrintObj,"for perm grps. given by relations",
  [IsPermutationGroupByRelations],
function(G)
  Print("PermutationGroupByRelations(", G!.degree,",",G!.relations,")");
end);
]]></Log>
<P/>
Next we have to write enough methods for the new representation so that the
existing algorithms can be used. In particular we will have to implement
methods for all operations for which library or kernel provides methods for
the existing (alternative) representations. In our particular case there are
no such methods. (If we would have implemented sparse matrices we
would have had to implement methods for the list access and assignment
functions, see <Ref Sect="Basic Operations for Lists"/>.)
However the existing way permutation groups are represented is by
generators. To be able to use the existing machinery we want to be able to
obtain a generating set also for groups in our new representation. This can
be done (albeit not very effectively) by a stabilizer calculation in the
symmetric group given by the <C>degree</C> component. The operation function to
use is probably a bit complicated and will depend on the format of the
<C>relations</C> (we have not specified in this example). In the following
method we use <C>operationfunction</C> as a placeholder;
<P/>
<Log><![CDATA[
InstallMethod(GeneratorsOfGroup,"for perm grps. given by relations",
  [IsPermutationGroupByRelations],
function(G)
local S,U;
  S:=SymmetricGroup(G!.degree);
  U:=Stabilizer(S,G!.relations,  operationfunction );
  return GeneratorsOfGroup(U);
end);
]]></Log>
<P/>
This is all we <E>must</E> do. Of course for performance reasons one might want
to install methods for further operations as well.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Components versus Attributes">
<Heading>Components versus Attributes</Heading>

In the last section we introduced two new components, <C>G!.degree</C> and
<C>G!.relations</C>. Technically, we could have used attributes instead.
There is no clear distinction which variant is to be preferred: An attribute
expresses part of the functionality available to certain objects (and thus
could be computed later and probably even for a wider class of objects), a
component is just part of the internal definition of an object.
<P/>
So if the data is <Q>of general interest</Q>, if we want the user to have
access to it, attributes are preferable. Moreover, attributes can be used 
by the method selection (by specifying the filter <C>HasAttr</C> for an 
attribute <C>Attr</C>). They provide a clean 
interface and their immutability makes it safe to hand the data to a user who potentially
could corrupt a components entries.
<P/>
On the other hand more <Q>technical</Q> data (say the encoding of a sparse
matrix) is better hidden from the user in a component, as declaring it as an
attribute would not give any advantage.
<P/>
Resource-wise, attributes need more memory (the attribute setter and
tester are implicitly declared, and one filter bit is required), the
attribute access is one further function call in the kernel, thus components
might be an immeasurable bit faster.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Adding new Concepts">
<Heading>Adding new Concepts</Heading>

Now we look how to implement a new concept for existing objects and fit
this in the method selection. Three examples that will be made more explicit
below would be groups for which a <Q>length</Q> of elements (as a word in
certain generators) is defined, groups that can be decomposed as a
semidirect product and M-groups.
<P/>
In each case we have two possibilities for the declaration. We can
either declare it
as a property or as a category. Both are eventually filter(s) and in this way
indistinguishable for the method selection. However, the value of
a property for a particular object can be unknown at first and later
in the session be computed (to be <K>true</K> or <K>false</K>).
This is implemented by reserving two filters for each property, one
indicating whether the property value is known, and one, provided
the value is known, to indicate the actual boolean value.
Contrary to this, the decision whether or not an object lies in a
category is taken at creation time and this is implemented using
a single filter.
<P/>
<List>
<Mark>Property:</Mark>
<Item>
Properties also are attributes:
If a property value is not known for an object, &GAP; tries to find a
method to compute the property value. If no suitable method is found, an
error is raised.
</Item>
<Mark>Category:</Mark>
<Item>
An object is in a category if it has been created in it. Testing the
category for an object simply returns this value. Existing objects cannot
enter a new category later in life. This means that in most cases one has to
write own code to create objects in a new category.
<P/>
If we want to implement a completely new concept so that new
operations are defined only for the new objects &ndash;for example bialgebras
for which a second scalar multiplication is defined&ndash;
usually a category is chosen.
<P/>
Technically, the behaviour of the category <C>IsXYZ</C>, declared as subcategory
of <C>IsABC</C> is therefore exactly the same as if we would declare <C>IsXYZ</C> to
be a property for <C>IsABC</C> and install the following method:
<Log><![CDATA[
InstallMethod(IsXYZ,"return false if not known",[IsABC],ReturnFalse);
]]></Log>
<P/>
(The word <C>category</C> also has a
well-defined mathematical meaning, but this does not need to concern us at
this point.
The set of objects which is defined to be a (&GAP;) category does
not need to be a category in the mathematical sense, vice versa not every
mathematical category is declared as a (&GAP;) category.)
</Item>
</List>
Eventually the choice between category and property often  becomes a matter of
taste or style.
<P/>
Sometimes there is even a third possibility (if you have &GAP;&nbsp;3 experience
this might reflect most closely <Q>an object whose operations record is
<C>XYOps</C></Q>): We might want to indicate this new concept simply by the fact
that certain attributes are set. In this case we could simply use the
respective attribute tester(s).
<P/>
The examples given below each give a short argument why the
respective solution was chosen, but one could argue as well for other
choices.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Example: M-groups">
<Heading>Example: M-groups</Heading>

<!-- %T add a sentence that the library contains this already; -->
<!-- %T the name of the library function is <C>IsMonomialGroup</C> -->

M-groups are finite groups for which all irreducible complex
representations are induced from linear representations of subgroups, it
turns out that they are all solvable and that every supersolvable group is
an M-group. See <Cite Key="Isa76"/> for further details.
<P/>
Solvability and supersolvability both are testable properties. We therefore
declare <C>IsMGroup</C> as a property for solvable groups:
<Log><![CDATA[
IsMGroup:=NewProperty("IsMGroup",IsSolvableGroup);
]]></Log>
The filter <Ref Func="IsSolvableGroup"/> in this declaration
<E>only</E> means that methods
for <C>IsMGroup</C> by default can only be installed for groups that are (and
know to be) solvable (though they could be installed for more general
situations using <Ref Func="InstallOtherMethod"/>).
It does not yet imply that M-groups
are solvable. We must do this deliberately via an implication and we use the
same technique to imply that every supersolvable group is an M-group.
<Log><![CDATA[
InstallTrueMethod(IsSolvableGroup,IsMGroup);
InstallTrueMethod(IsMGroup,IsSupersolvableGroup);
]]></Log>
<!-- %T The library is more accurate: -->
<!-- %T Monomiality is defined only for <E>finite</E> groups, -->
<!-- %T whereas infinite groups might be supersolvable! -->
<P/>
Now we might install a method that tests for solvable groups whether they
are M-groups:
<Log><![CDATA[
InstallMethod(IsMGroup,"for solvable groups",[IsSolvableGroup],
function(G)
  [... code omitted. The function must return `true' or `false' ...]
end);
]]></Log>
Note that this example of declaring the <C>IsMGroup</C> property for 
solvable groups is not a part of the &GAP; library, which uses a 
similar but different filter <Ref Prop="IsMonomialGroup"/>.
</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Example: Groups with a word length">
<Heading>Example: Groups with a word length</Heading>

Our second example is that of groups for whose elements a <E>word length</E>
is defined. (We assume that the word length is only defined in the context
of the group with respect to a preselected generating set
but not for single elements alone. However we will not delve into any
details of how this length is defined and how it could be computed.)
<P/>
Having a word length is a feature which enables other operations (for
example a <Q>word length</Q> function). This is exactly what categories are
intended for and therefore we use one.
<P/>
First, we declare the category. All objects in this category are groups and
so we inherit the supercategory <Ref Func="IsGroup"/>:
<P/>
<Log><![CDATA[
DeclareCategory("IsGroupWithWordLength",IsGroup);
]]></Log>
<P/>
We also define the operation which is <Q>enabled</Q> by this category, the word
length of a group element, which is defined for a group and an element
(remember that group elements are described by the category 
<Ref Func="IsMultiplicativeElementWithInverse"/>):
<P/>
<Log><![CDATA[
DeclareOperation("WordLengthOfElement",[IsGroupWithWordLength,
  IsMultiplicativeElementWithInverse]);
]]></Log>
<P/>
We then would proceed by installing methods to compute the word length in
concrete cases and might for example add further operations to get shortest
words in cosets.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Example: Groups with a decomposition as semidirect product">
<Heading>Example: Groups with a decomposition as semidirect product</Heading>
<P/>
<Index Key="DeclareAttribute!example"><C>DeclareAttribute!example</C></Index>
The third example is groups which have a (nontrivial) decomposition as a
semidirect product. If this information has been found out, we want to be
able to use it in algorithms. (Thus we do not only need the fact <E>that</E>
there is a decomposition, but also the decomposition itself.)
<P/>
We also want this to be applicable to every group and not only for groups
which have been explicitly constructed via
<Ref Func="SemidirectProduct" Label="for acting group, action, and a group"/>.
<P/>
Instead we simply declare an attribute
<C>SemidirectProductDecomposition</C> for groups.
(Again, in this manual we don't go in the details of how such an
decomposition would look like).
<P/>
<Log><![CDATA[
DeclareAttribute("SemidirectProductDecomposition",IsGroup);
]]></Log>
<P/>
If a decomposition has been found, it can be stored in a group using
<C>SetSemidirectProductDecomposition</C>. (At the moment all groups in &GAP; are
attribute storing.)
<P/>
Methods that rely on the existence of such a decomposition then get
installed for the tester filter <C>HasSemidirectProductDecomposition</C>.
<!-- %T but this filter expresses the <E>knowledge</E> of a decomposition, -->
<!-- %T not the <E>existence</E>!! -->

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Own Arithmetic Objects">
<Heading>Creating Own Arithmetic Objects</Heading>

Finally let's look at a way to create new objects with a user-defined
arithmetic such that one can form for example groups, rings or vector spaces
of these elements. This topic is discussed in much more detail in
chapter&nbsp;<Ref Chap="An Example -- Designing Arithmetic Operations"/>, in this section we
present a simple approach that may be useful to get started but does not
permit you to exploit all potential features.
<P/>
The basic design is that the user designs some way to represent her objects
in terms of &GAP;s built-in types, for example as a list or a record. 
We call this the <Q>defining data</Q> of the new objects.
Also provided are functions that perform arithmetic on this <Q>defining
data</Q>, that is they take objects of this form and return objects that
represent the result of the operation. The function
<Ref Func="ArithmeticElementCreator"/> then is called to provide a wrapping
such that
proper new &GAP;-objects are created which can be multiplied etc. with the
default infix operations such as <C>*</C>.
<P/>
<ManSection>
<Func Name="ArithmeticElementCreator" Arg="spec"/>

<Description>
offers a simple interface to create new arithmetic elements by providing
functions that perform addition, multiplication and so forth, conforming
to the specification <A>spec</A>. <C>ArithmeticElementCreator</C> 
creates a new category, representation and family for the new arithmetic 
elements being defined, and returns a function which takes the
<Q>defining data</Q> of an element and returns the corresponding new
arithmetic element.
<P/>
<A>spec</A> is a record with one or more of the following components:
<List>
<Mark><C>ElementName</C></Mark>
<Item>
   string used to identify the new type of object. A global
   identifier <C>Is<A>ElementName</A></C> will be defined to indicate
   a category for these now objects. (Therefore it is not clever to have
   blanks in the name). Also a collections category is defined.
   (You will get an error message if the identifier
   <C>Is<A>ElementName</A></C> is already defined.)
</Item>
<Mark><C>Equality</C>, <C>LessThan</C>, <C>One</C>, <C>Zero</C>,
 <C>Multiplication</C>, <C>Inverse</C>, <C>Addition</C>,
 <C>AdditiveInverse</C></Mark>
<Item>
   functions defining the arithmetic
   operations. The functions interface on the level of
   <Q>defining data</Q>, the actual methods installed will perform the
   unwrapping and wrapping as objects.
   Components are optional, but of course if no multiplication is
   defined elements cannot be multiplied and so forth.
   <P/>
   There are default methods for <C>Equality</C> and <C>LessThan</C>
   which simply calculate on the defining data.
   If one is defined, it must be ensured that the other is compatible
   (so that <M>a &lt; b</M> implies not <M>(a = b)</M>)
</Item>
<Mark><C>Print</C></Mark>
<Item>
   a function which prints the object.
   By default, just the defining data is printed.
</Item>
<Mark><C>MathInfo</C></Mark>
<Item>
   filters determining the mathematical properties of the elements
   created. A typical value is for example
   <C>IsMultiplicativeElementWithInverse</C> for group elements.
</Item>
<Mark><C>RepInfo</C></Mark>
<Item>
   filters determining the representational properties of the elements
   created. The objects created are always component objects,
   so in most cases the only reasonable option is
   <C>IsAttributeStoringRep</C> to permit the storing of attributes.
</Item>
</List>
<P/>
All components are optional and will be filled in with default values
(though of course an empty record will not result in useful objects).
<P/>
Note that the resulting objects are <E>not equal</E> to their defining
data (even though by default they print as only the defining data). The
operation <C>UnderlyingElement</C> can be used to obtain the defining
data of such an element.
</Description>
</ManSection>


<Subsection Label="expl:ArithmeticElementCreator">
<Heading>Example: ArithmeticElementCreator</Heading>

As the first example we look at subsets of <M>\{ 1, \ldots, 4 \}</M> and define an
<Q>addition</Q> as union and <Q>multiplication</Q> as intersection.
These operations are both commutative and we want the resulting elements to
know this.
<P/>
We therefore use the following specification:
<P/>
<Example><![CDATA[
gap> # the whole set
gap> w := [1,2,3,4];
[ 1, 2, 3, 4 ]
gap> PosetElementSpec :=rec(
>   # name of the new elements
>   ElementName := "PosetOn4",
>   # arithmetic operations
>   One := a -> w,
>   Zero := a -> [],
>   Multiplication := function(a, b) return Intersection(a, b); end,
>   Addition := function(a, b) return Union(a, b); end,
>   # Mathematical properties of the elements
>   MathInfo := IsCommutativeElement and
>               IsAssociativeElement and
>               IsAdditivelyCommutativeElement
> );;
gap> mkposet := ArithmeticElementCreator(PosetElementSpec);
function( x ) ... end
]]></Example>
<P/>
Now we can create new elements, perform arithmetic on them and form domains:
<P/>
<Example><![CDATA[
gap> a := mkposet([1,2,3]);
[ 1, 2, 3 ]
gap> CategoriesOfObject(a);
[ "IsExtAElement", "IsNearAdditiveElement", 
  "IsNearAdditiveElementWithZero", "IsAdditiveElement", 
  "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsAssociativeElement",
  "IsAdditivelyCommutativeElement", "IsCommutativeElement",
  "IsPosetOn4" ]
gap> a=[1,2,3];
false
gap> UnderlyingElement(a)=[1,2,3];
true
gap> b:=mkposet([2,3,4]);
[ 2, 3, 4 ]
gap> a+b;
[ 1, 2, 3, 4 ]
gap> a*b;
[ 2, 3 ]
gap> s:=Semigroup(a,b);
<commutative semigroup with 2 generators>
gap> Size(s);
3
]]></Example>
<P/>
The categories <C>IsPosetOn4</C> and <C>IsPosetOn4Collection</C> can be used to
install methods specific to the new objects.
<Example><![CDATA[
gap> IsPosetOn4Collection(s);
true
]]></Example>

</Subsection>
</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  xtndxmpl.tex              GAP manual                    Thomas Breuer -->
<!-- %% -->
<!-- %H  @(#)<M>Id: xtndxmpl.tex,v 4.19 2002/10/11 08:00:00 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="An Example -- Residue Class Rings">
<Heading>An Example &ndash; Residue Class Rings</Heading>

In this chapter, we give an example how &GAP; can be extended
by new data structures and new functionality.
In order to focus on the issues of the implementation,
the mathematics in the example chosen is trivial.
Namely, we will discuss computations with elements of residue class rings
<M>&ZZ; / n&ZZ;</M>.
<P/>
The first attempt is straightforward
(see Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>),
it deals with the implementation of the necessary arithmetic operations.
Section&nbsp;<Ref Sect="Why Proceed in a Different Way?"/> deals with the question
why it might be useful to use an approach that involves creating a new
data structure and integrating the algorithms dealing with these new
&GAP; objects into the system.
Section&nbsp;<Ref Sect="A Second Attempt to Implement Elements of Residue Class Rings"/>
shows how this can be done in our example,
and Section&nbsp;<Ref Sect="Compatibility of Residue Class Rings with Prime Fields"/>,
the question of further compatibility of the new objects with known
&GAP; objects is discussed.
Finally, Section&nbsp;<Ref Sect="Further Improvements in Implementing Residue Class Rings"/>
gives some hints how to improve the implementation presented before.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="A First Attempt to Implement Elements of Residue Class Rings">
<Heading>A First Attempt to Implement Elements of Residue Class Rings</Heading>

Suppose we want to do computations with elements of a ring <M>&ZZ; / n&ZZ;</M>,
where <M>n</M> is a positive integer.
<P/>
First we have to decide how to represent the element <M>k + n&ZZ;</M> in &GAP;.
If the modulus <M>n</M> is fixed then we can use the integer <M>k</M>.
More precisely, we can use any integer <M>k'</M>
such that <M>k - k'</M> is a multiple of <M>n</M>.
If different moduli are likely to occur then using a list of the form
<M>[ k, n ]</M>, or a record of the form <C>rec( residue := <A>k</A>, modulus := <A>n</A> )</C>
is more appropriate.
In the following, let us assume the list representation <M>[ k, n ]</M> is
chosen.
Moreover, we decide that the residue <M>k</M> in all such lists satisfies
<M>0 \leq k &lt; n</M>,
i.e., the result of adding two residue classes represented by
<M>[ k_1, n ]</M> and <M>[ k_2, n ]</M> (of course with same modulus <M>n</M>)
will be <M>[ k, n ]</M> with <M>k_1 + k_2</M> congruent to <M>k</M> modulo <M>n</M>
and <M>0 \leq k &lt; n</M>.
<P/>
Now we can implement the arithmetic operations for residue classes.
Note that the result of the <K>mod</K> operator is normalized as required.
The division by a noninvertible residue class results in <K>fail</K>.
<P/>
<Example><![CDATA[
gap> resclass_sum := function( c1, c2 )
>    if c1[2] <> c2[2] then Error( "different moduli" ); fi;
>    return [ ( c1[1] + c2[1] ) mod c1[2], c1[2] ];
> end;;
gap> 
gap> resclass_diff := function( c1, c2 )
>    if c1[2] <> c2[2] then Error( "different moduli" ); fi;
>    return [ ( c1[1] - c2[1] ) mod c1[2], c1[2] ];
> end;;
gap> 
gap> resclass_prod := function( c1, c2 )
>    if c1[2] <> c2[2] then Error( "different moduli" ); fi;
>    return [ ( c1[1] * c2[1] ) mod c1[2], c1[2] ];
> end;;
gap> 
gap> resclass_quo := function( c1, c2 )
>    local quo;
>    if c1[2] <> c2[2] then Error( "different moduli" ); fi;
>    quo:= QuotientMod( c1[1], c2[1], c1[2] );
>    if quo <> fail then
>      quo:= [ quo, c1[2] ];
>    fi;
>    return quo;
> end;;
]]></Example>
<P/>
With these functions, we can in principle compute with residue classes.
<P/>
<Example><![CDATA[
gap> list:= List( [ 0 .. 3 ], k -> [ k, 4 ] );
[ [ 0, 4 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ] ]
gap> resclass_sum( list[2], list[4] );
[ 0, 4 ]
gap> resclass_diff( list[1], list[2] );
[ 3, 4 ]
gap> resclass_prod( list[2], list[4] );
[ 3, 4 ]
gap> resclass_prod( list[3], list[4] );
[ 2, 4 ]
gap> List( list, x -> resclass_quo( list[2], x ) );
[ fail, [ 1, 4 ], fail, [ 3, 4 ] ]
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Why Proceed in a Different Way?">
<Heading>Why Proceed in a Different Way?</Heading>

It depends on the computations we intended to do with residue classes
whether or not the implementation described in the previous section
is satisfactory for us.
<P/>
Probably we are mainly interested in more complex data structures than
the residue classes themselves, for example in matrix algebras or matrix
groups over a ring such as <M>&ZZ; / 4&ZZ;</M>.
For this, we need functions to add, multiply, invert etc.&nbsp;matrices of
residue classes.
Of course this is not a difficult task, but it requires to write
additional &GAP; code.
<P/>
And when we have implemented the arithmetic operations for matrices of
residue classes, we might be interested in domain operations such as
computing the order of a matrix group over <M>&ZZ; / 4&ZZ;</M>,
a Sylow <M>2</M> subgroup, and so on.
The problem is that a residue class represented as a pair <M>[ k, n ]</M>
is not regarded as a group element by &GAP;.
We have not yet discussed how a matrix of residue classes shall be
represented, but if we choose the obvious representation of a list of
lists of our residue classes then also this is not a valid group element
in &GAP;.
Hence we cannot apply the function
<Ref Func="Group" Label="for a list of generators (and an identity element)"/>
to create a group of residue
classes or a group of matrices of residue classes.
This is because &GAP; assumes that group elements can be multiplied via
the infix operator <C>*</C> (equivalently,
via the operation <Ref Func="\*"/>).
Note that in fact the multiplication of two lists <M>[ k_1, n ]</M>,
<M>[ k_2, n ]</M> is defined, but we have
<M>[ k_1, n ] * [ k_2, n ] = k_1 * k_2 + n * n</M>, the standard scalar
product of two row vectors of same length.
That is, the multiplication with <C>*</C> is not compatible with the function
<C>resclass_prod</C> introduced in the previous section.
Similarly, ring elements are assumed to be added via the infix operator
<C>+</C>; the addition of residue classes is not compatible with the available
addition of row vectors.
<P/>
What we have done in the previous section can be described as
implementation of a <Q>standalone</Q> arithmetic for residue classes.
In order to use the machinery of the &GAP; library for creating higher
level objects such as matrices, polynomials, or domains over residue
class rings,
we have to <Q>integrate</Q> this implementation into the &GAP; library.
The key step will be to create a new kind of &GAP; objects.
This will be done in the following sections;
there we assume that residue classes and residue class rings are not
yet available in &GAP;;
in fact they are available, and their implementation is very close to
what is described here.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="A Second Attempt to Implement Elements of Residue Class Rings">
<Heading>A Second Attempt to Implement Elements of Residue Class Rings</Heading>

Faced with the problem to implement elements of the rings <M>&ZZ; / n&ZZ;</M>,
we must define the <E>types</E> of these elements as far as is necessary to
distinguish them from other &GAP; objects.
<P/>
As is described in Chapter&nbsp;<Ref Chap="Types of Objects"/>,
the type of an object comprises several aspects of information about this
object;
the <E>family</E> determines the relation of the object to other objects,
the <E>categories</E> determine what operations the object admits,
the <E>representation</E> determines how an object is actually represented,
and the <E>attributes</E> describe knowledge about the object.
<P/>
First of all, we must decide about the <E>family</E> of each residue class.
A natural way to do this is to put the elements of each ring <M>&ZZ; / n&ZZ;</M>
into a family of their own.
This means that for example elements of <M>&ZZ; / 3&ZZ;</M> and <M>&ZZ; / 9&ZZ;</M> lie
in different families.
So the only interesting relation between the families of two residue
classes is equality;
binary arithmetic operations with two residue classes will be admissible
only if their families are equal.
Note that in the naive approach in
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>,
we had to take care of different moduli by a check in each function;
these checks may disappear in the new approach because of our choice
of families.
<P/>
Note that we do not need to tell &GAP; anything about the above
decision concerning the families of the objects that we are going to
implement,
that is, the <E>declaration part</E> (see&nbsp;<Ref Sect="Declaration and Implementation Part"/>)
of the little &GAP; package we are writing contains nothing about the
distribution of the new objects into families.
(The actual construction of a family happens in the function <C>MyZmodnZ</C>
shown below.)
<P/>
Second, we want to describe methods to add or multiply two elements in
<M>&ZZ; / n&ZZ;</M>,
and these methods shall be not applicable to other &GAP; objects.
The natural way to do this is to create a new <E>category</E> in which all
elements of all rings <M>&ZZ; / n&ZZ;</M> lie.
This is done as follows.
<P/>
<Example><![CDATA[
gap> DeclareCategory( "IsMyZmodnZObj", IsScalar );
gap> cat:= CategoryCollections( IsMyZmodnZObj );;
gap> cat:= CategoryCollections( cat );;
gap> cat:= CategoryCollections( cat );;
]]></Example>
<P/>
So all elements in the rings <M>&ZZ; / n&ZZ;</M> will lie in the category
<C>IsMyZmodnZObj</C>, which is a subcategory of
<Ref Func="IsScalar"/>.
The latter means that one can add, subtract, multiply and divide
two such elements that lie in the same family,
with the obvious restriction that the second operand of a division
must be invertible.
(The name <C>IsMyZmodnZObj</C> is chosen because
<Ref Func="IsZmodnZObj"/> is already
defined in &GAP;, for an implementation of residue classes that is
very similar to the one developed in this manual chapter.
Using this different name, one can simply enter the &GAP; code of this
chapter into a &GAP; session, either interactively or by reading a file
with this code, and experiment after each step whether the expected
behaviour has been achieved, and what is still missing.)
<P/>
The next lines of &GAP; code above create the categories
<C>CategoryCollections( IsMyZmodnZObj )</C> and two higher levels of collections
categories of this, which will be needed later;
it is important to create these categories before collections of the objects
in <C>IsMyZmodnZObj</C> actually arise.
<P/>
Note that the only difference between <Ref Func="DeclareCategory"/> and
<Ref Func="NewCategory"/>
is that in a call to <Ref Func="DeclareCategory"/>,
a variable corresponding to the
first argument is set to the new category, and this variable is read-only
(see&nbsp;<Ref Sect="Global Variables in the Library"/>).
The same holds for <Ref Func="DeclareRepresentation"/> and
<Ref Func="NewRepresentation"/> etc.
<P/>
There is no analogue of categories in the implementation in
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>,
since there it was not necessary to distinguish residue classes from
other &GAP; objects.
Note that the functions there assumed that their arguments were residue
classes, and the user was responsible not to call them with other
arguments.
Thus an important aspect of types is to describe arguments of functions
explicitly.
<P/>
Third, we must decide about the <E>representation</E> of our objects.
This is something we know already from
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>,
where we chose a list of length two.
Here we may choose between two essentially different representations for
the new &GAP; objects, namely as <Q>component object</Q> (record-like)
or <Q>positional object</Q> (list-like).
We decide to store the modulus of each residue class in its family,
and to encode the element <M>k + n&ZZ;</M> by the unique residue in the range
<M>[ 0 .. n-1 ]</M> that is congruent to <M>k</M> modulo <M>n</M>,
and the object itself is chosen to be a positional object with this
residue at the first and only position (see&nbsp;<Ref Sect="Positional Objects"/>).
<P/>
<Example><![CDATA[
gap> DeclareRepresentation("IsMyModulusRep", IsPositionalObjectRep, [1]);
]]></Example>
<P/>
The fourth ingredients of a type, <E>attributes</E>, are usually of minor
importance for element objects.
In particular,
we do not need to introduce special attributes for residue classes.
<P/>
Having defined what the new objects shall look like,
we now declare a global function
(see&nbsp;<Ref Sect="Declaration and Implementation Part"/>),
to create an element when family and residue are given.
<P/>
<Example><![CDATA[
gap> DeclareGlobalFunction( "MyZmodnZObj" );
]]></Example>
<P/>
Now we have declared what we need,
and we can start to implement the missing methods resp. functions;
so the following command belongs to the <E>implementation part</E> of our
package (see&nbsp;<Ref Sect="Declaration and Implementation Part"/>).
<P/>
The probably most interesting function is the one to construct a
residue class.
<P/>
<Example><![CDATA[
gap> InstallGlobalFunction( MyZmodnZObj, function( Fam, residue )
>    return Objectify( NewType( Fam, IsMyZmodnZObj and IsMyModulusRep ),
>                      [ residue mod Fam!.modulus ] );
> end );
]]></Example>
<P/>
Note that we normalize <C>residue</C> explicitly using <K>mod</K>;
we assumed that the modulus is stored in <C>Fam</C>,
so we must take care of this below.
If <C>Fam</C> is a family of residue classes, and <C>residue</C> is an integer,
<C>MyZmodnZObj</C> returns the corresponding object in the family <C>Fam</C>,
which lies in the category <C>IsMyZmodnZObj</C> and in the representation
<C>IsMyModulusRep</C>.
<P/>
<C>MyZmodnZObj</C> needs an appropriate family as first argument,
so let us see how to get our hands on this.
Of course we could write a handy function to create such a family
for given modulus, but we choose another way.
In fact we do not really want to call <C>MyZmodnZObj</C> explicitly when we
want to create residue classes.
For example, if we want to enter a matrix of residues then usually
we start with a matrix of corresponding integers,
and it is more elegant to do the conversion via multiplying the matrix
with the identity of the required ring <M>&ZZ; / n&ZZ;</M>;
this is also done for the conversion of integral matrices to
finite field matrices.
(Note that we will have to install a method for this.)
So it is often sufficient to access this identity,
for example via <C>One( MyZmodnZ( <A>n</A> ) )</C>,
where <C>MyZmodnZ</C> returns a domain representing the ring <M>&ZZ; / n&ZZ;</M>
when called with the argument <M>n</M>.
We decide that constructing this ring is a natural place where the
creation of the family can be hidden,
and implement the function.
(Note that the declaration belongs to the declaration part,
and the installation belongs to the implementation part,
see&nbsp;<Ref Sect="Declaration and Implementation Part"/>).
<P/>
<Example><![CDATA[
gap> DeclareGlobalFunction( "MyZmodnZ" );
gap> 
gap> InstallGlobalFunction( MyZmodnZ, function( n )
>    local F, R;
> 
>    if not IsPosInt( n ) then
>      Error( "<n> must be a positive integer" );
>    fi;
> 
>    # Construct the family of element objects of our ring.
>    F:= NewFamily( Concatenation( "MyZmod", String( n ), "Z" ),
>                   IsMyZmodnZObj );
> 
>    # Install the data.
>    F!.modulus:= n;
> 
>    # Make the domain.
>    R:= RingWithOneByGenerators( [ MyZmodnZObj( F, 1 ) ] );
>    SetIsWholeFamily( R, true );
>    SetName( R, Concatenation( "(Integers mod ", String(n), ")" ) );
> 
>    # Return the ring.
>    return R;
> end );
]]></Example>
<P/>
Note that the modulus <C>n</C> is stored in the component <C>modulus</C> of the
family, as is assumed by <C>MyZmodnZ</C>.
Thus it is not necessary to store the modulus in each element.
When storing <C>n</C> with the <C>!.</C> operator as value of the component
<C>modulus</C>, we used that all families are in fact represented as
component objects (see&nbsp;<Ref Sect="Component Objects"/>).
<P/>
We see that we can use <Ref Func="RingWithOneByGenerators"/>
to construct a ring with one if we have the appropriate generators.
The construction via <Ref Func="RingWithOneByGenerators"/>
makes sure
that <Ref Func="IsRingWithOne"/>
(and <Ref Func="IsRing"/>) is <K>true</K> for each output of
<C>MyZmodnZ</C>.
So the main problem is to create the identity element of the ring,
which in our case suffices to generate the ring.
In order to create this element via <C>MyZmodnZObj</C>,
we have to construct its family first, at each call of <C>MyZmodnZ</C>.
<P/>
Also note that we may enter known information about the ring.
Here we store that it contains the whole family of elements;
this is useful for example when we want to check the membership of an
element in the ring, which can be decided from the type of the element
if the ring contains its whole elements family.
Giving a name to the ring causes that it will be printed
via printing the name.
(By the way:
This name <C>(Integers mod <A>n</A>)</C> looks like a call to
<Ref Func="\mod"/>
with the arguments <Ref Var="Integers"/> and <A>n</A>;
a construction of the ring via this call seems to be more natural than
by calling <C>MyZmodnZ</C>; later we shall install a
<Ref Func="\mod"/> method
in order to admit this construction.)
<P/>
Now we can read the above code into &GAP;,
and the following works already.
<P/>
<Example><![CDATA[
gap> R:= MyZmodnZ( 4 );
(Integers mod 4)
gap> IsRing( R );
true
gap> gens:= GeneratorsOfRingWithOne( R );
[ <object> ]
]]></Example>
<P/>
But of course this means just to ask for the information we have
explicitly stored in the ring.
Already the questions whether the ring is finite and how many elements
it has, cannot be answered by &GAP;.
Clearly we know the answers, and we could store them in the ring,
by setting the value of the property <Ref Func="IsFinite"/>
to <K>true</K> and the value of the attribute
<Ref Func="Size"/> to <A>n</A>
(the argument of the call to <C>MyZmodnZ</C>).
If we do not want to do so then &GAP; could only try to find out the number
of elements of the ring via forming the closure of the generators
under addition and multiplication,
but up to now, &GAP; does not know how to add or multiply two
elements of our ring.
<P/>
So we must install some methods for arithmetic and other
operations if the elements are to behave as we want.
<P/>
We start with a method for showing elements nicely on the screen.
There are different operations for this purpose.
One of them is <Ref Func="PrintObj"/>,
which is called for each argument in an explicit call to
<Ref Func="Print"/>.
Another one is <Ref Func="ViewObj"/>,
which is called in the read-eval-print loop for each object.
<Ref Func="ViewObj"/> shall produce short and human readable
information about the object in question,
whereas <Ref Func="PrintObj"/> shall produce information that
may be longer and is (if reasonable) readable by &GAP;.
We cannot satisfy the latter requirement for a
<Ref Func="PrintObj"/> method
because there is no way to make a family &GAP; readable.
So we decide to display the expression <C>( k mod n )</C> for an object
that is given by the residue <C>k</C> and the modulus <C>n</C>,
which would be fine as a <Ref Func="ViewObj"/> method.
Since the default for <Ref Func="ViewObj"/> is to call
<Ref Func="PrintObj"/>,
and since no other <Ref Func="ViewObj"/> method is applicable
to our elements,
we need only a <Ref Func="PrintObj"/> method.
<P/>
<Example><![CDATA[
gap> InstallMethod( PrintObj,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObj and IsMyModulusRep ],
>    function( x )
>    Print( "( ", x![1], " mod ", FamilyObj(x)!.modulus, " )" );
>    end );
]]></Example>
<P/>
So we installed a method for the operation
<Ref Func="PrintObj"/> (first argument),
and we gave it a suitable information message (second argument),
see&nbsp;<Ref Sect="ApplicableMethod"/> and&nbsp;<Ref Sect="Tracing Methods"/> for applications of
this information string.
The third argument tells &GAP; that the method is applicable for
objects that lie in the category <C>IsMyZmodnZObj</C> and in the representation
<C>IsMyModulusRep</C>.
and the fourth argument is the method itself.
More details about <Ref Func="InstallMethod"/> can be found
in&nbsp;<Ref Sect="Method Installation"/>.
<P/>
Note that the requirement <C>IsMyModulusRep</C> for the argument <C>x</C> allows us
to access the residue as <C>x![1]</C>.
Since the family of <C>x</C> has the component <C>modulus</C> bound if it is
constructed by <C>MyZmodnZ</C>, we may access this component.
We check whether the method installation has some effect.
<P/>
<Example><![CDATA[
gap> gens;
[ ( 1 mod 4 ) ]
]]></Example>
<P/>
Next we install methods for the comparison operations.
Note that we can assume that the residues in the representation chosen
are normalized.
<P/>
<Example><![CDATA[
gap> InstallMethod( \=,
>    "for two elements in Z/nZ (ModulusRep)",
>    IsIdenticalObj,
>    [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],
>    function( x, y ) return x![1] = y![1]; end );
gap> 
gap> InstallMethod( \<,
>    "for two elements in Z/nZ (ModulusRep)",
>    IsIdenticalObj,
>    [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],
>    function( x, y ) return x![1] < y![1]; end );
]]></Example>
<P/>
The third argument used in these installations specifies the required
relation between the families of the arguments
(see&nbsp;<Ref Sect="Families"/>).
This argument of a method installation, if present, is a function that shall
be applied to the families of the arguments.
<Ref Func="IsIdenticalObj"/> means that the methods are
applicable only if both arguments lie in the same family.
(In installations for unary methods, obviously no relation is required,
so this argument is left out there.)
<P/>
Up to now, we see no advantage of the new approach over the one in
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>.
For a residue class represented as <C>[ <A>k</A>, <A>n</A> ]</C>, the way it is printed
on the screen is sufficient, and equality and comparison of lists are
good enough to define equality and comparison of residue classes if needed.
But this is not the case in other situations.
For example, if we would have decided that the residue <A>k</A> need not be
normalized then we would have needed functions in
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>
that compute whether two residue classes are equal, and which of two
residue classes is regarded as larger than another.
Note that we are free to define what <Q>larger</Q> means for objects that
are newly introduced.
<P/>
Next we install methods for the arithmetic operations,
first for the additive structure.
<P/>
<Example><![CDATA[
gap> InstallMethod( \+,
>    "for two elements in Z/nZ (ModulusRep)",
>    IsIdenticalObj,
>    [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],
>    function( x, y )
>    return MyZmodnZObj( FamilyObj( x ), x![1] + y![1] );
>    end );
gap> 
gap> InstallMethod( ZeroOp,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObj ],
>    x -> MyZmodnZObj( FamilyObj( x ), 0 ) );
gap> 
gap> InstallMethod( AdditiveInverseOp,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObj and IsMyModulusRep ],
>    x -> MyZmodnZObj( FamilyObj( x ), AdditiveInverse( x![1] ) ) );
]]></Example>
<P/>
Here the new approach starts to pay off.
The method for the operation <Ref Func="\+"/> allows us
to use the infix operator <C>+</C> for residue classes.
The method for <Ref Func="ZeroOp"/> is used when we call
this operation or the attribute <Ref Func="Zero"/> explicitly,
and <Ref Func="ZeroOp"/> it is also used when we ask for
<C>0 * <A>rescl</A></C>, where <A>rescl</A> is a residue class.
<P/>
(Note that <Ref Func="Zero"/> and
<Ref Func="ZeroOp"/> are distinguished
because <C>0 * <A>obj</A></C> is guaranteed to return a <E>mutable</E> result
whenever a mutable version of this result exists in &GAP;
&ndash;for example if <A>obj</A> is a matrix&ndash;
whereas <Ref Func="Zero"/> is an attribute and therefore
returns <E>immutable</E> results;
for our example there is no difference since the residue classes are
always immutable,
nevertheless we have to install the method for
<Ref Func="ZeroOp"/>.
The same holds for <Ref Func="AdditiveInverse"/>,
<Ref Func="One"/>, and <Ref Func="Inverse"/>.)
<P/>
Similarly, <Ref Func="AdditiveInverseOp"/> can be either
called directly or via the unary <C>-</C> operator;
so we can compute the additive inverse of the
residue class <A>rescl</A> as <C>-<A>rescl</A></C>.
<P/>
It is not necessary to install methods for subtraction,
since this is handled via addition of the additive inverse of
the second argument if no other method is installed.
<P/>
Let us try what we can do with the methods that are available now.
<P/>
<Example><![CDATA[
gap> x:= gens[1];  y:= x + x;
( 1 mod 4 )
( 2 mod 4 )
gap> 0 * x;  -x;
( 0 mod 4 )
( 3 mod 4 )
gap> y = -y;  x = y;  x < y;  -x < y;
true
false
true
false
]]></Example>
<P/>
We might want to admit the addition of integers and elements in
rings <M>&ZZ; / n&ZZ;</M>, where an integer is implicitly identified
with its residue modulo <M>n</M>.
To achieve this, we install methods to add an integer to an object in
<C>IsMyZmodnZObj</C> from the left and from the right.
<P/>
<Example><![CDATA[
gap> InstallMethod( \+,
>    "for element in Z/nZ (ModulusRep) and integer",
>    [ IsMyZmodnZObj and IsMyModulusRep, IsInt ],
>    function( x, y )
>    return MyZmodnZObj( FamilyObj( x ), x![1] + y );
>    end );
gap> 
gap> InstallMethod( \+,
>    "for integer and element in Z/nZ (ModulusRep)",
>    [ IsInt, IsMyZmodnZObj and IsMyModulusRep ],
>    function( x, y )
>    return MyZmodnZObj( FamilyObj( y ), x + y![1] );
>    end );
]]></Example>
<P/>
Now we can do also the following.
<P/>
<Example><![CDATA[
gap> 2 + x;  7 - x;  y - 2;
( 3 mod 4 )
( 2 mod 4 )
( 0 mod 4 )
]]></Example>
<P/>
Similarly we install the methods dealing with the multiplicative
structure.
We need methods to multiply two of our objects,
and to compute identity and inverse.
The operation <Ref Func="OneOp"/> is called when we ask for
<C><A>rescl</A>^0</C>,
and <Ref Func="InverseOp"/> is called when we ask for
<C><A>rescl</A>^-1</C>.
Note that the method for <Ref Func="InverseOp"/> returns
<K>fail</K> if the argument is not invertible.
<P/>
<Example><![CDATA[
gap> InstallMethod( \*,
>    "for two elements in Z/nZ (ModulusRep)",
>    IsIdenticalObj,
>    [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],
>    function( x, y )
>    return MyZmodnZObj( FamilyObj( x ), x![1] * y![1] );
>    end );
gap> 
gap> InstallMethod( OneOp,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObj ],
>    elm -> MyZmodnZObj( FamilyObj( elm ), 1 ) );
gap> 
gap> InstallMethod( InverseOp,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObj and IsMyModulusRep ],
>    function( elm )
>    local residue;
>    residue:= QuotientMod( 1, elm![1], FamilyObj( elm )!.modulus );
>    if residue <> fail then
>      residue:= MyZmodnZObj( FamilyObj( elm ), residue );
>    fi;
>    return residue;
>    end );
]]></Example>
<P/>
To be able to multiply our objects with integers,
we need not (but we may, and we should if we are going for efficiency)
install special methods.
This is because in general, &GAP; interprets the multiplication
of an integer and an additive object as abbreviation of successive
additions, and there is one generic method for such a multiplication
that uses only additions and &ndash;in the case of a negative integer&ndash;
taking the additive inverse.
Analogously, there is a generic method for powering by integers
that uses only multiplications and taking the multiplicative inverse.
<P/>
Note that we could also interpret the multiplication with an integer
as a shorthand for the multiplication with the corresponding residue
class.
We are lucky that this interpretation is compatible with the one that
is already available.
If this would not be the case then of course we would get into trouble
by installing a concurrent multiplication that computes something
different from the multiplication that is already defined,
since &GAP; does not guarantee which of the applicable methods is
actually chosen (see&nbsp;<Ref Sect="Applicable Methods and Method Selection"/>).
<P/>
Now we have implemented methods for the arithmetic operations for our
elements, and the following calculations work.
<P/>
<Example><![CDATA[
gap> y:= 2 * x;  z:= (-5) * x;
( 2 mod 4 )
( 3 mod 4 )
gap> y * z;  y * y;
( 2 mod 4 )
( 0 mod 4 )
gap> y^-1;  y^0;
fail
( 1 mod 4 )
gap> z^-1;
( 3 mod 4 )
]]></Example>
<P/>
There are some other operations in &GAP; that we may want to accept
our elements as arguments.
An example is the operation <Ref Func="Int"/> that returns,
e.g.,
the integral part of a rational number or the integer corresponding to
an element in a finite prime field.
For our objects, we may define that <Ref Func="Int"/> returns
the normalized residue.
<P/>
Note that we <E>define</E> this behaviour for elements
but we <E>implement</E> it for objects in the representation <C>IsMyModulusRep</C>.
This means that if someone implements another representation of
residue classes then this person must be careful to implement
<Ref Func="Int"/>
methods for objects in this new representation compatibly with our
definition, i.e., such that the result is independent of the representation.
<P/>
<Example><![CDATA[
gap> InstallMethod( Int,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObj and IsMyModulusRep ],
>    z -> z![1] );
]]></Example>
<P/>
Another example of an operation for which we might want to install
a method is <Ref Func="\mod"/>.
We make the ring print itself as
<Ref Var="Integers"/> mod the modulus,
and then it is reasonable to allow a construction this way,
which makes the <Ref Func="PrintObj"/> output of the ring
&GAP; readable.
<P/>
<Example><![CDATA[
gap> InstallMethod( PrintObj,
>    "for full collection Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],
>    function( R )
>    Print( "(Integers mod ",
>           ElementsFamily( FamilyObj(R) )!.modulus, ")" );
>    end );
gap> 
gap> InstallMethod( \mod,
>    "for `Integers', and a positive integer",
>    [ IsIntegers, IsPosRat and IsInt ],
>    function( Integers, n ) return MyZmodnZ( n ); end );
]]></Example>
<P/>
Let us try this.
<P/>
<Example><![CDATA[
gap> Int( y );
2
gap> Integers mod 1789;
(Integers mod 1789)
]]></Example>
<P/>
Probably it is not necessary to emphasize that with the approach of
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>,
installing methods for existing operations is usually not possible or
at least not recommended.
For example, installing the function <C>resclass_sum</C> defined in
Section&nbsp;<Ref Sect="A First Attempt to Implement Elements of Residue Class Rings"/>
as a <Ref Func="\+"/> method for adding two lists of length two
(with integer entries) would not be compatible with the general
definition of the addition of two lists of same length.
Installing a method for the operation <Ref Func="Int"/>
that takes a list
<C>[ <A>k</A>, <A>n</A> ]</C> and returns <A>k</A> would in principle be possible,
since there is no <Ref Func="Int"/> method for lists yet,
but it is not sensible to do so because one can think of other
interpretations of such a list where different
<Ref Func="Int"/> methods could
be installed with the same right.
<P/>
As mentioned in Section&nbsp;<Ref Sect="Why Proceed in a Different Way?"/>,
one advantage of the new approach is that with the implementation
we have up to now, automatically also matrices of residue classes
can be treated.
<P/>
<Example><![CDATA[
gap> r:= Integers mod 16;
(Integers mod 16)
gap> x:= One( r );
( 1 mod 16 )
gap> mat:= IdentityMat( 2 ) * x;
[ [ ( 1 mod 16 ), ( 0 mod 16 ) ], [ ( 0 mod 16 ), ( 1 mod 16 ) ] ]
gap> mat[1][2]:= x;;
gap> mat;
[ [ ( 1 mod 16 ), ( 1 mod 16 ) ], [ ( 0 mod 16 ), ( 1 mod 16 ) ] ]
gap> Order( mat );
16
gap> mat + mat;
[ [ ( 2 mod 16 ), ( 2 mod 16 ) ], [ ( 0 mod 16 ), ( 2 mod 16 ) ] ]
gap> last^4;
[ [ ( 0 mod 16 ), ( 0 mod 16 ) ], [ ( 0 mod 16 ), ( 0 mod 16 ) ] ]
]]></Example>
<P/>
Such matrices, if they are invertible, are valid as group elements.
One technical problem is that the default algorithm for inverting matrices
may give up since Gaussian elimination need not be successful over rings
containing zero divisors.
Therefore we install a simpleminded inversion method that inverts an integer
matrix.
<P/>
<Example><![CDATA[
gap> InstallMethod( InverseOp,
>    "for an ordinary matrix over a ring Z/nZ",
>    [ IsMatrix and IsOrdinaryMatrix
>      and CategoryCollections( CategoryCollections( IsMyZmodnZObj ) ) ],
>    function( mat )
>    local one, modulus;
> 
>    one:= One( mat[1][1] );
>    modulus:= FamilyObj( one )!.modulus;
>    mat:= InverseOp( List( mat, row -> List( row, Int ) ) );
>    if mat <> fail then
>      mat:= ( mat mod modulus ) * one;
>    fi;
>    if not IsMatrix( mat ) then
>      mat:= fail;
>    fi;
>    return mat;
>    end );
]]></Example>
<P/>
Additionally we install a method for finding a domain that contains the
matrix entries; this is used by some &GAP; library functions.
<P/>
<Example><![CDATA[
gap> InstallMethod( DefaultFieldOfMatrixGroup,
>     "for a matrix group over a ring Z/nZ",
>     [ IsMatrixGroup and CategoryCollections( CategoryCollections(
>           CategoryCollections( IsMyZmodnZObj ) ) ) ],
>     G -> RingWithOneByGenerators([ One( Representative( G )[1][1] ) ]));
]]></Example>
<P/>
Now we can deal with matrix groups over residue class rings.
<P/>
<Example><![CDATA[
gap> mat2:= IdentityMat( 2 ) * x;;
gap> mat2[2][1]:= x;;
gap> g:= Group( mat, mat2 );;
gap> Size( g );
3072
gap> Factors( last );
[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3 ]
gap> syl3:= SylowSubgroup( g, 3 );;
gap> gens:= GeneratorsOfGroup( syl3 );
[ [ [ ( 1 mod 16 ), ( 7 mod 16 ) ], [ ( 11 mod 16 ), ( 14 mod 16 ) ] ] ]
gap> Order( gens[1] );
3
]]></Example>
<P/>
It should be noted that this way more involved methods for matrix groups
may not be available.
For example, many questions about a finite matrix group can be delegated
to an isomorphic permutation group via a so-called <Q>nice monomorphism</Q>;
this can be controlled by the filter
<Ref Func="IsHandledByNiceMonomorphism"/>.
<P/>
By the way, also groups of (invertible) residue classes can be formed,
but this may be of minor interest.
<Example><![CDATA[
gap> g:= Group( x );;  Size( g );
#I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for 
[ ( 1 mod 16 ) ]
1
gap> g:= Group( 3*x );;  Size( g );
#I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for 
[ ( 3 mod 16 ) ]
4
]]></Example>
<P/>
(The messages above tell that &GAP; does not know a method for deciding
whether the given elements are valid group elements.
We could add an appropriate <C>IsGeneratorsOfMagmaWithInverses</C> method if
we would want.)
<P/>
Having done enough for the elements,
we may install some more methods for the rings
if we want to use them as arguments.
These rings are finite,
and there are many generic methods that will work if they are able
to compute the list of elements of the ring,
so we install a method for this.
<P/>
<Example><![CDATA[
gap> InstallMethod( Enumerator,
>    "for full collection Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],
>    function( R )
>    local F;
>    F:= ElementsFamily( FamilyObj(R) );
>    return List( [ 0 .. Size( R ) - 1 ], x -> MyZmodnZObj( F, x ) );
>    end );
]]></Example>
<P/>
Note that this method is applicable only to full rings <M>&ZZ; / n&ZZ;</M>,
for proper subrings it would return a wrong result.
Furthermore, it is not required that the argument is a ring;
in fact this method is applicable also to the additive group
formed by all elements in the family,
provided that it knows to contain the whole family.
<P/>
Analogously, we install methods to compute the size,
a random element, and the units of full rings <M>&ZZ; / n&ZZ;</M>.
<P/>
<Example><![CDATA[
gap> InstallMethod( Random,
>    "for full collection Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],
>    R -> MyZmodnZObj( ElementsFamily( FamilyObj(R) ),
>                    Random( [ 0 .. Size( R ) - 1 ] ) ) );
gap> 
gap> InstallMethod( Size,
>    "for full ring Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],
>    R -> ElementsFamily( FamilyObj(R) )!.modulus );
gap> 
gap> InstallMethod( Units,
>    "for full ring Z/nZ",
>    [     CategoryCollections( IsMyZmodnZObj )
>      and IsWholeFamily and IsRing ],
>    function( R )
>    local F;
>    F:= ElementsFamily( FamilyObj( R ) );
>    return List( PrimeResidues( Size(R) ), x -> MyZmodnZObj( F, x ) );
>    end );
]]></Example>
<P/>
The <Ref Func="Units"/> method has the disadvantage
that the result is returned as a list
(in fact this list is also strictly sorted).
We could improve the implementation by returning the units as a group;
if we do not want to take the full list of elements as generators,
we can use the function <Ref Func="GeneratorsPrimeResidues"/>.
<P/>
<Example><![CDATA[
gap> InstallMethod( Units,
>    "for full ring Z/nZ",
>    [     CategoryCollections( IsMyZmodnZObj )
>      and IsWholeFamily and IsRing ],
>    function( R )
>    local G, gens;
> 
>    gens:= GeneratorsPrimeResidues( Size( R ) ).generators;
>    if not IsEmpty( gens ) and gens[ 1 ] = 1 then
>      gens:= gens{ [ 2 .. Length( gens ) ] };
>    fi;
>    gens:= Flat( gens ) * One( R );
>    return GroupByGenerators( gens, One( R ) );
>    end );
]]></Example>
<P/>
Each ring <M>&ZZ; / n&ZZ;</M> is finite,
and we could install a method that returns <K>true</K> when
<Ref Func="IsFinite"/> is
called with <M>&ZZ; / n&ZZ;</M> as argument.
But we can do this more elegantly via installing a <E>logical implication</E>.
<P/>
<Example><![CDATA[
gap> InstallTrueMethod( IsFinite,
>    CategoryCollections( IsMyZmodnZObj ) and IsDomain );
]]></Example>
<P/>
In effect, every domain that consists of elements in <C>IsMyZmodnZObj</C>
will automatically store that it is finite,
even if <Ref Func="IsFinite"/> is not called for it.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Compatibility of Residue Class Rings with Prime Fields">
<Heading>Compatibility of Residue Class Rings with Prime Fields</Heading>

The above implementation of residue classes and residue class rings
has at least two disadvantages.
First, if <M>p</M> is a prime then the ring <M>&ZZ; / p&ZZ;</M> is in fact a field,
but the return values of <C>MyZmodnZ</C> are never regarded as fields because
they are not in the category
<Ref Func="IsMagmaWithInversesIfNonzero"/>.
Second, and this makes the example really interesting,
there are already elements of finite prime fields implemented in &GAP;,
and we may want to identify them with elements in <M>&ZZ; / p&ZZ;</M>.
<P/>
To be more precise,
elements of finite fields in &GAP; lie in the category
<Ref Func="IsFFE"/>,
and there is already a representation,
<C>IsInternalRep</C>, of these elements
via discrete logarithms.
The aim of this section is to make <C>IsMyModulusRep</C> an alternative
representation of elements in finite prime fields.
<P/>
Note that this is only one step towards the desired compatibility.
Namely, after having a second representation of elements in finite
prime fields, we may wish that the function
<Ref Func="GF" Label="for field size"/>
(which is the usual
function to create finite fields in &GAP;) is able to return
<C>MyZmodnZ( <A>p</A> )</C> when <C>GF( <A>p</A> )</C> is called for a prime <A>p</A>.
Moreover, then we have to decide about a default representation of
elements in <C>GF( <A>p</A> )</C> for primes <A>p</A> for which both representations are
available.
Of course we can force the new representation by explicitly calling
<C>MyZmodnZ</C> and <C>MyZmodnZObj</C> whenever we want, but it is not a priori
clear in which situation which representation is preferable.
<P/>
The same questions will occur when we want to implement a new
representation for non-prime fields.
The steps of this implementation will be the same as described in this
chapter,
and we will have to achieve compatibility with both the internal
representation of elements in small finite fields and the representation
<C>IsMyModulusRep</C> of elements in arbitrary prime fields.
<P/>
But let us now turn back to the task of this section.
We first adjust the setup of the declaration part of the previous section,
and then repeat the installations with suitable modifications.
<P/>
(We should start a new &GAP; session for that, otherwise &GAP; will
complain that the objects to be declared are already bound;
additionally, the methods installed above may be not compatible with
the ones we want.)
<P/>
<Log><![CDATA[
gap> DeclareCategory( "IsMyZmodnZObj", IsScalar );
gap> 
gap> DeclareCategory( "IsMyZmodnZObjNonprime", IsMyZmodnZObj );
gap> 
gap> DeclareSynonym( "IsMyZmodpZObj", IsMyZmodnZObj and IsFFE );
gap> 
gap> DeclareRepresentation( "IsMyModulusRep", IsPositionalObjectRep, [ 1 ] );
gap> 
gap> DeclareGlobalFunction( "MyZmodnZObj" );
gap> 
gap> DeclareGlobalFunction( "MyZmodnZ" );
]]></Log>
<P/>
As in the previous section,
all (newly introduced) elements of rings <M>&ZZ; / n&ZZ;</M> lie in the category
<C>IsMyZmodnZObj</C>.
But now we introduce two subcategories, namely <C>IsMyZmodnZObjNonprime</C>
for all elements in rings <M>&ZZ; / n&ZZ;</M> where <M>n</M> is not a prime,
and <C>IsMyZmodpZObj</C> for elements in finite prime fields.
All objects in the latter are automatically known to lie in the
category <Ref Func="IsFFE"/> of finite field elements.
<P/>
It would be reasonable if also those internally represented elements
in the category <Ref Func="IsFFE"/> that do in fact lie
in a prime field
would also  lie in the category <C>IsMyZmodnZObj</C> (and thus in fact in
<C>IsMyZmodpZObj</C>).
But this cannot be achieved because internally represented finite field
elements do in general not store whether they lie in a prime field.
<P/>
As for the implementation part,
again let us start with the definitions of <C>MyZmodnZObj</C> and <C>MyZmodnZ</C>.
<P/>
<Log><![CDATA[
gap> InstallGlobalFunction( MyZmodnZObj, function( Fam, residue )
>    if IsFFEFamily( Fam ) then
>      return Objectify( NewType( Fam, IsMyZmodpZObj
>                                  and IsMyModulusRep ),
>                    [ residue mod Characteristic( Fam ) ] );
>    else
>      return Objectify( NewType( Fam, IsMyZmodnZObjNonprime
>                                  and IsMyModulusRep ),
>                    [ residue mod Fam!.modulus ] );
>    fi;
> end );

gap> InstallGlobalFunction( MyZmodnZ, function( n )
>    local F, R;
> 
>    if not ( IsInt( n ) and IsPosRat( n ) ) then
>      Error( "<n> must be a positive integer" );
>    elif IsPrimeInt( n ) then
>      # Construct the family of element objects of our field.
>      F:= FFEFamily( n );
>      # Make the domain.
>      R:= FieldOverItselfByGenerators( [ MyZmodnZObj( F, 1 ) ] );
>      SetIsPrimeField( R, true );
>    else
>      # Construct the family of element objects of our ring.
>      F:= NewFamily( Concatenation( "MyZmod", String( n ), "Z" ),
>                     IsMyZmodnZObjNonprime );
>      # Install the data.
>      F!.modulus:= n;
>      # Make the domain.
>      R:= RingWithOneByGenerators( [ MyZmodnZObj( F, 1 ) ] );
>      SetIsWholeFamily( R, true );
>      SetName( R, Concatenation( "(Integers mod ",String(n),")" ) );
>    fi;
> 
>    # Return the ring resp. field.
>    return R;
> end );
]]></Log>
<P/>
Note that the result of <C>MyZmodnZ</C> with a prime as argument is a field that
does not contain the whole family of its elements, since all finite field
elements of a fixed characteristic lie in the same family.
Further note that we cannot expect a family of finite field elements
to have a component <C>modulus</C>,
so we use <Ref Func="Characteristic"/> to get the modulus.
Requiring that <C>Fam!.modulus</C> works also if <C>Fam</C> is a family of
finite field elements would violate the rule
that an extension of &GAP; should not force changes in existing code,
in this case code dealing with families of finite field elements.
<P/>
<Log><![CDATA[
gap> InstallMethod( PrintObj,
>    "for element in Z/nZ (ModulusRep)",
>    [ IsMyZmodnZObjNonprime and IsMyModulusRep ],
>    function( x )
>    Print( "( ", x![1], " mod ", FamilyObj(x)!.modulus, " )" );
>    end );
gap> 
gap> InstallMethod( PrintObj,
>    "for element in Z/pZ (ModulusRep)",
>    [ IsMyZmodpZObj and IsMyModulusRep ],
>    function( x )
>    Print( "( ", x![1], " mod ", Characteristic(x), " )" );
>    end );
gap> 
gap> InstallMethod( \=,
>    "for two elements in Z/nZ (ModulusRep)",
>    IsIdenticalObj,
>    [ IsMyZmodnZObj and IsMyModulusRep,
>      IsMyZmodnZObj and IsMyModulusRep ],
>    function( x, y ) return x![1] = y![1]; end );
]]></Log>
<P/>
The above method to check equality is independent of whether the
arguments have a prime or nonprime modulus,
so we installed it for arguments in <C>IsMyZmodnZObj</C>.
Now we install also methods to compare objects in <C>IsMyZmodpZObj</C>
with the <Q>old</Q> finite field elements.
<P/>
<Log><![CDATA[
gap> InstallMethod( \=,
>    "for element in Z/pZ (ModulusRep) and internal FFE",
>    IsIdenticalObj,
>    [ IsMyZmodpZObj and IsMyModulusRep, IsFFE and IsInternalRep ],
>    function( x, y )
>    return DegreeFFE( y ) = 1 and x![1] = IntFFE( y );
>    end );
gap> 
gap> InstallMethod( \=,
>    "for internal FFE and element in Z/pZ (ModulusRep)",
>    IsIdenticalObj,
>    [ IsFFE and IsInternalRep, IsMyZmodpZObj and IsMyModulusRep ],
>    function( x, y )
>    return DegreeFFE( x ) = 1 and IntFFE( x ) = y![1];
>    end );
]]></Log>
<P/>
The situation with the operation <C>&lt;</C> is more difficult.
Of course we are free to define the comparison of objects in
<C>IsMyZmodnZObjNonprime</C>,
but for the finite field elements, the comparison must be compatible
with the predefined comparison of the <Q>old</Q> finite field elements.
The definition of the <C>&lt;</C> comparison of internally represented
finite field elements can be found
in Chapter&nbsp;<Ref Chap="Finite Fields"/>.
In situations where the documentation does not provide the required
information, one has to look it up in the &GAP; code;
for example, the comparison in our case can be found in the
appropriate source code file of the &GAP; kernel.
<P/>
<Log><![CDATA[
gap> InstallMethod( \<,
>    "for two elements in Z/nZ (ModulusRep, nonprime)",
>    IsIdenticalObj,
>    [ IsMyZmodnZObjNonprime and IsMyModulusRep,
>      IsMyZmodnZObjNonprime and IsMyModulusRep ],
>    function( x, y ) return x![1] < y![1]; end );
gap> 
gap> InstallMethod( \<,
>    "for two elements in Z/pZ (ModulusRep)",
>    IsIdenticalObj,
>    [ IsMyZmodpZObj and IsMyModulusRep,
>      IsMyZmodpZObj and IsMyModulusRep ],
>    function( x, y )
>    local p, r;      # characteristic and primitive root
>    if x![1] = 0 then
>      return y![1] <> 0;
>    elif y![1] = 0 then
>      return false;
>    else
>      p:= Characteristic( x );
>      r:= PrimitiveRootMod( p );
>      return LogMod( x![1], r, p ) < LogMod( y![1], r, p );
>    fi;
>    end );
gap> 
gap> InstallMethod( \<,
>    "for element in Z/pZ (ModulusRep) and internal FFE",
>    IsIdenticalObj,
>    [ IsMyZmodpZObj and IsMyModulusRep, IsFFE and IsInternalRep ],
>    function( x, y )
>    return x![1] * One( y ) < y;
>    end );
gap> 
gap> InstallMethod( \<,
>    "for internal FFE and element in Z/pZ (ModulusRep)",
>    IsIdenticalObj,
>    [ IsFFE and IsInternalRep, IsMyZmodpZObj and IsMyModulusRep ],
>    function( x, y )
>    return x < y![1] * One( x );
>    end );
]]></Log>
<P/>
Now we install the same methods for the arithmetic operations
<Ref Func="\+"/>, <Ref Func="ZeroOp"/>,
<Ref Func="AdditiveInverseOp"/>,
<C>\-</C>, <Ref Func="\*"/>,
and <Ref Func="OneOp"/>
as in the previous section, without listing them below.
Also the same <Ref Func="Int"/> method is installed
for objects in <C>IsMyZmodnZObj</C>.
Note that it is compatible with the definition of
<Ref Func="Int"/> for finite
field elements.
And of course the same method for <Ref Func="\mod"/> is
installed.
<P/>
We have to be careful, however, with the methods for
<Ref Func="InverseOp"/>,
<Ref Func="\/"/>, and <Ref Func="\^"/>.
These methods and the missing methods for arithmetic operations with
one argument in <C>IsMyModulusRep</C> and the other in <C>IsInternalRep</C>
are given below.
<P/>
<Log><![CDATA[
gap> InstallMethod( \+,
>    "for element in Z/pZ (ModulusRep) and internal FFE",
>    IsIdenticalObj,
>    [ IsMyZmodpZObj and IsMyModulusRep, IsFFE and IsInternalRep ],
>    function( x, y ) return x![1] + y; end );
gap> 
gap> InstallMethod( \+,
>    "for internal FFE and element in Z/pZ (ModulusRep)",
>    IsIdenticalObj,
>    [ IsFFE and IsInternalRep, IsMyZmodpZObj and IsMyModulusRep ],
>    function( x, y ) return x + y![1]; end );
gap> 
gap> InstallMethod( \*,
>    "for element in Z/pZ (ModulusRep) and internal FFE",
>    IsIdenticalObj,
>    [ IsMyZmodpZObj and IsMyModulusRep, IsFFE and IsInternalRep ],
>    function( x, y ) return x![1] * y; end );
gap> 
gap> InstallMethod( \*,
>    "for internal FFE and element in Z/pZ (ModulusRep)",
>    IsIdenticalObj,
>    [ IsFFE and IsInternalRep, IsMyZmodpZObj and IsMyModulusRep ],
>    function( x, y ) return x * y![1]; end );
gap> 
gap> InstallMethod( InverseOp,
>    "for element in Z/nZ (ModulusRep, nonprime)",
>    [ IsMyZmodnZObjNonprime and IsMyModulusRep ],
>    function( x )
>    local residue;
>    residue:= QuotientMod( 1, x![1], FamilyObj(x)!.modulus );
>    if residue <> fail then
>      residue:= MyZmodnZObj( FamilyObj(x), residue );
>    fi;
>    return residue;
>    end );
gap> 
gap> InstallMethod( InverseOp,
>    "for element in Z/pZ (ModulusRep)",
>    [ IsMyZmodpZObj and IsMyModulusRep ],
>    function( x )
>    local residue;
>    residue:= QuotientMod( 1, x![1], Characteristic( FamilyObj(x) ) );
>    if residue <> fail then
>      residue:= MyZmodnZObj( FamilyObj(x), residue );
>    fi;
>    return residue;
>    end );
]]></Log>
<P/>
The operation <Ref Func="DegreeFFE" Label="for a FFE"/> is defined
for finite field elements,
we need a method for objects in <C>IsMyZmodpZObj</C>.
Note that we need not require <C>IsMyModulusRep</C> since no access to
representation dependent data occurs.
<P/>
<Log><![CDATA[
gap> InstallMethod( DegreeFFE,
>    "for element in Z/pZ",
>    [ IsMyZmodpZObj ],
>    z -> 1 );
]]></Log>
<P/>
The methods for <Ref Func="Enumerator"/>,
<Ref Func="Random" Label="for a list or collection"/>,
<Ref Func="Size"/>,
and <Ref Func="Units"/>,
that we had installed in the previous section had all assumed that
their argument contains the whole family of its elements.
So these methods make sense only for the nonprime case.
For the prime case, there are already methods for these operations
with argument a field.
<P/>
<Log><![CDATA[
gap> InstallMethod( Enumerator,
>    "for full ring Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObjNonprime ) and IsWholeFamily ],
>    function( R )
>    local F;
>    F:= ElementsFamily( FamilyObj( R ) );
>    return List( [ 0 .. Size( R ) - 1 ], x -> MyZmodnZObj( F, x ) );
>    end );
gap> 
gap> InstallMethod( Random,
>    "for full ring Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObjNonprime ) and IsWholeFamily ],
>    R -> MyZmodnZObj( ElementsFamily( FamilyObj( R ) ),
>                    Random( [ 0 .. Size( R ) - 1 ] ) ) );
gap> 
gap> InstallMethod( Size,
>    "for full ring Z/nZ",
>    [ CategoryCollections( IsMyZmodnZObjNonprime ) and IsWholeFamily ],
>    R -> ElementsFamily( FamilyObj( R ) )!.modulus );
gap> 
gap> InstallMethod( Units,
>    "for full ring Z/nZ",
>    [     CategoryCollections( IsMyZmodnZObjNonprime )
>      and IsWholeFamily and IsRing ],
>    function( R )
>    local G, gens;
> 
>    gens:= GeneratorsPrimeResidues( Size( R ) ).generators;
>    if not IsEmpty( gens ) and gens[ 1 ] = 1 then
>      gens:= gens{ [ 2 .. Length( gens ) ] };
>    fi;
>    gens:= Flat( gens ) * One( R );
>    return GroupByGenerators( gens, One( R ) );
>    end );
gap> 
gap> InstallTrueMethod( IsFinite,
>    CategoryCollections( IsMyZmodnZObjNonprime ) and IsDomain );
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Further Improvements in Implementing Residue Class Rings">
<Heading>Further Improvements in Implementing Residue Class Rings</Heading>

There are of course many possibilities to improve the implementation.
<P/>
With the setup as described above,
subsequent calls <C>MyZmodnZ( <A>n</A> )</C> with the same <A>n</A> yield incompatible
rings in the sense that elements of one ring cannot be added to elements
of an other one.
The solution for this problem is to keep a global list of all results of
<C>MyZmodnZ</C> in the current &GAP; session, and to return the stored values
whenever possible.
Note that this approach would admit <Ref Func="PrintObj"/>
methods that produce &GAP; readable output.
<P/>
One can improve the <Ref Func="Units"/> method for the full
ring in such a way
that a group is returned and not only a list of its elements;
then the result of <Ref Func="Units"/> can be used,
e.&nbsp;g., as input for the operation
<Ref Func="SylowSubgroup"/>.
<P/>
To make computations more efficient,
one can install methods for <C>\-</C>,
<Ref Func="\/"/>, and <Ref Func="\^"/>;
one reason for doing so may be that this avoids the unnecessary construction
of the additive or multiplicative inverse, or of intermediate powers.
<P/>
<Log><![CDATA[
InstallMethod( \-, "two elements in Z/nZ (ModulusRep)", ... );
InstallMethod( \-, "Z/nZ-obj. (ModulusRep) and integer", ... );
InstallMethod( \-, "integer and Z/nZ-obj. (ModulusRep)", ... );
InstallMethod( \-, "Z/pZ-obj. (ModulusRep) and internal FFE", ... );
InstallMethod( \-, "internal FFE and Z/pZ-obj. (ModulusRep)", ... );
InstallMethod( \*, "Z/nZ-obj. (ModulusRep) and integer", ... );
InstallMethod( \*, "integer and Z/nZ-obj. (ModulusRep)", ... );
InstallMethod( \/, "two Z/nZ-objs. (ModulusRep, nonprime)", ... );
InstallMethod( \/, "two Z/pZ-objs. (ModulusRep)", ... );
InstallMethod( \/, "Z/nZ-obj. (ModulusRep) and integer", ... );
InstallMethod( \/, "integer and Z/nZ-obj. (ModulusRep)", ... );
InstallMethod( \/, "Z/pZ-obj. (ModulusRep) and internal FFE", ... );
InstallMethod( \/, "internal FFE and Z/pZ-obj. (ModulusRep)", ... );
InstallMethod( \^, "Z/nZ-obj. (ModulusRep, nonprime) & int.", ... );
InstallMethod( \^, "Z/pZ-obj. (ModulusRep), and integer", ... );
]]></Log>
<P/>
The call to <Ref Func="NewType"/> in <C>MyZmodnZObj</C> can be avoided
by storing the required type, e.g., in the family.
But note that it is <E>not</E> admissible to take the type of an existing
object as first argument of <Ref Func="Objectify"/>.
For example, suppose two objects in <C>IsMyZmodnZObj</C> shall be added.
Then we must not use the type of one of the arguments in a call of
<Ref Func="Objectify"/>, because the argument may have knowledge that is not
correct for the result of the addition.
One may think of the property <Ref Func="IsOne"/>
that may hold for both arguments but certainly not for their sum.
<P/>
For comparing two objects in <C>IsMyZmodpZObj</C> via <Q><C>&lt;</C></Q>,
we had to install a quite expensive method because of the compatibility
with the comparison of finite field elements that did already exist.
In fact &GAP; supports finite fields with elements represented via
discrete logarithms only up to a given size.
So in principle we have the freedom to define a cheaper comparison
via <Q><C>&lt;</C></Q> for objects in <C>IsMyZmodpZObj</C>
if the modulus is large enough.
This is possible by introducing two categories <C>IsMyZmodpZObjSmall</C>
and <C>IsMyZmodpZObjLarge</C>, which are subcategories of <C>IsMyZmodpZObj</C>,
and to install different <Ref Func="\&lt;"/> methods
for pairs of objects
in these categories.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  arith.tex                 GAP manual                    Thomas Breuer -->
<!-- %% -->
<!-- %H  @(#)<M>Id: arith.tex,v 4.4 2000/01/21 13:21:28 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="An Example -- Designing Arithmetic Operations">
<Heading>An Example &ndash; Designing Arithmetic Operations</Heading>

In this chapter, we give a &ndash;hopefully typical&ndash;
example of extending &GAP; by new objects with prescribed
arithmetic operations (for a simple approach that may be useful 
to get started though does not permit to exploit all potential 
features, see also <Ref Func="ArithmeticElementCreator"/>).

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="New Arithmetic Operations vs. New Objects">
<Heading>New Arithmetic Operations vs. New Objects</Heading>

A usual procedure in mathematics is the definition of new operations for
given objects;
here are a few typical examples.
The Lie bracket defines an interesting new multiplicative
structure on a given (associative) algebra.
Forming a group ring can be viewed as defining a new addition for the
elements of the given group, and extending the multiplication to sums
of group elements in a natural way.
Forming the exterior algebra of a given vector space can be viewed as
defining a new multiplication for the vectors in a natural way.
<P/>
&GAP; does <E>not</E> support such a procedure.
The main reason for this is that in &GAP;, the multiplication in a group,
a ring etc.&nbsp;is always written as <C>*</C>,
and the addition in a vector space, a ring etc.&nbsp; is always written as <C>+</C>.
Therefore it is not possible to define the Lie bracket as a
<Q>second multiplication</Q> for the elements of a given algebra;
in fact, the multiplication in Lie algebras in &GAP; is denoted by <C>*</C>.
Analogously, constructing the group ring as sketched above is impossible
if an addition is already defined for the elements;
note the difference between the usual addition of matrices and the
addition in the group ring of a matrix group!
(See Chapter&nbsp;<Ref Chap="Magma Rings"/> for an example.)
Similarly, there is already a multiplication defined for row vectors
(yielding the standard scalar product), hence these vectors cannot be
regarded as elements of the exterior algebra of the space.
<P/>
In situations such as the ones mentioned above,
&GAP;'s way to deal with the structures in question is the following.
Instead of defining <E>new</E> operations for the <E>given</E> objects,
<E>new</E> objects are created to which the <E>given</E> arithmetic operations
<C>*</C> and <C>+</C> are then made applicable.
<P/>
With this construction, matrix Lie algebras consist of matrices that are
different from the matrices with associative multiplication;
technically, the type of a matrix determines how it is multiplied with
other matrices (see&nbsp;<Ref Func="IsMatrix"/>).
A matrix with the Lie bracket as its multiplication can be created with
the function <Ref Func="LieObject"/>
from a matrix with the usual associative multiplication.
<P/>
Group rings (more general: magma rings,
see Chapter&nbsp;<Ref Chap="Magma Rings"/>)
can be constructed with <Ref Func="FreeMagmaRing"/>
from a coefficient ring and a group.
The elements of the group are not contained in such a group ring, 
one has to use an embedding map for creating a group ring element that
corresponds to a given group element.
<P/>
It should be noted that the &GAP; approach to the construction of
Lie algebras from associative algebras is generic in the sense
that all objects in the filter <Ref Filt="IsLieObject"/> use the 
same methods for their addition, multiplication etc.,
by delegating to the <Q>underlying</Q> objects of the associative algebra,
no matter what these objects actually are.
Analogously, also the construction of group rings is generic.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Designing new Multiplicative Objects">
<Heading>Designing new Multiplicative Objects</Heading>

The goal of this section is to implement objects with a prescribed
multiplication.
Let us assume that we are given a field <M>F</M>,
and that we want to define a new multiplication <M>*</M> on <M>F</M>
that is given by <M>a * b = a b - a - b + 2</M>;
here <M>a b</M> denotes the ordinary product in <M>F</M>.
<P/>
By the discussion in Section&nbsp;<Ref Sect="New Arithmetic Operations vs. New Objects"/>,
we know that we cannot define a new multiplication on <M>F</M> itself
but have to create new objects.
<P/>
We want to distinguish these new objects from all other &GAP; objects,
in order to describe for example the situation that two of our objects
shall be multiplied.
This distinction is made via the <E>type</E> of the objects.
More precisely, we declare a new <E>filter</E>, a function that will return
<K>true</K> for our new objects, and <K>false</K> for all other &GAP; objects.
This can be done by calling <Ref Func="DeclareFilter"/>,
but since our objects will know about the value already when they are
constructed, the filter can be created with
<Ref Func="DeclareCategory"/> or <Ref Func="NewCategory"/>.
<P/>
<Log><![CDATA[
DeclareCategory( "IsMyObject", IsObject );
]]></Log>
<P/>
The idea is that the new multiplication will be installed only
for objects that <Q>lie in the category <C>IsMyObject</C></Q>.
<P/>
The next question is what internal data our new objects store,
and how they are accessed.
The easiest solution is to store the <Q>underlying</Q> object from the
field <M>F</M>.
&GAP; provides two general possibilities how to store this,
namely record-like and list-like structures
(for examples, see&nbsp;<Ref Sect="Component Objects"/> and&nbsp;<Ref Sect="Positional Objects"/>).
We decide to store the data in a list-like structure, at position 1.
This <E>representation</E> is declared as follows.
<P/>
<Log><![CDATA[
DeclareRepresentation( "IsMyObjectListRep", IsPositionalObjectRep, [ 1 ] );
]]></Log>
<P/>
Of course we can argue that this declaration is superfluous
because <E>all</E> objects in the category <C>IsMyObject</C> will be represented
this way;
it is possible to proceed like that,
but often (in more complicated situations) it turns out to be useful 
that several representations are available for <Q>the same element</Q>.
<P/>
For creating the type of our objects, we need to specify to which <E>family</E>
(see&nbsp;<Ref Sect="Families"/>) the objects shall belong.
For the moment, we need not say anything about relations to other &GAP;
objects,
thus the only requirement is that all new objects lie in the <E>same</E> family;
therefore we create a <E>new</E> family.
Also we are not interested in properties that some of our objects have
and others do not have,
thus we need only one type,
and store it in a global variable.
<P/>
<Log><![CDATA[
MyType:= NewType( NewFamily( "MyFamily" ),
                  IsMyObject and IsMyObjectListRep );
]]></Log>
<P/>
The next step is to write a function that creates a new object.
It may look as follows.
<Log><![CDATA[
MyObject:= val -> Objectify( MyType, [ Immutable( val ) ] );
]]></Log>
Note that we store an <E>immutable copy</E> of the argument in the returned
object;
without doing so, for example if the argument would be a mutable matrix
then the corresponding new object would be changed whenever the matrix
is changed
(see&nbsp;<Ref Sect="Mutability and Copyability"/> for more
details about mutability).
<P/>
Having entered the above &GAP; code, we can create some of our objects.
<Log><![CDATA[
gap> a:= MyObject( 3 );  b:= MyObject( 5 );
<object>
<object>
gap> a![1];  b![1];
3
5
]]></Log>
But clearly a lot is missing.
Besides the fact that the desired multiplication is not yet installed,
we see that also the way how the objects are printed is not satisfactory.
<P/>
Let us improve the latter first.
There are two &GAP; functions <Ref Func="View"/> and
<Ref Func="Print"/> for showing objects
on the screen.
<Ref Func="View"/> is thought to show a short and human
readable form of the object,
and <Ref Func="Print"/> is thought to show a not necessarily
short form that is &GAP; readable whenever this makes sense.
We decide to show <C>a</C> as <C><A>3</A></C> by
<Ref Func="View"/>, and to show the construction
<C>MyObject( 3 )</C> by <Ref Func="Print"/>;
the methods are installed for the underlying operations
<Ref Func="ViewObj"/> and
<Ref Func="PrintObj"/>.
<Log><![CDATA[
InstallMethod( ViewObj,
    "for object in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep ],
    function( obj )
    Print( "<", obj![1], ">" );
    end );

InstallMethod( PrintObj,
    "for object in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep ],
    function( obj )
    Print( "MyObject( ", obj![1], " )" );
    end );
]]></Log>
<P/>
This is the result of the above installations.
<Log><![CDATA[
gap> a; Print( a, "\n" );
<3>
MyObject( 3 )
]]></Log>
<P/>
And now we try to install the multiplication.
<P/>
<Log><![CDATA[
InstallMethod( \*,
    "for two objects in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep,
      IsMyObject and IsMyObjectListRep ],
    function( a, b )
    return MyObject( a![1] * b![1] - a![1] - b![1] + 2 );
    end );
]]></Log>
<P/>
When we enter the above code, &GAP; runs into an error.
This is due to the fact that the operation <Ref Func="\*"/>
is declared for two arguments that lie in the category
<Ref Func="IsMultiplicativeElement"/>.
One could circumvent the check whether the method matches the
declaration of the operation, by calling <Ref Func="InstallOtherMethod"/>
instead of <Ref Func="InstallMethod"/>.
But it would make sense if our objects would lie in
<Ref Func="IsMultiplicativeElement"/>,
for example because some generic methods
for objects with multiplication would be available then,
such as powering by positive integers via repeated squaring.
So we want that <C>IsMyObject</C> implies
<Ref Func="IsMultiplicativeElement"/>.
The easiest way to achieve such implications is to use the
implied filter as second argument of the <Ref Func="DeclareCategory"/> call;
but since we do not want to start anew,
we can also install the implication afterwards.
<P/>
<Log><![CDATA[
InstallTrueMethod( IsMultiplicativeElement, IsMyObject );
]]></Log>
<P/>
Afterwards, installing the multiplication works without problems.
Note that <C>MyType</C> and therefore also <C>a</C> and <C>b</C> are <E>not</E>
affected by this implication, so we construct them anew.
<P/>
<Log><![CDATA[
gap> MyType:= NewType( NewFamily( "MyFamily" ),
>                      IsMyObject and IsMyObjectListRep );;
gap> a:= MyObject( 3 );;  b:= MyObject( 5 );;
gap> a*b;  a^27;
<9>
<134217729>
]]></Log>
<P/>
Powering the new objects by negative integers is not possible yet,
because &GAP; does not know how to compute the inverse of an element <M>a</M>,
say, which is defined as the unique element <M>a'</M> such that both
<M>a a'</M> and <M>a' a</M> are <Q>the unique multiplicative neutral
element that belongs to <M>a</M></Q>.
<P/>
And also this neutral element, if it exists,
cannot be computed by &GAP; in our current situation.
It does, however, make sense to ask for the multiplicative neutral
element of a given magma, and for inverses of elements in the magma.
<P/>
But before we can form domains of our objects,
we must define when two objects are regarded as equal;
note that this is necessary in order to decide about the uniqueness
of neutral and inverse elements.
In our situation, equality is defined in the obvious way.
For being able to form sets of our objects,
also an ordering via <Ref Func="\&lt;"/> is defined for them.
<P/>
<Log><![CDATA[
InstallMethod( \=,
    "for two objects in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep,
      IsMyObject and IsMyObjectListRep ],
    function( a, b )
    return a![1] = b![1];
    end );

InstallMethod( \<,
    "for two objects in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep,
      IsMyObject and IsMyObjectListRep ],
    function( a, b )
    return a![1] < b![1];
    end );
]]></Log>
<P/>
Let us look at an example.
We start with finite field elements because then the domains are finite,
hence the generic methods for such domains will have a chance to succeed.
<P/>
<Log><![CDATA[
gap> a:= MyObject( Z(7) );
<Z(7)>
gap> m:= Magma( a );
<magma with 1 generators>
gap> e:= MultiplicativeNeutralElement( m );
<Z(7)^2>
gap> elms:= AsList( m );
[ <Z(7)>, <Z(7)^2>, <Z(7)^5> ]
gap> ForAll( elms, x -> ForAny( elms, y -> x*y = e and y*x = e ) );
true
gap> List( elms, x -> First( elms, y -> x*y = e and y*x = e ) );   
[ <Z(7)^5>, <Z(7)^2>, <Z(7)> ]
]]></Log>
<P/>
So a multiplicative neutral element exists,
in fact all elements in the magma <C>m</C> are invertible.
But what about the following.
<P/>
<Log><![CDATA[
gap> b:= MyObject( Z(7)^0 );  m:= Magma( a, b );
<Z(7)^0>
<magma with 2 generators>
gap> elms:= AsList( m );
[ <Z(7)^0>, <Z(7)>, <Z(7)^2>, <Z(7)^5> ]
gap> e:= MultiplicativeNeutralElement( m );
<Z(7)^2>
gap> ForAll( elms, x -> ForAny( elms, y -> x*y = e and y*x = e ) );
false
gap> List( elms, x -> b * x );
[ <Z(7)^0>, <Z(7)^0>, <Z(7)^0>, <Z(7)^0> ]
]]></Log>
<P/>
Here we found a multiplicative neutral element,
but the element <C>b</C> does not have an inverse.
If an addition would be defined for our elements then we would say
that <C>b</C> behaves like a zero element.
<P/>
When we started to implement the new objects,
we said that we wanted to define the new multiplication for elements
of a given field <M>F</M>.
In principle, the current implementation would admit also something
like <C>MyObject( 2 ) * MyObject( Z(7) )</C>.
But if we decide that our initial assumption holds,
we may define the identity and the inverse of the object <C>&lt;a></C> as
<C>&lt;2*e></C> and <C>&lt;a/(a-e)></C>, respectively,
where <C>e</C> is the identity element in <M>F</M> and <C>/</C> denotes the division
in <M>F</M>; 
note that the element <C>&lt;e></C> is not invertible,
and that the above definitions are determined by the multiplication
defined for our objects.
Further note that after the installations shown below,
also <C>One( MyObject( 1 ) )</C> is defined.
<P/>
(For technical reasons, we do not install the intended methods for
the attributes <Ref Func="One"/> and
<Ref Func="Inverse"/> but for the operations
<Ref Func="OneOp"/>
and <Ref Func="InverseOp"/>.
This is because for certain kinds of objects &ndash;mainly matrices&ndash;
one wants to support a method to compute a <E>mutable</E> identity or
inverse, and the attribute needs only a method that takes this
object, makes it immutable, and then returns this object.
As stated above, we only want to deal with immutable objects,
so this distinction is not really interesting for us.)
<P/>
A more interesting point to note is that we should mark our objects
as likely to be invertible,
since we add the possibility to invert them.
Again, this could have been part of the declaration of <C>IsMyObject</C>,
but we may also formulate an implication for the existing category.
<P/>
<Log><![CDATA[
InstallTrueMethod( IsMultiplicativeElementWithInverse, IsMyObject );

InstallMethod( OneOp,
    "for an object in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep ],
    a -> MyObject( 2 * One( a![1] ) ) );

InstallMethod( InverseOp,
    "for an object in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep ],
    a -> MyObject( a![1] / ( a![1] - One( a![1] ) ) ) );
]]></Log>
Now we can form groups of our (nonzero) elements.
<Log><![CDATA[
gap> MyType:= NewType( NewFamily( "MyFamily" ),
>                   IsMyObject and IsMyObjectListRep );;
gap> 
gap> a:= MyObject( Z(7) );
<Z(7)>
gap> b:= MyObject( 0*Z(7) );  g:= Group( a, b );
<0*Z(7)>
<group with 2 generators>
gap> Size( g );
6
]]></Log>
<P/>
We are completely free to define an <E>addition</E> for our elements,
a natural one is given by <C>&lt;a> + &lt;b> = &lt;a+b-1></C>.
As we did for the multiplication, we first change <C>IsMyObject</C>
such that the additive structure is also known.
<Log><![CDATA[
InstallTrueMethod( IsAdditiveElementWithInverse, IsMyObject );
]]></Log>
Next we install the methods for the addition,
and those to compute the additive neutral element
and the additive inverse.
<P/>
<Log><![CDATA[
InstallMethod( \+,
    "for two objects in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep,
      IsMyObject and IsMyObjectListRep ],
    function( a, b )
    return MyObject( a![1] + b![1] - 1 );
    end );

InstallMethod( ZeroOp,
    "for an object in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep ],
    a -> MyObject( One( a![1] ) ) );

InstallMethod( AdditiveInverseOp,
    "for an object in `IsMyObject'",
    [ IsMyObject and IsMyObjectListRep ],
    a -> MyObject( a![1] / ( a![1] - One( a![1] ) ) ) );
]]></Log>
<P/>
Let us try whether the addition works.
<P/>
<Log><![CDATA[
gap> MyType:= NewType( NewFamily( "MyFamily" ),
>                   IsMyObject and IsMyObjectListRep );;
gap> a:= MyObject( Z(7) );;  b:= MyObject( 0*Z(7) );;
gap> m:= AdditiveMagma( a, b );
<additive magma with 2 generators>
gap> Size( m );
7
]]></Log>
<P/>
Similar as installing a multiplication automatically makes
powering by integers available,
multiplication with integers becomes available with the addition.
<P/>
<Log><![CDATA[
gap> 2 * a;
<Z(7)^5>
gap> a+a;
<Z(7)^5>
gap> MyObject( 2*Z(7)^0 ) * a;
<Z(7)>
]]></Log>
<P/>
In particular we see that this multiplication does <E>not</E> coincide
with the multiplication of two of our objects,
that is, an integer <E>cannot</E> be used as a shorthand for one of the
new objects in a multiplication.
<P/>
(It should be possible to create a <E>field</E> with the new multiplication
and addition.
Currently this fails, due to missing methods for computing
several kinds of generators from field generators,
for computing the characteristic in the case that the family does not
know this in advance,
for checking with <Ref Func="AsField"/> whether a domain
is in fact a field, for computing the closure as a field.)
<P/>
It should be emphasized that the mechanism described above may be not
suitable for the situation that one wants to consider many different
multiplications <Q>on the same set of objects</Q>,
since the installation of a new multiplication requires the declaration
of at least one new filter and the installation of several methods.
But the design of &GAP; is not suitable for such dynamic method
installations.
<P/>
Turning this argument the other way round,
the implementation of the new arithmetics defined by the above
multiplication and addition is available for any field <M>F</M>,
one need not repeat it for each field one is interested in.
<P/>
Similar to the above situation,
the construction of a magma ring <M>RM</M> from a coefficient ring <M>R</M>
and a magma <M>M</M> is implemented only once,
since the definition of the arithmetic operations depends only on the
given multiplication of <M>M</M> and not on <M>M</M> itself.
So the addition is not implemented for the elements in <M>M</M> or
&ndash;more precisely&ndash; for an isomorphic copy.
In some sense, the addition is installed <Q>for the multiplication</Q>,
and as mentioned in Section&nbsp;<Ref Sect="New Arithmetic Operations vs. New Objects"/>,
there is only one multiplication <Ref Func="\*"/> in &GAP;.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  libform.tex              GAP documentation           Alexander Hulpke -->
<!-- %% -->
<!-- %H  @(#)<M>Id: libform.tex,v 4.14 2004/01/27 09:26:53 stefan Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Library Files">
<Heading>Library Files</Heading>

This chapter describes some of the conventions used in the &GAP;
library files.
These conventions are intended as a help on how to read library files and
how to find information in them.
So everybody is recommended to follow these conventions,
although they do not prescribe a compulsory programming style
&ndash;&GAP; itself will not bother with the formatting of files.
<P/>
Filenames have traditionally &GAP; adhered to the 8+3 convention (to make it
possible to use the same filenames even on a MS-DOS file system) and been in
lower case (systems that do not recognize lower case in file names will
convert them automatically to upper case). It is no longer so important to 
adhere to these conventions, but at the very least filenames should adhere
to a 16+5 convention, and be distinct even after identifying upper and lower
case. Directory names of packages, however, <E>must</E> be in lower case
(the <Ref Func="LoadPackage"/> command assumes this).


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="File Types">
<Heading>File Types</Heading>

The &GAP; library consists of the following types of files, distinguished
by their suffixes:
<P/>
<List>
<Mark><C>.g</C> </Mark>
<Item>
    Files which contain parts of the <Q>inner workings</Q> of &GAP;.
    These files usually do not contain mathematical functionality,
    except for providing links to kernel functions.
</Item>
<Mark><C>.gd</C> </Mark>
<Item>
    Declaration files.
    These files contain declarations of all categories, attributes,
    operations, and global functions.
    These files also contain the operation definitions in comments.
</Item>
<Mark><C>.gi</C> </Mark>
<Item>
    Implementation files.
    These files contain all installations of methods and global functions.
    Usually declarations of representations are also considered to be
    part of the implementation and are therefore found in the <C>.gi</C> files.
</Item>
</List>
<P/>
As a rule of thumb, all <C>.gd</C> files are read in before the <C>.gi</C>
files are read.
Therefore a <C>.gi</C> file usually may use any operation or global function
(it has been declared before),
and no care has to be taken towards the order in which the <C>.gi</C> files
are read. 

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Finding Implementations in the Library">
<Heading>Finding Implementations in the Library</Heading>

For a concretely given function, you can use
<Ref Func="FilenameFunc"/> and <Ref Func="StartlineFunc"/> for finding the
file where this function is defined, and the line in this file where the
definition of this function starts.
This does not work for arbitrary functions,
see Section <Ref Func="FilenameFunc"/> for the restrictions.
<P/>
If you are interested in getting the function which implements a method
for specific arguments, you can use <Ref Sect="ApplicableMethod"/>.
If <Ref Func="FilenameFunc"/> does not work for this method then
setting the print level of <Ref Sect="ApplicableMethod"/> higher will give
you the installation string for this method, which can be used for searching
in library files.
<P/>
To find the occurrence of functions, methods, function names,
and installation strings in the library,
one can use the <C>grep</C> tool under UNIX.
To find a function, search for the function name in the <C>.gd</C> files;
as global variables are usually declared only once,
only few files will show up.
The function installation is likely to occur in the corresponding
<C>.gi</C> file.
<P/>
To find a method from the known operation name and the installation string,
search for the string <Q><C>Method(</C></Q>
(this catches both <Ref Func="InstallMethod"/> and
<Ref Func="InstallOtherMethod"/>)
and the installation string or the operation name.
<P/>
The following tools from the &GAP; package <Package>Browse</Package>
can be used for accessing the code of functions.
<P/>
<List>
<Item>
    <Ref Func="BrowseGapMethods" BookName="browse"/> shows an overview of
    &GAP;'s operations and methods, and allows one to navigate through the
    files that contain the implementations of the methods, using a pager.
</Item>
<Item>
    <Ref Func="BrowseProfile" BookName="browse"/> shows profiling results
    (similar to <Ref Func="DisplayProfile"/>) and allows one to navigate
    through the files that contain the implementations of the functions
    that were actually used, using a pager.
</Item>
</List>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Undocumented Variables">
<Heading>Undocumented Variables</Heading>

For several global variables in &GAP;,
no information is available via the help system 
(see Section&nbsp;<Ref Sect="Help" BookName="tut"/>,
for a quick overview of the help system,
or Chapter&nbsp;<Ref Chap="The Help System"/>,
for details).
There are various reasons for <Q>hiding</Q> a variable from the user;
namely, the variable may be regarded as of minor importance
(for example, it may be a function called by documented &GAP;
functions that first compute many input parameters for the undocumented
function),
or it belongs to a part of &GAP; that is still experimental in the sense
that the meaning of the variable has not yet been fixed or even that it is
not clear whether the variable will vanish in a more developed version.
<P/>
As a consequence, it is dangerous to use undocumented variables because
they are not guaranteed to exist or to behave the same in future versions
of &GAP;.
<P/>
Conversely, for <E>documented</E> variables, the definitions in the &GAP;
manual can be relied on for future &GAP; versions (unless they turn out
to be erroneous);
if the &GAP; developers find that some piece of minor, but documented
functionality is an insurmountable obstacle to important developments,
they may make the smallest possible incompatible change to the functionality
at the time of a major release.
However, in any such case it will be announced clearly in the &GAP; Forum
what has been changed and why.
<P/>
So on the one hand, the developers of &GAP; want to keep the freedom
of changing undocumented &GAP; code.
On the other hand, users may be interested in using undocumented
variables.
<P/>
In this case, whenever you write &GAP; code involving undocumented
variables,
and want to make sure that this code will work in future versions of &GAP;,
you may ask at <Email>support@gap-system.org</Email> for documentation
about the variables in question.
The &GAP; developers then decide whether these variables shall be
documented or not, and if yes, what the definitions shall be.
<P/>
In the former case, the new documentation is added to the &GAP; manual,
this means that from then on, this definition is protected against
changes.
<P/>
In the latter case (which may occur for example if the variables
in question are still experimental), you may add the current
values of these variables to your private code if you want to
be sure that nothing will be broken later due to changes in &GAP;.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  helpintf.tex              GAP documentation              Frank Lübeck -->
<!-- %% -->
<!-- %H  @(#)<M>Id: helpintf.tex,v 4.8 2003/02/19 09:03:52 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<!-- %%  This file describes the interface between the GAP help system and the -->
<!-- %%  actual documents. -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Interface to the GAP Help System">
<Heading>Interface to the GAP Help System</Heading>

In this chapter we describe which  information the help system needs about a
manual book and  how to tell it this information.  The code which implements
this interface can be found in <F>lib/helpbase.gi</F>.
<P/>
If you are intending to use a documentation format that is already  used  by
some other help book you probably don't need  to  know  anything  from  this
chapter. However, if you want to create a new format and make  it  available
to &GAP; then hopefully you will find the necessary information here.
<P/>
The basic idea of the  help  system  is  as  follows:  One  tells  &GAP;  a
directory which contains a file <F>manual.six</F>,
see&nbsp;<Ref Sect="Installing and Removing a Help Book"/>.
When the &GAP; help is asked something about this book  it  reads  in  some
basic information from the file <F>manual.six</F>:
strings like section  headers,
function names, and index  entries  to  be  searched  by  the  online  help;
information about the available formats of this book like text,  html,  dvi,
and pdf;  the  actual  files  containing  the  documentation,  corresponding
section numbers, and page numbers: and so on.
See&nbsp;<Ref Sect="The manual.six File"/>  for
a description of the format of the <F>manual.six</F> file.
<P/>
It  turns  out  that there  is  almost  no  restriction  on  the  format  of
the  <F>manual.six</F>  file,   except  that  it  must  provide   a  string,  say
<C>"myownformat"</C> which  identifies the  format of the  help book.  Then the
basic actions  on a help  book are delegated by  the help system  to handler
functions stored in a  record <C>HELP_BOOK_HANDLER.myownformat</C>.
See&nbsp;<Ref Sect="The Help Book Handler"/> for  information  which  functions must  be  provided by  the
handler and what they  are supposed to do. The main work  to teach &GAP; to
use a new document format is to write these handler functions and to produce
an appropriate <F>manual.six</F> file.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Installing and Removing a Help Book">
<Heading>Installing and Removing a Help Book</Heading>

<ManSection>
<Func Name="HELP_ADD_BOOK" Arg="short, long, dir"/>

<Description>
This command tells &GAP; that in directory <A>dir</A> (given as either a  string
describing   the   path   relative   to   the    &GAP;    root    directory
<C>GAPInfo.RootPaths[1]</C> or as directory object) contains the basic information
about a help book. The string <A>short</A> is used as  an  identifying  name  for
that book  by  the  online  help.  The  string  <A>long</A>  should  be  a  short
explanation of the content of the book. Both strings together should  easily
fit on a line, since they are displayed with <C>?books</C>.
<P/>
It is possible to reinstall a book with different strings  <A>short</A>,  <A>long</A>;
(for example, documentation of a not-loaded &GAP; package indicates this in
the string <A>short</A> and if you later load the package,  &GAP;  quietly
changes the string <A>short</A> as it reinstalls its documentation).
<P/>
The only condition necessary to make the installation of a book  <E>valid</E>  is
that the directory <A>dir</A> must contain a file <F>manual.six</F>. The next  section
explains how this file must look.
</Description>
</ManSection>

<ManSection>
<Func Name="HELP_REMOVE_BOOK" Arg="short"/>

<Description>
This command tells &GAP; not to use the help book with identifying name <A>short</A>
any more. The book can be re-installed using <Ref Func="HELP_ADD_BOOK" />. <P/>

</Description>
</ManSection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The manual.six File">
<Heading>The manual.six File</Heading>

If a <F>manual.six</F> file for a help book is not in the format of the
<F>gapmacro.tex</F> macros, explained in the document 
<Q>The gapmacro.tex Manual Format</Q> (see the file 
<F>gap4r5/doc/gapmacrodoc.pdf</F> from the tools archive 
<C>etc/tools.tar.gz</C> which should be unpacked using the script 
<F>etc/install-tools.sh</F>), the first non-empty line of 
<F>manual.six</F> must be of the form
<P/>
<C>#SIXFORMAT</C> <A>myownformat</A>
<P/>
where <A>myownformat</A> is an identifying string for this format.
The reading of
the  (remainder  of  the)  file  is   then   delegated   to   the   function
<C>HELP_BOOK_HANDLER.<A>myownformat</A>.ReadSix</C> which must exist.
Thus  there  are
no further regulations for the format of the <F>manual.six</F> file,  other  that
what you yourself impose. If such a line is missing then it is assumed  that
the <F>manual.six</F> file complies with the <F>gapmacro.tex</F> documentation  format
which is the <C>default</C> format.
<P/>
Section <Ref Sect="The Help Book Handler"/> explains how the return value of
<C>HELP_BOOK_HANDLER.<A>myownformat</A>.ReadSix</C> should look like and which further
function should be contained in <C>HELP_BOOK_HANDLER.<A>myownformat</A></C>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Help Book Handler">
<Heading>The Help Book Handler</Heading>

<Index>document formats!for help books</Index>
For  each  document  format   <A>myownformat</A>   there   must   be   a   record
<C>HELP_BOOK_HANDLER.<A>myownformat</A></C> of functions with the following names  and
functionality.
<P/>
An implementation example  of  such  a  set  of  handler  functions  is  the
<C>default</C> format, which is the  format  name  used  for  the  <F>gapmacro.tex</F>
documentation format, and this is contained in the file <F>lib/helpdef.gi</F>.
<P/>
The package &GAPDoc; (see Chapter&nbsp;<Ref Chap="Introduction and Example" BookName="gapdoc"/>)
also defines a format (as it should) which is called: <C>GapDocGAP</C> (the  case
<E>is</E> significant).
<P/>
As you can see by the above two examples, the name for a document format can
be anything, but it should be in some way meaningful.
<P/>
<List>
<Mark>
<C>ReadSix( <A>stream</A> )</C></Mark>
<Item>
  For an input text stream <A>stream</A> to a <F>manual.six</F> file,
  this must return a record <A>info</A> which has at least the following two
  components:
  <C>bookname</C> which is the short identifying  name  of  the  help  book,  and
  <C>entries</C>. Here <A>info</A><C>.entries</C> must be a list with one entry per  search
  string (which can be a section header,  function  name,  index  entry,  or
  whatever seems sensible to be searched  for  matching  a  help  query).  A
  <E>match</E> for the &GAP; help is a pair (<A>info</A>, <A>i</A>) where <A>i</A> refers to an
  index for the list <A>info</A><C>.entries</C> and  this  corresponds  to  a  certain
  position in the document. There is one further regulation for  the  format
  of the entries of <A>info</A><C>.entries</C>. They  must  be  lists  and  the  first
  element of such a list must be a string which is  printed  by  &GAP;  for
  example when  several  matches  are  found  for  a  query  (so  it  should
  essentially be the string which is searched for the match, except that  it
  may contain upper and lower case letters or some  markup).  There  may  be
  other components in <A>info</A> which are needed by the  functions  below,  but
  their names and formats are  not  prescribed.  The  <A>stream</A>  argument  is
  typically generated using <Ref Func="InputTextFile"/>, e.g.
<P/>
<Example><![CDATA[
gap> dirs := DirectoriesLibrary( "doc/ref" );;
gap> file := Filename( dirs, "manual.six" );;
gap> stream := InputTextFile( file );;
]]></Example>
</Item>
<Mark><C>ShowChapters( <A>info</A> )</C> </Mark>
<Item>
  This must return a text string or list of text lines  which  contains  the
  chapter headers of the book <A>info</A><C>.bookname</C>.
</Item>
<Mark><C>ShowSection( <A>info</A> )</C> </Mark>
<Item>
  This must return  a text string or  list of text lines  which contains the
  section (and chapter) headers of the book <A>info</A><C>.bookname</C>.
</Item>
<Mark><C>SearchMatches( <A>info</A>, <A>topic</A>, <A>frombegin</A> )</C> </Mark>
<Item>
  This  function must  return  a  list of  indices  of <A>info</A><C>.entries</C>  for
  entries which  match the search  string <A>topic</A>. If <A>frombegin</A>  is <K>true</K>
  then  those parts  of  <A>topic</A> which  are separated  by  spaces should  be
  considered  as  the  beginnings  of  words  to  decide  the  matching.  It
  <A>frombegin</A> is <K>false</K>, a substring search should be performed. The string
  <A>topic</A>  can be  assumed to  be already  normalized (transformed  to lower
  case, and whitespace normalized). The function must return a list with two
  entries <C>[exact,  match]</C> where <C>exact</C> is  the list of indices  for exact
  matches and <C>match</C> a list of indices of the remaining matches.
</Item>
<Mark><C>MatchPrevChap( <A>info</A>, <A>i</A> )</C> </Mark>
<Item>
  This should return  the match [<A>info</A>, <C>j</C>] which points  to the beginning
  of  the  chapter  containing  match [<A>info</A>,  <A>i</A>],  respectively  to  the
  beginning  of  the  previous  chapter  if [<A>info</A>,  <A>i</A>]  is  already  the
  beginning of a chapter. (Corresponds to <C>?&lt;&lt;</C>.)
</Item>
<Mark><C>MatchNextChap( <A>info</A>, <A>i</A> )</C> </Mark>
<Item>
  Like the previous function except that it should return the match for  the
  beginning of the next chapter. (Corresponds to <C>?>></C>.)
</Item>
<Mark><C>MatchPrev( <A>info</A>, <A>i</A> )</C> </Mark>
<Item>
  This should return the previous section (or  appropriate  portion  of  the
  document). (Corresponds to <C>?&lt;</C>.)
</Item>
<Mark><C>MatchNext( <A>info</A>, <A>i</A> )</C> </Mark>
<Item>
  Like the previous function except that it should return the  next  section
  (or appropriate portion of the document). (Corresponds to <C>?></C>.)
</Item>
<Mark><C>HelpData( <A>info</A>, <A>i</A>, <A>type</A> )</C> </Mark>
<Item>
  This returns for match [<A>info</A>, <A>i</A>] some data whose format depends on the
  string <A>type</A>,  or <K>fail</K> if these  data are not available.  The values of
  <A>type</A> which currently must be handled and the corresponding result format
  are described in the list below.
</Item>
</List>
<P/>
The <C>HELP_BOOK_HANDLER.<A>myownformat</A>.HelpData</C> function must recognize the
following values of the <A>type</A> argument.
<P/>
<List>
<Mark>
<C>"text"</C> </Mark>
<Item>
  This must return a corresponding text string in a format which can be fed
  into the <C>Pager</C>, see&nbsp;<Ref Func="Pager"/>. 
</Item>
<Mark><C>"url"</C> </Mark>
<Item>
  If the help book is available in HTML  format this must return an URL as a
  string (Probably a <C>file://</C> URL containing  a label for the  exact start
  position in that file). Otherwise it returns <K>fail</K>.
</Item>
<Mark><C>"dvi"</C> </Mark>
<Item>
  If the help book  is available in dvi-format this must  return a record of
  form  <C>rec( file := <A>filename</A>, page := <A>pagenumber</A> )</C>.
  Otherwise it returns <K>fail</K>.
</Item>
<Mark><C>"pdf"</C> </Mark>
<Item>
  Same as case <C>"dvi"</C>, but for the corresponding pdf-file.
</Item>
<Mark><C>"secnr"</C> </Mark>
<Item>
  This  must return  a  pair  like <C>[[3,3,1], "3.3.1"]</C>  which gives  the
  section  number  as  chapter  number, section  number,  subsection  number
  triple  and a  corresponding  string  (a chapter  itself  is encoded  like
  <C>[[4,0,0], "4."]</C>). Useful for cross-referencing between help books.
</Item>
</List>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Introducing new Viewer for the Online Help">
<Heading>Introducing new Viewer for the Online Help</Heading>

To introduce a new viewer for the online help, 
one should extend the global record <Ref Var="HELP_VIEWER_INFO"/>,
the structure of which is explained below.

<ManSection>
<Var Name="HELP_VIEWER_INFO"/>

<Description>
The record <Ref Var="HELP_VIEWER_INFO"/> contains one component for each
help viewer. Each such component is a record with two components:
<C>.type</C> and <C>.show</C>.
<P/>
The component <C>.type</C> refers to one of the <C>type</C>s recognized 
by the <C>HelpData</C> handler function explained in the previous 
section (currently one of <C>"text"</C>, <C>"url"</C>, <C>"dvi"</C>, 
or <C>"pdf"</C>).
<P/>
The component <C>.show</C> is a function which gets as input the result
of a corresponding <C>HelpData</C> handler call, if it was not <K>fail</K>. 
This function has to perform the actual display of the data. (E.g., by 
calling a function like <Ref Func="Pager"/> or by starting up an external 
viewer program.)
</Description>
</ManSection>


</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  foa.tex                   GAP documentation            Heiko Theißen -->
<!-- %% -->
<!-- %H  @(#)<M>Id: foa.tex,v 4.20 2002/10/09 12:32:13 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<Chapter Label="Function-Operation-Attribute Triples">
<Heading>Function-Operation-Attribute Triples</Heading>

&GAP;  is eager  to maintain information  that  it has gathered about an
object, possibly by lengthy  calculations. The most  important mechanism
for information maintenance  is the  automatic  storage and look-up  that
takes  place  for  <E>attributes</E>; and    this   was already mentioned   in
section&nbsp;<Ref Sect="Attributes" BookName="tut"/>.
In   this  chapter  we  will
describe further mechanisms that  allow storage of  results that  are not
values of attributes.
<P/>
<Index>FOA triples</Index>
The  idea which is   common to all  sections  is that certain operations,
which are  not themselves attributes, have  an attribute  associated with
them. To automatically delegate tasks to the  attribute, &GAP; knows, in
addition  to  the <E>operation</E>  and  the  <E>attributes</E>   also a
<E>function</E>, which  is  <Q>wrapped around</Q> the  other  two. This <Q>wrapper
function</Q>  is called by    the user and    decides whether to  call  the
operation    or  the    attribute     or  possibly     both.   The  whole
<E>f</E>unction-<E>o</E>peration-<E>a</E>ttribute triple (or <E>FOA triple</E>)  is set up by
a single   &GAP; command which  writes the  wrapper function and already
installs  some methods,  e.g.,  for the attribute  to   fall back on  the
operation. The idea  is then that subsequent  methods, which  perform the
actual computation, are installed   only for the operation,   whereas the
wrapper function remains unaltered, and  in general no additional methods
for the attribute are required either.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Key Dependent Operations">
<Heading>Key Dependent Operations</Heading>

<ManSection>
<Func Name="KeyDependentOperation"
 Arg='name, dom-req, key-req, key-test'/>

<Description>
There are several functions that require as first argument a domain,
e.g., a  group, and as second argument something much simpler,
e.g., a prime.
<Ref Func="SylowSubgroup"/> is an example.
Since its value depends on two arguments, it cannot be an attribute,
yet one would like to store the Sylow subgroups once they have been
computed.
<P/>
The idea is to provide an attribute of the group,
called <C>ComputedSylowSubgroups</C>,
and to store the groups in this list.
The name implies that the value of this attribute may change in the
course of a &GAP; session,
whenever a newly-computed Sylow subgroup is put into the list.
Therefore, this is a <E>mutable attribute</E>
(see <Ref Sect="Creating Attributes and Properties"/>).
The list contains primes in each bound odd position and a corresponding
Sylow subgroup in the following even position.
More precisely, if
<C><A>p</A> = ComputedSylowSubgroups( <A>G</A> )[ <A>even</A> - 1 ]</C>
then <C>ComputedSylowSubgroups( <A>G</A> )[ <A>even</A> ]</C> holds the
value of <C>SylowSubgroup( <A>G</A>, <A>p</A> )</C>.
The pairs are sorted in increasing order of <A>p</A>,
in particular at most one Sylow <A>p</A> subgroup of <A>G</A> is stored
for each prime <A>p</A>.
This attribute value is maintained by the function
<Ref Func="SylowSubgroup"/>,
which calls the operation <C>SylowSubgroupOp( <A>G</A>, <A>p</A> )</C>
to do the real work, if the prime <A>p</A> cannot be found in the list.
So methods that do the real work should be installed
for <C>SylowSubgroupOp</C>
and not for <Ref Func="SylowSubgroup"/>.
<P/>
The same mechanism works for other functions as well,
e.g., for <Ref Func="PCore"/>,
but also for <Ref Func="HallSubgroup"/>,
where the second argument is not a prime but a set of primes.
<P/>
<Ref Func="KeyDependentOperation"/> declares the two operations and the
attribute as described above,
with names <A>name</A>, <A>name</A><C>Op</C>,
and <C>Computed</C><A>name</A><C>s</C>.
<A>dom-req</A> and <A>key-req</A> specify the required filters for the
first and second argument of the operation <A>name</A><C>Op</C>,
which are needed to create this operation with
<Ref Func="DeclareOperation"/>.
<A>dom-req</A> is also the required filter for the corresponding
attribute <C>Computed</C><A>name</A><C>s</C>.
The fourth argument <A>key-test</A> is in general a function to which the
second argument
<A>info</A> of <C><A>name</A>( <A>D</A>, <A>info</A> )</C> will be
passed.
This function can perform tests on <A>info</A>,
and raise an error if appropriate.
<P/>
For example, to set up the three objects
<Ref Func="SylowSubgroup"/>,
<C>SylowSubgroupOp</C>,
<C>ComputedSylowSubgroups</C> together,
the declaration file <F>lib/grp.gd</F> contains the following line of
code.
<Log><![CDATA[
KeyDependentOperation( "SylowSubgroup", IsGroup, IsPosInt, "prime" );
]]></Log>
In this example, <A>key-test</A> has the value <C>"prime"</C>,
which is silently replaced by a function that tests whether its argument
is a prime.
<P/>
<Example><![CDATA[
gap> s4 := Group((1,2,3,4),(1,2));;
gap> SylowSubgroup( s4, 5 );;  ComputedSylowSubgroups( s4 );
[ 5, Group(()) ]
gap> SylowSubgroup( s4, 2 );;  ComputedSylowSubgroups( s4 );
[ 2, Group([ (3,4), (1,4)(2,3), (1,3)(2,4) ]), 5, Group(()) ]
]]></Example>
<P/>
<Log><![CDATA[
gap> SylowSubgroup( s4, 6 );
Error, SylowSubgroup: <p> must be a prime called from
<compiled or corrupted call value>  called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
]]></Log>
<P/>
Thus the prime test need not be repeated in the methods for the operation
<C>SylowSubgroupOp</C> (which are installed to do
the real work).
Note that no methods need be installed for
<Ref Func="SylowSubgroup"/> and
<C>ComputedSylowSubgroups</C>.
If a method is installed with <Ref Func="InstallMethod"/>
for a wrapper operation such as
<Ref Func="SylowSubgroup"/> then a warning is signalled
provided the <Ref InfoClass="InfoWarning"/> level
is at least <C>1</C>.
(Use <Ref Func="InstallMethod"/> in order to suppress the
warning.)
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="In Parent Attributes">
<Heading>In Parent Attributes</Heading>

<ManSection>
<Func Name="InParentFOA" Arg='name, super, sub, AorP'/>

<Description>
This section describes how you can add  new <Q>in parent attributes</Q>
(see&nbsp;<Ref Sect="Constructing Subdomains"/>
and <Ref Sect="Parents"/>).
As an example, we describe how 
<Ref Func="Index" Label="for a group and its subgroup"/>
and its related functions are implemented.
<P/>
There are two operations 
<Ref Func="Index" Label="for a group and its subgroup"/> and
<C>IndexOp</C>,
and an attribute <C>IndexInParent</C>.
They are created together as shown below,
and after they have been created,
methods need be installed only for <C>IndexOp</C>.
In the creation process, <C>IndexInParent</C>
already gets one default method installed
(in addition to the usual system getter of each attribute,
see&nbsp;<Ref Sect="Attributes"/>),
namely <C>D -> IndexOp( Parent( D ), D )</C>.
<P/>
The operation <Ref Func="Index" Label="for a group and its subgroup"/> 
proceeds as follows.
<List>
<Item>
  If it is called with the two arguments <A>super</A> and <A>sub</A>,
  and if <C>HasParent( <A>sub</A> )</C> and
  <C>IsIdenticalObj( <A>super</A>, Parent( <A>sub</A> ) )</C>
  are <K>true</K>, <C>IndexInParent</C> is called
  with argument <A>sub</A>, and the result is returned.
</Item>
<Item>
  Otherwise, <C>IndexOp</C> is called with the same arguments that
  <Ref Func="Index" Label="for a group and its subgroup"/> was called with,
  and the result is returned.
</Item>
</List>
(Note that it is in principle possible to install even
<Ref Func="Index" Label="for a group and its subgroup"/> 
and <C>IndexOp</C> methods
for a number of arguments different from two,
with <Ref Func="InstallOtherMethod"/>,
see <Ref Sect="Creating Attributes and Properties"/>).
<P/>
The call of <Ref Func="InParentFOA"/> declares the operations and the
attribute as described above,
with names <A>name</A>, <A>name</A><C>Op</C>,
and <A>name</A><C>InParent</C>.
<A>super-req</A> and <A>sub-req</A> specify the required filters for the
first and second argument of the operation <A>name</A><C>Op</C>,
which are needed to create this operation with
<Ref Func="DeclareOperation"/>.
<A>sub-req</A> is also the required filter for the corresponding
attribute <A>name</A><C>InParent</C>;
note that <Ref Func="HasParent"/> is <E>not</E> required
for the argument <A>U</A> of <A>name</A><C>InParent</C>,
because even without a parent stored,
<C>Parent( <A>U</A> )</C> is legal, meaning <A>U</A> itself
(see&nbsp;<Ref Sect="Parents"/>).
The fourth argument must be <Ref Func="DeclareProperty"/>
if <A>name</A><C>InParent</C> takes only boolean values (for example in
the case <C>IsNormalInParent</C>),
and <Ref Func="DeclareAttribute"/> otherwise.
<P/>
For example, to set up the three objects
<Ref Func="Index" Label="for a group and its subgroup"/>, <C>IndexOp</C>,
and <C>IndexInParent</C> together,
the declaration file <F>lib/domain.gd</F> contains the following line of
code.
<Log><![CDATA[
InParentFOA( "Index", IsGroup, IsGroup, DeclareAttribute );
]]></Log>
<P/>
Note that no methods need be installed for
<Ref Func="Index" Label="for a group and its subgroup"/> 
and <C>IndexInParent</C>.
</Description>
</ManSection>


</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operation Functions">
<Heading>Operation Functions</Heading>

<Index Key="ExternalSet" Subkey="computing orbits"><C>ExternalSet</C></Index>
<Index Key="G-sets" Subkey="computing orbits"><M>G</M>-sets</Index>
<Index Key="Orbits" Subkey="as attributes for external sets"><C>Orbits</C></Index>
Chapter&nbsp;<Ref Chap="Group Actions"/>
and, in particular,
the Section&nbsp;<Ref Sect="About Group Actions"/>
<!-- % currently in <C>abattoir/group.tex</C>, <C>abattoir/permgrp.tex</C>, -->
<!-- % <C>abattoir/solvgrp.tex</C> ... -->
explain that certain operations such as <Ref Sect="Orbits"/>),
besides their usual usage with arguments <A>G</A>, <A>D</A>, and <A>opr</A>,
can also be applied to an external set (<M>G</M>-set),
in which case they can be interpreted as attributes.
Moreover, they can also be interpreted as attributes for permutation
groups, meaning the natural action on the set of its moved points.
<P/>
The definition of <Ref Sect="Orbits"/> says that a method
should be a function
with arguments <A>G</A>, <A>D</A>, <A>gens</A>, <A>oprs</A>, and <A>opr</A>,
as in the case of the operation <Ref Func="ExternalSet"/>
when specified via <A>gens</A> and <A>oprs</A>
(see&nbsp;<Ref Sect="External Sets"/>).
All other syntax variants allowed for <Ref Sect="Orbits"/>
(e.g., leaving out <A>gens</A> and <A>oprs</A>)
are handled by default methods.
<P/>
The default methods for <Ref Sect="Orbits"/> support the
following behaviour.
<Enum>
<Item>
    If the only argument is an external set <A>xset</A> and the attribute
    tester <C>HasOrbits( <A>xset</A> )</C> returns <K>true</K>,
    the stored value of that attribute is returned.
</Item>
<Item>
    If the only argument is an external set <A>xset</A> and the attribute
    value is not known,
    the default arguments are obtained from the data of <A>xset</A>.
</Item>
<Item>
    If <A>gens</A> and <A>oprs</A> are not specified,
    <A>gens</A> is set to <C>Pcgs( <A>G</A> )</C>
    if <C>CanEasilyComputePcgs( <A>G</A> )</C>
    is <K>true</K>, and to <C>GeneratorsOfGroup( <A>G</A> )</C> otherwise;
    <A>oprs</A> is set to <A>gens</A>.
</Item>
<Item>
    The default value of <A>opr</A> is <Ref Func="OnPoints"/>.
</Item>
<Item>
    In the case of an operation of a permutation group <A>G</A>
    on <C>MovedPoints( <A>G</A> )</C> via
    <Ref Func="OnPoints"/>,
    if the attribute tester <C>HasOrbits( <A>G</A> )</C> returns <K>true</K>,
    the stored attribute value is returned.
</Item>
<Item>
    The operation is called as
    <C><A>result</A>:= Orbits( <A>G</A>, <A>D</A>, <A>gens</A>,
    <A>oprs</A>, <A>opr</A> )</C>.
</Item>
<Item>
    In the case of an external set <A>xset</A> or a permutation group
    <A>G</A> in its natural action,
    the attribute setter is called to store <A>result</A>.
</Item>
<Item>
    <A>result</A> is returned.
</Item>
</Enum>
<P/>
The declaration of operations that match the above pattern is done
as follows.

<ManSection>
<Func Name="OrbitsishOperation" Arg='name, reqs, usetype, AorP'/>

<Description>
declares an attribute <C>op</C>, with name <A>name</A>.
The second argument <A>reqs</A> specifies the list of required filters
for the usual (five-argument) methods that do the real work.
<P/>
If the third argument <A>usetype</A> is <K>true</K>,
the function call <C>op( xset )</C> will
&ndash;if the value of <C>op</C> for <C>xset</C> is not yet known&ndash;
delegate to the five-argument call of <C>op</C> with second argument
<C>xset</C> rather than with <C>D</C>.
This allows certain methods for <C>op</C> to make use of the type of
<C>xset</C>, in which the types of the external subsets of <C>xset</C>
and of the external orbits in <C>xset</C> are stored.
(This is used to avoid repeated calls of
<Ref Func="NewType"/> in functions like
<C>ExternalOrbits( xset )</C>,
which call <C>ExternalOrbit( xset, pnt )</C> for several values of
<C>pnt</C>.)
<P/>
For property testing functions such as
<Ref Func="IsTransitive" Label="for a group, an action domain, etc."/>,
the fourth argument <A>AorP</A> must be
<Ref Func="NewProperty"/>,
otherwise it must be <Ref Func="NewAttribute"/>;
in the former case, a property is returned, in the latter case an
attribute that is not a property.
<P/>
For example, to set up the operation <Ref Func="Orbits"/>,
the declaration file <F>lib/oprt.gd</F> contains the following line of
code:
<Log><![CDATA[
OrbitsishOperation( "Orbits", OrbitsishReq, false, NewAttribute );
]]></Log>
The global variable <C>OrbitsishReq</C> contains the standard
requirements
<Log><![CDATA[
OrbitsishReq := [ IsGroup, IsList,
                  IsList,
                  IsList,
                  IsFunction ];
]]></Log>
which are usually entered in calls to <Ref Func="OrbitsishOperation"/>.
<P/>
The new operation, e.g., <Ref Func="Orbits"/>,
can be called either as <C>Orbits( <A>xset</A> )</C> for an external set
<A>xset</A>, or as <C>Orbits( <A>G</A> )</C> for a permutation group
<A>G</A>, meaning the orbits on the moved
points of <A>G</A> via <Ref Func="OnPoints"/>,
or as
<P/>
<C>Orbits( <A>G</A>, <A>Omega</A>[, <A>gens</A>, <A>acts</A>][,
<A>act</A>] )</C>,
<P/>
with a group <A>G</A>, a domain or list <A>Omega</A>,
generators <A>gens</A> of <A>G</A>, and corresponding elements
<A>acts</A> that act on <A>Omega</A> via the function <A>act</A>;
the default of <A>gens</A> and <A>acts</A> is a list of group generators
of <A>G</A>,
the default of <A>act</A> is <Ref Func="OnPoints"/>.
<P/>
Only methods for the five-argument version need to be installed for
doing the real work.
(And of course methods for one argument in case one wants to define
a new meaning of the attribute.)
</Description>
</ManSection>

<ManSection>
<Func Name="OrbitishFO" Arg='name, reqs, famrel, usetype, realenum'/>

<Description>
is used to create operations like <Ref Func="Orbit"/>.
This function is analogous to <Ref Func="OrbitsishOperation"/>,
but for operations <A>orbish</A> like
<C>Orbit( <A>G</A>, <A>Omega</A>, <A>pnt</A> )</C>.
Since the return values of these operations depend on the additional
argument <A>pnt</A>, there is no associated attribute.
<P/>
The call of <Ref Func="OrbitishFO"/> declares a wrapper function and its
operation, with names <A>name</A> and <A>name</A><C>Op</C>.
<P/>
The second argument <A>reqs</A> specifies the list of required filters
for the operation <A>name</A><C>Op</C>.
<P/>
The third argument <A>famrel</A> is used to test the family relation
between the second and third argument of
<C><A>name</A>( <A>G</A>, <A>D</A>, <A>pnt</A> )</C>.
For example, <A>famrel</A> is <C>IsCollsElms</C> in the case of
<Ref Func="Orbit"/> because <A>pnt</A> must be an element
of <A>D</A>.
Similarly, in the call <C>Blocks( <A>G</A>, <A>D</A>, <A>seed</A> )</C>,
<A>seed</A> must be a subset of <A>D</A>,
and the family relation must be
<Ref Func="IsIdenticalObj"/>.
<P/>
The fourth argument <A>usetype</A> serves the same purpose as in the case
of <Ref Func="OrbitsishOperation"/>.
<A>usetype</A> can also be an attribute, such as
<C>BlocksAttr</C> or <C>MaximalBlocksAttr</C>.
In this case, if only one of the two arguments <A>Omega</A> and
<A>pnt</A> is given,
blocks with no seed are computed, they are stored as attribute values
according to the rules of <Ref Func="OrbitsishOperation"/>.
<P/>
If the 5th argument is set to <K>true</K>, the action for an external set
should use the enumerator, otherwise it uses the
<Ref Func="HomeEnumerator"/> value. This will
make a difference for external orbits as part of a larger domain.
</Description>
</ManSection>


<Subsection Label="Example: Orbit and OrbitOp">
<Heading>Example: Orbit and OrbitOp</Heading>

For example, to setup the function <Ref Func="Orbit"/>
and its operation <C>OrbitOp</C>,
the declaration file <F>lib/oprt.gd</F> contains the following line of code:
<Log><![CDATA[
OrbitishFO( "Orbit", OrbitishReq, IsCollsElms, false, false );
]]></Log>
The variable <C>OrbitishReq</C> contains the standard requirements
<Log><![CDATA[
OrbitishReq  := [ IsGroup, IsList, IsObject,
		  IsList,
		  IsList,
		  IsFunction ];
]]></Log>
which are usually entered in calls to <Ref Func="OrbitishFO"/>.
<P/>
The relation test via <A>famrel</A> is used to provide a uniform
construction of the wrapper functions created by
<Ref Func="OrbitishFO"/>,
in spite of the different syntax of the specific functions.
For example, <Ref Func="Orbit"/> admits the calls
<C>Orbit( <A>G</A>, <A>D</A>, <A>pnt</A>, <A>opr</A> )</C>
and <C>Orbit( <A>G</A>, <A>pnt</A>, <A>opr</A> )</C>,
i.e., the second argument <A>D</A> may be omitted;
<Ref Func="Blocks" Label="for a group, an action domain, etc."/>
admits the calls
<C>Blocks( <A>G</A>, <A>D</A>, <A>seed</A>, <A>opr</A> )</C> and
<C>Blocks( <A>G</A>, <A>D</A>, <A>opr</A> )</C>,
i.e., the third argument may be omitted.
The translation to the appropriate call of <C>OrbitOp</C> or
<C>BlocksOp</C>,
for either operation with five or six arguments, 
is handled via <A>famrel</A>.
<P/>
As a  consequence, there must not only be methods for <C>OrbitOp</C>
with the six arguments corresponding to <C>OrbitishReq</C>,
but also methods for only five arguments (i.e., without <A>D</A>).
Plenty of examples are contained in the implementation file
<F>lib/oprt.gi</F>.
<P/>
In order to handle a few special cases
(currently <Ref Func="Blocks" Label="for a group, an action domain, etc."/>
and
<Ref Func="MaximalBlocks" Label="for a group, an action domain, etc."/>),
also the following form of <Ref Func="OrbitishFO"/> is supported.
<P/>
<C>OrbitishFO( <A>name</A>, <A>reqs</A>, <A>famrel</A>, <A>attr</A> )</C>
<P/>
The functions in question depend upon an argument <A>seed</A>,
so they cannot be regarded as attributes.
However, they are most often called without giving <A>seed</A>,
meaning <Q>choose any minimal resp. maximal block system</Q>.
In this case, the result can be stored as the value of the attribute
<A>attr</A> that was entered as fourth argument of
<Ref Func="OrbitishFO"/>.
This attribute is considered by a call
<C>Blocks( <A>G</A>, <A>D</A>, <A>opr</A> )</C>
(i.e., without <A>seed</A>) in the same way as
<Ref Func="Orbits"/> considers <C>OrbitsAttr</C>.
<P/>
To set this up,
the declaration file <F>lib/oprt.gd</F> contains the following lines:
<Log><![CDATA[
DeclareAttribute( "BlocksAttr", IsExternalSet );
OrbitishFO( "Blocks",
    [ IsGroup, IsList, IsList,
      IsList,
      IsList,
      IsFunction ], IsIdenticalObj, BlocksAttr, true );
]]></Log>
And this extraordinary FOA triple works as follows:
<Example><![CDATA[
gap> s4 := Group((1,2,3,4),(1,2));;
gap> Blocks( s4, MovedPoints(s4), [1,2] );
[ [ 1, 2, 3, 4 ] ]
gap> Tester( BlocksAttr )( s4 );
false
gap> Blocks( s4, MovedPoints(s4) );       
[ [ 1, 2, 3, 4 ] ]
gap> Tester( BlocksAttr )( s4 );  BlocksAttr( s4 );
true
[ [ 1, 2, 3, 4 ] ]
]]></Example>

</Subsection>
</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  weakptr.tex              GAP documentation               Steve Linton -->
<!-- %% -->
<!-- %H  @(#)<M>Id: weakptr.tex,v 4.13 2006/06/28 15:32:35 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  The GAP Project -->
<!-- %% -->
<!-- %%  This file describes the use of weak pointers -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Weak Pointers">
<Heading>Weak Pointers</Heading>

This chapter describes the use of the kernel feature of <E>weak pointers</E>.
This feature is primarily intended for use only in &GAP; internals, and
should be used extremely carefully otherwise.
<P/>
The GASMAN garbage collector is the part of the kernel that manages memory in
the users workspace.  It will  normally only reclaim  the storage used by  an
object when the object cannot be reached as a subobject of any &GAP; variable,
or from any reference in the kernel.
We say that any link to object <M>a</M> from object <M>b</M>
<Q>keeps object <M>a</M> alive</Q>, as long as <M>b</M> is alive.
It is occasionally convenient, however, to have a link to an object
which <E>does not keep it alive</E>, and this is a weak pointer.
The most common use is in caches, and similar structures,
where it is only necessary to remember how to solve problem <M>x</M>
as long as some other link to <M>x</M> exists.
<P/>
The  following section <Ref Sect="Weak Pointer Objects"/> describes
the semantics of the objects that contain weak pointers.
Following sections describe the functions available to manipulate them.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Weak Pointer Objects">
<Heading>Weak Pointer Objects</Heading>

A <E>weak pointer object</E> is similar to a mutable plain list,
except that it does not keep its subobjects alive during a garbage collection.
From the &GAP; viewpoint this means that its entries may become unbound,
apparently spontaneously, at any time.
Considerable care is therefore needed in programming with such an object.


<ManSection>
<Func Name="WeakPointerObj" Arg="list"/>

<Description>
<Ref Func="WeakPointerObj"/> returns a weak pointer object which contains
the same subobjects as the list <A>list</A>,
that is it returns a <E>shallow</E> weak copy of <A>list</A>.
<P/>
<Example><![CDATA[
gap> w := WeakPointerObj( [ 1, , [2,3], fail, rec( a := 1) ] );
WeakPointerObj( [ 1, , [ 2, 3 ], fail, rec( a := 1 ) ] )
]]></Example>
<P/>
After some computations involving garbage collections
(but not necessarily in the <E>first</E> garbage collection after
the above assignment),
&GAP; will notice that the list and the record stored in <C>w</C>
are not referenced by other objects than <C>w</C>,
and that therefore these entries may disappear.
<P/>
<Log><![CDATA[
gap> GASMAN("collect");

... (perhaps more computations and garbage collections) ...

gap> GASMAN("collect");
gap> w;
WeakPointerObj( [ 1, , , fail ] )
]]></Log>
<P/>
Note that <C>w</C> has failed to keep its list and record subobjects alive
during the garbage collections.
Certain subobjects, such as small integers and elements of small finite
fields, are not stored in the workspace,
and so are not subject to garbage collection, while certain other objects,
such as the Boolean values, are always reachable from global variables
or the kernel and so are never garbage collected.
<P/>
Subobjects reachable without going through a weak pointer object do not
evaporate, as in:
<P/>
<Example><![CDATA[
gap> w := WeakPointerObj( [ 1, , , fail ] );
WeakPointerObj( [ 1, , , fail ] )
gap> l := [1,2,3];;
gap> w[1] := l;;
gap> w;
WeakPointerObj( [ [ 1, 2, 3 ], , , fail ] )
gap> GASMAN("collect");
gap> w;                
WeakPointerObj( [ [ 1, 2, 3 ], , , fail ] )
]]></Example>
<P/>
Note also that the global variables <C>last</C>, <C>last2</C> and <C>last3</C>
will keep things alive &ndash;this can be confusing when debugging.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Low Level Access Functions for Weak Pointer Objects">
<Heading>Low Level Access Functions for Weak Pointer Objects</Heading>

<Index>ElmWPObj</Index>
<ManSection>
<Func Name="SetElmWPObj" Arg="wp, pos, val"/>
<Func Name="UnbindElmWPObj" Arg="wp, pos"/>
<Func Name="ElmWPObj" Arg="wp, pos"/>
<Func Name="IsBoundElmWPObj" Arg="wp, pos"/>
<Func Name="LengthWPObj" Arg="wp"/>

<Description>
The functions <Ref Func="SetElmWPObj"/> and
<Ref Func="UnbindElmWPObj"/> set and unbind entries in a weak pointer object.
<P/>
The function <Ref Func="ElmWPObj"/> returns the element at position
<A>pos</A> of the weak pointer object <A>wp</A>, if there is one,
and <K>fail</K> otherwise.
A return value of <K>fail</K> can thus arise either because
(a) the value <K>fail</K> is stored at position <A>pos</A>, or
(b) no value is stored at position <A>pos</A>.
Since <K>fail</K> cannot vanish in a garbage collection, these two cases can
safely be distinguished by a <E>subsequent</E> call to
<Ref Func="IsBoundElmWPObj"/>,
which returns <K>true</K> if there is currently a value bound at position
<A>pos</A> of <A>wp</A> and <K>false</K> otherwise.
<P/>
Note that it is <E>not</E> safe to write:
<P/>
<C>if IsBoundElmWPObj(w,i) then x:= ElmWPObj(w,i); fi;</C>
<P/>
and treat <C>x</C> as reliably containing a value taken from <C>w</C>,
as a badly timed garbage collection could leave <C>x</C> containing
<K>fail</K>.
Instead use
<P/>
<C>x := ElmWPObj(w,i); if x &lt;> fail or IsBoundElmWPObj(w,i) then . . .</C>.
<P/>
Here is an example.
<P/>
<Example><![CDATA[
gap> w := WeakPointerObj( [ 1, , [2,3], fail, rec() ] );   
WeakPointerObj( [ 1, , [ 2, 3 ], fail, rec(  ) ] )
gap> SetElmWPObj(w,5,[]);
gap> w;
WeakPointerObj( [ 1, , [ 2, 3 ], fail, [  ] ] )
gap> UnbindElmWPObj(w,1);
gap> w;
WeakPointerObj( [ , , [ 2, 3 ], fail, [  ] ] )
gap> ElmWPObj(w,3);      
[ 2, 3 ]
gap> ElmWPObj(w,1);
fail
]]></Example>
<P/>
Now after some computations and garbage collections <M>\ldots</M>
<P/>
<Example><![CDATA[
gap> 2;;3;;4;;GASMAN("collect"); # clear last, last2, last3
]]></Example>
<P/>
<M>\ldots</M> we get the following.
<P/>
<Log><![CDATA[
gap> ElmWPObj(w,3);          
fail
gap> w;
WeakPointerObj( [ , , , fail ] )
gap> ElmWPObj(w,4);
fail
gap> IsBoundElmWPObj(w,3);
false
gap> IsBoundElmWPObj(w,4);
true
]]></Log>
</Description>
</ManSection>

</Section>

    
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Accessing Weak Pointer Objects as Lists">
<Heading>Accessing Weak Pointer Objects as Lists</Heading>

Weak pointer objects are members of <C>ListsFamily</C>
and the categories <Ref Func="IsList"/>
and <Ref Func="IsMutable"/>.
Methods based  on  the low-level functions in  the previous
section, are  installed for the list  access operations,  enabling them to be
used as lists.    However, it is  <E>not recommended</E>  that  these be used   in
programming. They   are  supplied mainly as   a convenience  for  interactive
working, and   may not be   safe, since functions  and methods  for lists may
assume that after <C>IsBound(w[i])</C> returns <K>true</K>,
access to <C>w[i]</C> is safe.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Copying Weak Pointer Objects">
<Heading>Copying Weak Pointer Objects</Heading>

A <Ref Func="ShallowCopy"/> method is installed,
which makes a new weak pointer object
containing the same objects as the original.
<P/>
It is possible to apply <Ref Func="StructuralCopy"/>
to a weak pointer object, obtaining
a new weak  pointer object containing copies of  the objects in the original. 
This <E>may not be safe</E> if a badly timed garbage collection occurs during
copying.
<P/>
Applying <Ref Func="Immutable"/> to a weak pointer object
produces an immutable plain
list containing immutable copies of the objects contained in the weak pointer
object. An immutable weak pointer object is a contradiction in terms.
 
</Section>
 
 
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The GASMAN Interface for Weak Pointer Objects">
<Heading>The GASMAN Interface for Weak Pointer Objects</Heading>

The key support for weak pointers is in the files <F>src/gasman.c</F> and
<F>src/gasman.h</F>.
This document assumes familiarity with the rest of the operation of GASMAN.
A kernel type (tnum) of bags which are intended to act as weak pointers to
their subobjects must meet three conditions.
Firstly, the marking function installed for that tnum must use
<C>MarkBagWeakly</C> for those subbags, rather than <C>MARK_BAG</C>.
Secondly, before any access to such a subbag, it must be checked with
<C>IS_WEAK_DEAD_BAG</C>.
If that returns <K>true</K>, then the subbag has evaporated in a recent garbage
collection and must not be accessed.
Typically the reference to it should be removed.
Thirdly, a <E>sweeping function</E> must be installed for that tnum
which copies the bag, removing all references to dead weakly held subbags.
<P/>
The files <F>src/weakptr.c</F> and <F>src/weakptr.h</F> use this interface
to support weak pointer objects.
Other objects with weak behaviour could be implemented in a similar way.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  stbchain.tex              GAP documentation            Heiko Theißen -->
<!-- %% -->
<!-- %H  @(#)<M>Id: stbchain.tex,v 4.18 2002/10/14 12:38:11 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<Chapter Label="More about Stabilizer Chains">
<Heading>More about Stabilizer Chains</Heading>

This  chapter contains some rather  technical complements to the material
handled in the chapters&nbsp;<Ref Chap="Permutations"/>
and <Ref Chap="Permutation Groups"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Generalized Conjugation Technique">
<Heading>Generalized Conjugation Technique</Heading>

The command <C>ConjugateGroup( <A>G</A>, <A>p</A> )</C>
(see&nbsp;<Ref Func="ConjugateGroup"/>)
for a  permutation  group  <A>G</A>  with  stabilizer  chain
equips its result also with a stabilizer chain, namely with the chain  of
<A>G</A> conjugate by <A>p</A>. Conjugating a stabilizer chain by a permutation <A>p</A>
means replacing all the points which appear in the <C>orbit</C> components  by
their images under <A>p</A> and replacing every permutation <A>g</A> which  appears
in a <C>labels</C> or <C>transversal</C> component  by  its  conjugate  <M>g^p</M>.  The
conjugate <M>g^p</M> acts on the mapped points  exactly  as  <A>g</A>  did  on  the
original points, i.e., <M>(pnt.p). g^p = (pnt.g).p</M>. Since the  entries  in
the <C>translabels</C> components are integers pointing to  positions  of  the
<C>labels</C> list, the <C>translabels</C> lists just have to be  permuted  by  <A>p</A>
for the conjugated stabilizer.
Then <C>generators</C> is reconstructed as
<C>labels{ genlabels }</C> and
<C>transversal{ orbit }</C> as
<C>labels{ translabels{ orbit } }</C>.
<P/>
<Index>generalized conjugation technique</Index>
This conjugation technique can be generalized. Instead of mapping  points
and  permutations  under  the  same  permutation  <A>p</A>,  it  is  sometimes
desirable (e.g., in the context of permutation  group  homomorphisms)  to
map the points with an arbitrary mapping <M>map</M> and the permutations  with
a homomorphism <M>hom</M> such that the compatibility of the actions is  still
valid:   <M>map(pnt).hom(g) = map(pnt.g)</M>.   (Of   course    the   ordinary
conjugation is a special case  of  this,  with   <M>map(pnt) = pnt.p</M>   and
<M>hom(g) = g^p</M>.)
<P/>
In  the  generalized  case,  the  <Q>conjugated</Q>  chain  need  not  be  a
stabilizer chain for the image of <M>hom</M>, since the  <Q>preimage</Q>  of  the
stabilizer of <M>map(b)</M> (where <M>b</M> is a base point) need not fix <M>b</M>,  but
only fixes the preimage <M>map^{{-1}}( map(b) )</M> setwise. Therefore the  method
can be applied only to one level and the next stabilizer must be computed
explicitly.
But if <M>map</M> is injective, we have <M>map(b).hom(g) = map(b)</M> if and
only if <M>b.g = b</M>, and if this holds, then <M>g = w(g_1, \ldots, g_n)</M>
is a  word  in  the
generators <M>g_1, \ldots, g_n</M> of the stabilizer of&nbsp;<M>b</M> and
<!-- % replaced \buildrel *\over= by {$*$}{$=$} ... easiest compromise for HTML -->
<M>hom(g) =^* w( hom(g_1), \ldots, hom(g_n) )</M> is in the
<Q>conjugated</Q> stabilizer.
If, more generally, <M>hom</M> is a right inverse to a homomorphism
<M>\varphi</M> (i.e., <M>\varphi(hom(g)) = g</M> for all <M>g</M>),
equality <M>*</M> holds modulo the kernel of <M>\varphi</M>;
in this case the <Q>conjugated</Q> chain can be made into a real stabilizer
chain by extending each level with the generators of the kernel and
appending a proper stabilizer chain of the kernel at the end.
These special cases will occur in the algorithms for permutation group
homomorphisms (see&nbsp;<Ref Chap="Group Homomorphisms"/>).
<P/>
To <Q>conjugate</Q> the points (i.e., <C>orbit</C>) and permutations (i.e.,
<C>labels</C>) of the Schreier tree, a loop is set up over the <C>orbit</C> list
constructed during the orbit algorithm, and  for  each  vertex  <M>b</M>  with
unique edge <M>a(l)b</M> ending at <M>b</M>, the label <M>l</M> is mapped with <M>hom</M> and
<M>b</M> with <M>map</M>. We assume  that  the  <C>orbit</C>  list  was  built  w.r.t.&nbsp;a
certain ordering <M>&lt;</M> of the labels,
where <M>l' &lt; l</M> means that every  point  in
the orbit was mapped with <M>l'</M> before it was mapped with <M>l</M>. This  shape
of the <C>orbit</C> list is guaranteed if the Schreier tree is  extended  only
by <Ref Func="AddGeneratorsExtendSchreierTree"/>,
and it is then also guaranteed  for
the <Q>conjugated</Q> Schreier tree. (The ordering of the labels  cannot  be
read from the Schreier tree, however.)
<P/>
In the generalized case, it can happen that  the  edge  <M>a(l)b</M>  bears  a
label <M>l</M> whose image is <Q>old</Q>, i.e., equal to the image of an  earlier
label <M>l' &lt; l</M>. Because of the compatibility of the actions we  then  have
<M>map(b) = map(a).hom(l)^{{-1}} = map(a).hom(l')^{{-1}} = map(a{{l'}}^{{-1}})</M>,
so <M>map(b)</M> is already equal to the image  of  the  vertex  <M>a{{l'}}^{{-1}}</M>.
This vertex must have been  encountered  before  <M>b = al^{{-1}}</M>  because
<M>l' &lt; l</M>. We conclude that the image of a label can be <Q>old</Q> only if the
vertex at the end of the corresponding edge has an  <Q>old</Q>  image,  too,
but then it need not be <Q>conjugated</Q> at all. A similar  remark  applies
to labels which map under <M>hom</M> to the identity.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The General Backtrack Algorithm with Ordered Partitions">
<Heading>The General Backtrack Algorithm with Ordered Partitions</Heading>

Section <Ref Sect="Backtrack"/> describes the basic
functions for a backtrack search. The purpose of
this section  is  to document  how  the general   backtrack algorithm  is
implemented in &GAP; and which  parts you have to modify  if you want to
write your own backtrack routines.

<Subsection Label="Internal representation of ordered partitions">
<Heading>Internal representation of ordered partitions</Heading>

<Index Subkey="internal representation">ordered partitions</Index>
&GAP; represents  an  ordered  partition  as  a  record  with   the   following
components.
<List>
<Mark><C>points</C></Mark>
<Item>
        a list  of all points contained in  the  partition, such that the
        points of each cell from lie consecutively,
</Item>
<Mark><C>cellno</C></Mark>
<Item>
        a list whose <A>i</A>th entry is the number of the cell which contains
        the point <A>i</A>,
</Item>
<Mark><C>firsts</C></Mark>
<Item>
        a list  such that  <C>points[firsts[<A>j</A>]]</C>  is  the first point  in
        <C>points</C> which is in cell <A>j</A>,
</Item>
<Mark><C>lengths</C></Mark>
<Item>
        a list of the  cell lengths.
</Item>
</List>
Some of the information is  redundant, e.g., the  <C>lengths</C> could also be
read off the <C>firsts</C> list,  but since this   need not be increasing,  it
would    require some searching. Similar  for    <C>cellno</C>, which could be
replaced by a systematic search  of <C>points</C>, keeping  track of what cell
is currently being  traversed.
With the above components, the <A>m</A>th cell of a partition <A>P</A>
is expressed as <C><A>P</A>.points{ [ <A>P</A>.firsts[<A>m</A>] ..
<A>P</A>.firsts[<A>m</A>] + <A>P</A>.lengths[<A>m</A>] - 1 ] }</C>.
The   most   important
operations, however, to be performed upon <A>P</A> are the splitting of a cell
and the reuniting  of the two parts. Following  the strategy  of J.&nbsp;Leon,
<!-- explicit citation, please -->
this is done as follows:
<P/>
<List>
<Mark>(1)</Mark>
<Item>
The points which make up the cell that is to be split are sorted so  that
the ones that remain inside occupy positions <C>[ <A>P</A>.firsts[<A>m</A>] .. <A>last</A>
]</C> in the list <C><A>P</A>.points</C> (for a suitable value of <A>last</A>).
</Item>
<Mark>(2)</Mark>
<Item>
The  points  at  positions  <C>[ <A>last</A> + 1 .. <A>P</A>.firsts[<A>m</A>] +
<A>P</A>.lengths[<A>m</A>] - 1 ]</C> will form the additional cell.
For this new  cell
requires additional entries are added to the lists <C><A>P</A>.firsts</C>  (namely,
<C><A>last</A>+1</C>) and <C><A>P</A>.lengths</C> (namely,
<C><A>P</A>.firsts[<A>m</A>] + <A>P</A>.lengths[<A>m</A>] - <A>last</A> - 1</C>).
</Item>
<Mark>(3)</Mark>
<Item>
The entries of the sublist
<C><A>P</A>.cellno{ [ <A>last</A>+1 .. <A>P</A>.firsts[<A>m</A>] +
P.lengths[<A>m</A>]-1 ] }</C> must be set to the number of the new cell.
</Item>
<Mark>(4)</Mark>
<Item>
  The entry <C><A>P</A>.lengths[<A>m</A>]</C> must be reduced to
  <C><A>last</A> - <A>P</A>.firsts[<A>m</A>] + 1</C>.
</Item>
</List>
<P/>
Then reuniting the  two cells requires  only the reversal of steps&nbsp;2 to&nbsp;4
above. The list <C><A>P</A>.points</C> need not be rearranged.

</Subsection>

<Subsection Label="Functions for setting up an R-base">
<Heading>Functions for setting up an R-base</Heading>

This subsection explains
some  &GAP;  functions   which   are   local   to   the   library   file
<F>lib/stbcbckt.gi</F> which contains the code for backtracking in permutation
groups. They are mentioned here because you might find them helpful  when
you want  to  implement  you  own  backtracking  function  based  on  the
partition concept. An important argument to most of the functions is  the
R-base <M>R</M>, which you should regard as a black box. We will tell you how
to set it up, how to maintain it and where to pass it as argument, but it
is not necessary for you to know its internal representation. However, if
you insist to learn the whole story: Here are the record components  from
which an R-base is made up:
<P/>
<List>
<Mark><C>domain</C></Mark>
<Item>
    the set <M>\Omega</M> on which the group <M>G</M> operates
</Item>
<Mark><C>base</C></Mark>
<Item>
    the sequence <M>(a_1, \ldots, a_r)</M> of base points
</Item>
<Mark><C>partition</C></Mark>
<Item>
    an  ordered  partition, initially  <M>\Pi_0</M>, this  will be  refined to
    <M>\Pi_1, \ldots, \Pi_r</M> during the backtrack algorithm
</Item>
<Mark><C>where</C></Mark>
<Item>
    a list such that <M>a_i</M> lies in cell number <C>where</C><M>[i]</M> of <M>\Pi_i</M>
</Item>
<Mark><C>rfm</C></Mark>
<Item>
    a    list whose <M>i</M>th entry  is   a  list of   refinements which take
    <M>\Sigma_i</M>  to <M>\Sigma_{{i+1}}</M>;  the    structure of a  refinement  is
    described below
</Item>
<Mark><C>chain</C></Mark>
<Item>
    a (copy of a) stabilizer  chain for <M>G</M> (not  if  <M>G</M> is a  symmetric
    group)
</Item>
<Mark><C>fix</C></Mark>
<Item>
    only if  <M>G</M> is a  symmetric group:  a list whose  <M>i</M> entry contains
    <C>Fixcells( </C><M>\Pi_i</M><C> )</C>
</Item>
<Mark><C>level</C></Mark>
<Item>
    initially equal to <C>chain</C>,  this will be changed  to chains  for the
    stabilizers <M>G_{{a_1 \ldots a_i}}</M> for <M>i = 1, \ldots, r</M>
    during the
    backtrack algorithm; if <M>G</M> is a  symmetric group, only the number of
    moved points is stored for each stabilizer
</Item>
<Mark><C>lev</C></Mark>
<Item>
    a  list   whose  <M>i</M>th  entry   remembers   the  <C>level</C> entry    for
    <M>G_{{a_1 \ldots a_{{i-1}}}}</M>
</Item>
<Mark><C>level2</C>, <C>lev2</C></Mark>
<Item>
    a similar  construction   for a second  group  (used  in intersection
    calculations), <K>false</K> otherwise.  This second group <M>H</M> activated if
    the R-base  is constructed as  <C>EmptyRBase( </C><M>[ G, H ], \Omega,
    \Pi_0</M><C> )</C> (if <M>G = H</M>, &GAP; sets <C>level2 = </C><K>true</K> instead).
</Item>
<Mark><C>nextLevel</C></Mark>
<Item>
    this is described below
</Item>
</List>
<P/>
As  our guiding example, we  present  code for the function
<Ref Func="Centralizer" Label="for a magma and a submagma"/>
which calculates the centralizer of an element <M>g</M> in the group <M>G</M>.
(The real code is more general and has a few more subtleties.)
<P/>
<Listing><![CDATA[
Pi_0 := TrivialPartition( omega );
R := EmptyRBase( G, omega, Pi_0 );
R.nextLevel := function( Pi, rbase )
local  fix, p, q, where;
NextRBasePoint( Pi, rbase );
fix := Fixcells( Pi );
for p  in fix  do
  q := p ^ g;
  where := IsolatePoint( Pi, q );
  if where <> false  then
    Add( fix, q );
    ProcessFixpoint( R, q );
    AddRefinement( R, "Centralizer", [ Pi.cellno[ p ], q, where ] );
    if Pi.lengths[ where ] = 1  then
      p := FixpointCellNo( Pi, where );
      ProcessFixpoint( R, p );
      AddRefinement( R, "ProcessFixpoint", [ p, where ] );
    fi;
  fi;
od;
end;

return PartitionBacktrack(
  G,
  c -> g ^ c = g,
  false,
  R,
  [ Pi_0, g ],
  L, R );
]]></Listing>
<P/>
The list numbers below refer to the line numbers of the code above.
<P/>
<List>
  <Mark>1.</Mark>
  <Item>
    <C>omega</C> is the set on which <C>G</C> acts and <C>Pi_0</C>
    is the first member  of the decreasing sequence of partitions mentioned
    in <Ref Sect="Backtrack"/>.
    We  set  <C>Pi_0 = omega</C>,  which  is  constructed  as
    <C>TrivialPartition( omega )</C>, but we could have started with  a  finer
    partition, e.g., into unions of <C>g</C>-cycles of the same length.
  </Item>
  <Mark>2.</Mark>
  <Item>
    This statement sets up the R-base in the variable <C>R</C>.
  </Item>
  <Mark>3.-21.</Mark>
  <Item>
    These lines define a function <C>R.nextLevel</C> which  is  called
    whenever an additional member in the sequence
    <C>Pi_0 </C><M>\geq \Pi_1 \geq \ldots</M>
    of partitions is needed. If <M>\Pi_i</M> does  not  yet  contain  enough
    base points in one-point cells, &GAP;  will  call
    <C>R.nextLevel( </C><M>\Pi_i,</M><C> R )</C>,
    and this function will choose a new base point <M>a_{{i+1}}</M>, refine
    <M>\Pi_i</M> to <M>\Pi_{{i+1}}</M>
    (thereby <E>changing</E> the first argument) and  store
    all necessary information in&nbsp;<C>R</C>.
  </Item>
  <Mark>5.</Mark>
  <Item>
    This statement selects a new base point <M>a_{{i+1}}</M>,
    which is not yet in  a one-point cell of <M>\Pi</M> and still moved
    by the stabilizer <M>G_{{a_1 \ldots a_i}}</M> of the earlier base points.
    If certain points  of  <C>omega</C>  should be preferred as base point
    (e.g., because they belong to long cycles  of <C>g</C>),
    a list of points starting with the most wanted ones, can  be  given
    as an optional third argument to <C>NextRBasePoint</C>
    (actually, this is done in the real code for
    <Ref Func="Centralizer" Label="for a magma and a submagma"/>).
  </Item>
  <Mark>6.</Mark>
  <Item>
    <C>Fixcells( </C><M>\Pi</M><C> )</C> returns the list of  points  in
    one-point  cells  of <M>\Pi</M>
    (ordered as the cells are ordered in <M>\Pi</M>).
  </Item>
  <Mark>7.</Mark>
  <Item>
    For every point <M>p \in fix</M>, if we know the image
    <M>p</M><C>^</C><M>g</M> under  <M>c \in C_G(e)</M>,
    we also know <M>( p</M><C>^</C><M>g )</M><C>^</C><M>c
    = ( p</M><C>^</C><M>c )</M><C>^</C><M>g</M>.
    We therefore want to isolate these extra points in <M>\Pi</M>.
  </Item>
  <Mark>9.</Mark>
  <Item>
    This statement puts point <M>q</M> in a cell of its own,
    returning in  <C>where</C> the number of the cell of <M>\Pi</M>
    from which <M>q</M>  was  taken.
    If  <M>q</M>  was already the only point in its cell,
    <C>where = </C><K>false</K> instead.
  </Item>
  <Mark>12.</Mark>
  <Item>
    This command does the necessary bookkeeping for the extra base point
    <M>q</M>:
    It prescribes <M>q</M> as next base in the stabilizer chain for  <M>G</M>
    (needed, e.g., in line&nbsp;5)
    and  returns  <K>false</K>  if  <M>q</M>  was  already  fixed  the
    stabilizer of the earlier base points
    (and <K>true</K> otherwise; this is  not used here).
    Another call to <C>ProcessFixpoint</C> like  this  was  implicitly
    made by the function <C>NextRBasePoint</C> to register the chosen
    base  point.
    By contrast, the point <M>q</M> was not chosen this way,
    so  <C>ProcessFixpoint</C> must be called explicitly for&nbsp;<M>q</M>.
  </Item>
  <Mark>13.</Mark>
  <Item>
    This statement registers the function  which  will  be  used  during  the
    backtrack search to perform the corresponding refinements on the  <Q>image
    partition</Q> <M>\Sigma_i</M>
    (to  yield  the  refined  <M>\Sigma_{{i+1}}</M>).
    After choosing an image <M>b_{{i+1}}</M> for the base point
    <M>a_{{i+1}}</M>, &GAP; will compute
    <M>\Sigma_i \wedge (\{ b_{{i+1}} \}, \Omega \setminus \{ b_{{i+1}} \})</M>
    and store this partition in <M>I</M><C>.partition</C>,
    where <M>I</M> is a black box similar to <M>R</M>,
    but corresponding to the current <Q>image  partition</Q>
    (hence  it  is  an <Q>R-image</Q> in analogy to the R-base).
    Then &GAP; will call the function
    <C>Refinements.Centralizer( R, I, Pi.cellno[ p ], p, where )</C>,
    with  the  then  current  values  of  <M>R</M>  and  <M>I</M>,
    but   where <M>\Pi</M><C>.cellno</C><M>[ p ]</M>, <M>p</M>,
    <C>where</C> still have the values  they  have  at the time of this
    <C>AddRefinement</C> command.
    This function call will further refine <M>I</M><C>.partition</C>
    to yield <M>\Sigma_{{i+1}}</M> as it  is  programmed  in the function
    <C>Refinements.Centralizer</C>, which is  described  below.
    (The global variable <C>Refinements</C> is a record which contains  all
    refinement functions for all backtracking procedures.)
  </Item>
  <Mark>14.-19.</Mark>
  <Item>
    If the cell from which <M>q</M> was taken out had only two points,
    we now have an additional one-point cell.
    This condition is checked in line&nbsp;13 and if it is true,
    this extra fixpoint <M>p</M> is taken  (line&nbsp;15),
    processed  like <M>q</M> before (line&nbsp;16) and is then (line&nbsp;17)
    passed to  another  refinement function
    <C>Refinements.ProcessFixpoint( R, I, p, where )</C>,
    which is also described below.
  </Item>
  <Mark>23.-29.</Mark>
  <Item>
    This command  starts  the  backtrack  search.  Its  result  will  be  the
    centralizer as a subgroup of <M>G</M>. Its arguments are
  </Item>
  <Mark>24.</Mark>
  <Item>
    the group we want to run through,
  </Item>
  <Mark>25.</Mark>
  <Item>
    the property we want to test, as a &GAP; function,
  </Item>
  <Mark>26.</Mark>
  <Item>
    <K>false</K> if we are looking for a subgroup, <K>true</K> in the case
    of   a  representative  search    (when  the result   would    be one
    representative),
  </Item>
  <Mark>27.</Mark>
  <Item>
    the R-base,
  </Item>
  <Mark>28.</Mark>
  <Item>
    a list  of data, to be stored  in <M>I</M><C>.data</C>, which has
    in position&nbsp;1 the first member <M>\Sigma_0</M>  of the decreasing
    sequence of <Q>image partitions</Q> mentioned in
    <Ref Sect="Backtrack"/>.
    In the centralizer example, position&nbsp;2 contains the
    element that is  to be centralized. In the  case of  a representative
    search,  i.e.,  a conjugacy test  <M>g</M><C>^</C><M>c</M><C> ?= </C><M>h</M>, we
    would  have <M>h</M>   instead of  <M>g</M>   here, and   possibly a <M>\Sigma_0</M>
    different from <M>\Pi_0</M> (e.g., a  partition into unions of  <M>h</M>-cycles
    of same length).
  </Item>
  <Mark>29.</Mark>
  <Item>
    two subgroups <M>L \leq C_G(g)</M> and <M>R \leq C_G(h)</M> known  in
    advance (we have <M>L = R</M> in the centralizer case).
  </Item>
</List>

</Subsection>


<Subsection Label="Refinement functions for the backtrack search">
<Heading>Refinement functions for the backtrack search</Heading>

The last
subsection showed   how the refinement   process leading from  <M>\Pi_i</M> to
<M>\Pi_{{i+1}}</M>  is coded in the  function  <M>R</M><C>.nextLevel</C>, this  has to be
executed once the  base point  <M>a_{{i+1}}</M>.  The analogous refinement  step
from <M>\Sigma_i</M> to <M>\Sigma_{{i+1}}</M> must be performed for each choice of an
image <M>b_{{i+1}}</M> for  <M>a_{{i+1}}</M>, and it will  depend  on the corresponding
value of <M>\Sigma_i \wedge (\{b_{{i+1}}\}, \Omega \setminus \{b_{{i+1}}\})</M>.
But  before
we  can continue  our centralizer example,  we  must,  for the interested
reader, document the record components of the other black box <M>I</M>, as we
did above for the R-base black box <M>R</M>. Most of the components change as
&GAP; walks up and down the levels of the search tree.
<List>
  <Mark><C>data</C></Mark>
  <Item>
    this will be mentioned below
  </Item>
  <Mark><C>depth</C></Mark>
  <Item>
    the level <M>i</M> in the search tree of the current node <M>\Sigma_i</M>
  </Item>
  <Mark><C>bimg</C></Mark>
  <Item>
    a list of images of the points in <M>R</M><C>.base</C>
  </Item>
  <Mark><C>partition</C></Mark>
  <Item>
    the partition <M>\Sigma_i</M> of the current node
  </Item>
  <Mark><C>level</C></Mark>
  <Item>
    the stabilizer chain <M>R</M><C>.lev</C><M>[i]</M> at the current level
  </Item>
  <Mark><C>perm</C></Mark>
  <Item>
    a permutation mapping <C>Fixcells</C><M>( \Pi_i )</M> to
    <C>Fixcells</C><M>( \Sigma_i )</M>;
    this implies mapping <M>(a_1, \ldots, a_i)</M> to
    <M>(b_1, \ldots, b_i)</M>
  </Item>
  <Mark><C>level2</C>, <C>perm2</C></Mark>
  <Item>
    a  similar construction for    the second stabilizer chain,   <K>false</K>
    otherwise (and <K>true</K> if <M>R</M><C>.level2 = </C><K>true</K>)
  </Item>
</List>
<P/>
As declared in the above code for <Ref Func="Centralizer" Label="for a magma and a submagma"/>,
the refinement is performed by the function
<C>Refinement.Centralizer</C><M>( R, I, \Pi</M><C>.cellno</C><M>[p], p, where )</M>.
The  functions in the  record
<C>Refinement</C> always   take two  additional   arguments  before  the  ones
specified  in  the <C>AddRefinement</C>  call (in  line&nbsp;13 above),  namely the
R-base  <M>R</M> and  the  current  value  <M>I</M>  of the <Q>R-image</Q>.
In our example, <M>p</M> is a fixpoint of
<M>\Pi = \Pi_i \wedge (\{ a_{{i+1}} \}, \Omega \setminus \{ a_{{i+1}} \})</M>
such that <M>where = \Pi</M><C>.cellno</C><M>[ p^g ]</M>.
The <C>Refinement</C> functions must return <K>false</K> if the refinement is
unsuccessful (e.g., because it  leads to <M>\Sigma_{{i+1}}</M> having  different
cell   sizes from  <M>\Pi_{{i+1}}</M>)  and  <K>true</K>  otherwise.
Our particular function looks like this.
<P/>
<Listing><![CDATA[
Refinements.Centralizer := function( R, I, cellno, p, where )
local  Sigma, q;
Sigma := I.partition;
q := FixpointCellNo( Sigma, cellno ) ^ I.data[ 2 ];
return IsolatePoint( Sigma, q ) = where and ProcessFixpoint( I, p, q );
end;
]]></Listing>
<P/>
The list numbers below refer to the line numbers of the code immediately
above.
<P/>
<List>
  <Mark>3.</Mark>
  <Item>
    The current value of
    <M>\Sigma_i \wedge (\{ b_{{i+1}} \}, \Omega \setminus \{ b_{{i+1}} \})</M>
    is always found in <M>I</M><C>.partition</C>.
  </Item>
  <Mark>4.</Mark>
  <Item>
    The image of the only point in cell number
    <M>cellno = \Pi_i</M><C>.cellno</C><M>[ p ]</M> in <M>\Sigma</M>
    under <M>g = I</M><C>.data</C><M>[ 2 ]</M> is calculated.
  </Item>
  <Mark>5.</Mark>
  <Item>
    The function returns <K>true</K> only if the  image  <M>q</M>  has  the
    same  cell number in <M>\Sigma</M> as <M>p</M> had in <M>\Pi</M>
    (i.e., <M>where</M>) and if <M>q</M> can  be prescribed as an  image
    for  <M>p</M>  under  the  coset  of  the  stabilizer
    <M>G_{{a_1 \ldots a_{{i+1}}}}.c</M> where <M>c \in G</M>  is  an
    (already  constructed) element mapping the  earlier  base  points
    <M>a_1, \ldots, a_{{i+1}}</M>  to  the already chosen images
    <M>b_1, \ldots, b_{{i+1}}</M>.
    This  latter  condition  is tested by
    <C>ProcessFixpoint</C><M>( I, p, q )</M> which, if successful,
    also does the necessary bookkeeping in <M>I</M>.
    In analogy to  the  remark  about line&nbsp;12 in the program above,
    the chosen image  <M>b_{{i+1}}</M>  for  the  base point <M>a_{{i+1}}</M>
    has already been processed  implicitly  by  the  function
    <C>PartitionBacktrack</C>,
    and this processing includes the construction of an element
    <M>c \in  G</M>  which  maps  <C>Fixcells</C><M>( \Pi_i )</M>  to
    <C>Fixcells</C><M>( \Sigma_i )</M>  and  <M>a_{{i+1}}</M>  to
    <M>b_{{i+1}}</M>.
    By  contrast,  the  extra fixpoints <M>p</M> and <M>q</M> in
    <M>\Pi_{{i+1}}</M> and <M>\Sigma_{{i+1}}</M> were  not  chosen automatically,
    so they require an  explicit  call  of  <C>ProcessFixpoint</C>,
    which replaces the element <M>c</M> by some <M>c'.c</M>
    (with  <M>c' \in  G_{{a_1 \ldots a_{{i+1}}}}</M>) which in addition maps
    <M>p</M> to <M>q</M>, or returns <K>false</K> if  this is impossible.
  </Item>
</List>
<P/>
You should now be able to  guess what
<C>Refinements.ProcessFixpoint</C><M>( R, I, p, where )</M> does:
it  simply returns
<C>ProcessFixpoint</C><M>( I, p, </M><C>FixpointCellNo</C><M>(
 I</M><C>.partition</C><M>, where ) )</M>.
<P/>
<E>Summary.</E>
<P/>
When you write  your  own backtrack functions using
the  partition technique,  you  have  to  supply  an R-base, including  a
component <C>nextLevel</C>, and   the  functions in the   <C>Refinements</C> record
which  you need. Then  you can start  the backtrack by passing the R-base
and the additional data (for the  <C>data</C> component of the <Q>R-image</Q>) to
<C>PartitionBacktrack</C>.

</Subsection>

<Subsection Label="Functions for meeting ordered partitions">
<Heading>Functions for meeting ordered partitions</Heading>

A   kind  of
refinement that   occurs  in particular  in   the  normalizer calculation
involves computing  the  meet of <M>\Pi</M>  (cf.&nbsp;lines&nbsp;6ff.&nbsp;above) with an
arbitrary other partition  <M>\Lambda</M>, not just  with one point. To do this
efficiently, &GAP; uses the following two functions.
<P/>
<C>StratMeetPartition( </C><M>R</M>, <M>\Pi</M>, <M>\Lambda</M> <C>[</C>, <M>g</M> <C>] )</C>
<P/>
<C>MeetPartitionStrat( </C><M>R</M>, <M>I</M><C>{, </C><M>\Lambda'</M><C>}[, {</C><M>g'</M><C>}]</C>, <M>strat</M> <C>)</C>
<P/>
<Index>meet strategy</Index>
Such a  <C>StratMeetPartition</C>   command would   typically appear in    the
function call <M>R</M><C>.nextLevel</C><M>(  \Pi, R )</M>  (during the refinement of
<M>\Pi_i</M>  to  <M>\Pi_{{i+1}}</M>).
This command replaces <M>\Pi</M> by <M>\Pi \wedge \Lambda</M>
(thereby  <E>changing</E> the  second  argument) and returns a <Q>meet
strategy</Q>  <M>strat</M>. This  is  (for  us) a  black   box which  serves two
purposes:  First, it allows &GAP; to  calculate faster the corresponding
meet <M>\Sigma \wedge \Lambda'</M>,  which must then  appear in a <C>Refinements</C>
function  (during the refinement of  <M>\Sigma_i</M> to <M>\Sigma_{{i+1}}</M>). It is
faster  to compute <M>\Sigma \wedge \Lambda'</M> with  the <Q>meet strategy</Q> of
<M>\Pi \wedge \Lambda</M> because  if the refinement  of <M>\Sigma</M> is successful
at  all, the  intersection  of a  cell from   the left hand  side of  the
<M>\wedge</M> sign  with a cell  from the right hand side  must  have the same
size   in both cases  (and  <M>strat</M>  records these   sizes, so  that only
non-empty intersections must  be calculated for <M>\Sigma \wedge \Lambda'</M>).
Second, if  there  is a discrepancy  between  the behaviour prescribed by
<M>strat</M> and the behaviour observed when refining <M>\Sigma</M>, the refinement
can immediately be abandoned.
<P/>
On  the  other hand, if you  only  want to meet   a  partition <M>\Pi</M> with
<M>\Lambda</M>  for  a one-time  use, without recording   a strategy,  you can
simply type <C>StratMeetPartition</C><M>( \Pi, \Lambda )</M>  as in the following
example, which also demonstrates some other partition-related commands.
<P/>
<!-- % <Example><![CDATA[ -->
<!-- % gap> P := Partition( [[1,2],[3,4,5],[6]] );;  Cells( P ); -->
<!-- % [ [ 1, 2 ], [ 3, 4, 5 ], [ 6 ] ] -->
<!-- % gap> Q := OnPartitions( P, (1,3,6) );;  Cells( Q );   -->
<!-- % [ [ 3, 2 ], [ 6, 4, 5 ], [ 1 ] ]  -->
<!-- % gap> StratMeetPartition( P, Q );  -->
<!-- % [  ]  # the ``meet strategy'' was not recorded, ignore this result -->
<!-- % gap> Cells( P ); -->
<!-- % [ [ 1 ], [ 5, 4 ], [ 6 ], [ 2 ], [ 3 ] ] -->
<!-- % ]]></Example> -->
<!--  -->
<!-- % The preceding (original) example doesn't work because there is no -->
<!-- % function 'OnPartitions'. The following example works, but I don't -->
<!-- % know if it makes sense to have it here at all. (Note, in particular, -->
<!-- % that the function 'Partition' is undocumented.)  VF  14.10.02 -->

<Example><![CDATA[
gap> P := Partition( [[1,2],[3,4,5],[6]] );;  Cells( P );
[ [ 1, 2 ], [ 3, 4, 5 ], [ 6 ] ]
gap> Q := Partition( OnTuplesTuples( last, (1,3,6) ) );;  Cells( Q );
[ [ 3, 2 ], [ 6, 4, 5 ], [ 1 ] ]
gap> StratMeetPartition( P, Q );
[  ]
gap> # The ``meet strategy'' was not recorded, ignore this result.
gap> Cells( P );
[ [ 1 ], [ 5, 4 ], [ 6 ], [ 2 ], [ 3 ] ]
]]></Example>
<P/>
You can even say  <C>StratMeetPartition</C><M>( \Pi, \Delta )</M>  where <M>\Delta</M>
is simply  a subset  of  <M>\Omega</M>, it   will then  be interpreted as  the
partition <M>(\Delta, \Omega \setminus \Delta)</M>.
<P/>
&GAP; makes use   of  the advantages  of   a <Q>meet  strategy</Q>  if  the
refinement   function  in <C>Refinements</C>  contains  a <C>MeetPartitionStrat</C>
command where   <M>strat</M>  is   the    <Q>meet  strategy</Q>  calculated    by
<C>StratMeetPartition</C> before.  Such a command replaces <M>I</M><C>.partition</C> by
its meet with <M>\Lambda'</M>, again changing the argument <M>I</M>. The necessary
reversal of these changes when backtracking from  a node (and prescribing
the next possible image  for a base point) is  automatically done by  the
function <C>PartitionBacktrack</C>.
<P/>
In  all cases, an additional  argument <M>g</M> means that the   meet is to be
taken  not with <M>\Lambda</M>, but instead with <M>\Lambda.{{g^{{-1}}}}</M>,
where
operation  on ordered partitions is  meant cellwise  (and setwise on each
cell). (Analogously for the primed arguments.)
<P/>
<Example><![CDATA[
gap> P := Partition( [[1,2],[3,4,5],[6]] );;
gap> StratMeetPartition( P, P, (1,6,3) );;  Cells( P );
[ [ 1 ], [ 5, 4 ], [ 6 ], [ 2 ], [ 3 ] ]
]]></Example>
Note that <M>P.(1,3,6) = Q</M>.

</Subsection>


<Subsection Label="Avoiding multiplication of permutations">
<Heading>Avoiding multiplication of permutations</Heading>

In the  description
of  the last subsections, the  backtrack  algorithm constructs an element
<M>c \in G</M> mapping  the base points   to the prescribed images  and finally
tests the property in question for that element. During the construction,
<M>c</M> is obtained as a product  of transversal elements from the stabilizer
chain for <M>G</M>,  and so multiplications  of permutations are required  for
every <M>c</M>  submitted to the test,  even if the  test fails (i.e.,  in our
centralizer example, if <M>g</M><C>^</C><M>c</M><C>&lt;></C><M>g</M>). Even if the construction of
<M>c</M> stops before images  for all base  points have been chosen, because a
refinement was unsuccessful,  several  multiplications will  already have
been performed by (explicit or implicit) calls of <C>ProcessFixpoint</C>, and,
actually, the general   backtrack procedure implemented in  &GAP; avoids
this.
<P/>
For this purpose, &GAP; does  not actually multiply the permutations but
rather stores  all the factors of the   product in a  list. Specifically,
instead of carrying out  the multiplication in <M>c \mapsto c'.c</M>  mentioned
in  the   comment  to  line&nbsp;5 of  the   above  program &mdash; where <M>c' \in
G_{{a_1 \ldots a_{{i+1}}}}</M> is a  product  of factorized inverse  transversal
elements, see <Ref Sect="Stabilizer Chain Records"/> &mdash;
&GAP; appends the list of these factorized inverse transversal  elements
(giving <M>c'</M>) to the list of factors already collected for <M>c</M>. Here <M>c'</M>
is multiplied from the left and is itself  a  product  of  <E>inverses</E>  of
strong generators of <M>G</M>, but &GAP; simply spares itself all the work of
inverting permutations and stores only  a  <Q>list  of  inverses</Q>,  whose
product is then <M>(c'.c)^{{-1}}</M> (which is the new value of  <M>c^{{-1}}</M>).  The
<Q>list of inverses</Q> is extended this way whenever  <C>ProcessFixpoint</C>  is
called to improve&nbsp;<M>c</M>.
<P/>
The  product has to be multiplied  out only when  the property is finally
tested  for  the  element <M>c</M>. But  it  is  often possible  to  delay the
multiplication  even  further, namely  until after   the test, so  that no
multiplication is required in the case of  an unsuccessful test. Then the
test  itself  must be carried   out with the  factorized   version of the
element <M>c</M>.  For  this purpose,  <C>PartitionBacktrack</C> can  be passed its
second argument (the property  in question) in  a different way, not as a
single &GAP; function, but as a list like in lines 2&ndash;4 of the following
alternative excerpt from the code for
<Ref Func="Centralizer" Label="for a magma and a submagma"/>.
<P/>
<Listing><![CDATA[
return PartitionBacktrack( G,
  [ g, g,
  OnPoints,
  c -> c!.lftObj = c!.rgtObj ],
  false, R, [ Pi_0, g ], L, R );
]]></Listing>
<P/>
The test for <M>c</M> to have the property in question is of the form
<M>opr( left, c ) = right</M> where  <M>opr</M>   is an  operation  function as
explained in <Ref Sect="External Sets"/>. In other words,
<M>c</M> passes the test if and only if it maps a <Q>left object</Q> to a <Q>right
object</Q> under  a certain operation.
In the centralizer example, we have <M>opr</M><C> = OnPoints</C> and
<M>left = right = g</M>,
but in a conjugacy test, we would have <M>right = h</M>.
<P/>
<List>
  <Mark>2.</Mark>
  <Item>
    Two first two entries (here <M>g</M> and <M>g</M>) are the  values  of
    <M>left</M>  and <M>right</M>.
  </Item>
  <Mark>3.</Mark>
  <Item>
    The third entry (here <Ref Func="OnPoints"/>)
    is the operation <M>opr</M>.
  </Item>
  <Mark>4.</Mark>
  <Item>
    The fourth entry is the test to be performed upon the mapped left  object
    <M>left</M> and preimage of the right object
    <M>opr( right, c</M><C>^-1</C><M> )</M>.
    Here &GAP; operates with the inverse of <M>c</M> because this is
    the  product  of the permutations stored in the <Q>list  of  inverses</Q>.
    The  preimage  of <M>right</M> under <M>c</M> is then calculated
    by mapping <M>right</M> with the  factors of <M>c^{{-1}}</M> one by one,
    without the need to multiply these factors.
    This mapping  of  <M>right</M>  is  automatically  done  by  the
    <C>ProcessFixpoint</C> function whenever <M>c</M> is extended,
    the current value of <M>right</M> is always stored in
    <M>c</M><C>!.rgtObj</C>.
    When the test  given  by  the  fourth  entry  is finally performed,
    the element <M>c</M>  has  two  components
    <M>c</M><C>!.lftObj</C><M> = left</M> and
    <M>c</M><C>!.rgtObj</C><M> = opr( right, c</M><C>^-1</C><M> )</M>,
    which must be  used to express the desired relation as a function of
    <M>c</M>.
    In our  centralizer example,
    we simply have to test whether they are equal.
  </Item>
</List>

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Stabilizer Chains for Automorphisms Acting on Enumerators">
<Heading>Stabilizer Chains for Automorphisms Acting on Enumerators</Heading>

This section describes a way of representing the automorphism group of a
group as permutation group, following <Cite Key="Sims97"/>. The code however is
not yet included in the &GAP; library.
<P/>
In this section  we present an example in  which objects we  already know
(namely,  automorphisms  of   solvable  groups)   are  equipped  with the
permutation-like operations <C>^</C> and <C>/</C>  for action on positive integers.
To achieve this, we must  define a new  type of objects which behave like
permutations   but are  represented     as automorphisms  acting  on   an
enumerator.  Our  goal is to  generalize  the Schreier-Sims algorithm for
construction of a stabilizer chain to groups of such new automorphisms.


<Subsection Label="An operation domain for automorphisms">
<Heading>An operation domain for automorphisms</Heading>

The idea we describe here is due  to C.&nbsp;Sims.
We consider  a group <M>A</M>  of  automorphisms of a
group <M>G</M>, given by generators,  and we would like  to know its order. Of
course we  could   follow the strategy  of  the   Schreier-Sims algorithm
(described  in <Ref Sect="Stabilizer Chains"/>) for <M>A</M>
acting   on   <M>G</M>. This would    involve   a  call  of
<C>StabChainStrong( EmptyStabChain( [], One( <A>A</A> ) ), GroupGenerators( <A>A</A> ) )</C>  where
<C>StabChainStrong</C>  is a function as the  one described in the pseudo-code
below:
<P/>
<Listing><![CDATA[
StabChainStrong := function( S, newgens )
  Extend the Schreier tree of S with newgens.
  for sch  in  Schreier generators  do
    if not sch in S.stabilizer  then
      StabChainStrong( S.stabilizer, [ sch ] );
    fi;
  od;
end;
]]></Listing>
<P/>
The membership test <M>sch \notin S</M><C>.stabilizer</C> can be performed because
the  stabilizer chain  of <M>S</M><C>.stabilizer</C>  is   already correct at  that
moment. We  even know a base  in advance, namely  any  generating set for
<M>G</M>.
Fix such a generating set <M>(g_1, \ldots, g_d)</M> and observe that this
base  is  generally very   short compared  to   the degree <M>|G|</M>  of  the
operation. The problem with the Schreier-Sims algorithm, however, is then
that the length of the first  basic orbit <M>g_1.A</M>  would already have the
magnitude of <M>|G|</M>,  and the basic orbits at  deeper levels would  not be
much shorter. For the advantage of a short base  we pay the high price of
long basic  orbits, since the  product of  the  (few) basic orbit lengths
must  equal <M>|A|</M>.  Such  long  orbits  make the Schreier-Sims  algorithm
infeasible,   so we have to   look for a  longer base  with shorter basic
orbits.
<P/>
Assume that   <M>G</M> is solvable  and  choose  a  characteristic series with
elementary abelian factors. For the sake of  simplicity we assume that <M>N
&lt; G</M> is an   elementary abelian characteristic subgroup  with elementary
abelian factor group <M>G/N</M>. Since <M>N</M> is characteristic, <M>A</M> also acts as
a group of automorphisms  on the factor  group <M>G/N</M>,  but of course  not
necessarily  faithfully. To retain  a faithful action,  we let <M>A</M> act on
the   disjoint   union   <M>G/N</M>   with   <M>G</M>,   and   choose    as    base
<M>(g_1 N, \ldots, g_d N, g_1, \ldots, g_d)</M>.
Now the first <M>d</M> basic  orbits  lie
inside <M>G/N</M> and can have length at most <M>[G:N]</M>. Since the  base
points <M>g_1 N, \ldots, g_d N</M>  form  a  generating  set  for  <M>G/N</M>,  their
iterated stabilizer <M>A^{(d+1)}</M> acts trivially on the factor group <M>G/N</M>,
i.e., it leaves the cosets <M>g_i N</M> invariant. Accordingly,  the  next  <M>d</M>
basic orbits lie inside <M>g_i N</M> (for <M>i = 1, \ldots, d</M>) and can  have  length
at most&nbsp;<M>|N|</M>.
<P/>
Generalizing this method to a characteristic series
<M>G = N_0 &gt; N_1 &gt; \ldots &gt; N_l = \{ 1 \}</M> of length
<M>l &gt; 2</M>, we  can always find  a base of length <M>l.d</M>
such that each  basic orbit is  contained in a  coset of a characteristic
factor, i.e. in a set of the form <M>g_i N_{{j-1}} / N_j</M>
(where <M>g_i</M> is one of
the generators  of <M>G</M> and <M>1 \leq j \leq l</M>).
In particular, the  length of
the basic  orbits   is  bounded   by  the  size  of    the  corresponding
characteristic factors. To implement a Schreier-Sims algorithm for such a
base, we  must  be   able  to  let   automorphisms  act  on   cosets   of
characteristic  factors <M>g_i N_{{j-1}} / N_j</M>,
for  varying  <M>i</M>  and <M>j</M>.  We
would    like to    translate each such     action  into  an  action   on
<M>\{ 1, \ldots, [ N_{{j-1}}:N_j] \}</M>,
because then we need not enumerate the operation domain,
which is the disjoint union of
<M>G / N_1</M>, <M>G / N_2 \ldots G / N_l</M>,
as a whole. Enumerating it  as a whole would result  in basic orbits like
<C>orbit</C><M> \subseteq \{ 1001, \ldots, 1100 \}</M>
with a  <C>transversal</C> list whose
first 1000 entries would be unbound, but  still require 4&nbsp;bytes of memory
each (see&nbsp;<Ref Sect="Stabilizer Chain Records"/>).
<P/>
Identifying each coset <M>g_i N_{{j-1}} / N_j</M> into
<M>\{ 1, \ldots, [N_{{j-1}}:N_j] \}</M> of course means
that we have  to change the action  of
the automorphisms on     every  level of   the  stabilizer   chain.  Such
flexibility is not   possible with permutations  because their  effect on
positive  integers  is <Q>hardwired</Q>  into them,  but  we can install new
operations for automorphisms.

</Subsection>


<Subsection Label="Enumerators for cosets of characteristic factors">
<Heading>Enumerators for cosets of characteristic factors</Heading>

So far  we
have  not used the  fact that  the characteristic  factors are elementary
abelian, but we will do so from  here on.
Our first task is to implement an enumerator
(see <Ref Func="AsList"/> and
<Ref Sect="Enumerators"/>)
for a coset of a characteristic factor in a solvable  group  <M>G</M>.
We assume that such a coset <M>g N/M</M> is given by
<P/>
<List>
  <Mark>(1)</Mark>
  <Item>
    a pcgs for  the group  <M>G</M> (see  <Ref Func="Pcgs"/>),
    let <M>n = </M><C>Length( </C><M>pcgs</M><C> )</C>;
  </Item>
  <Mark>(2)</Mark>
  <Item>
    a range <M>range = [ start .. stop ]</M> indicating that
    <M>N = \langle pcgs\{ [ start .. n ] \} \rangle</M> and
    <M>M = \langle pcgs\{ [ stop + 1 .. n ] \} \rangle</M>,
    i.e., the cosets of <M>pcgs\{ range \}</M> form a base
    for the vector space <M>N/M</M>;
  </Item>
  <Mark>(3)</Mark>
  <Item>
    the representative <M>g</M>.
  </Item>
</List>
<P/>
We   first  define a  new representation  for   such enumerators and then
construct them by simply putting these three pieces of data into a record
object. The  enumerator  should  behave as  a   list of  group   elements
(representing cosets modulo <M>M</M>),   consequently, its family will  be the
family of the <M>pcgs</M> itself.
<P/>
<Log><![CDATA[
DeclareRepresentation( "IsCosetSolvableFactorEnumeratorRep", IsEnumerator,
    [ "pcgs", "range", "representative" ] );

EnumeratorCosetSolvableFactor := function( pcgs, range, g )
    return Objectify( NewType( FamilyObj( pcgs ),
                   IsCosetSolvableFactorEnumeratorRep ),
                   rec( pcgs := pcgs,
                       range := range,
              representative := g ) );
end;
]]></Log>
<P/>
The definition of the operations <Ref Func="Length"/>,
<Ref Func="\[\]"/> and <Ref Func="Position"/>
is now
straightforward. The  code has sometimes  been  abbreviated and is  meant
<Q>cum grano salis</Q>,  e.g.,  the declaration of  the local  variables has
been left out.
<P/>
<Log><![CDATA[
InstallMethod( Length, [ IsCosetSolvableFactorEnumeratorRep ],
    enum -> Product( RelativeOrdersPcgs( enum!.pcgs ){ enum!.range } ) );

InstallMethod( \[\], [ IsCosetSolvableFactorEnumeratorRep,
        IsPosRat and IsInt ],
    function( enum, pos )
    elm := ();
    pos := pos - 1;
    for i  in Reversed( enum!.range )  do
        p := RelativeOrderOfPcElement( enum!.pcgs, i );
        elm := enum!.pcgs[ i ] ^ ( pos mod p ) * elm;
        pos := QuoInt( pos, p );
    od;
    return enum!.representative * elm;
end );

InstallMethod( Position, [ IsCosetSolvableFactorEnumeratorRep,
        IsObject, IsZeroCyc ],
    function( enum, elm, zero )
    exp := ExponentsOfPcElement( enum!.pcgs,
                   LeftQuotient( enum!.representative, elm ) );
    pos := 0;
    for i  in enum!.range  do
        pos := pos * RelativeOrderOfPcElement( pcgs, i ) + exp[ i ];
    od;
    return pos + 1;
end );
]]></Log>

</Subsection>


<Subsection Label="Making automorphisms act on such enumerators">
<Heading>Making automorphisms act on such enumerators</Heading>

Our next task is to make automorphisms of the solvable group
<M>pcgs</M><C>!.group</C> act on
<M>[ 1 .. </M><C>Length</C><M>( enum ) ]</M> for such an enumerator
<M>enum</M>. We achieve this
by  introducing a new  representation of automorphisms on enumerators and
by putting the enumerator together  with the automorphism into an  object
which behaves like  a permutation. Turning  an ordinary automorphism into
such  a special  automorphism requires  then   the construction of  a new
object which has the new type. We provide an operation
<C>PermOnEnumerator( <A>model</A>, <A>aut</A> )</C> which constructs such a new
object having the same type as <A>model</A>,
but representing the  automorphism  <A>aut</A>. So <A>aut</A>  can be
either an ordinary automorphism or one which already has an enumerator in
its type, but perhaps  different from the one  we want (i.e. from the one
in <A>model</A>).
<P/>
<Log><![CDATA[
DeclareCategory( "IsPermOnEnumerator",
    IsMultiplicativeElementWithInverse and IsPerm );

DeclareRepresentation( "IsPermOnEnumeratorDefaultRep",
    IsPermOnEnumerator and IsAttributeStoringRep,
    [ "perm" ] );

DeclareOperation( "PermOnEnumerator",
    [ IsEnumerator, IsObject ] );

InstallMethod( PermOnEnumerator,
    [ IsEnumerator, IsObject ],
    function( enum, a )
    SetFilterObj( a, IsMultiplicativeElementWithInverse );
    a := Objectify( NewKind( PermutationsOnEnumeratorsFamily,
                 IsPermOnEnumeratorDefaultRep ),
                 rec( perm := a ) );
    SetEnumerator( a, enum );
    return a;
end );

InstallMethod( PermOnEnumerator,
    [ IsEnumerator, IsPermOnEnumeratorDefaultRep ],
    function( enum, a )
    a := Objectify( TypeObj( a ), rec( perm := a!.perm ) );
    SetEnumerator( a, enum );
    return a;
end );
]]></Log>
<P/>
Next we  have to install new  methods for the  operations which calculate
the  product of two automorphisms, because   this product must again have
the    right type. We    also have to write  a    function which uses the
enumerators to apply such an automorphism to positive integers.
<P/>
<Log><![CDATA[
InstallMethod( \*, IsIdenticalObj,
    [ IsPermOnEnumeratorDefaultRep, IsPermOnEnumeratorDefaultRep ],
    function( a, b )
    perm := a!.perm * b!.perm;
    SetIsBijective( perm, true );
    return PermOnEnumerator( Enumerator( a ), perm );
end );

InstallMethod( \^,
    [ IsPosRat and IsInt, IsPermOnEnumeratorDefaultRep ],
    function( p, a )
    return PositionCanonical( Enumerator( a ),
                   Enumerator( a )[ p ] ^ a!.perm );
end );
]]></Log>
<P/>
How the corresponding methods for <C><A>p</A> / <A>aut</A></C>
and <C><A>aut</A> ^ <A>n</A></C> look like is obvious.
<P/>
Now we  can  formulate  the recursive procedure   <C>StabChainStrong</C> which
extends  the stabilizer chain by adding  in new  generators <M>newgens</M>. We
content  ourselves again   with pseudo-code, emphasizing  only  the lines
which set the <C>EnumeratorDomainPermutation</C>. We assume that initially <M>S</M>
is a stabilizer chain for the trivial subgroup with a level for each pair
<M>(range,g)</M> characterizing an enumerator  (as  described above). We  also
assume that  the <C>identity</C>  element at each  level already  has the type
corresponding to that level.
<P/>
<Listing><![CDATA[
StabChainStrong := function( S, newgens )
  for i  in [ 1 .. Length( newgens ) ]  do
    newgens[ i ] := AutomorphismOnEnumerator( S.identity, newgens[ i ] );
  od;
  Extend the Schreier tree of S with newgens.
  for sch  in  Schreier generators  do
    if not sch in S.stabilizer  then
      StabChainStrong( S.stabilizer, [ sch ] );
    fi;
  od;
end;
]]></Listing>

</Subsection>
</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->



</Body>

<Bibliography Databases="../manualbib.xml"/>

<TheIndex/>

</Book>

<!-- ==================================================================== -->
